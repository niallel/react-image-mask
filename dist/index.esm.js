import { jsxs, jsx } from 'react/jsx-runtime';
import * as React from 'react';
import React__default, { useState, useRef, useEffect, forwardRef, useCallback, useImperativeHandle } from 'react';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */


var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/*!
 * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2024 Fonticons, Inc.
 */
function _defineProperty$1(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}
function ownKeys$1(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2$1(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$1(Object(t), true).forEach(function (r) {
      _defineProperty$1(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}

const noop = () => {};
let _WINDOW = {};
let _DOCUMENT = {};
let _MUTATION_OBSERVER = null;
let _PERFORMANCE = {
  mark: noop,
  measure: noop
};
try {
  if (typeof window !== 'undefined') _WINDOW = window;
  if (typeof document !== 'undefined') _DOCUMENT = document;
  if (typeof MutationObserver !== 'undefined') _MUTATION_OBSERVER = MutationObserver;
  if (typeof performance !== 'undefined') _PERFORMANCE = performance;
} catch (e) {}
const {
  userAgent = ''
} = _WINDOW.navigator || {};
const WINDOW = _WINDOW;
const DOCUMENT = _DOCUMENT;
const MUTATION_OBSERVER = _MUTATION_OBSERVER;
const PERFORMANCE = _PERFORMANCE;
!!WINDOW.document;
const IS_DOM = !!DOCUMENT.documentElement && !!DOCUMENT.head && typeof DOCUMENT.addEventListener === 'function' && typeof DOCUMENT.createElement === 'function';
const IS_IE = ~userAgent.indexOf('MSIE') || ~userAgent.indexOf('Trident/');

var p$1 = /fa(s|r|l|t|d|dr|dl|dt|b|k|kd|ss|sr|sl|st|sds|sdr|sdl|sdt)?[\-\ ]/,
  g = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit)?.*/i;
var S = {
    classic: {
      fa: "solid",
      fas: "solid",
      "fa-solid": "solid",
      far: "regular",
      "fa-regular": "regular",
      fal: "light",
      "fa-light": "light",
      fat: "thin",
      "fa-thin": "thin",
      fab: "brands",
      "fa-brands": "brands"
    },
    duotone: {
      fa: "solid",
      fad: "solid",
      "fa-solid": "solid",
      "fa-duotone": "solid",
      fadr: "regular",
      "fa-regular": "regular",
      fadl: "light",
      "fa-light": "light",
      fadt: "thin",
      "fa-thin": "thin"
    },
    sharp: {
      fa: "solid",
      fass: "solid",
      "fa-solid": "solid",
      fasr: "regular",
      "fa-regular": "regular",
      fasl: "light",
      "fa-light": "light",
      fast: "thin",
      "fa-thin": "thin"
    },
    "sharp-duotone": {
      fa: "solid",
      fasds: "solid",
      "fa-solid": "solid",
      fasdr: "regular",
      "fa-regular": "regular",
      fasdl: "light",
      "fa-light": "light",
      fasdt: "thin",
      "fa-thin": "thin"
    }
  },
  A = {
    GROUP: "duotone-group",
    PRIMARY: "primary",
    SECONDARY: "secondary"
  },
  P = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone"];
var s = "classic",
  t = "duotone",
  r = "sharp",
  o = "sharp-duotone",
  L = [s, t, r, o];
var G = {
    classic: {
      900: "fas",
      400: "far",
      normal: "far",
      300: "fal",
      100: "fat"
    },
    duotone: {
      900: "fad",
      400: "fadr",
      300: "fadl",
      100: "fadt"
    },
    sharp: {
      900: "fass",
      400: "fasr",
      300: "fasl",
      100: "fast"
    },
    "sharp-duotone": {
      900: "fasds",
      400: "fasdr",
      300: "fasdl",
      100: "fasdt"
    }
  };
var lt = {
    "Font Awesome 6 Free": {
      900: "fas",
      400: "far"
    },
    "Font Awesome 6 Pro": {
      900: "fas",
      400: "far",
      normal: "far",
      300: "fal",
      100: "fat"
    },
    "Font Awesome 6 Brands": {
      400: "fab",
      normal: "fab"
    },
    "Font Awesome 6 Duotone": {
      900: "fad",
      400: "fadr",
      normal: "fadr",
      300: "fadl",
      100: "fadt"
    },
    "Font Awesome 6 Sharp": {
      900: "fass",
      400: "fasr",
      normal: "fasr",
      300: "fasl",
      100: "fast"
    },
    "Font Awesome 6 Sharp Duotone": {
      900: "fasds",
      400: "fasdr",
      normal: "fasdr",
      300: "fasdl",
      100: "fasdt"
    }
  };
var pt = new Map([["classic", {
    defaultShortPrefixId: "fas",
    defaultStyleId: "solid",
    styleIds: ["solid", "regular", "light", "thin", "brands"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["sharp", {
    defaultShortPrefixId: "fass",
    defaultStyleId: "solid",
    styleIds: ["solid", "regular", "light", "thin"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["duotone", {
    defaultShortPrefixId: "fad",
    defaultStyleId: "solid",
    styleIds: ["solid", "regular", "light", "thin"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["sharp-duotone", {
    defaultShortPrefixId: "fasds",
    defaultStyleId: "solid",
    styleIds: ["solid", "regular", "light", "thin"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }]]),
  xt = {
    classic: {
      solid: "fas",
      regular: "far",
      light: "fal",
      thin: "fat",
      brands: "fab"
    },
    duotone: {
      solid: "fad",
      regular: "fadr",
      light: "fadl",
      thin: "fadt"
    },
    sharp: {
      solid: "fass",
      regular: "fasr",
      light: "fasl",
      thin: "fast"
    },
    "sharp-duotone": {
      solid: "fasds",
      regular: "fasdr",
      light: "fasdl",
      thin: "fasdt"
    }
  };
var Ft = ["fak", "fa-kit", "fakd", "fa-kit-duotone"],
  St = {
    kit: {
      fak: "kit",
      "fa-kit": "kit"
    },
    "kit-duotone": {
      fakd: "kit-duotone",
      "fa-kit-duotone": "kit-duotone"
    }
  },
  At = ["kit"];
var Ct = {
  kit: {
    "fa-kit": "fak"
  }};
var Lt = ["fak", "fakd"],
  Wt = {
    kit: {
      fak: "fa-kit"
    }};
var Et = {
    kit: {
      kit: "fak"
    },
    "kit-duotone": {
      "kit-duotone": "fakd"
    }
  };

var t$1 = {
    GROUP: "duotone-group",
    SWAP_OPACITY: "swap-opacity",
    PRIMARY: "primary",
    SECONDARY: "secondary"
  },
  r$1 = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone"];
var bt$1 = ["fak", "fa-kit", "fakd", "fa-kit-duotone"];
var Yt = {
    "Font Awesome Kit": {
      400: "fak",
      normal: "fak"
    },
    "Font Awesome Kit Duotone": {
      400: "fakd",
      normal: "fakd"
    }
  };
var ua = {
    classic: {
      "fa-brands": "fab",
      "fa-duotone": "fad",
      "fa-light": "fal",
      "fa-regular": "far",
      "fa-solid": "fas",
      "fa-thin": "fat"
    },
    duotone: {
      "fa-regular": "fadr",
      "fa-light": "fadl",
      "fa-thin": "fadt"
    },
    sharp: {
      "fa-solid": "fass",
      "fa-regular": "fasr",
      "fa-light": "fasl",
      "fa-thin": "fast"
    },
    "sharp-duotone": {
      "fa-solid": "fasds",
      "fa-regular": "fasdr",
      "fa-light": "fasdl",
      "fa-thin": "fasdt"
    }
  },
  I$1 = {
    classic: ["fas", "far", "fal", "fat", "fad"],
    duotone: ["fadr", "fadl", "fadt"],
    sharp: ["fass", "fasr", "fasl", "fast"],
    "sharp-duotone": ["fasds", "fasdr", "fasdl", "fasdt"]
  },
  ga = {
    classic: {
      fab: "fa-brands",
      fad: "fa-duotone",
      fal: "fa-light",
      far: "fa-regular",
      fas: "fa-solid",
      fat: "fa-thin"
    },
    duotone: {
      fadr: "fa-regular",
      fadl: "fa-light",
      fadt: "fa-thin"
    },
    sharp: {
      fass: "fa-solid",
      fasr: "fa-regular",
      fasl: "fa-light",
      fast: "fa-thin"
    },
    "sharp-duotone": {
      fasds: "fa-solid",
      fasdr: "fa-regular",
      fasdl: "fa-light",
      fasdt: "fa-thin"
    }
  },
  x$1 = ["fa-solid", "fa-regular", "fa-light", "fa-thin", "fa-duotone", "fa-brands"],
  Ia = ["fa", "fas", "far", "fal", "fat", "fad", "fadr", "fadl", "fadt", "fab", "fass", "fasr", "fasl", "fast", "fasds", "fasdr", "fasdl", "fasdt", ...r$1, ...x$1],
  m$1 = ["solid", "regular", "light", "thin", "duotone", "brands"],
  c$1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
  F$1 = c$1.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]),
  ma = [...Object.keys(I$1), ...m$1, "2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "fw", "inverse", "layers-counter", "layers-text", "layers", "li", "pull-left", "pull-right", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", t$1.GROUP, t$1.SWAP_OPACITY, t$1.PRIMARY, t$1.SECONDARY].concat(c$1.map(a => "".concat(a, "x"))).concat(F$1.map(a => "w-".concat(a)));
var wa = {
    "Font Awesome 5 Free": {
      900: "fas",
      400: "far"
    },
    "Font Awesome 5 Pro": {
      900: "fas",
      400: "far",
      normal: "far",
      300: "fal"
    },
    "Font Awesome 5 Brands": {
      400: "fab",
      normal: "fab"
    },
    "Font Awesome 5 Duotone": {
      900: "fad"
    }
  };

const NAMESPACE_IDENTIFIER = '___FONT_AWESOME___';
const UNITS_IN_GRID = 16;
const DEFAULT_CSS_PREFIX = 'fa';
const DEFAULT_REPLACEMENT_CLASS = 'svg-inline--fa';
const DATA_FA_I2SVG = 'data-fa-i2svg';
const DATA_FA_PSEUDO_ELEMENT = 'data-fa-pseudo-element';
const DATA_FA_PSEUDO_ELEMENT_PENDING = 'data-fa-pseudo-element-pending';
const DATA_PREFIX = 'data-prefix';
const DATA_ICON = 'data-icon';
const HTML_CLASS_I2SVG_BASE_CLASS = 'fontawesome-i2svg';
const MUTATION_APPROACH_ASYNC = 'async';
const TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS = ['HTML', 'HEAD', 'STYLE', 'SCRIPT'];
const PRODUCTION$1 = (() => {
  try {
    return process.env.NODE_ENV === 'production';
  } catch (e$$1) {
    return false;
  }
})();
function familyProxy(obj) {
  // Defaults to the classic family if family is not available
  return new Proxy(obj, {
    get(target, prop) {
      return prop in target ? target[prop] : target[s];
    }
  });
}
const _PREFIX_TO_STYLE = _objectSpread2$1({}, S);

// We changed FACSSClassesToStyleId in the icons repo to be canonical and as such, "classic" family does not have any
// duotone styles.  But we do still need duotone in _PREFIX_TO_STYLE below, so we are manually adding
// {'fa-duotone': 'duotone'}
_PREFIX_TO_STYLE[s] = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, {
  'fa-duotone': 'duotone'
}), S[s]), St['kit']), St['kit-duotone']);
const PREFIX_TO_STYLE = familyProxy(_PREFIX_TO_STYLE);
const _STYLE_TO_PREFIX = _objectSpread2$1({}, xt);

// We changed FAStyleIdToShortPrefixId in the icons repo to be canonical and as such, "classic" family does not have any
// duotone styles.  But we do still need duotone in _STYLE_TO_PREFIX below, so we are manually adding {duotone: 'fad'}
_STYLE_TO_PREFIX[s] = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, {
  duotone: 'fad'
}), _STYLE_TO_PREFIX[s]), Et['kit']), Et['kit-duotone']);
const STYLE_TO_PREFIX = familyProxy(_STYLE_TO_PREFIX);
const _PREFIX_TO_LONG_STYLE = _objectSpread2$1({}, ga);
_PREFIX_TO_LONG_STYLE[s] = _objectSpread2$1(_objectSpread2$1({}, _PREFIX_TO_LONG_STYLE[s]), Wt['kit']);
const PREFIX_TO_LONG_STYLE = familyProxy(_PREFIX_TO_LONG_STYLE);
const _LONG_STYLE_TO_PREFIX = _objectSpread2$1({}, ua);
_LONG_STYLE_TO_PREFIX[s] = _objectSpread2$1(_objectSpread2$1({}, _LONG_STYLE_TO_PREFIX[s]), Ct['kit']);
familyProxy(_LONG_STYLE_TO_PREFIX);
const ICON_SELECTION_SYNTAX_PATTERN = p$1; // eslint-disable-line no-useless-escape

const LAYERS_TEXT_CLASSNAME = 'fa-layers-text';
const FONT_FAMILY_PATTERN = g;
const _FONT_WEIGHT_TO_PREFIX = _objectSpread2$1({}, G);
familyProxy(_FONT_WEIGHT_TO_PREFIX);
const ATTRIBUTES_WATCHED_FOR_MUTATION = ['class', 'data-prefix', 'data-icon', 'data-fa-transform', 'data-fa-mask'];
const DUOTONE_CLASSES = A;
const RESERVED_CLASSES = [...At, ...ma];

const initial = WINDOW.FontAwesomeConfig || {};
function getAttrConfig(attr) {
  var element = DOCUMENT.querySelector('script[' + attr + ']');
  if (element) {
    return element.getAttribute(attr);
  }
}
function coerce(val) {
  // Getting an empty string will occur if the attribute is set on the HTML tag but without a value
  // We'll assume that this is an indication that it should be toggled to true
  if (val === '') return true;
  if (val === 'false') return false;
  if (val === 'true') return true;
  return val;
}
if (DOCUMENT && typeof DOCUMENT.querySelector === 'function') {
  const attrs = [['data-family-prefix', 'familyPrefix'], ['data-css-prefix', 'cssPrefix'], ['data-family-default', 'familyDefault'], ['data-style-default', 'styleDefault'], ['data-replacement-class', 'replacementClass'], ['data-auto-replace-svg', 'autoReplaceSvg'], ['data-auto-add-css', 'autoAddCss'], ['data-auto-a11y', 'autoA11y'], ['data-search-pseudo-elements', 'searchPseudoElements'], ['data-observe-mutations', 'observeMutations'], ['data-mutate-approach', 'mutateApproach'], ['data-keep-original-source', 'keepOriginalSource'], ['data-measure-performance', 'measurePerformance'], ['data-show-missing-icons', 'showMissingIcons']];
  attrs.forEach(_ref => {
    let [attr, key] = _ref;
    const val = coerce(getAttrConfig(attr));
    if (val !== undefined && val !== null) {
      initial[key] = val;
    }
  });
}
const _default = {
  styleDefault: 'solid',
  familyDefault: s,
  cssPrefix: DEFAULT_CSS_PREFIX,
  replacementClass: DEFAULT_REPLACEMENT_CLASS,
  autoReplaceSvg: true,
  autoAddCss: true,
  autoA11y: true,
  searchPseudoElements: false,
  observeMutations: true,
  mutateApproach: 'async',
  keepOriginalSource: true,
  measurePerformance: false,
  showMissingIcons: true
};

// familyPrefix is deprecated but we must still support it if present
if (initial.familyPrefix) {
  initial.cssPrefix = initial.familyPrefix;
}
const _config = _objectSpread2$1(_objectSpread2$1({}, _default), initial);
if (!_config.autoReplaceSvg) _config.observeMutations = false;
const config = {};
Object.keys(_default).forEach(key => {
  Object.defineProperty(config, key, {
    enumerable: true,
    set: function (val) {
      _config[key] = val;
      _onChangeCb.forEach(cb => cb(config));
    },
    get: function () {
      return _config[key];
    }
  });
});

// familyPrefix is deprecated as of 6.2.0 and should be removed in 7.0.0
Object.defineProperty(config, 'familyPrefix', {
  enumerable: true,
  set: function (val) {
    _config.cssPrefix = val;
    _onChangeCb.forEach(cb => cb(config));
  },
  get: function () {
    return _config.cssPrefix;
  }
});
WINDOW.FontAwesomeConfig = config;
const _onChangeCb = [];
function onChange(cb) {
  _onChangeCb.push(cb);
  return () => {
    _onChangeCb.splice(_onChangeCb.indexOf(cb), 1);
  };
}

const d$2 = UNITS_IN_GRID;
const meaninglessTransform = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: false,
  flipY: false
};
function insertCss(css) {
  if (!css || !IS_DOM) {
    return;
  }
  const style = DOCUMENT.createElement('style');
  style.setAttribute('type', 'text/css');
  style.innerHTML = css;
  const headChildren = DOCUMENT.head.childNodes;
  let beforeChild = null;
  for (let i = headChildren.length - 1; i > -1; i--) {
    const child = headChildren[i];
    const tagName = (child.tagName || '').toUpperCase();
    if (['STYLE', 'LINK'].indexOf(tagName) > -1) {
      beforeChild = child;
    }
  }
  DOCUMENT.head.insertBefore(style, beforeChild);
  return css;
}
const idPool = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function nextUniqueId() {
  let size = 12;
  let id = '';
  while (size-- > 0) {
    id += idPool[Math.random() * 62 | 0];
  }
  return id;
}
function toArray(obj) {
  const array = [];
  for (let i = (obj || []).length >>> 0; i--;) {
    array[i] = obj[i];
  }
  return array;
}
function classArray(node) {
  if (node.classList) {
    return toArray(node.classList);
  } else {
    return (node.getAttribute('class') || '').split(' ').filter(i => i);
  }
}
function htmlEscape(str) {
  return "".concat(str).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}
function joinAttributes(attributes) {
  return Object.keys(attributes || {}).reduce((acc, attributeName) => {
    return acc + "".concat(attributeName, "=\"").concat(htmlEscape(attributes[attributeName]), "\" ");
  }, '').trim();
}
function joinStyles(styles) {
  return Object.keys(styles || {}).reduce((acc, styleName) => {
    return acc + "".concat(styleName, ": ").concat(styles[styleName].trim(), ";");
  }, '');
}
function transformIsMeaningful(transform) {
  return transform.size !== meaninglessTransform.size || transform.x !== meaninglessTransform.x || transform.y !== meaninglessTransform.y || transform.rotate !== meaninglessTransform.rotate || transform.flipX || transform.flipY;
}
function transformForSvg(_ref) {
  let {
    transform,
    containerWidth,
    iconWidth
  } = _ref;
  const outer = {
    transform: "translate(".concat(containerWidth / 2, " 256)")
  };
  const innerTranslate = "translate(".concat(transform.x * 32, ", ").concat(transform.y * 32, ") ");
  const innerScale = "scale(".concat(transform.size / 16 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / 16 * (transform.flipY ? -1 : 1), ") ");
  const innerRotate = "rotate(".concat(transform.rotate, " 0 0)");
  const inner = {
    transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
  };
  const path = {
    transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
  };
  return {
    outer,
    inner,
    path
  };
}
function transformForCss(_ref2) {
  let {
    transform,
    width = UNITS_IN_GRID,
    height = UNITS_IN_GRID,
    startCentered = false
  } = _ref2;
  let val = '';
  if (startCentered && IS_IE) {
    val += "translate(".concat(transform.x / d$2 - width / 2, "em, ").concat(transform.y / d$2 - height / 2, "em) ");
  } else if (startCentered) {
    val += "translate(calc(-50% + ".concat(transform.x / d$2, "em), calc(-50% + ").concat(transform.y / d$2, "em)) ");
  } else {
    val += "translate(".concat(transform.x / d$2, "em, ").concat(transform.y / d$2, "em) ");
  }
  val += "scale(".concat(transform.size / d$2 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / d$2 * (transform.flipY ? -1 : 1), ") ");
  val += "rotate(".concat(transform.rotate, "deg) ");
  return val;
}

var baseStyles = ":root, :host {\n  --fa-font-solid: normal 900 1em/1 \"Font Awesome 6 Free\";\n  --fa-font-regular: normal 400 1em/1 \"Font Awesome 6 Free\";\n  --fa-font-light: normal 300 1em/1 \"Font Awesome 6 Pro\";\n  --fa-font-thin: normal 100 1em/1 \"Font Awesome 6 Pro\";\n  --fa-font-duotone: normal 900 1em/1 \"Font Awesome 6 Duotone\";\n  --fa-font-duotone-regular: normal 400 1em/1 \"Font Awesome 6 Duotone\";\n  --fa-font-duotone-light: normal 300 1em/1 \"Font Awesome 6 Duotone\";\n  --fa-font-duotone-thin: normal 100 1em/1 \"Font Awesome 6 Duotone\";\n  --fa-font-brands: normal 400 1em/1 \"Font Awesome 6 Brands\";\n  --fa-font-sharp-solid: normal 900 1em/1 \"Font Awesome 6 Sharp\";\n  --fa-font-sharp-regular: normal 400 1em/1 \"Font Awesome 6 Sharp\";\n  --fa-font-sharp-light: normal 300 1em/1 \"Font Awesome 6 Sharp\";\n  --fa-font-sharp-thin: normal 100 1em/1 \"Font Awesome 6 Sharp\";\n  --fa-font-sharp-duotone-solid: normal 900 1em/1 \"Font Awesome 6 Sharp Duotone\";\n  --fa-font-sharp-duotone-regular: normal 400 1em/1 \"Font Awesome 6 Sharp Duotone\";\n  --fa-font-sharp-duotone-light: normal 300 1em/1 \"Font Awesome 6 Sharp Duotone\";\n  --fa-font-sharp-duotone-thin: normal 100 1em/1 \"Font Awesome 6 Sharp Duotone\";\n}\n\nsvg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {\n  overflow: visible;\n  box-sizing: content-box;\n}\n\n.svg-inline--fa {\n  display: var(--fa-display, inline-block);\n  height: 1em;\n  overflow: visible;\n  vertical-align: -0.125em;\n}\n.svg-inline--fa.fa-2xs {\n  vertical-align: 0.1em;\n}\n.svg-inline--fa.fa-xs {\n  vertical-align: 0em;\n}\n.svg-inline--fa.fa-sm {\n  vertical-align: -0.0714285705em;\n}\n.svg-inline--fa.fa-lg {\n  vertical-align: -0.2em;\n}\n.svg-inline--fa.fa-xl {\n  vertical-align: -0.25em;\n}\n.svg-inline--fa.fa-2xl {\n  vertical-align: -0.3125em;\n}\n.svg-inline--fa.fa-pull-left {\n  margin-right: var(--fa-pull-margin, 0.3em);\n  width: auto;\n}\n.svg-inline--fa.fa-pull-right {\n  margin-left: var(--fa-pull-margin, 0.3em);\n  width: auto;\n}\n.svg-inline--fa.fa-li {\n  width: var(--fa-li-width, 2em);\n  top: 0.25em;\n}\n.svg-inline--fa.fa-fw {\n  width: var(--fa-fw-width, 1.25em);\n}\n\n.fa-layers svg.svg-inline--fa {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.fa-layers-counter, .fa-layers-text {\n  display: inline-block;\n  position: absolute;\n  text-align: center;\n}\n\n.fa-layers {\n  display: inline-block;\n  height: 1em;\n  position: relative;\n  text-align: center;\n  vertical-align: -0.125em;\n  width: 1em;\n}\n.fa-layers svg.svg-inline--fa {\n  transform-origin: center center;\n}\n\n.fa-layers-text {\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  transform-origin: center center;\n}\n\n.fa-layers-counter {\n  background-color: var(--fa-counter-background-color, #ff253a);\n  border-radius: var(--fa-counter-border-radius, 1em);\n  box-sizing: border-box;\n  color: var(--fa-inverse, #fff);\n  line-height: var(--fa-counter-line-height, 1);\n  max-width: var(--fa-counter-max-width, 5em);\n  min-width: var(--fa-counter-min-width, 1.5em);\n  overflow: hidden;\n  padding: var(--fa-counter-padding, 0.25em 0.5em);\n  right: var(--fa-right, 0);\n  text-overflow: ellipsis;\n  top: var(--fa-top, 0);\n  transform: scale(var(--fa-counter-scale, 0.25));\n  transform-origin: top right;\n}\n\n.fa-layers-bottom-right {\n  bottom: var(--fa-bottom, 0);\n  right: var(--fa-right, 0);\n  top: auto;\n  transform: scale(var(--fa-layers-scale, 0.25));\n  transform-origin: bottom right;\n}\n\n.fa-layers-bottom-left {\n  bottom: var(--fa-bottom, 0);\n  left: var(--fa-left, 0);\n  right: auto;\n  top: auto;\n  transform: scale(var(--fa-layers-scale, 0.25));\n  transform-origin: bottom left;\n}\n\n.fa-layers-top-right {\n  top: var(--fa-top, 0);\n  right: var(--fa-right, 0);\n  transform: scale(var(--fa-layers-scale, 0.25));\n  transform-origin: top right;\n}\n\n.fa-layers-top-left {\n  left: var(--fa-left, 0);\n  right: auto;\n  top: var(--fa-top, 0);\n  transform: scale(var(--fa-layers-scale, 0.25));\n  transform-origin: top left;\n}\n\n.fa-1x {\n  font-size: 1em;\n}\n\n.fa-2x {\n  font-size: 2em;\n}\n\n.fa-3x {\n  font-size: 3em;\n}\n\n.fa-4x {\n  font-size: 4em;\n}\n\n.fa-5x {\n  font-size: 5em;\n}\n\n.fa-6x {\n  font-size: 6em;\n}\n\n.fa-7x {\n  font-size: 7em;\n}\n\n.fa-8x {\n  font-size: 8em;\n}\n\n.fa-9x {\n  font-size: 9em;\n}\n\n.fa-10x {\n  font-size: 10em;\n}\n\n.fa-2xs {\n  font-size: 0.625em;\n  line-height: 0.1em;\n  vertical-align: 0.225em;\n}\n\n.fa-xs {\n  font-size: 0.75em;\n  line-height: 0.0833333337em;\n  vertical-align: 0.125em;\n}\n\n.fa-sm {\n  font-size: 0.875em;\n  line-height: 0.0714285718em;\n  vertical-align: 0.0535714295em;\n}\n\n.fa-lg {\n  font-size: 1.25em;\n  line-height: 0.05em;\n  vertical-align: -0.075em;\n}\n\n.fa-xl {\n  font-size: 1.5em;\n  line-height: 0.0416666682em;\n  vertical-align: -0.125em;\n}\n\n.fa-2xl {\n  font-size: 2em;\n  line-height: 0.03125em;\n  vertical-align: -0.1875em;\n}\n\n.fa-fw {\n  text-align: center;\n  width: 1.25em;\n}\n\n.fa-ul {\n  list-style-type: none;\n  margin-left: var(--fa-li-margin, 2.5em);\n  padding-left: 0;\n}\n.fa-ul > li {\n  position: relative;\n}\n\n.fa-li {\n  left: calc(-1 * var(--fa-li-width, 2em));\n  position: absolute;\n  text-align: center;\n  width: var(--fa-li-width, 2em);\n  line-height: inherit;\n}\n\n.fa-border {\n  border-color: var(--fa-border-color, #eee);\n  border-radius: var(--fa-border-radius, 0.1em);\n  border-style: var(--fa-border-style, solid);\n  border-width: var(--fa-border-width, 0.08em);\n  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);\n}\n\n.fa-pull-left {\n  float: left;\n  margin-right: var(--fa-pull-margin, 0.3em);\n}\n\n.fa-pull-right {\n  float: right;\n  margin-left: var(--fa-pull-margin, 0.3em);\n}\n\n.fa-beat {\n  animation-name: fa-beat;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, ease-in-out);\n}\n\n.fa-bounce {\n  animation-name: fa-bounce;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));\n}\n\n.fa-fade {\n  animation-name: fa-fade;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n}\n\n.fa-beat-fade {\n  animation-name: fa-beat-fade;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n}\n\n.fa-flip {\n  animation-name: fa-flip;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, ease-in-out);\n}\n\n.fa-shake {\n  animation-name: fa-shake;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, linear);\n}\n\n.fa-spin {\n  animation-name: fa-spin;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 2s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, linear);\n}\n\n.fa-spin-reverse {\n  --fa-animation-direction: reverse;\n}\n\n.fa-pulse,\n.fa-spin-pulse {\n  animation-name: fa-spin;\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, steps(8));\n}\n\n@media (prefers-reduced-motion: reduce) {\n  .fa-beat,\n.fa-bounce,\n.fa-fade,\n.fa-beat-fade,\n.fa-flip,\n.fa-pulse,\n.fa-shake,\n.fa-spin,\n.fa-spin-pulse {\n    animation-delay: -1ms;\n    animation-duration: 1ms;\n    animation-iteration-count: 1;\n    transition-delay: 0s;\n    transition-duration: 0s;\n  }\n}\n@keyframes fa-beat {\n  0%, 90% {\n    transform: scale(1);\n  }\n  45% {\n    transform: scale(var(--fa-beat-scale, 1.25));\n  }\n}\n@keyframes fa-bounce {\n  0% {\n    transform: scale(1, 1) translateY(0);\n  }\n  10% {\n    transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n  }\n  30% {\n    transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n  }\n  50% {\n    transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n  }\n  57% {\n    transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n  }\n  64% {\n    transform: scale(1, 1) translateY(0);\n  }\n  100% {\n    transform: scale(1, 1) translateY(0);\n  }\n}\n@keyframes fa-fade {\n  50% {\n    opacity: var(--fa-fade-opacity, 0.4);\n  }\n}\n@keyframes fa-beat-fade {\n  0%, 100% {\n    opacity: var(--fa-beat-fade-opacity, 0.4);\n    transform: scale(1);\n  }\n  50% {\n    opacity: 1;\n    transform: scale(var(--fa-beat-fade-scale, 1.125));\n  }\n}\n@keyframes fa-flip {\n  50% {\n    transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n  }\n}\n@keyframes fa-shake {\n  0% {\n    transform: rotate(-15deg);\n  }\n  4% {\n    transform: rotate(15deg);\n  }\n  8%, 24% {\n    transform: rotate(-18deg);\n  }\n  12%, 28% {\n    transform: rotate(18deg);\n  }\n  16% {\n    transform: rotate(-22deg);\n  }\n  20% {\n    transform: rotate(22deg);\n  }\n  32% {\n    transform: rotate(-12deg);\n  }\n  36% {\n    transform: rotate(12deg);\n  }\n  40%, 100% {\n    transform: rotate(0deg);\n  }\n}\n@keyframes fa-spin {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n.fa-rotate-90 {\n  transform: rotate(90deg);\n}\n\n.fa-rotate-180 {\n  transform: rotate(180deg);\n}\n\n.fa-rotate-270 {\n  transform: rotate(270deg);\n}\n\n.fa-flip-horizontal {\n  transform: scale(-1, 1);\n}\n\n.fa-flip-vertical {\n  transform: scale(1, -1);\n}\n\n.fa-flip-both,\n.fa-flip-horizontal.fa-flip-vertical {\n  transform: scale(-1, -1);\n}\n\n.fa-rotate-by {\n  transform: rotate(var(--fa-rotate-angle, 0));\n}\n\n.fa-stack {\n  display: inline-block;\n  vertical-align: middle;\n  height: 2em;\n  position: relative;\n  width: 2.5em;\n}\n\n.fa-stack-1x,\n.fa-stack-2x {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n  z-index: var(--fa-stack-z-index, auto);\n}\n\n.svg-inline--fa.fa-stack-1x {\n  height: 1em;\n  width: 1.25em;\n}\n.svg-inline--fa.fa-stack-2x {\n  height: 2em;\n  width: 2.5em;\n}\n\n.fa-inverse {\n  color: var(--fa-inverse, #fff);\n}\n\n.sr-only,\n.fa-sr-only {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n.sr-only-focusable:not(:focus),\n.fa-sr-only-focusable:not(:focus) {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n.svg-inline--fa .fa-primary {\n  fill: var(--fa-primary-color, currentColor);\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa .fa-secondary {\n  fill: var(--fa-secondary-color, currentColor);\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-primary {\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-secondary {\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa mask .fa-primary,\n.svg-inline--fa mask .fa-secondary {\n  fill: black;\n}";

function css() {
  const dcp = DEFAULT_CSS_PREFIX;
  const drc = DEFAULT_REPLACEMENT_CLASS;
  const fp = config.cssPrefix;
  const rc = config.replacementClass;
  let s = baseStyles;
  if (fp !== dcp || rc !== drc) {
    const dPatt = new RegExp("\\.".concat(dcp, "\\-"), 'g');
    const customPropPatt = new RegExp("\\--".concat(dcp, "\\-"), 'g');
    const rPatt = new RegExp("\\.".concat(drc), 'g');
    s = s.replace(dPatt, ".".concat(fp, "-")).replace(customPropPatt, "--".concat(fp, "-")).replace(rPatt, ".".concat(rc));
  }
  return s;
}
let _cssInserted = false;
function ensureCss() {
  if (config.autoAddCss && !_cssInserted) {
    insertCss(css());
    _cssInserted = true;
  }
}
var InjectCSS = {
  mixout() {
    return {
      dom: {
        css,
        insertCss: ensureCss
      }
    };
  },
  hooks() {
    return {
      beforeDOMElementCreation() {
        ensureCss();
      },
      beforeI2svg() {
        ensureCss();
      }
    };
  }
};

const w = WINDOW || {};
if (!w[NAMESPACE_IDENTIFIER]) w[NAMESPACE_IDENTIFIER] = {};
if (!w[NAMESPACE_IDENTIFIER].styles) w[NAMESPACE_IDENTIFIER].styles = {};
if (!w[NAMESPACE_IDENTIFIER].hooks) w[NAMESPACE_IDENTIFIER].hooks = {};
if (!w[NAMESPACE_IDENTIFIER].shims) w[NAMESPACE_IDENTIFIER].shims = [];
var namespace = w[NAMESPACE_IDENTIFIER];

const functions = [];
const listener = function () {
  DOCUMENT.removeEventListener('DOMContentLoaded', listener);
  loaded = 1;
  functions.map(fn => fn());
};
let loaded = false;
if (IS_DOM) {
  loaded = (DOCUMENT.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(DOCUMENT.readyState);
  if (!loaded) DOCUMENT.addEventListener('DOMContentLoaded', listener);
}
function domready (fn) {
  if (!IS_DOM) return;
  loaded ? setTimeout(fn, 0) : functions.push(fn);
}

function toHtml(abstractNodes) {
  const {
    tag,
    attributes = {},
    children = []
  } = abstractNodes;
  if (typeof abstractNodes === 'string') {
    return htmlEscape(abstractNodes);
  } else {
    return "<".concat(tag, " ").concat(joinAttributes(attributes), ">").concat(children.map(toHtml).join(''), "</").concat(tag, ">");
  }
}

function iconFromMapping(mapping, prefix, iconName) {
  if (mapping && mapping[prefix] && mapping[prefix][iconName]) {
    return {
      prefix,
      iconName,
      icon: mapping[prefix][iconName]
    };
  }
}

/**
 * # Reduce
 *
 * A fast object `.reduce()` implementation.
 *
 * @param  {Object}   subject      The object to reduce over.
 * @param  {Function} fn           The reducer function.
 * @param  {mixed}    initialValue The initial value for the reducer, defaults to subject[0].
 * @param  {Object}   thisContext  The context for the reducer.
 * @return {mixed}                 The final result.
 */
var reduce = function fastReduceObject(subject, fn, initialValue, thisContext) {
  var keys = Object.keys(subject),
    length = keys.length,
    iterator = fn,
    i,
    key,
    result;
  if (initialValue === undefined) {
    i = 1;
    result = subject[keys[0]];
  } else {
    i = 0;
    result = initialValue;
  }
  for (; i < length; i++) {
    key = keys[i];
    result = iterator(result, subject[key], key, subject);
  }
  return result;
};

/**
 * ucs2decode() and codePointAt() are both works of Mathias Bynens and licensed under MIT
 *
 * Copyright Mathias Bynens <https://mathiasbynens.be/>

 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:

 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

function ucs2decode(string) {
  const output = [];
  let counter = 0;
  const length = string.length;
  while (counter < length) {
    const value = string.charCodeAt(counter++);
    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
      const extra = string.charCodeAt(counter++);
      if ((extra & 0xFC00) == 0xDC00) {
        // eslint-disable-line eqeqeq
        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
function toHex(unicode) {
  const decoded = ucs2decode(unicode);
  return decoded.length === 1 ? decoded[0].toString(16) : null;
}
function codePointAt(string, index) {
  const size = string.length;
  let first = string.charCodeAt(index);
  let second;
  if (first >= 0xD800 && first <= 0xDBFF && size > index + 1) {
    second = string.charCodeAt(index + 1);
    if (second >= 0xDC00 && second <= 0xDFFF) {
      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
    }
  }
  return first;
}

function normalizeIcons(icons) {
  return Object.keys(icons).reduce((acc, iconName) => {
    const icon = icons[iconName];
    const expanded = !!icon.icon;
    if (expanded) {
      acc[icon.iconName] = icon.icon;
    } else {
      acc[iconName] = icon;
    }
    return acc;
  }, {});
}
function defineIcons(prefix, icons) {
  let params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const {
    skipHooks = false
  } = params;
  const normalized = normalizeIcons(icons);
  if (typeof namespace.hooks.addPack === 'function' && !skipHooks) {
    namespace.hooks.addPack(prefix, normalizeIcons(icons));
  } else {
    namespace.styles[prefix] = _objectSpread2$1(_objectSpread2$1({}, namespace.styles[prefix] || {}), normalized);
  }

  /**
   * Font Awesome 4 used the prefix of `fa` for all icons. With the introduction
   * of new styles we needed to differentiate between them. Prefix `fa` is now an alias
   * for `fas` so we'll ease the upgrade process for our users by automatically defining
   * this as well.
   */
  if (prefix === 'fas') {
    defineIcons('fa', icons);
  }
}

const {
  styles,
  shims
} = namespace;
const FAMILY_NAMES = Object.keys(PREFIX_TO_LONG_STYLE);
const PREFIXES_FOR_FAMILY = FAMILY_NAMES.reduce((acc, familyId) => {
  acc[familyId] = Object.keys(PREFIX_TO_LONG_STYLE[familyId]);
  return acc;
}, {});
let _defaultUsablePrefix = null;
let _byUnicode = {};
let _byLigature = {};
let _byOldName = {};
let _byOldUnicode = {};
let _byAlias = {};
function isReserved(name) {
  return ~RESERVED_CLASSES.indexOf(name);
}
function getIconName(cssPrefix, cls) {
  const parts = cls.split('-');
  const prefix = parts[0];
  const iconName = parts.slice(1).join('-');
  if (prefix === cssPrefix && iconName !== '' && !isReserved(iconName)) {
    return iconName;
  } else {
    return null;
  }
}
const build = () => {
  const lookup = reducer => {
    return reduce(styles, (o$$1, style, prefix) => {
      o$$1[prefix] = reduce(style, reducer, {});
      return o$$1;
    }, {});
  };
  _byUnicode = lookup((acc, icon, iconName) => {
    if (icon[3]) {
      acc[icon[3]] = iconName;
    }
    if (icon[2]) {
      const aliases = icon[2].filter(a$$1 => {
        return typeof a$$1 === 'number';
      });
      aliases.forEach(alias => {
        acc[alias.toString(16)] = iconName;
      });
    }
    return acc;
  });
  _byLigature = lookup((acc, icon, iconName) => {
    acc[iconName] = iconName;
    if (icon[2]) {
      const aliases = icon[2].filter(a$$1 => {
        return typeof a$$1 === 'string';
      });
      aliases.forEach(alias => {
        acc[alias] = iconName;
      });
    }
    return acc;
  });
  _byAlias = lookup((acc, icon, iconName) => {
    const aliases = icon[2];
    acc[iconName] = iconName;
    aliases.forEach(alias => {
      acc[alias] = iconName;
    });
    return acc;
  });

  // If we have a Kit, we can't determine if regular is available since we
  // could be auto-fetching it. We'll have to assume that it is available.
  const hasRegular = 'far' in styles || config.autoFetchSvg;
  const shimLookups = reduce(shims, (acc, shim) => {
    const maybeNameMaybeUnicode = shim[0];
    let prefix = shim[1];
    const iconName = shim[2];
    if (prefix === 'far' && !hasRegular) {
      prefix = 'fas';
    }
    if (typeof maybeNameMaybeUnicode === 'string') {
      acc.names[maybeNameMaybeUnicode] = {
        prefix,
        iconName
      };
    }
    if (typeof maybeNameMaybeUnicode === 'number') {
      acc.unicodes[maybeNameMaybeUnicode.toString(16)] = {
        prefix,
        iconName
      };
    }
    return acc;
  }, {
    names: {},
    unicodes: {}
  });
  _byOldName = shimLookups.names;
  _byOldUnicode = shimLookups.unicodes;
  _defaultUsablePrefix = getCanonicalPrefix(config.styleDefault, {
    family: config.familyDefault
  });
};
onChange(c$$1 => {
  _defaultUsablePrefix = getCanonicalPrefix(c$$1.styleDefault, {
    family: config.familyDefault
  });
});
build();
function byUnicode(prefix, unicode) {
  return (_byUnicode[prefix] || {})[unicode];
}
function byLigature(prefix, ligature) {
  return (_byLigature[prefix] || {})[ligature];
}
function byAlias(prefix, alias) {
  return (_byAlias[prefix] || {})[alias];
}
function byOldName(name) {
  return _byOldName[name] || {
    prefix: null,
    iconName: null
  };
}
function byOldUnicode(unicode) {
  const oldUnicode = _byOldUnicode[unicode];
  const newUnicode = byUnicode('fas', unicode);
  return oldUnicode || (newUnicode ? {
    prefix: 'fas',
    iconName: newUnicode
  } : null) || {
    prefix: null,
    iconName: null
  };
}
function getDefaultUsablePrefix() {
  return _defaultUsablePrefix;
}
const emptyCanonicalIcon = () => {
  return {
    prefix: null,
    iconName: null,
    rest: []
  };
};
function getFamilyId(values) {
  let family = s;
  const famProps = FAMILY_NAMES.reduce((acc, familyId) => {
    acc[familyId] = "".concat(config.cssPrefix, "-").concat(familyId);
    return acc;
  }, {});
  L.forEach(familyId => {
    if (values.includes(famProps[familyId]) || values.some(v$$1 => PREFIXES_FOR_FAMILY[familyId].includes(v$$1))) {
      family = familyId;
    }
  });
  return family;
}
function getCanonicalPrefix(styleOrPrefix) {
  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    family = s
  } = params;
  const style = PREFIX_TO_STYLE[family][styleOrPrefix];

  // handles the exception of passing in only a family of 'duotone' with no style
  if (family === t && !styleOrPrefix) {
    return 'fad';
  }
  const prefix = STYLE_TO_PREFIX[family][styleOrPrefix] || STYLE_TO_PREFIX[family][style];
  const defined = styleOrPrefix in namespace.styles ? styleOrPrefix : null;
  const result = prefix || defined || null;
  return result;
}
function moveNonFaClassesToRest(classNames) {
  let rest = [];
  let iconName = null;
  classNames.forEach(cls => {
    const result = getIconName(config.cssPrefix, cls);
    if (result) {
      iconName = result;
    } else if (cls) {
      rest.push(cls);
    }
  });
  return {
    iconName,
    rest
  };
}
function sortedUniqueValues(arr) {
  return arr.sort().filter((value, index, arr) => {
    return arr.indexOf(value) === index;
  });
}
function getCanonicalIcon(values) {
  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    skipLookups = false
  } = params;
  let givenPrefix = null;
  const faCombinedClasses = Ia.concat(bt$1);
  const faStyleOrFamilyClasses = sortedUniqueValues(values.filter(cls => faCombinedClasses.includes(cls)));
  const nonStyleOrFamilyClasses = sortedUniqueValues(values.filter(cls => !Ia.includes(cls)));
  const faStyles = faStyleOrFamilyClasses.filter(cls => {
    givenPrefix = cls;
    return !P.includes(cls);
  });
  const [styleFromValues = null] = faStyles;
  const family = getFamilyId(faStyleOrFamilyClasses);
  const canonical = _objectSpread2$1(_objectSpread2$1({}, moveNonFaClassesToRest(nonStyleOrFamilyClasses)), {}, {
    prefix: getCanonicalPrefix(styleFromValues, {
      family
    })
  });
  return _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, canonical), getDefaultCanonicalPrefix({
    values,
    family,
    styles,
    config,
    canonical,
    givenPrefix
  })), applyShimAndAlias(skipLookups, givenPrefix, canonical));
}
function applyShimAndAlias(skipLookups, givenPrefix, canonical) {
  let {
    prefix,
    iconName
  } = canonical;
  if (skipLookups || !prefix || !iconName) {
    return {
      prefix,
      iconName
    };
  }
  const shim = givenPrefix === 'fa' ? byOldName(iconName) : {};
  const aliasIconName = byAlias(prefix, iconName);
  iconName = shim.iconName || aliasIconName || iconName;
  prefix = shim.prefix || prefix;
  if (prefix === 'far' && !styles['far'] && styles['fas'] && !config.autoFetchSvg) {
    // Allow a fallback from the regular style to solid if regular is not available
    // but only if we aren't auto-fetching SVGs
    prefix = 'fas';
  }
  return {
    prefix,
    iconName
  };
}
const newCanonicalFamilies = L.filter(familyId => {
  return familyId !== s || familyId !== t;
});
const newCanonicalStyles = Object.keys(ga).filter(key => key !== s).map(key => Object.keys(ga[key])).flat();
function getDefaultCanonicalPrefix(prefixOptions) {
  const {
    values,
    family,
    canonical,
    givenPrefix = '',
    styles = {},
    config: config$$1 = {}
  } = prefixOptions;
  const isDuotoneFamily = family === t;
  const valuesHasDuotone = values.includes('fa-duotone') || values.includes('fad');
  const defaultFamilyIsDuotone = config$$1.familyDefault === 'duotone';
  const canonicalPrefixIsDuotone = canonical.prefix === 'fad' || canonical.prefix === 'fa-duotone';
  if (!isDuotoneFamily && (valuesHasDuotone || defaultFamilyIsDuotone || canonicalPrefixIsDuotone)) {
    canonical.prefix = 'fad';
  }
  if (values.includes('fa-brands') || values.includes('fab')) {
    canonical.prefix = 'fab';
  }
  if (!canonical.prefix && newCanonicalFamilies.includes(family)) {
    const validPrefix = Object.keys(styles).find(key => newCanonicalStyles.includes(key));
    if (validPrefix || config$$1.autoFetchSvg) {
      const defaultPrefix = pt.get(family).defaultShortPrefixId;
      canonical.prefix = defaultPrefix;
      canonical.iconName = byAlias(canonical.prefix, canonical.iconName) || canonical.iconName;
    }
  }
  if (canonical.prefix === 'fa' || givenPrefix === 'fa') {
    // The fa prefix is not canonical. So if it has made it through until this point
    // we will shift it to the correct prefix.
    canonical.prefix = getDefaultUsablePrefix() || 'fas';
  }
  return canonical;
}

class Library {
  constructor() {
    this.definitions = {};
  }
  add() {
    for (var _len = arguments.length, definitions = new Array(_len), _key = 0; _key < _len; _key++) {
      definitions[_key] = arguments[_key];
    }
    const additions = definitions.reduce(this._pullDefinitions, {});
    Object.keys(additions).forEach(key => {
      this.definitions[key] = _objectSpread2$1(_objectSpread2$1({}, this.definitions[key] || {}), additions[key]);
      defineIcons(key, additions[key]);

      // TODO can we stop doing this? We can't get the icons by 'fa-solid' any longer so this probably needs to change
      const longPrefix = PREFIX_TO_LONG_STYLE[s][key];
      if (longPrefix) defineIcons(longPrefix, additions[key]);
      build();
    });
  }
  reset() {
    this.definitions = {};
  }
  _pullDefinitions(additions, definition) {
    const normalized = definition.prefix && definition.iconName && definition.icon ? {
      0: definition
    } : definition;
    Object.keys(normalized).map(key => {
      const {
        prefix,
        iconName,
        icon
      } = normalized[key];
      const aliases = icon[2];
      if (!additions[prefix]) additions[prefix] = {};
      if (aliases.length > 0) {
        aliases.forEach(alias => {
          if (typeof alias === 'string') {
            additions[prefix][alias] = icon;
          }
        });
      }
      additions[prefix][iconName] = icon;
    });
    return additions;
  }
}

let _plugins = [];
let _hooks = {};
const providers = {};
const defaultProviderKeys = Object.keys(providers);
function registerPlugins(nextPlugins, _ref) {
  let {
    mixoutsTo: obj
  } = _ref;
  _plugins = nextPlugins;
  _hooks = {};
  Object.keys(providers).forEach(k => {
    if (defaultProviderKeys.indexOf(k) === -1) {
      delete providers[k];
    }
  });
  _plugins.forEach(plugin => {
    const mixout = plugin.mixout ? plugin.mixout() : {};
    Object.keys(mixout).forEach(tk => {
      if (typeof mixout[tk] === 'function') {
        obj[tk] = mixout[tk];
      }
      if (typeof mixout[tk] === 'object') {
        Object.keys(mixout[tk]).forEach(sk => {
          if (!obj[tk]) {
            obj[tk] = {};
          }
          obj[tk][sk] = mixout[tk][sk];
        });
      }
    });
    if (plugin.hooks) {
      const hooks = plugin.hooks();
      Object.keys(hooks).forEach(hook => {
        if (!_hooks[hook]) {
          _hooks[hook] = [];
        }
        _hooks[hook].push(hooks[hook]);
      });
    }
    if (plugin.provides) {
      plugin.provides(providers);
    }
  });
  return obj;
}
function chainHooks(hook, accumulator) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  const hookFns = _hooks[hook] || [];
  hookFns.forEach(hookFn => {
    accumulator = hookFn.apply(null, [accumulator, ...args]); // eslint-disable-line no-useless-call
  });
  return accumulator;
}
function callHooks(hook) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  const hookFns = _hooks[hook] || [];
  hookFns.forEach(hookFn => {
    hookFn.apply(null, args);
  });
  return undefined;
}
function callProvided() {
  const hook = arguments[0];
  const args = Array.prototype.slice.call(arguments, 1);
  return providers[hook] ? providers[hook].apply(null, args) : undefined;
}

function findIconDefinition(iconLookup) {
  if (iconLookup.prefix === 'fa') {
    iconLookup.prefix = 'fas';
  }
  let {
    iconName
  } = iconLookup;
  const prefix = iconLookup.prefix || getDefaultUsablePrefix();
  if (!iconName) return;
  iconName = byAlias(prefix, iconName) || iconName;
  return iconFromMapping(library.definitions, prefix, iconName) || iconFromMapping(namespace.styles, prefix, iconName);
}
const library = new Library();
const noAuto = () => {
  config.autoReplaceSvg = false;
  config.observeMutations = false;
  callHooks('noAuto');
};
const dom = {
  i2svg: function () {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (IS_DOM) {
      callHooks('beforeI2svg', params);
      callProvided('pseudoElements2svg', params);
      return callProvided('i2svg', params);
    } else {
      return Promise.reject(new Error('Operation requires a DOM of some kind.'));
    }
  },
  watch: function () {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      autoReplaceSvgRoot
    } = params;
    if (config.autoReplaceSvg === false) {
      config.autoReplaceSvg = true;
    }
    config.observeMutations = true;
    domready(() => {
      autoReplace({
        autoReplaceSvgRoot
      });
      callHooks('watch', params);
    });
  }
};
const parse = {
  icon: icon => {
    if (icon === null) {
      return null;
    }
    if (typeof icon === 'object' && icon.prefix && icon.iconName) {
      return {
        prefix: icon.prefix,
        iconName: byAlias(icon.prefix, icon.iconName) || icon.iconName
      };
    }
    if (Array.isArray(icon) && icon.length === 2) {
      const iconName = icon[1].indexOf('fa-') === 0 ? icon[1].slice(3) : icon[1];
      const prefix = getCanonicalPrefix(icon[0]);
      return {
        prefix,
        iconName: byAlias(prefix, iconName) || iconName
      };
    }
    if (typeof icon === 'string' && (icon.indexOf("".concat(config.cssPrefix, "-")) > -1 || icon.match(ICON_SELECTION_SYNTAX_PATTERN))) {
      const canonicalIcon = getCanonicalIcon(icon.split(' '), {
        skipLookups: true
      });
      return {
        prefix: canonicalIcon.prefix || getDefaultUsablePrefix(),
        iconName: byAlias(canonicalIcon.prefix, canonicalIcon.iconName) || canonicalIcon.iconName
      };
    }
    if (typeof icon === 'string') {
      const prefix = getDefaultUsablePrefix();
      return {
        prefix,
        iconName: byAlias(prefix, icon) || icon
      };
    }
  }
};
const api = {
  noAuto,
  config,
  dom,
  parse,
  library,
  findIconDefinition,
  toHtml
};
const autoReplace = function () {
  let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const {
    autoReplaceSvgRoot = DOCUMENT
  } = params;
  if ((Object.keys(namespace.styles).length > 0 || config.autoFetchSvg) && IS_DOM && config.autoReplaceSvg) api.dom.i2svg({
    node: autoReplaceSvgRoot
  });
};

function domVariants(val, abstractCreator) {
  Object.defineProperty(val, 'abstract', {
    get: abstractCreator
  });
  Object.defineProperty(val, 'html', {
    get: function () {
      return val.abstract.map(a => toHtml(a));
    }
  });
  Object.defineProperty(val, 'node', {
    get: function () {
      if (!IS_DOM) return;
      const container = DOCUMENT.createElement('div');
      container.innerHTML = val.html;
      return container.children;
    }
  });
  return val;
}

function asIcon (_ref) {
  let {
    children,
    main,
    mask,
    attributes,
    styles,
    transform
  } = _ref;
  if (transformIsMeaningful(transform) && main.found && !mask.found) {
    const {
      width,
      height
    } = main;
    const offset = {
      x: width / height / 2,
      y: 0.5
    };
    attributes['style'] = joinStyles(_objectSpread2$1(_objectSpread2$1({}, styles), {}, {
      'transform-origin': "".concat(offset.x + transform.x / 16, "em ").concat(offset.y + transform.y / 16, "em")
    }));
  }
  return [{
    tag: 'svg',
    attributes,
    children
  }];
}

function asSymbol (_ref) {
  let {
    prefix,
    iconName,
    children,
    attributes,
    symbol
  } = _ref;
  const id = symbol === true ? "".concat(prefix, "-").concat(config.cssPrefix, "-").concat(iconName) : symbol;
  return [{
    tag: 'svg',
    attributes: {
      style: 'display: none;'
    },
    children: [{
      tag: 'symbol',
      attributes: _objectSpread2$1(_objectSpread2$1({}, attributes), {}, {
        id
      }),
      children
    }]
  }];
}

function makeInlineSvgAbstract(params) {
  const {
    icons: {
      main,
      mask
    },
    prefix,
    iconName,
    transform,
    symbol,
    title,
    maskId,
    titleId,
    extra,
    watchable = false
  } = params;
  const {
    width,
    height
  } = mask.found ? mask : main;
  const isUploadedIcon = Lt.includes(prefix);
  const attrClass = [config.replacementClass, iconName ? "".concat(config.cssPrefix, "-").concat(iconName) : ''].filter(c$$1 => extra.classes.indexOf(c$$1) === -1).filter(c$$1 => c$$1 !== '' || !!c$$1).concat(extra.classes).join(' ');
  let content = {
    children: [],
    attributes: _objectSpread2$1(_objectSpread2$1({}, extra.attributes), {}, {
      'data-prefix': prefix,
      'data-icon': iconName,
      'class': attrClass,
      'role': extra.attributes.role || 'img',
      'xmlns': 'http://www.w3.org/2000/svg',
      'viewBox': "0 0 ".concat(width, " ").concat(height)
    })
  };
  const uploadedIconWidthStyle = isUploadedIcon && !~extra.classes.indexOf('fa-fw') ? {
    width: "".concat(width / height * 16 * 0.0625, "em")
  } : {};
  if (watchable) {
    content.attributes[DATA_FA_I2SVG] = '';
  }
  if (title) {
    content.children.push({
      tag: 'title',
      attributes: {
        id: content.attributes['aria-labelledby'] || "title-".concat(titleId || nextUniqueId())
      },
      children: [title]
    });
    delete content.attributes.title;
  }
  const args = _objectSpread2$1(_objectSpread2$1({}, content), {}, {
    prefix,
    iconName,
    main,
    mask,
    maskId,
    transform,
    symbol,
    styles: _objectSpread2$1(_objectSpread2$1({}, uploadedIconWidthStyle), extra.styles)
  });
  const {
    children,
    attributes
  } = mask.found && main.found ? callProvided('generateAbstractMask', args) || {
    children: [],
    attributes: {}
  } : callProvided('generateAbstractIcon', args) || {
    children: [],
    attributes: {}
  };
  args.children = children;
  args.attributes = attributes;
  if (symbol) {
    return asSymbol(args);
  } else {
    return asIcon(args);
  }
}
function makeLayersTextAbstract(params) {
  const {
    content,
    width,
    height,
    transform,
    title,
    extra,
    watchable = false
  } = params;
  const attributes = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, extra.attributes), title ? {
    'title': title
  } : {}), {}, {
    'class': extra.classes.join(' ')
  });
  if (watchable) {
    attributes[DATA_FA_I2SVG] = '';
  }
  const styles = _objectSpread2$1({}, extra.styles);
  if (transformIsMeaningful(transform)) {
    styles['transform'] = transformForCss({
      transform,
      startCentered: true,
      width,
      height
    });
    styles['-webkit-transform'] = styles['transform'];
  }
  const styleString = joinStyles(styles);
  if (styleString.length > 0) {
    attributes['style'] = styleString;
  }
  const val = [];
  val.push({
    tag: 'span',
    attributes,
    children: [content]
  });
  if (title) {
    val.push({
      tag: 'span',
      attributes: {
        class: 'sr-only'
      },
      children: [title]
    });
  }
  return val;
}
function makeLayersCounterAbstract(params) {
  const {
    content,
    title,
    extra
  } = params;
  const attributes = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, extra.attributes), title ? {
    'title': title
  } : {}), {}, {
    'class': extra.classes.join(' ')
  });
  const styleString = joinStyles(extra.styles);
  if (styleString.length > 0) {
    attributes['style'] = styleString;
  }
  const val = [];
  val.push({
    tag: 'span',
    attributes,
    children: [content]
  });
  if (title) {
    val.push({
      tag: 'span',
      attributes: {
        class: 'sr-only'
      },
      children: [title]
    });
  }
  return val;
}

const {
  styles: styles$1
} = namespace;
function asFoundIcon(icon) {
  const width = icon[0];
  const height = icon[1];
  const [vectorData] = icon.slice(4);
  let element = null;
  if (Array.isArray(vectorData)) {
    element = {
      tag: 'g',
      attributes: {
        class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.GROUP)
      },
      children: [{
        tag: 'path',
        attributes: {
          class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.SECONDARY),
          fill: 'currentColor',
          d: vectorData[0]
        }
      }, {
        tag: 'path',
        attributes: {
          class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.PRIMARY),
          fill: 'currentColor',
          d: vectorData[1]
        }
      }]
    };
  } else {
    element = {
      tag: 'path',
      attributes: {
        fill: 'currentColor',
        d: vectorData
      }
    };
  }
  return {
    found: true,
    width,
    height,
    icon: element
  };
}
const missingIconResolutionMixin = {
  found: false,
  width: 512,
  height: 512
};
function maybeNotifyMissing(iconName, prefix) {
  if (!PRODUCTION$1 && !config.showMissingIcons && iconName) {
    console.error("Icon with name \"".concat(iconName, "\" and prefix \"").concat(prefix, "\" is missing."));
  }
}
function findIcon(iconName, prefix) {
  let givenPrefix = prefix;
  if (prefix === 'fa' && config.styleDefault !== null) {
    prefix = getDefaultUsablePrefix();
  }
  return new Promise((resolve, reject) => {
    if (givenPrefix === 'fa') {
      const shim = byOldName(iconName) || {};
      iconName = shim.iconName || iconName;
      prefix = shim.prefix || prefix;
    }
    if (iconName && prefix && styles$1[prefix] && styles$1[prefix][iconName]) {
      const icon = styles$1[prefix][iconName];
      return resolve(asFoundIcon(icon));
    }
    maybeNotifyMissing(iconName, prefix);
    resolve(_objectSpread2$1(_objectSpread2$1({}, missingIconResolutionMixin), {}, {
      icon: config.showMissingIcons && iconName ? callProvided('missingIconAbstract') || {} : {}
    }));
  });
}

const noop$1 = () => {};
const p$2 = config.measurePerformance && PERFORMANCE && PERFORMANCE.mark && PERFORMANCE.measure ? PERFORMANCE : {
  mark: noop$1,
  measure: noop$1
};
const preamble = "FA \"6.7.2\"";
const begin = name => {
  p$2.mark("".concat(preamble, " ").concat(name, " begins"));
  return () => end(name);
};
const end = name => {
  p$2.mark("".concat(preamble, " ").concat(name, " ends"));
  p$2.measure("".concat(preamble, " ").concat(name), "".concat(preamble, " ").concat(name, " begins"), "".concat(preamble, " ").concat(name, " ends"));
};
var perf = {
  begin,
  end
};

const noop$2 = () => {};
function isWatched(node) {
  const i2svg = node.getAttribute ? node.getAttribute(DATA_FA_I2SVG) : null;
  return typeof i2svg === 'string';
}
function hasPrefixAndIcon(node) {
  const prefix = node.getAttribute ? node.getAttribute(DATA_PREFIX) : null;
  const icon = node.getAttribute ? node.getAttribute(DATA_ICON) : null;
  return prefix && icon;
}
function hasBeenReplaced(node) {
  return node && node.classList && node.classList.contains && node.classList.contains(config.replacementClass);
}
function getMutator() {
  if (config.autoReplaceSvg === true) {
    return mutators.replace;
  }
  const mutator = mutators[config.autoReplaceSvg];
  return mutator || mutators.replace;
}
function createElementNS(tag) {
  return DOCUMENT.createElementNS('http://www.w3.org/2000/svg', tag);
}
function createElement(tag) {
  return DOCUMENT.createElement(tag);
}
function convertSVG(abstractObj) {
  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    ceFn = abstractObj.tag === 'svg' ? createElementNS : createElement
  } = params;
  if (typeof abstractObj === 'string') {
    return DOCUMENT.createTextNode(abstractObj);
  }
  const tag = ceFn(abstractObj.tag);
  Object.keys(abstractObj.attributes || []).forEach(function (key) {
    tag.setAttribute(key, abstractObj.attributes[key]);
  });
  const children = abstractObj.children || [];
  children.forEach(function (child) {
    tag.appendChild(convertSVG(child, {
      ceFn
    }));
  });
  return tag;
}
function nodeAsComment(node) {
  let comment = " ".concat(node.outerHTML, " ");
  /* BEGIN.ATTRIBUTION */
  comment = "".concat(comment, "Font Awesome fontawesome.com ");
  /* END.ATTRIBUTION */
  return comment;
}
const mutators = {
  replace: function (mutation) {
    const node = mutation[0];
    if (node.parentNode) {
      mutation[1].forEach(abstract => {
        node.parentNode.insertBefore(convertSVG(abstract), node);
      });
      if (node.getAttribute(DATA_FA_I2SVG) === null && config.keepOriginalSource) {
        let comment = DOCUMENT.createComment(nodeAsComment(node));
        node.parentNode.replaceChild(comment, node);
      } else {
        node.remove();
      }
    }
  },
  nest: function (mutation) {
    const node = mutation[0];
    const abstract = mutation[1];

    // If we already have a replaced node we do not want to continue nesting within it.
    // Short-circuit to the standard replacement
    if (~classArray(node).indexOf(config.replacementClass)) {
      return mutators.replace(mutation);
    }
    const forSvg = new RegExp("".concat(config.cssPrefix, "-.*"));
    delete abstract[0].attributes.id;
    if (abstract[0].attributes.class) {
      const splitClasses = abstract[0].attributes.class.split(' ').reduce((acc, cls) => {
        if (cls === config.replacementClass || cls.match(forSvg)) {
          acc.toSvg.push(cls);
        } else {
          acc.toNode.push(cls);
        }
        return acc;
      }, {
        toNode: [],
        toSvg: []
      });
      abstract[0].attributes.class = splitClasses.toSvg.join(' ');
      if (splitClasses.toNode.length === 0) {
        node.removeAttribute('class');
      } else {
        node.setAttribute('class', splitClasses.toNode.join(' '));
      }
    }
    const newInnerHTML = abstract.map(a => toHtml(a)).join('\n');
    node.setAttribute(DATA_FA_I2SVG, '');
    node.innerHTML = newInnerHTML;
  }
};
function performOperationSync(op) {
  op();
}
function perform(mutations, callback) {
  const callbackFunction = typeof callback === 'function' ? callback : noop$2;
  if (mutations.length === 0) {
    callbackFunction();
  } else {
    let frame = performOperationSync;
    if (config.mutateApproach === MUTATION_APPROACH_ASYNC) {
      frame = WINDOW.requestAnimationFrame || performOperationSync;
    }
    frame(() => {
      const mutator = getMutator();
      const mark = perf.begin('mutate');
      mutations.map(mutator);
      mark();
      callbackFunction();
    });
  }
}
let disabled = false;
function disableObservation() {
  disabled = true;
}
function enableObservation() {
  disabled = false;
}
let mo = null;
function observe(options) {
  if (!MUTATION_OBSERVER) {
    return;
  }
  if (!config.observeMutations) {
    return;
  }
  const {
    treeCallback = noop$2,
    nodeCallback = noop$2,
    pseudoElementsCallback = noop$2,
    observeMutationsRoot = DOCUMENT
  } = options;
  mo = new MUTATION_OBSERVER(objects => {
    if (disabled) return;
    const defaultPrefix = getDefaultUsablePrefix();
    toArray(objects).forEach(mutationRecord => {
      if (mutationRecord.type === 'childList' && mutationRecord.addedNodes.length > 0 && !isWatched(mutationRecord.addedNodes[0])) {
        if (config.searchPseudoElements) {
          pseudoElementsCallback(mutationRecord.target);
        }
        treeCallback(mutationRecord.target);
      }
      if (mutationRecord.type === 'attributes' && mutationRecord.target.parentNode && config.searchPseudoElements) {
        pseudoElementsCallback(mutationRecord.target.parentNode);
      }
      if (mutationRecord.type === 'attributes' && isWatched(mutationRecord.target) && ~ATTRIBUTES_WATCHED_FOR_MUTATION.indexOf(mutationRecord.attributeName)) {
        if (mutationRecord.attributeName === 'class' && hasPrefixAndIcon(mutationRecord.target)) {
          const {
            prefix,
            iconName
          } = getCanonicalIcon(classArray(mutationRecord.target));
          mutationRecord.target.setAttribute(DATA_PREFIX, prefix || defaultPrefix);
          if (iconName) mutationRecord.target.setAttribute(DATA_ICON, iconName);
        } else if (hasBeenReplaced(mutationRecord.target)) {
          nodeCallback(mutationRecord.target);
        }
      }
    });
  });
  if (!IS_DOM) return;
  mo.observe(observeMutationsRoot, {
    childList: true,
    attributes: true,
    characterData: true,
    subtree: true
  });
}
function disconnect() {
  if (!mo) return;
  mo.disconnect();
}

function styleParser (node) {
  const style = node.getAttribute('style');
  let val = [];
  if (style) {
    val = style.split(';').reduce((acc, style) => {
      const styles = style.split(':');
      const prop = styles[0];
      const value = styles.slice(1);
      if (prop && value.length > 0) {
        acc[prop] = value.join(':').trim();
      }
      return acc;
    }, {});
  }
  return val;
}

function classParser (node) {
  const existingPrefix = node.getAttribute('data-prefix');
  const existingIconName = node.getAttribute('data-icon');
  const innerText = node.innerText !== undefined ? node.innerText.trim() : '';
  let val = getCanonicalIcon(classArray(node));
  if (!val.prefix) {
    val.prefix = getDefaultUsablePrefix();
  }
  if (existingPrefix && existingIconName) {
    val.prefix = existingPrefix;
    val.iconName = existingIconName;
  }
  if (val.iconName && val.prefix) {
    return val;
  }
  if (val.prefix && innerText.length > 0) {
    val.iconName = byLigature(val.prefix, node.innerText) || byUnicode(val.prefix, toHex(node.innerText));
  }
  if (!val.iconName && config.autoFetchSvg && node.firstChild && node.firstChild.nodeType === Node.TEXT_NODE) {
    val.iconName = node.firstChild.data;
  }
  return val;
}

function attributesParser (node) {
  const extraAttributes = toArray(node.attributes).reduce((acc, attr) => {
    if (acc.name !== 'class' && acc.name !== 'style') {
      acc[attr.name] = attr.value;
    }
    return acc;
  }, {});
  const title = node.getAttribute('title');
  const titleId = node.getAttribute('data-fa-title-id');
  if (config.autoA11y) {
    if (title) {
      extraAttributes['aria-labelledby'] = "".concat(config.replacementClass, "-title-").concat(titleId || nextUniqueId());
    } else {
      extraAttributes['aria-hidden'] = 'true';
      extraAttributes['focusable'] = 'false';
    }
  }
  return extraAttributes;
}

function blankMeta() {
  return {
    iconName: null,
    title: null,
    titleId: null,
    prefix: null,
    transform: meaninglessTransform,
    symbol: false,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    extra: {
      classes: [],
      styles: {},
      attributes: {}
    }
  };
}
function parseMeta(node) {
  let parser = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    styleParser: true
  };
  const {
    iconName,
    prefix,
    rest: extraClasses
  } = classParser(node);
  const extraAttributes = attributesParser(node);
  const pluginMeta = chainHooks('parseNodeAttributes', {}, node);
  let extraStyles = parser.styleParser ? styleParser(node) : [];
  return _objectSpread2$1({
    iconName,
    title: node.getAttribute('title'),
    titleId: node.getAttribute('data-fa-title-id'),
    prefix,
    transform: meaninglessTransform,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    symbol: false,
    extra: {
      classes: extraClasses,
      styles: extraStyles,
      attributes: extraAttributes
    }
  }, pluginMeta);
}

const {
  styles: styles$2
} = namespace;
function generateMutation(node) {
  const nodeMeta = config.autoReplaceSvg === 'nest' ? parseMeta(node, {
    styleParser: false
  }) : parseMeta(node);
  if (~nodeMeta.extra.classes.indexOf(LAYERS_TEXT_CLASSNAME)) {
    return callProvided('generateLayersText', node, nodeMeta);
  } else {
    return callProvided('generateSvgReplacementMutation', node, nodeMeta);
  }
}
function getKnownPrefixes() {
  return [...Ft, ...Ia];
}
function onTree(root) {
  let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (!IS_DOM) return Promise.resolve();
  const htmlClassList = DOCUMENT.documentElement.classList;
  const hclAdd = suffix => htmlClassList.add("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix));
  const hclRemove = suffix => htmlClassList.remove("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix));
  const prefixes = config.autoFetchSvg ? getKnownPrefixes() : P.concat(Object.keys(styles$2));
  if (!prefixes.includes('fa')) {
    prefixes.push('fa');
  }
  const prefixesDomQuery = [".".concat(LAYERS_TEXT_CLASSNAME, ":not([").concat(DATA_FA_I2SVG, "])")].concat(prefixes.map(p$$1 => ".".concat(p$$1, ":not([").concat(DATA_FA_I2SVG, "])"))).join(', ');
  if (prefixesDomQuery.length === 0) {
    return Promise.resolve();
  }
  let candidates = [];
  try {
    candidates = toArray(root.querySelectorAll(prefixesDomQuery));
  } catch (e$$1) {
    // noop
  }
  if (candidates.length > 0) {
    hclAdd('pending');
    hclRemove('complete');
  } else {
    return Promise.resolve();
  }
  const mark = perf.begin('onTree');
  const mutations = candidates.reduce((acc, node) => {
    try {
      const mutation = generateMutation(node);
      if (mutation) {
        acc.push(mutation);
      }
    } catch (e$$1) {
      if (!PRODUCTION$1) {
        if (e$$1.name === 'MissingIcon') {
          console.error(e$$1);
        }
      }
    }
    return acc;
  }, []);
  return new Promise((resolve, reject) => {
    Promise.all(mutations).then(resolvedMutations => {
      perform(resolvedMutations, () => {
        hclAdd('active');
        hclAdd('complete');
        hclRemove('pending');
        if (typeof callback === 'function') callback();
        mark();
        resolve();
      });
    }).catch(e$$1 => {
      mark();
      reject(e$$1);
    });
  });
}
function onNode(node) {
  let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  generateMutation(node).then(mutation => {
    if (mutation) {
      perform([mutation], callback);
    }
  });
}
function resolveIcons(next) {
  return function (maybeIconDefinition) {
    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const iconDefinition = (maybeIconDefinition || {}).icon ? maybeIconDefinition : findIconDefinition(maybeIconDefinition || {});
    let {
      mask
    } = params;
    if (mask) {
      mask = (mask || {}).icon ? mask : findIconDefinition(mask || {});
    }
    return next(iconDefinition, _objectSpread2$1(_objectSpread2$1({}, params), {}, {
      mask
    }));
  };
}
const render = function (iconDefinition) {
  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    transform = meaninglessTransform,
    symbol = false,
    mask = null,
    maskId = null,
    title = null,
    titleId = null,
    classes = [],
    attributes = {},
    styles = {}
  } = params;
  if (!iconDefinition) return;
  const {
    prefix,
    iconName,
    icon
  } = iconDefinition;
  return domVariants(_objectSpread2$1({
    type: 'icon'
  }, iconDefinition), () => {
    callHooks('beforeDOMElementCreation', {
      iconDefinition,
      params
    });
    if (config.autoA11y) {
      if (title) {
        attributes['aria-labelledby'] = "".concat(config.replacementClass, "-title-").concat(titleId || nextUniqueId());
      } else {
        attributes['aria-hidden'] = 'true';
        attributes['focusable'] = 'false';
      }
    }
    return makeInlineSvgAbstract({
      icons: {
        main: asFoundIcon(icon),
        mask: mask ? asFoundIcon(mask.icon) : {
          found: false,
          width: null,
          height: null,
          icon: {}
        }
      },
      prefix,
      iconName,
      transform: _objectSpread2$1(_objectSpread2$1({}, meaninglessTransform), transform),
      symbol,
      title,
      maskId,
      titleId,
      extra: {
        attributes,
        styles,
        classes
      }
    });
  });
};
var ReplaceElements = {
  mixout() {
    return {
      icon: resolveIcons(render)
    };
  },
  hooks() {
    return {
      mutationObserverCallbacks(accumulator) {
        accumulator.treeCallback = onTree;
        accumulator.nodeCallback = onNode;
        return accumulator;
      }
    };
  },
  provides(providers$$1) {
    providers$$1.i2svg = function (params) {
      const {
        node = DOCUMENT,
        callback = () => {}
      } = params;
      return onTree(node, callback);
    };
    providers$$1.generateSvgReplacementMutation = function (node, nodeMeta) {
      const {
        iconName,
        title,
        titleId,
        prefix,
        transform,
        symbol,
        mask,
        maskId,
        extra
      } = nodeMeta;
      return new Promise((resolve, reject) => {
        Promise.all([findIcon(iconName, prefix), mask.iconName ? findIcon(mask.iconName, mask.prefix) : Promise.resolve({
          found: false,
          width: 512,
          height: 512,
          icon: {}
        })]).then(_ref => {
          let [main, mask] = _ref;
          resolve([node, makeInlineSvgAbstract({
            icons: {
              main,
              mask
            },
            prefix,
            iconName,
            transform,
            symbol,
            maskId,
            title,
            titleId,
            extra,
            watchable: true
          })]);
        }).catch(reject);
      });
    };
    providers$$1.generateAbstractIcon = function (_ref2) {
      let {
        children,
        attributes,
        main,
        transform,
        styles
      } = _ref2;
      const styleString = joinStyles(styles);
      if (styleString.length > 0) {
        attributes['style'] = styleString;
      }
      let nextChild;
      if (transformIsMeaningful(transform)) {
        nextChild = callProvided('generateAbstractTransformGrouping', {
          main,
          transform,
          containerWidth: main.width,
          iconWidth: main.width
        });
      }
      children.push(nextChild || main.icon);
      return {
        children,
        attributes
      };
    };
  }
};

var Layers = {
  mixout() {
    return {
      layer(assembler) {
        let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        const {
          classes = []
        } = params;
        return domVariants({
          type: 'layer'
        }, () => {
          callHooks('beforeDOMElementCreation', {
            assembler,
            params
          });
          let children = [];
          assembler(args => {
            Array.isArray(args) ? args.map(a => {
              children = children.concat(a.abstract);
            }) : children = children.concat(args.abstract);
          });
          return [{
            tag: 'span',
            attributes: {
              class: ["".concat(config.cssPrefix, "-layers"), ...classes].join(' ')
            },
            children
          }];
        });
      }
    };
  }
};

var LayersCounter = {
  mixout() {
    return {
      counter(content) {
        let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        const {
          title = null,
          classes = [],
          attributes = {},
          styles = {}
        } = params;
        return domVariants({
          type: 'counter',
          content
        }, () => {
          callHooks('beforeDOMElementCreation', {
            content,
            params
          });
          return makeLayersCounterAbstract({
            content: content.toString(),
            title,
            extra: {
              attributes,
              styles,
              classes: ["".concat(config.cssPrefix, "-layers-counter"), ...classes]
            }
          });
        });
      }
    };
  }
};

var LayersText = {
  mixout() {
    return {
      text(content) {
        let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        const {
          transform = meaninglessTransform,
          title = null,
          classes = [],
          attributes = {},
          styles = {}
        } = params;
        return domVariants({
          type: 'text',
          content
        }, () => {
          callHooks('beforeDOMElementCreation', {
            content,
            params
          });
          return makeLayersTextAbstract({
            content,
            transform: _objectSpread2$1(_objectSpread2$1({}, meaninglessTransform), transform),
            title,
            extra: {
              attributes,
              styles,
              classes: ["".concat(config.cssPrefix, "-layers-text"), ...classes]
            }
          });
        });
      }
    };
  },
  provides(providers$$1) {
    providers$$1.generateLayersText = function (node, nodeMeta) {
      const {
        title,
        transform,
        extra
      } = nodeMeta;
      let width = null;
      let height = null;
      if (IS_IE) {
        const computedFontSize = parseInt(getComputedStyle(node).fontSize, 10);
        const boundingClientRect = node.getBoundingClientRect();
        width = boundingClientRect.width / computedFontSize;
        height = boundingClientRect.height / computedFontSize;
      }
      if (config.autoA11y && !title) {
        extra.attributes['aria-hidden'] = 'true';
      }
      return Promise.resolve([node, makeLayersTextAbstract({
        content: node.innerHTML,
        width,
        height,
        transform,
        title,
        extra,
        watchable: true
      })]);
    };
  }
};

const CLEAN_CONTENT_PATTERN = new RegExp('\u{22}', 'ug');
const SECONDARY_UNICODE_RANGE = [1105920, 1112319];
const _FONT_FAMILY_WEIGHT_TO_PREFIX = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, {
  FontAwesome: {
    normal: 'fas',
    400: 'fas'
  }
}), lt), wa), Yt);
const FONT_FAMILY_WEIGHT_TO_PREFIX = Object.keys(_FONT_FAMILY_WEIGHT_TO_PREFIX).reduce((acc, key) => {
  acc[key.toLowerCase()] = _FONT_FAMILY_WEIGHT_TO_PREFIX[key];
  return acc;
}, {});
const FONT_FAMILY_WEIGHT_FALLBACK = Object.keys(FONT_FAMILY_WEIGHT_TO_PREFIX).reduce((acc, fontFamily) => {
  const weights = FONT_FAMILY_WEIGHT_TO_PREFIX[fontFamily];
  acc[fontFamily] = weights[900] || [...Object.entries(weights)][0][1];
  return acc;
}, {});
function hexValueFromContent(content) {
  const cleaned = content.replace(CLEAN_CONTENT_PATTERN, '');
  const codePoint = codePointAt(cleaned, 0);
  const isPrependTen = codePoint >= SECONDARY_UNICODE_RANGE[0] && codePoint <= SECONDARY_UNICODE_RANGE[1];
  const isDoubled = cleaned.length === 2 ? cleaned[0] === cleaned[1] : false;
  return {
    value: isDoubled ? toHex(cleaned[0]) : toHex(cleaned),
    isSecondary: isPrependTen || isDoubled
  };
}
function getPrefix(fontFamily, fontWeight) {
  const fontFamilySanitized = fontFamily.replace(/^['"]|['"]$/g, '').toLowerCase();
  const fontWeightInteger = parseInt(fontWeight);
  const fontWeightSanitized = isNaN(fontWeightInteger) ? 'normal' : fontWeightInteger;
  return (FONT_FAMILY_WEIGHT_TO_PREFIX[fontFamilySanitized] || {})[fontWeightSanitized] || FONT_FAMILY_WEIGHT_FALLBACK[fontFamilySanitized];
}
function replaceForPosition(node, position) {
  const pendingAttribute = "".concat(DATA_FA_PSEUDO_ELEMENT_PENDING).concat(position.replace(':', '-'));
  return new Promise((resolve, reject) => {
    if (node.getAttribute(pendingAttribute) !== null) {
      // This node is already being processed
      return resolve();
    }
    const children = toArray(node.children);
    const alreadyProcessedPseudoElement = children.filter(c$$1 => c$$1.getAttribute(DATA_FA_PSEUDO_ELEMENT) === position)[0];
    const styles = WINDOW.getComputedStyle(node, position);
    const fontFamily = styles.getPropertyValue('font-family');
    const fontFamilyMatch = fontFamily.match(FONT_FAMILY_PATTERN);
    const fontWeight = styles.getPropertyValue('font-weight');
    const content = styles.getPropertyValue('content');
    if (alreadyProcessedPseudoElement && !fontFamilyMatch) {
      // If we've already processed it but the current computed style does not result in a font-family,
      // that probably means that a class name that was previously present to make the icon has been
      // removed. So we now should delete the icon.
      node.removeChild(alreadyProcessedPseudoElement);
      return resolve();
    } else if (fontFamilyMatch && content !== 'none' && content !== '') {
      const content = styles.getPropertyValue('content');
      let prefix = getPrefix(fontFamily, fontWeight);
      const {
        value: hexValue,
        isSecondary
      } = hexValueFromContent(content);
      const isV4 = fontFamilyMatch[0].startsWith('FontAwesome');
      let iconName = byUnicode(prefix, hexValue);
      let iconIdentifier = iconName;
      if (isV4) {
        const iconName4 = byOldUnicode(hexValue);
        if (iconName4.iconName && iconName4.prefix) {
          iconName = iconName4.iconName;
          prefix = iconName4.prefix;
        }
      }

      // Only convert the pseudo element in this ::before/::after position into an icon if we haven't
      // already done so with the same prefix and iconName
      if (iconName && !isSecondary && (!alreadyProcessedPseudoElement || alreadyProcessedPseudoElement.getAttribute(DATA_PREFIX) !== prefix || alreadyProcessedPseudoElement.getAttribute(DATA_ICON) !== iconIdentifier)) {
        node.setAttribute(pendingAttribute, iconIdentifier);
        if (alreadyProcessedPseudoElement) {
          // Delete the old one, since we're replacing it with a new one
          node.removeChild(alreadyProcessedPseudoElement);
        }
        const meta = blankMeta();
        const {
          extra
        } = meta;
        extra.attributes[DATA_FA_PSEUDO_ELEMENT] = position;
        findIcon(iconName, prefix).then(main => {
          const abstract = makeInlineSvgAbstract(_objectSpread2$1(_objectSpread2$1({}, meta), {}, {
            icons: {
              main,
              mask: emptyCanonicalIcon()
            },
            prefix,
            iconName: iconIdentifier,
            extra,
            watchable: true
          }));
          const element = DOCUMENT.createElementNS('http://www.w3.org/2000/svg', 'svg');
          if (position === '::before') {
            node.insertBefore(element, node.firstChild);
          } else {
            node.appendChild(element);
          }
          element.outerHTML = abstract.map(a$$1 => toHtml(a$$1)).join('\n');
          node.removeAttribute(pendingAttribute);
          resolve();
        }).catch(reject);
      } else {
        resolve();
      }
    } else {
      resolve();
    }
  });
}
function replace(node) {
  return Promise.all([replaceForPosition(node, '::before'), replaceForPosition(node, '::after')]);
}
function processable(node) {
  return node.parentNode !== document.head && !~TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS.indexOf(node.tagName.toUpperCase()) && !node.getAttribute(DATA_FA_PSEUDO_ELEMENT) && (!node.parentNode || node.parentNode.tagName !== 'svg');
}
function searchPseudoElements(root) {
  if (!IS_DOM) return;
  return new Promise((resolve, reject) => {
    const operations = toArray(root.querySelectorAll('*')).filter(processable).map(replace);
    const end = perf.begin('searchPseudoElements');
    disableObservation();
    Promise.all(operations).then(() => {
      end();
      enableObservation();
      resolve();
    }).catch(() => {
      end();
      enableObservation();
      reject();
    });
  });
}
var PseudoElements = {
  hooks() {
    return {
      mutationObserverCallbacks(accumulator) {
        accumulator.pseudoElementsCallback = searchPseudoElements;
        return accumulator;
      }
    };
  },
  provides(providers) {
    providers.pseudoElements2svg = function (params) {
      const {
        node = DOCUMENT
      } = params;
      if (config.searchPseudoElements) {
        searchPseudoElements(node);
      }
    };
  }
};

let _unwatched = false;
var MutationObserver$1 = {
  mixout() {
    return {
      dom: {
        unwatch() {
          disableObservation();
          _unwatched = true;
        }
      }
    };
  },
  hooks() {
    return {
      bootstrap() {
        observe(chainHooks('mutationObserverCallbacks', {}));
      },
      noAuto() {
        disconnect();
      },
      watch(params) {
        const {
          observeMutationsRoot
        } = params;
        if (_unwatched) {
          enableObservation();
        } else {
          observe(chainHooks('mutationObserverCallbacks', {
            observeMutationsRoot
          }));
        }
      }
    };
  }
};

const parseTransformString = transformString => {
  let transform = {
    size: 16,
    x: 0,
    y: 0,
    flipX: false,
    flipY: false,
    rotate: 0
  };
  return transformString.toLowerCase().split(' ').reduce((acc, n) => {
    const parts = n.toLowerCase().split('-');
    const first = parts[0];
    let rest = parts.slice(1).join('-');
    if (first && rest === 'h') {
      acc.flipX = true;
      return acc;
    }
    if (first && rest === 'v') {
      acc.flipY = true;
      return acc;
    }
    rest = parseFloat(rest);
    if (isNaN(rest)) {
      return acc;
    }
    switch (first) {
      case 'grow':
        acc.size = acc.size + rest;
        break;
      case 'shrink':
        acc.size = acc.size - rest;
        break;
      case 'left':
        acc.x = acc.x - rest;
        break;
      case 'right':
        acc.x = acc.x + rest;
        break;
      case 'up':
        acc.y = acc.y - rest;
        break;
      case 'down':
        acc.y = acc.y + rest;
        break;
      case 'rotate':
        acc.rotate = acc.rotate + rest;
        break;
    }
    return acc;
  }, transform);
};
var PowerTransforms = {
  mixout() {
    return {
      parse: {
        transform: transformString => {
          return parseTransformString(transformString);
        }
      }
    };
  },
  hooks() {
    return {
      parseNodeAttributes(accumulator, node) {
        const transformString = node.getAttribute('data-fa-transform');
        if (transformString) {
          accumulator.transform = parseTransformString(transformString);
        }
        return accumulator;
      }
    };
  },
  provides(providers) {
    providers.generateAbstractTransformGrouping = function (_ref) {
      let {
        main,
        transform,
        containerWidth,
        iconWidth
      } = _ref;
      const outer = {
        transform: "translate(".concat(containerWidth / 2, " 256)")
      };
      const innerTranslate = "translate(".concat(transform.x * 32, ", ").concat(transform.y * 32, ") ");
      const innerScale = "scale(".concat(transform.size / 16 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / 16 * (transform.flipY ? -1 : 1), ") ");
      const innerRotate = "rotate(".concat(transform.rotate, " 0 0)");
      const inner = {
        transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
      };
      const path = {
        transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
      };
      const operations = {
        outer,
        inner,
        path
      };
      return {
        tag: 'g',
        attributes: _objectSpread2$1({}, operations.outer),
        children: [{
          tag: 'g',
          attributes: _objectSpread2$1({}, operations.inner),
          children: [{
            tag: main.icon.tag,
            children: main.icon.children,
            attributes: _objectSpread2$1(_objectSpread2$1({}, main.icon.attributes), operations.path)
          }]
        }]
      };
    };
  }
};

const ALL_SPACE = {
  x: 0,
  y: 0,
  width: '100%',
  height: '100%'
};
function fillBlack(abstract) {
  let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  if (abstract.attributes && (abstract.attributes.fill || force)) {
    abstract.attributes.fill = 'black';
  }
  return abstract;
}
function deGroup(abstract) {
  if (abstract.tag === 'g') {
    return abstract.children;
  } else {
    return [abstract];
  }
}
var Masks = {
  hooks() {
    return {
      parseNodeAttributes(accumulator, node) {
        const maskData = node.getAttribute('data-fa-mask');
        const mask = !maskData ? emptyCanonicalIcon() : getCanonicalIcon(maskData.split(' ').map(i => i.trim()));
        if (!mask.prefix) {
          mask.prefix = getDefaultUsablePrefix();
        }
        accumulator.mask = mask;
        accumulator.maskId = node.getAttribute('data-fa-mask-id');
        return accumulator;
      }
    };
  },
  provides(providers) {
    providers.generateAbstractMask = function (_ref) {
      let {
        children,
        attributes,
        main,
        mask,
        maskId: explicitMaskId,
        transform
      } = _ref;
      const {
        width: mainWidth,
        icon: mainPath
      } = main;
      const {
        width: maskWidth,
        icon: maskPath
      } = mask;
      const trans = transformForSvg({
        transform,
        containerWidth: maskWidth,
        iconWidth: mainWidth
      });
      const maskRect = {
        tag: 'rect',
        attributes: _objectSpread2$1(_objectSpread2$1({}, ALL_SPACE), {}, {
          fill: 'white'
        })
      };
      const maskInnerGroupChildrenMixin = mainPath.children ? {
        children: mainPath.children.map(fillBlack)
      } : {};
      const maskInnerGroup = {
        tag: 'g',
        attributes: _objectSpread2$1({}, trans.inner),
        children: [fillBlack(_objectSpread2$1({
          tag: mainPath.tag,
          attributes: _objectSpread2$1(_objectSpread2$1({}, mainPath.attributes), trans.path)
        }, maskInnerGroupChildrenMixin))]
      };
      const maskOuterGroup = {
        tag: 'g',
        attributes: _objectSpread2$1({}, trans.outer),
        children: [maskInnerGroup]
      };
      const maskId = "mask-".concat(explicitMaskId || nextUniqueId());
      const clipId = "clip-".concat(explicitMaskId || nextUniqueId());
      const maskTag = {
        tag: 'mask',
        attributes: _objectSpread2$1(_objectSpread2$1({}, ALL_SPACE), {}, {
          id: maskId,
          maskUnits: 'userSpaceOnUse',
          maskContentUnits: 'userSpaceOnUse'
        }),
        children: [maskRect, maskOuterGroup]
      };
      const defs = {
        tag: 'defs',
        children: [{
          tag: 'clipPath',
          attributes: {
            id: clipId
          },
          children: deGroup(maskPath)
        }, maskTag]
      };
      children.push(defs, {
        tag: 'rect',
        attributes: _objectSpread2$1({
          fill: 'currentColor',
          'clip-path': "url(#".concat(clipId, ")"),
          mask: "url(#".concat(maskId, ")")
        }, ALL_SPACE)
      });
      return {
        children,
        attributes
      };
    };
  }
};

var MissingIconIndicator = {
  provides(providers) {
    let reduceMotion = false;
    if (WINDOW.matchMedia) {
      reduceMotion = WINDOW.matchMedia('(prefers-reduced-motion: reduce)').matches;
    }
    providers.missingIconAbstract = function () {
      const gChildren = [];
      const FILL = {
        fill: 'currentColor'
      };
      const ANIMATION_BASE = {
        attributeType: 'XML',
        repeatCount: 'indefinite',
        dur: '2s'
      };

      // Ring
      gChildren.push({
        tag: 'path',
        attributes: _objectSpread2$1(_objectSpread2$1({}, FILL), {}, {
          d: 'M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z'
        })
      });
      const OPACITY_ANIMATE = _objectSpread2$1(_objectSpread2$1({}, ANIMATION_BASE), {}, {
        attributeName: 'opacity'
      });
      const dot = {
        tag: 'circle',
        attributes: _objectSpread2$1(_objectSpread2$1({}, FILL), {}, {
          cx: '256',
          cy: '364',
          r: '28'
        }),
        children: []
      };
      if (!reduceMotion) {
        dot.children.push({
          tag: 'animate',
          attributes: _objectSpread2$1(_objectSpread2$1({}, ANIMATION_BASE), {}, {
            attributeName: 'r',
            values: '28;14;28;28;14;28;'
          })
        }, {
          tag: 'animate',
          attributes: _objectSpread2$1(_objectSpread2$1({}, OPACITY_ANIMATE), {}, {
            values: '1;0;1;1;0;1;'
          })
        });
      }
      gChildren.push(dot);
      gChildren.push({
        tag: 'path',
        attributes: _objectSpread2$1(_objectSpread2$1({}, FILL), {}, {
          opacity: '1',
          d: 'M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z'
        }),
        children: reduceMotion ? [] : [{
          tag: 'animate',
          attributes: _objectSpread2$1(_objectSpread2$1({}, OPACITY_ANIMATE), {}, {
            values: '1;0;0;0;0;1;'
          })
        }]
      });
      if (!reduceMotion) {
        // Exclamation
        gChildren.push({
          tag: 'path',
          attributes: _objectSpread2$1(_objectSpread2$1({}, FILL), {}, {
            opacity: '0',
            d: 'M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z'
          }),
          children: [{
            tag: 'animate',
            attributes: _objectSpread2$1(_objectSpread2$1({}, OPACITY_ANIMATE), {}, {
              values: '0;0;1;1;0;0;'
            })
          }]
        });
      }
      return {
        tag: 'g',
        attributes: {
          'class': 'missing'
        },
        children: gChildren
      };
    };
  }
};

var SvgSymbols = {
  hooks() {
    return {
      parseNodeAttributes(accumulator, node) {
        const symbolData = node.getAttribute('data-fa-symbol');
        const symbol = symbolData === null ? false : symbolData === '' ? true : symbolData;
        accumulator['symbol'] = symbol;
        return accumulator;
      }
    };
  }
};

var plugins = [InjectCSS, ReplaceElements, Layers, LayersCounter, LayersText, PseudoElements, MutationObserver$1, PowerTransforms, Masks, MissingIconIndicator, SvgSymbols];

registerPlugins(plugins, {
  mixoutsTo: api
});
api.noAuto;
api.config;
api.library;
api.dom;
const parse$1 = api.parse;
api.findIconDefinition;
api.toHtml;
const icon = api.icon;
api.layer;
api.text;
api.counter;

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var propTypes = {exports: {}};

var reactIs = {exports: {}};

var reactIs_production_min = {};

/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_production_min;

function requireReactIs_production_min () {
	if (hasRequiredReactIs_production_min) return reactIs_production_min;
	hasRequiredReactIs_production_min = 1;
var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
	Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
	function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}reactIs_production_min.AsyncMode=l;reactIs_production_min.ConcurrentMode=m;reactIs_production_min.ContextConsumer=k;reactIs_production_min.ContextProvider=h;reactIs_production_min.Element=c;reactIs_production_min.ForwardRef=n;reactIs_production_min.Fragment=e;reactIs_production_min.Lazy=t;reactIs_production_min.Memo=r;reactIs_production_min.Portal=d;
	reactIs_production_min.Profiler=g;reactIs_production_min.StrictMode=f;reactIs_production_min.Suspense=p;reactIs_production_min.isAsyncMode=function(a){return A(a)||z(a)===l};reactIs_production_min.isConcurrentMode=A;reactIs_production_min.isContextConsumer=function(a){return z(a)===k};reactIs_production_min.isContextProvider=function(a){return z(a)===h};reactIs_production_min.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};reactIs_production_min.isForwardRef=function(a){return z(a)===n};reactIs_production_min.isFragment=function(a){return z(a)===e};reactIs_production_min.isLazy=function(a){return z(a)===t};
	reactIs_production_min.isMemo=function(a){return z(a)===r};reactIs_production_min.isPortal=function(a){return z(a)===d};reactIs_production_min.isProfiler=function(a){return z(a)===g};reactIs_production_min.isStrictMode=function(a){return z(a)===f};reactIs_production_min.isSuspense=function(a){return z(a)===p};
	reactIs_production_min.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};reactIs_production_min.typeOf=z;
	return reactIs_production_min;
}

var reactIs_development = {};

/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_development;

function requireReactIs_development () {
	if (hasRequiredReactIs_development) return reactIs_development;
	hasRequiredReactIs_development = 1;



	if (process.env.NODE_ENV !== "production") {
	  (function() {

	// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var hasSymbol = typeof Symbol === 'function' && Symbol.for;
	var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
	var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
	var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
	var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
	var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
	var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
	var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
	// (unstable) APIs that have been removed. Can we remove the symbols?

	var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
	var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
	var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
	var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
	var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
	var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
	var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
	var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
	var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
	var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
	var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

	function isValidElementType(type) {
	  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
	  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
	}

	function typeOf(object) {
	  if (typeof object === 'object' && object !== null) {
	    var $$typeof = object.$$typeof;

	    switch ($$typeof) {
	      case REACT_ELEMENT_TYPE:
	        var type = object.type;

	        switch (type) {
	          case REACT_ASYNC_MODE_TYPE:
	          case REACT_CONCURRENT_MODE_TYPE:
	          case REACT_FRAGMENT_TYPE:
	          case REACT_PROFILER_TYPE:
	          case REACT_STRICT_MODE_TYPE:
	          case REACT_SUSPENSE_TYPE:
	            return type;

	          default:
	            var $$typeofType = type && type.$$typeof;

	            switch ($$typeofType) {
	              case REACT_CONTEXT_TYPE:
	              case REACT_FORWARD_REF_TYPE:
	              case REACT_LAZY_TYPE:
	              case REACT_MEMO_TYPE:
	              case REACT_PROVIDER_TYPE:
	                return $$typeofType;

	              default:
	                return $$typeof;
	            }

	        }

	      case REACT_PORTAL_TYPE:
	        return $$typeof;
	    }
	  }

	  return undefined;
	} // AsyncMode is deprecated along with isAsyncMode

	var AsyncMode = REACT_ASYNC_MODE_TYPE;
	var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
	var ContextConsumer = REACT_CONTEXT_TYPE;
	var ContextProvider = REACT_PROVIDER_TYPE;
	var Element = REACT_ELEMENT_TYPE;
	var ForwardRef = REACT_FORWARD_REF_TYPE;
	var Fragment = REACT_FRAGMENT_TYPE;
	var Lazy = REACT_LAZY_TYPE;
	var Memo = REACT_MEMO_TYPE;
	var Portal = REACT_PORTAL_TYPE;
	var Profiler = REACT_PROFILER_TYPE;
	var StrictMode = REACT_STRICT_MODE_TYPE;
	var Suspense = REACT_SUSPENSE_TYPE;
	var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

	function isAsyncMode(object) {
	  {
	    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
	      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

	      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
	    }
	  }

	  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
	}
	function isConcurrentMode(object) {
	  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
	}
	function isContextConsumer(object) {
	  return typeOf(object) === REACT_CONTEXT_TYPE;
	}
	function isContextProvider(object) {
	  return typeOf(object) === REACT_PROVIDER_TYPE;
	}
	function isElement(object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	}
	function isForwardRef(object) {
	  return typeOf(object) === REACT_FORWARD_REF_TYPE;
	}
	function isFragment(object) {
	  return typeOf(object) === REACT_FRAGMENT_TYPE;
	}
	function isLazy(object) {
	  return typeOf(object) === REACT_LAZY_TYPE;
	}
	function isMemo(object) {
	  return typeOf(object) === REACT_MEMO_TYPE;
	}
	function isPortal(object) {
	  return typeOf(object) === REACT_PORTAL_TYPE;
	}
	function isProfiler(object) {
	  return typeOf(object) === REACT_PROFILER_TYPE;
	}
	function isStrictMode(object) {
	  return typeOf(object) === REACT_STRICT_MODE_TYPE;
	}
	function isSuspense(object) {
	  return typeOf(object) === REACT_SUSPENSE_TYPE;
	}

	reactIs_development.AsyncMode = AsyncMode;
	reactIs_development.ConcurrentMode = ConcurrentMode;
	reactIs_development.ContextConsumer = ContextConsumer;
	reactIs_development.ContextProvider = ContextProvider;
	reactIs_development.Element = Element;
	reactIs_development.ForwardRef = ForwardRef;
	reactIs_development.Fragment = Fragment;
	reactIs_development.Lazy = Lazy;
	reactIs_development.Memo = Memo;
	reactIs_development.Portal = Portal;
	reactIs_development.Profiler = Profiler;
	reactIs_development.StrictMode = StrictMode;
	reactIs_development.Suspense = Suspense;
	reactIs_development.isAsyncMode = isAsyncMode;
	reactIs_development.isConcurrentMode = isConcurrentMode;
	reactIs_development.isContextConsumer = isContextConsumer;
	reactIs_development.isContextProvider = isContextProvider;
	reactIs_development.isElement = isElement;
	reactIs_development.isForwardRef = isForwardRef;
	reactIs_development.isFragment = isFragment;
	reactIs_development.isLazy = isLazy;
	reactIs_development.isMemo = isMemo;
	reactIs_development.isPortal = isPortal;
	reactIs_development.isProfiler = isProfiler;
	reactIs_development.isStrictMode = isStrictMode;
	reactIs_development.isSuspense = isSuspense;
	reactIs_development.isValidElementType = isValidElementType;
	reactIs_development.typeOf = typeOf;
	  })();
	}
	return reactIs_development;
}

var hasRequiredReactIs;

function requireReactIs () {
	if (hasRequiredReactIs) return reactIs.exports;
	hasRequiredReactIs = 1;

	if (process.env.NODE_ENV === 'production') {
	  reactIs.exports = requireReactIs_production_min();
	} else {
	  reactIs.exports = requireReactIs_development();
	}
	return reactIs.exports;
}

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

var objectAssign;
var hasRequiredObjectAssign;

function requireObjectAssign () {
	if (hasRequiredObjectAssign) return objectAssign;
	hasRequiredObjectAssign = 1;
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};
	return objectAssign;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactPropTypesSecret_1;
var hasRequiredReactPropTypesSecret;

function requireReactPropTypesSecret () {
	if (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1;
	hasRequiredReactPropTypesSecret = 1;

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

	ReactPropTypesSecret_1 = ReactPropTypesSecret;
	return ReactPropTypesSecret_1;
}

var has;
var hasRequiredHas;

function requireHas () {
	if (hasRequiredHas) return has;
	hasRequiredHas = 1;
	has = Function.call.bind(Object.prototype.hasOwnProperty);
	return has;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var checkPropTypes_1;
var hasRequiredCheckPropTypes;

function requireCheckPropTypes () {
	if (hasRequiredCheckPropTypes) return checkPropTypes_1;
	hasRequiredCheckPropTypes = 1;

	var printWarning = function() {};

	if (process.env.NODE_ENV !== 'production') {
	  var ReactPropTypesSecret = /*@__PURE__*/ requireReactPropTypesSecret();
	  var loggedTypeFailures = {};
	  var has = /*@__PURE__*/ requireHas();

	  printWarning = function(text) {
	    var message = 'Warning: ' + text;
	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) { /**/ }
	  };
	}

	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?Function} getStack Returns the component stack.
	 * @private
	 */
	function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
	  if (process.env.NODE_ENV !== 'production') {
	    for (var typeSpecName in typeSpecs) {
	      if (has(typeSpecs, typeSpecName)) {
	        var error;
	        // Prop type validation may throw. In case they do, we don't want to
	        // fail the render phase where it didn't fail before. So we log it.
	        // After these have been cleaned up, we'll let them throw.
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          if (typeof typeSpecs[typeSpecName] !== 'function') {
	            var err = Error(
	              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
	              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' +
	              'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'
	            );
	            err.name = 'Invariant Violation';
	            throw err;
	          }
	          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	        } catch (ex) {
	          error = ex;
	        }
	        if (error && !(error instanceof Error)) {
	          printWarning(
	            (componentName || 'React class') + ': type specification of ' +
	            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
	            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
	            'You may have forgotten to pass an argument to the type checker ' +
	            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
	            'shape all require an argument).'
	          );
	        }
	        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	          // Only monitor this failure once because there tends to be a lot of the
	          // same error.
	          loggedTypeFailures[error.message] = true;

	          var stack = getStack ? getStack() : '';

	          printWarning(
	            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
	          );
	        }
	      }
	    }
	  }
	}

	/**
	 * Resets warning cache when testing.
	 *
	 * @private
	 */
	checkPropTypes.resetWarningCache = function() {
	  if (process.env.NODE_ENV !== 'production') {
	    loggedTypeFailures = {};
	  }
	};

	checkPropTypes_1 = checkPropTypes;
	return checkPropTypes_1;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var factoryWithTypeCheckers;
var hasRequiredFactoryWithTypeCheckers;

function requireFactoryWithTypeCheckers () {
	if (hasRequiredFactoryWithTypeCheckers) return factoryWithTypeCheckers;
	hasRequiredFactoryWithTypeCheckers = 1;

	var ReactIs = requireReactIs();
	var assign = requireObjectAssign();

	var ReactPropTypesSecret = /*@__PURE__*/ requireReactPropTypesSecret();
	var has = /*@__PURE__*/ requireHas();
	var checkPropTypes = /*@__PURE__*/ requireCheckPropTypes();

	var printWarning = function() {};

	if (process.env.NODE_ENV !== 'production') {
	  printWarning = function(text) {
	    var message = 'Warning: ' + text;
	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };
	}

	function emptyFunctionThatReturnsNull() {
	  return null;
	}

	factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
	  /* global Symbol */
	  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

	  /**
	   * Returns the iterator method function contained on the iterable object.
	   *
	   * Be sure to invoke the function with the iterable as context:
	   *
	   *     var iteratorFn = getIteratorFn(myIterable);
	   *     if (iteratorFn) {
	   *       var iterator = iteratorFn.call(myIterable);
	   *       ...
	   *     }
	   *
	   * @param {?object} maybeIterable
	   * @return {?function}
	   */
	  function getIteratorFn(maybeIterable) {
	    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  /**
	   * Collection of methods that allow declaration and validation of props that are
	   * supplied to React components. Example usage:
	   *
	   *   var Props = require('ReactPropTypes');
	   *   var MyArticle = React.createClass({
	   *     propTypes: {
	   *       // An optional string prop named "description".
	   *       description: Props.string,
	   *
	   *       // A required enum prop named "category".
	   *       category: Props.oneOf(['News','Photos']).isRequired,
	   *
	   *       // A prop named "dialog" that requires an instance of Dialog.
	   *       dialog: Props.instanceOf(Dialog).isRequired
	   *     },
	   *     render: function() { ... }
	   *   });
	   *
	   * A more formal specification of how these methods are used:
	   *
	   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	   *   decl := ReactPropTypes.{type}(.isRequired)?
	   *
	   * Each and every declaration produces a function with the same signature. This
	   * allows the creation of custom validation functions. For example:
	   *
	   *  var MyLink = React.createClass({
	   *    propTypes: {
	   *      // An optional string or URI prop named "href".
	   *      href: function(props, propName, componentName) {
	   *        var propValue = props[propName];
	   *        if (propValue != null && typeof propValue !== 'string' &&
	   *            !(propValue instanceof URI)) {
	   *          return new Error(
	   *            'Expected a string or an URI for ' + propName + ' in ' +
	   *            componentName
	   *          );
	   *        }
	   *      }
	   *    },
	   *    render: function() {...}
	   *  });
	   *
	   * @internal
	   */

	  var ANONYMOUS = '<<anonymous>>';

	  // Important!
	  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
	  var ReactPropTypes = {
	    array: createPrimitiveTypeChecker('array'),
	    bigint: createPrimitiveTypeChecker('bigint'),
	    bool: createPrimitiveTypeChecker('boolean'),
	    func: createPrimitiveTypeChecker('function'),
	    number: createPrimitiveTypeChecker('number'),
	    object: createPrimitiveTypeChecker('object'),
	    string: createPrimitiveTypeChecker('string'),
	    symbol: createPrimitiveTypeChecker('symbol'),

	    any: createAnyTypeChecker(),
	    arrayOf: createArrayOfTypeChecker,
	    element: createElementTypeChecker(),
	    elementType: createElementTypeTypeChecker(),
	    instanceOf: createInstanceTypeChecker,
	    node: createNodeChecker(),
	    objectOf: createObjectOfTypeChecker,
	    oneOf: createEnumTypeChecker,
	    oneOfType: createUnionTypeChecker,
	    shape: createShapeTypeChecker,
	    exact: createStrictShapeTypeChecker,
	  };

	  /**
	   * inlined Object.is polyfill to avoid requiring consumers ship their own
	   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	   */
	  /*eslint-disable no-self-compare*/
	  function is(x, y) {
	    // SameValue algorithm
	    if (x === y) {
	      // Steps 1-5, 7-10
	      // Steps 6.b-6.e: +0 != -0
	      return x !== 0 || 1 / x === 1 / y;
	    } else {
	      // Step 6.a: NaN == NaN
	      return x !== x && y !== y;
	    }
	  }
	  /*eslint-enable no-self-compare*/

	  /**
	   * We use an Error-like object for backward compatibility as people may call
	   * PropTypes directly and inspect their output. However, we don't use real
	   * Errors anymore. We don't inspect their stack anyway, and creating them
	   * is prohibitively expensive if they are created too often, such as what
	   * happens in oneOfType() for any type before the one that matched.
	   */
	  function PropTypeError(message, data) {
	    this.message = message;
	    this.data = data && typeof data === 'object' ? data: {};
	    this.stack = '';
	  }
	  // Make `instanceof Error` still work for returned errors.
	  PropTypeError.prototype = Error.prototype;

	  function createChainableTypeChecker(validate) {
	    if (process.env.NODE_ENV !== 'production') {
	      var manualPropTypeCallCache = {};
	      var manualPropTypeWarningCount = 0;
	    }
	    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	      componentName = componentName || ANONYMOUS;
	      propFullName = propFullName || propName;

	      if (secret !== ReactPropTypesSecret) {
	        if (throwOnDirectAccess) {
	          // New behavior only for users of `prop-types` package
	          var err = new Error(
	            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	            'Use `PropTypes.checkPropTypes()` to call them. ' +
	            'Read more at http://fb.me/use-check-prop-types'
	          );
	          err.name = 'Invariant Violation';
	          throw err;
	        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
	          // Old behavior for people using React.PropTypes
	          var cacheKey = componentName + ':' + propName;
	          if (
	            !manualPropTypeCallCache[cacheKey] &&
	            // Avoid spamming the console because they are often not actionable except for lib authors
	            manualPropTypeWarningCount < 3
	          ) {
	            printWarning(
	              'You are manually calling a React.PropTypes validation ' +
	              'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +
	              'and will throw in the standalone `prop-types` package. ' +
	              'You may be seeing this warning due to a third-party PropTypes ' +
	              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
	            );
	            manualPropTypeCallCache[cacheKey] = true;
	            manualPropTypeWarningCount++;
	          }
	        }
	      }
	      if (props[propName] == null) {
	        if (isRequired) {
	          if (props[propName] === null) {
	            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
	          }
	          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
	        }
	        return null;
	      } else {
	        return validate(props, propName, componentName, location, propFullName);
	      }
	    }

	    var chainedCheckType = checkType.bind(null, false);
	    chainedCheckType.isRequired = checkType.bind(null, true);

	    return chainedCheckType;
	  }

	  function createPrimitiveTypeChecker(expectedType) {
	    function validate(props, propName, componentName, location, propFullName, secret) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== expectedType) {
	        // `propValue` being instance of, say, date/regexp, pass the 'object'
	        // check, but we can offer a more precise error message here rather than
	        // 'of type `object`'.
	        var preciseType = getPreciseType(propValue);

	        return new PropTypeError(
	          'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),
	          {expectedType: expectedType}
	        );
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createAnyTypeChecker() {
	    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
	  }

	  function createArrayOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	      }
	      var propValue = props[propName];
	      if (!Array.isArray(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	      }
	      for (var i = 0; i < propValue.length; i++) {
	        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createElementTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!isValidElement(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createElementTypeTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!ReactIs.isValidElementType(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createInstanceTypeChecker(expectedClass) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!(props[propName] instanceof expectedClass)) {
	        var expectedClassName = expectedClass.name || ANONYMOUS;
	        var actualClassName = getClassName(props[propName]);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createEnumTypeChecker(expectedValues) {
	    if (!Array.isArray(expectedValues)) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (arguments.length > 1) {
	          printWarning(
	            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
	            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
	          );
	        } else {
	          printWarning('Invalid argument supplied to oneOf, expected an array.');
	        }
	      }
	      return emptyFunctionThatReturnsNull;
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      for (var i = 0; i < expectedValues.length; i++) {
	        if (is(propValue, expectedValues[i])) {
	          return null;
	        }
	      }

	      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
	        var type = getPreciseType(value);
	        if (type === 'symbol') {
	          return String(value);
	        }
	        return value;
	      });
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createObjectOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	      }
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	      }
	      for (var key in propValue) {
	        if (has(propValue, key)) {
	          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	          if (error instanceof Error) {
	            return error;
	          }
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createUnionTypeChecker(arrayOfTypeCheckers) {
	    if (!Array.isArray(arrayOfTypeCheckers)) {
	      process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	      return emptyFunctionThatReturnsNull;
	    }

	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (typeof checker !== 'function') {
	        printWarning(
	          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
	          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
	        );
	        return emptyFunctionThatReturnsNull;
	      }
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      var expectedTypes = [];
	      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	        var checker = arrayOfTypeCheckers[i];
	        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
	        if (checkerResult == null) {
	          return null;
	        }
	        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {
	          expectedTypes.push(checkerResult.data.expectedType);
	        }
	      }
	      var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createNodeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!isNode(props[propName])) {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function invalidValidatorError(componentName, location, propFullName, key, type) {
	    return new PropTypeError(
	      (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +
	      'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'
	    );
	  }

	  function createShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      for (var key in shapeTypes) {
	        var checker = shapeTypes[key];
	        if (typeof checker !== 'function') {
	          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createStrictShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      // We need to check all keys in case some are required but missing from props.
	      var allKeys = assign({}, props[propName], shapeTypes);
	      for (var key in allKeys) {
	        var checker = shapeTypes[key];
	        if (has(shapeTypes, key) && typeof checker !== 'function') {
	          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
	        }
	        if (!checker) {
	          return new PropTypeError(
	            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
	            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
	            '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')
	          );
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }

	    return createChainableTypeChecker(validate);
	  }

	  function isNode(propValue) {
	    switch (typeof propValue) {
	      case 'number':
	      case 'string':
	      case 'undefined':
	        return true;
	      case 'boolean':
	        return !propValue;
	      case 'object':
	        if (Array.isArray(propValue)) {
	          return propValue.every(isNode);
	        }
	        if (propValue === null || isValidElement(propValue)) {
	          return true;
	        }

	        var iteratorFn = getIteratorFn(propValue);
	        if (iteratorFn) {
	          var iterator = iteratorFn.call(propValue);
	          var step;
	          if (iteratorFn !== propValue.entries) {
	            while (!(step = iterator.next()).done) {
	              if (!isNode(step.value)) {
	                return false;
	              }
	            }
	          } else {
	            // Iterator will provide entry [k,v] tuples rather than values.
	            while (!(step = iterator.next()).done) {
	              var entry = step.value;
	              if (entry) {
	                if (!isNode(entry[1])) {
	                  return false;
	                }
	              }
	            }
	          }
	        } else {
	          return false;
	        }

	        return true;
	      default:
	        return false;
	    }
	  }

	  function isSymbol(propType, propValue) {
	    // Native Symbol.
	    if (propType === 'symbol') {
	      return true;
	    }

	    // falsy value can't be a Symbol
	    if (!propValue) {
	      return false;
	    }

	    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	    if (propValue['@@toStringTag'] === 'Symbol') {
	      return true;
	    }

	    // Fallback for non-spec compliant Symbols which are polyfilled.
	    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	      return true;
	    }

	    return false;
	  }

	  // Equivalent of `typeof` but with special handling for array and regexp.
	  function getPropType(propValue) {
	    var propType = typeof propValue;
	    if (Array.isArray(propValue)) {
	      return 'array';
	    }
	    if (propValue instanceof RegExp) {
	      // Old webkits (at least until Android 4.0) return 'function' rather than
	      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	      // passes PropTypes.object.
	      return 'object';
	    }
	    if (isSymbol(propType, propValue)) {
	      return 'symbol';
	    }
	    return propType;
	  }

	  // This handles more types than `getPropType`. Only used for error messages.
	  // See `createPrimitiveTypeChecker`.
	  function getPreciseType(propValue) {
	    if (typeof propValue === 'undefined' || propValue === null) {
	      return '' + propValue;
	    }
	    var propType = getPropType(propValue);
	    if (propType === 'object') {
	      if (propValue instanceof Date) {
	        return 'date';
	      } else if (propValue instanceof RegExp) {
	        return 'regexp';
	      }
	    }
	    return propType;
	  }

	  // Returns a string that is postfixed to a warning about an invalid type.
	  // For example, "undefined" or "of type array"
	  function getPostfixForTypeWarning(value) {
	    var type = getPreciseType(value);
	    switch (type) {
	      case 'array':
	      case 'object':
	        return 'an ' + type;
	      case 'boolean':
	      case 'date':
	      case 'regexp':
	        return 'a ' + type;
	      default:
	        return type;
	    }
	  }

	  // Returns class name of the object, if any.
	  function getClassName(propValue) {
	    if (!propValue.constructor || !propValue.constructor.name) {
	      return ANONYMOUS;
	    }
	    return propValue.constructor.name;
	  }

	  ReactPropTypes.checkPropTypes = checkPropTypes;
	  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};
	return factoryWithTypeCheckers;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var factoryWithThrowingShims;
var hasRequiredFactoryWithThrowingShims;

function requireFactoryWithThrowingShims () {
	if (hasRequiredFactoryWithThrowingShims) return factoryWithThrowingShims;
	hasRequiredFactoryWithThrowingShims = 1;

	var ReactPropTypesSecret = /*@__PURE__*/ requireReactPropTypesSecret();

	function emptyFunction() {}
	function emptyFunctionWithReset() {}
	emptyFunctionWithReset.resetWarningCache = emptyFunction;

	factoryWithThrowingShims = function() {
	  function shim(props, propName, componentName, location, propFullName, secret) {
	    if (secret === ReactPropTypesSecret) {
	      // It is still safe when called from React.
	      return;
	    }
	    var err = new Error(
	      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	      'Use PropTypes.checkPropTypes() to call them. ' +
	      'Read more at http://fb.me/use-check-prop-types'
	    );
	    err.name = 'Invariant Violation';
	    throw err;
	  }	  shim.isRequired = shim;
	  function getShim() {
	    return shim;
	  }	  // Important!
	  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
	  var ReactPropTypes = {
	    array: shim,
	    bigint: shim,
	    bool: shim,
	    func: shim,
	    number: shim,
	    object: shim,
	    string: shim,
	    symbol: shim,

	    any: shim,
	    arrayOf: getShim,
	    element: shim,
	    elementType: shim,
	    instanceOf: getShim,
	    node: shim,
	    objectOf: getShim,
	    oneOf: getShim,
	    oneOfType: getShim,
	    shape: getShim,
	    exact: getShim,

	    checkPropTypes: emptyFunctionWithReset,
	    resetWarningCache: emptyFunction
	  };

	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};
	return factoryWithThrowingShims;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredPropTypes;

function requirePropTypes () {
	if (hasRequiredPropTypes) return propTypes.exports;
	hasRequiredPropTypes = 1;
	if (process.env.NODE_ENV !== 'production') {
	  var ReactIs = requireReactIs();

	  // By explicitly using `prop-types` you are opting into new development behavior.
	  // http://fb.me/prop-types-in-prod
	  var throwOnDirectAccess = true;
	  propTypes.exports = /*@__PURE__*/ requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
	} else {
	  // By explicitly using `prop-types` you are opting into new production behavior.
	  // http://fb.me/prop-types-in-prod
	  propTypes.exports = /*@__PURE__*/ requireFactoryWithThrowingShims()();
	}
	return propTypes.exports;
}

var propTypesExports = /*@__PURE__*/ requirePropTypes();
var PropTypes = /*@__PURE__*/getDefaultExportFromCjs(propTypesExports);

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// Get CSS class list from a props object
function classList(props) {
  var _classes;

  var beat = props.beat,
      fade = props.fade,
      beatFade = props.beatFade,
      bounce = props.bounce,
      shake = props.shake,
      flash = props.flash,
      spin = props.spin,
      spinPulse = props.spinPulse,
      spinReverse = props.spinReverse,
      pulse = props.pulse,
      fixedWidth = props.fixedWidth,
      inverse = props.inverse,
      border = props.border,
      listItem = props.listItem,
      flip = props.flip,
      size = props.size,
      rotation = props.rotation,
      pull = props.pull; // map of CSS class names to properties

  var classes = (_classes = {
    'fa-beat': beat,
    'fa-fade': fade,
    'fa-beat-fade': beatFade,
    'fa-bounce': bounce,
    'fa-shake': shake,
    'fa-flash': flash,
    'fa-spin': spin,
    'fa-spin-reverse': spinReverse,
    'fa-spin-pulse': spinPulse,
    'fa-pulse': pulse,
    'fa-fw': fixedWidth,
    'fa-inverse': inverse,
    'fa-border': border,
    'fa-li': listItem,
    'fa-flip': flip === true,
    'fa-flip-horizontal': flip === 'horizontal' || flip === 'both',
    'fa-flip-vertical': flip === 'vertical' || flip === 'both'
  }, _defineProperty(_classes, "fa-".concat(size), typeof size !== 'undefined' && size !== null), _defineProperty(_classes, "fa-rotate-".concat(rotation), typeof rotation !== 'undefined' && rotation !== null && rotation !== 0), _defineProperty(_classes, "fa-pull-".concat(pull), typeof pull !== 'undefined' && pull !== null), _defineProperty(_classes, 'fa-swap-opacity', props.swapOpacity), _classes); // map over all the keys in the classes object
  // return an array of the keys where the value for the key is not null

  return Object.keys(classes).map(function (key) {
    return classes[key] ? key : null;
  }).filter(function (key) {
    return key;
  });
}

// Camelize taken from humps
// humps is copyright © 2012+ Dom Christie
// Released under the MIT license.
// Performant way to determine if object coerces to a number
function _isNumerical(obj) {
  obj = obj - 0; // eslint-disable-next-line no-self-compare

  return obj === obj;
}

function camelize(string) {
  if (_isNumerical(string)) {
    return string;
  } // eslint-disable-next-line no-useless-escape


  string = string.replace(/[\-_\s]+(.)?/g, function (match, chr) {
    return chr ? chr.toUpperCase() : '';
  }); // Ensure 1st char is always lowercase

  return string.substr(0, 1).toLowerCase() + string.substr(1);
}

var _excluded = ["style"];

function capitalize(val) {
  return val.charAt(0).toUpperCase() + val.slice(1);
}

function styleToObject(style) {
  return style.split(';').map(function (s) {
    return s.trim();
  }).filter(function (s) {
    return s;
  }).reduce(function (acc, pair) {
    var i = pair.indexOf(':');
    var prop = camelize(pair.slice(0, i));
    var value = pair.slice(i + 1).trim();
    prop.startsWith('webkit') ? acc[capitalize(prop)] = value : acc[prop] = value;
    return acc;
  }, {});
}

function convert(createElement, element) {
  var extraProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (typeof element === 'string') {
    return element;
  }

  var children = (element.children || []).map(function (child) {
    return convert(createElement, child);
  });
  /* eslint-disable dot-notation */

  var mixins = Object.keys(element.attributes || {}).reduce(function (acc, key) {
    var val = element.attributes[key];

    switch (key) {
      case 'class':
        acc.attrs['className'] = val;
        delete element.attributes['class'];
        break;

      case 'style':
        acc.attrs['style'] = styleToObject(val);
        break;

      default:
        if (key.indexOf('aria-') === 0 || key.indexOf('data-') === 0) {
          acc.attrs[key.toLowerCase()] = val;
        } else {
          acc.attrs[camelize(key)] = val;
        }

    }

    return acc;
  }, {
    attrs: {}
  });

  var _extraProps$style = extraProps.style,
      existingStyle = _extraProps$style === void 0 ? {} : _extraProps$style,
      remaining = _objectWithoutProperties(extraProps, _excluded);

  mixins.attrs['style'] = _objectSpread2(_objectSpread2({}, mixins.attrs['style']), existingStyle);
  /* eslint-enable */

  return createElement.apply(void 0, [element.tag, _objectSpread2(_objectSpread2({}, mixins.attrs), remaining)].concat(_toConsumableArray(children)));
}

var PRODUCTION = false;

try {
  PRODUCTION = process.env.NODE_ENV === 'production';
} catch (e) {}

function log () {
  if (!PRODUCTION && console && typeof console.error === 'function') {
    var _console;

    (_console = console).error.apply(_console, arguments);
  }
}

function normalizeIconArgs(icon) {
  // this has everything that it needs to be rendered which means it was probably imported
  // directly from an icon svg package
  if (icon && _typeof(icon) === 'object' && icon.prefix && icon.iconName && icon.icon) {
    return icon;
  }

  if (parse$1.icon) {
    return parse$1.icon(icon);
  } // if the icon is null, there's nothing to do


  if (icon === null) {
    return null;
  } // if the icon is an object and has a prefix and an icon name, return it


  if (icon && _typeof(icon) === 'object' && icon.prefix && icon.iconName) {
    return icon;
  } // if it's an array with length of two


  if (Array.isArray(icon) && icon.length === 2) {
    // use the first item as prefix, second as icon name
    return {
      prefix: icon[0],
      iconName: icon[1]
    };
  } // if it's a string, use it as the icon name


  if (typeof icon === 'string') {
    return {
      prefix: 'fas',
      iconName: icon
    };
  }
}

// creates an object with a key of key
// and a value of value
// if certain conditions are met
function objectWithKey(key, value) {
  // if the value is a non-empty array
  // or it's not an array but it is truthy
  // then create the object with the key and the value
  // if not, return an empty array
  return Array.isArray(value) && value.length > 0 || !Array.isArray(value) && value ? _defineProperty({}, key, value) : {};
}

var defaultProps = {
  border: false,
  className: '',
  mask: null,
  maskId: null,
  fixedWidth: false,
  inverse: false,
  flip: false,
  icon: null,
  listItem: false,
  pull: null,
  pulse: false,
  rotation: null,
  size: null,
  spin: false,
  spinPulse: false,
  spinReverse: false,
  beat: false,
  fade: false,
  beatFade: false,
  bounce: false,
  shake: false,
  symbol: false,
  title: '',
  titleId: null,
  transform: null,
  swapOpacity: false
};
var FontAwesomeIcon = /*#__PURE__*/React__default.forwardRef(function (props, ref) {
  var allProps = _objectSpread2(_objectSpread2({}, defaultProps), props);

  var iconArgs = allProps.icon,
      maskArgs = allProps.mask,
      symbol = allProps.symbol,
      className = allProps.className,
      title = allProps.title,
      titleId = allProps.titleId,
      maskId = allProps.maskId;
  var iconLookup = normalizeIconArgs(iconArgs);
  var classes = objectWithKey('classes', [].concat(_toConsumableArray(classList(allProps)), _toConsumableArray((className || '').split(' '))));
  var transform = objectWithKey('transform', typeof allProps.transform === 'string' ? parse$1.transform(allProps.transform) : allProps.transform);
  var mask = objectWithKey('mask', normalizeIconArgs(maskArgs));
  var renderedIcon = icon(iconLookup, _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, classes), transform), mask), {}, {
    symbol: symbol,
    title: title,
    titleId: titleId,
    maskId: maskId
  }));

  if (!renderedIcon) {
    log('Could not find icon', iconLookup);
    return null;
  }

  var abstract = renderedIcon.abstract;
  var extraProps = {
    ref: ref
  };
  Object.keys(allProps).forEach(function (key) {
    // eslint-disable-next-line no-prototype-builtins
    if (!defaultProps.hasOwnProperty(key)) {
      extraProps[key] = allProps[key];
    }
  });
  return convertCurry(abstract[0], extraProps);
});
FontAwesomeIcon.displayName = 'FontAwesomeIcon';
FontAwesomeIcon.propTypes = {
  beat: PropTypes.bool,
  border: PropTypes.bool,
  beatFade: PropTypes.bool,
  bounce: PropTypes.bool,
  className: PropTypes.string,
  fade: PropTypes.bool,
  flash: PropTypes.bool,
  mask: PropTypes.oneOfType([PropTypes.object, PropTypes.array, PropTypes.string]),
  maskId: PropTypes.string,
  fixedWidth: PropTypes.bool,
  inverse: PropTypes.bool,
  flip: PropTypes.oneOf([true, false, 'horizontal', 'vertical', 'both']),
  icon: PropTypes.oneOfType([PropTypes.object, PropTypes.array, PropTypes.string]),
  listItem: PropTypes.bool,
  pull: PropTypes.oneOf(['right', 'left']),
  pulse: PropTypes.bool,
  rotation: PropTypes.oneOf([0, 90, 180, 270]),
  shake: PropTypes.bool,
  size: PropTypes.oneOf(['2xs', 'xs', 'sm', 'lg', 'xl', '2xl', '1x', '2x', '3x', '4x', '5x', '6x', '7x', '8x', '9x', '10x']),
  spin: PropTypes.bool,
  spinPulse: PropTypes.bool,
  spinReverse: PropTypes.bool,
  symbol: PropTypes.oneOfType([PropTypes.bool, PropTypes.string]),
  title: PropTypes.string,
  titleId: PropTypes.string,
  transform: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
  swapOpacity: PropTypes.bool
};
var convertCurry = convert.bind(null, React__default.createElement);

/*!
 * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2024 Fonticons, Inc.
 */
const faRotateLeft = {
  prefix: 'fas',
  iconName: 'rotate-left',
  icon: [512, 512, ["rotate-back", "rotate-backward", "undo-alt"], "f2ea", "M48.5 224L40 224c-13.3 0-24-10.7-24-24L16 72c0-9.7 5.8-18.5 14.8-22.2s19.3-1.7 26.2 5.2L98.6 96.6c87.6-86.5 228.7-86.2 315.8 1c87.5 87.5 87.5 229.3 0 316.8s-229.3 87.5-316.8 0c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0c62.5 62.5 163.8 62.5 226.3 0s62.5-163.8 0-226.3c-62.2-62.2-162.7-62.5-225.3-1L185 183c6.9 6.9 8.9 17.2 5.2 26.2s-12.5 14.8-22.2 14.8L48.5 224z"]
};
const faMarker = {
  prefix: 'fas',
  iconName: 'marker',
  icon: [512, 512, [], "f5a1", "M481 31C445.1-4.8 386.9-4.8 351 31l-15 15L322.9 33C294.8 4.9 249.2 4.9 221.1 33L135 119c-9.4 9.4-9.4 24.6 0 33.9s24.6 9.4 33.9 0L255 66.9c9.4-9.4 24.6-9.4 33.9 0L302.1 80 186.3 195.7 316.3 325.7 481 161c35.9-35.9 35.9-94.1 0-129.9zM293.7 348.3L163.7 218.3 99.5 282.5c-48 48-80.8 109.2-94.1 175.8l-5 25c-1.6 7.9 .9 16 6.6 21.7s13.8 8.1 21.7 6.6l25-5c66.6-13.3 127.8-46.1 175.8-94.1l64.2-64.2z"]
};
const faSquare = {
  prefix: 'fas',
  iconName: 'square',
  icon: [448, 512, [9632, 9723, 9724, 61590], "f0c8", "M0 96C0 60.7 28.7 32 64 32H384c35.3 0 64 28.7 64 64V416c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V96z"]
};
const faTrash = {
  prefix: 'fas',
  iconName: 'trash',
  icon: [448, 512, [], "f1f8", "M135.2 17.7L128 32 32 32C14.3 32 0 46.3 0 64S14.3 96 32 96l384 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-96 0-7.2-14.3C307.4 6.8 296.3 0 284.2 0L163.8 0c-12.1 0-23.2 6.8-28.6 17.7zM416 128L32 128 53.2 467c1.6 25.3 22.6 45 47.9 45l245.8 0c25.3 0 46.3-19.7 47.9-45L416 128z"]
};
const faRotateRight = {
  prefix: 'fas',
  iconName: 'rotate-right',
  icon: [512, 512, ["redo-alt", "rotate-forward"], "f2f9", "M463.5 224l8.5 0c13.3 0 24-10.7 24-24l0-128c0-9.7-5.8-18.5-14.8-22.2s-19.3-1.7-26.2 5.2L413.4 96.6c-87.6-86.5-228.7-86.2-315.8 1c-87.5 87.5-87.5 229.3 0 316.8s229.3 87.5 316.8 0c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0c-62.5 62.5-163.8 62.5-226.3 0s-62.5-163.8 0-226.3c62.2-62.2 162.7-62.5 225.3-1L327 183c-6.9 6.9-8.9 17.2-5.2 26.2s12.5 14.8 22.2 14.8l119.5 0z"]
};
const faCircleDown = {
  prefix: 'fas',
  iconName: 'circle-down',
  icon: [512, 512, [61466, "arrow-alt-circle-down"], "f358", "M256 0a256 256 0 1 0 0 512A256 256 0 1 0 256 0zM244.7 395.3l-112-112c-4.6-4.6-5.9-11.5-3.5-17.4s8.3-9.9 14.8-9.9l64 0 0-96c0-17.7 14.3-32 32-32l32 0c17.7 0 32 14.3 32 32l0 96 64 0c6.5 0 12.3 3.9 14.8 9.9s1.1 12.9-3.5 17.4l-112 112c-6.2 6.2-16.4 6.2-22.6 0z"]
};
const faEraser = {
  prefix: 'fas',
  iconName: 'eraser',
  icon: [576, 512, [], "f12d", "M290.7 57.4L57.4 290.7c-25 25-25 65.5 0 90.5l80 80c12 12 28.3 18.7 45.3 18.7L288 480l9.4 0L512 480c17.7 0 32-14.3 32-32s-14.3-32-32-32l-124.1 0L518.6 285.3c25-25 25-65.5 0-90.5L381.3 57.4c-25-25-65.5-25-90.5 0zM297.4 416l-9.4 0-105.4 0-80-80L227.3 211.3 364.7 348.7 297.4 416z"]
};
const faMagnifyingGlass = {
  prefix: 'fas',
  iconName: 'magnifying-glass',
  icon: [512, 512, [128269, "search"], "f002", "M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"]
};
const faArrowsUpDownLeftRight = {
  prefix: 'fas',
  iconName: 'arrows-up-down-left-right',
  icon: [512, 512, ["arrows"], "f047", "M278.6 9.4c-12.5-12.5-32.8-12.5-45.3 0l-64 64c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l9.4-9.4L224 224l-114.7 0 9.4-9.4c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-64 64c-12.5 12.5-12.5 32.8 0 45.3l64 64c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3l-9.4-9.4L224 288l0 114.7-9.4-9.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l64 64c12.5 12.5 32.8 12.5 45.3 0l64-64c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-9.4 9.4L288 288l114.7 0-9.4 9.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l64-64c12.5-12.5 12.5-32.8 0-45.3l-64-64c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l9.4 9.4L288 224l0-114.7 9.4 9.4c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3l-64-64z"]
};
const faDrawPolygon = {
  prefix: 'fas',
  iconName: 'draw-polygon',
  icon: [448, 512, [], "f5ee", "M96 151.4l0 209.1c9.7 5.6 17.8 13.7 23.4 23.4l209.1 0c0-.1 .1-.2 .1-.3l-4.5-7.9-32-56s0 0 0 0c-1.4 .1-2.8 .1-4.2 .1c-35.3 0-64-28.7-64-64s28.7-64 64-64c1.4 0 2.8 0 4.2 .1c0 0 0 0 0 0l32-56 4.5-7.9-.1-.3-209.1 0c-5.6 9.7-13.7 17.8-23.4 23.4zM384.3 352c35.2 .2 63.7 28.7 63.7 64c0 35.3-28.7 64-64 64c-23.7 0-44.4-12.9-55.4-32l-209.1 0c-11.1 19.1-31.7 32-55.4 32c-35.3 0-64-28.7-64-64c0-23.7 12.9-44.4 32-55.4l0-209.1C12.9 140.4 0 119.7 0 96C0 60.7 28.7 32 64 32c23.7 0 44.4 12.9 55.4 32l209.1 0c11.1-19.1 31.7-32 55.4-32c35.3 0 64 28.7 64 64c0 35.3-28.5 63.8-63.7 64l-4.5 7.9-32 56-2.3 4c4.2 8.5 6.5 18 6.5 28.1s-2.3 19.6-6.5 28.1l2.3 4 32 56 4.5 7.9z"]
};

var colorOptions = [
    { name: 'Black', value: 'rgba(0, 0, 0, 1)' },
    { name: 'White', value: 'rgba(255, 255, 255, 1)' },
    { name: 'Red', value: 'rgba(255, 0, 0, 1)' },
    { name: 'Green', value: 'rgba(0, 255, 0, 1)' },
    { name: 'Blue', value: 'rgba(0, 0, 255, 1)' },
    { name: 'Orange', value: 'rgba(255, 165, 0, 1)' },
    { name: 'Pink', value: 'rgba(255, 192, 203, 1)' }
];
var brushSizes = [5, 10, 20, 30, 40, 50, 60];
var zoomLevels = [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000];
var ImageMaskControls = function (_a) {
    var setToolMode = _a.setToolMode, toolMode = _a.toolMode, clearCanvas = _a.clearCanvas, currentZoom = _a.currentZoom, undo = _a.undo, redo = _a.redo, canUndo = _a.canUndo, canRedo = _a.canRedo, onDownloadMask = _a.onDownloadMask, setMaskColor = _a.setMaskColor, currentMaskColor = _a.currentMaskColor, setOpacity = _a.setOpacity, currentOpacity = _a.currentOpacity, setBrushSize = _a.setBrushSize, currentBrushSize = _a.currentBrushSize, setZoom = _a.setZoom;
    var _b = useState(false), showColorDropdown = _b[0], setShowColorDropdown = _b[1];
    var _c = useState(false), showBrushDropdown = _c[0], setShowBrushDropdown = _c[1];
    var _d = useState(false), showZoomDropdown = _d[0], setShowZoomDropdown = _d[1];
    var _e = useState(false), showMaskDropdown = _e[0], setShowMaskDropdown = _e[1];
    var _f = useState(false), showEraserDropdown = _f[0], setShowEraserDropdown = _f[1];
    var controlsRef = useRef(null);
    var closeAllDropdowns = function () {
        setShowColorDropdown(false);
        setShowBrushDropdown(false);
        setShowZoomDropdown(false);
        setShowMaskDropdown(false);
        setShowEraserDropdown(false);
    };
    useEffect(function () {
        var handleClickOutside = function (event) {
            if (controlsRef.current && !controlsRef.current.contains(event.target)) {
                closeAllDropdowns();
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return function () {
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, []);
    var handleColorClick = function (e) {
        e.stopPropagation();
        setShowColorDropdown(!showColorDropdown);
        setShowBrushDropdown(false);
        setShowZoomDropdown(false);
        setShowMaskDropdown(false);
        setShowEraserDropdown(false);
    };
    var handleBrushClick = function (e) {
        e.stopPropagation();
        setShowBrushDropdown(!showBrushDropdown);
        setShowColorDropdown(false);
        setShowZoomDropdown(false);
        setShowMaskDropdown(false);
        setShowEraserDropdown(false);
    };
    var handleZoomClick = function (e) {
        e.stopPropagation();
        setShowZoomDropdown(!showZoomDropdown);
        setShowColorDropdown(false);
        setShowBrushDropdown(false);
        setShowMaskDropdown(false);
        setShowEraserDropdown(false);
    };
    var handleZoomChange = function (zoom) {
        if (setZoom) {
            setZoom(zoom);
        }
        setShowZoomDropdown(false);
    };
    var handleMaskToolSelect = function (tool) {
        setToolMode("mask-".concat(tool));
        setShowMaskDropdown(false);
    };
    var handleEraserToolSelect = function (tool) {
        setToolMode("eraser-".concat(tool));
        setShowEraserDropdown(false);
    };
    return (jsxs("div", __assign({ className: "controls-bar", ref: controlsRef, onClick: function (e) {
            // Only close dropdowns if clicking directly on the bar (not on buttons or controls)
            if (e.target === e.currentTarget) {
                closeAllDropdowns();
            }
        } }, { children: [jsxs("div", __assign({ className: "action-buttons" }, { children: [undo && (jsx("button", __assign({ onClick: function (e) {
                            e.stopPropagation();
                            undo();
                            closeAllDropdowns();
                        }, disabled: !canUndo, title: "Undo" }, { children: jsxs("div", __assign({ className: "button-content" }, { children: [jsx(FontAwesomeIcon, { icon: faRotateLeft, size: "lg" }), jsx("span", { children: "Undo" })] })) }))), redo && (jsx("button", __assign({ onClick: function (e) {
                            e.stopPropagation();
                            redo();
                            closeAllDropdowns();
                        }, disabled: !canRedo, title: "Redo" }, { children: jsxs("div", __assign({ className: "button-content" }, { children: [jsx(FontAwesomeIcon, { icon: faRotateRight, size: "lg" }), jsx("span", { children: "Redo" })] })) })))] })), jsxs("div", __assign({ className: "tool-buttons" }, { children: [jsx("button", __assign({ className: toolMode === 'move' ? 'active' : '', onClick: function (e) {
                            e.stopPropagation();
                            setToolMode('move');
                            closeAllDropdowns();
                        }, title: "Move" }, { children: jsxs("div", __assign({ className: "button-content" }, { children: [jsx(FontAwesomeIcon, { icon: faArrowsUpDownLeftRight, size: "lg" }), jsx("span", { children: "Move" })] })) })), jsxs("div", __assign({ className: "dropdown" }, { children: [jsx("button", __assign({ className: toolMode.startsWith('mask-') ? 'active' : '', onClick: function (e) {
                                    e.stopPropagation();
                                    setShowMaskDropdown(!showMaskDropdown);
                                    setShowEraserDropdown(false);
                                    setShowColorDropdown(false);
                                    setShowBrushDropdown(false);
                                    setShowZoomDropdown(false);
                                }, title: "Mask Tools" }, { children: jsxs("div", __assign({ className: "button-content" }, { children: [toolMode === 'mask-freehand' && jsx(FontAwesomeIcon, { icon: faMarker, size: "lg" }), toolMode === 'mask-box' && jsx(FontAwesomeIcon, { icon: faSquare, size: "lg" }), toolMode === 'mask-polygon' && jsx(FontAwesomeIcon, { icon: faDrawPolygon, size: "lg" }), !toolMode.startsWith('mask-') && jsx(FontAwesomeIcon, { icon: faMarker, size: "lg" }), jsx("span", { children: "Mask" })] })) })), showMaskDropdown && (jsxs("div", __assign({ className: "dropdown-content" }, { children: [jsx("button", __assign({ onClick: function () { return handleMaskToolSelect('freehand'); } }, { children: jsxs("div", __assign({ className: "button-content" }, { children: [jsx(FontAwesomeIcon, { icon: faMarker, size: "lg" }), jsx("span", { children: "Freehand" })] })) })), jsx("button", __assign({ onClick: function () { return handleMaskToolSelect('box'); } }, { children: jsxs("div", __assign({ className: "button-content" }, { children: [jsx(FontAwesomeIcon, { icon: faSquare, size: "lg" }), jsx("span", { children: "Box" })] })) })), jsx("button", __assign({ onClick: function () { return handleMaskToolSelect('polygon'); } }, { children: jsxs("div", __assign({ className: "button-content" }, { children: [jsx(FontAwesomeIcon, { icon: faDrawPolygon, size: "lg" }), jsx("span", { children: "Polygon" })] })) }))] })))] })), jsxs("div", __assign({ className: "dropdown" }, { children: [jsx("button", __assign({ className: toolMode.startsWith('eraser-') ? 'active' : '', onClick: function (e) {
                                    e.stopPropagation();
                                    setShowEraserDropdown(!showEraserDropdown);
                                    setShowMaskDropdown(false);
                                    setShowColorDropdown(false);
                                    setShowBrushDropdown(false);
                                    setShowZoomDropdown(false);
                                }, title: "Eraser Tools" }, { children: jsxs("div", __assign({ className: "button-content" }, { children: [toolMode === 'eraser-freehand' && jsx(FontAwesomeIcon, { icon: faEraser, size: "lg" }), toolMode === 'eraser-box' && jsx(FontAwesomeIcon, { icon: faSquare, size: "lg" }), !toolMode.startsWith('eraser-') && jsx(FontAwesomeIcon, { icon: faEraser, size: "lg" }), jsx("span", { children: "Eraser" })] })) })), showEraserDropdown && (jsxs("div", __assign({ className: "dropdown-content" }, { children: [jsx("button", __assign({ onClick: function () { return handleEraserToolSelect('freehand'); } }, { children: jsxs("div", __assign({ className: "button-content" }, { children: [jsx(FontAwesomeIcon, { icon: faEraser, size: "lg" }), jsx("span", { children: "Freehand" })] })) })), jsx("button", __assign({ onClick: function () { return handleEraserToolSelect('box'); } }, { children: jsxs("div", __assign({ className: "button-content" }, { children: [jsx(FontAwesomeIcon, { icon: faSquare, size: "lg" }), jsx("span", { children: "Box" })] })) }))] })))] }))] })), jsxs("div", __assign({ className: "dropdown-container" }, { children: [jsx("button", __assign({ className: "dropdown-button", onClick: handleBrushClick, title: "Brush Size" }, { children: jsxs("div", __assign({ className: "button-content" }, { children: [jsx("div", { className: "current-brush", style: {
                                        width: 20,
                                        height: 20,
                                        backgroundColor: (toolMode === null || toolMode === void 0 ? void 0 : toolMode.startsWith('eraser')) ? 'rgba(255, 0, 0, 0.3)' : currentMaskColor === null || currentMaskColor === void 0 ? void 0 : currentMaskColor.replace('1)', '0.3)'),
                                        border: "1px solid ".concat((toolMode === null || toolMode === void 0 ? void 0 : toolMode.startsWith('eraser')) ? 'rgba(255, 0, 0, 0.5)' : currentMaskColor)
                                    } }), jsxs("span", { children: [currentBrushSize, "px"] })] })) })), showBrushDropdown && (jsx("div", __assign({ className: "dropdown-menu brush-dropdown" }, { children: brushSizes.map(function (size) { return (jsxs("button", __assign({ className: "brush-option ".concat(currentBrushSize === size ? 'active' : ''), onClick: function (e) {
                                e.stopPropagation();
                                setBrushSize === null || setBrushSize === void 0 ? void 0 : setBrushSize(size);
                                setShowBrushDropdown(false);
                            }, title: "".concat(size, "px") }, { children: [jsxs("span", { children: [size, "px"] }), jsx("div", { className: "brush-size-circle", style: {
                                        width: size,
                                        height: size,
                                        backgroundColor: (toolMode === null || toolMode === void 0 ? void 0 : toolMode.startsWith('eraser')) ? 'rgba(255, 0, 0, 0.3)' : currentMaskColor === null || currentMaskColor === void 0 ? void 0 : currentMaskColor.replace('1)', '0.3)'),
                                        border: "1px solid ".concat((toolMode === null || toolMode === void 0 ? void 0 : toolMode.startsWith('eraser')) ? 'rgba(255, 0, 0, 0.5)' : currentMaskColor)
                                    } })] }), size)); }) })))] })), jsxs("div", __assign({ className: "dropdown-container" }, { children: [jsx("button", __assign({ className: "dropdown-button", onClick: handleColorClick, title: "Color Options" }, { children: jsxs("div", __assign({ className: "button-content" }, { children: [jsx("div", { className: "current-color", style: { backgroundColor: currentMaskColor } }), jsx("span", { children: "Color" })] })) })), showColorDropdown && (jsx("div", __assign({ className: "dropdown-menu color-dropdown" }, { children: colorOptions.map(function (color) { return (jsx("button", { className: "color-option ".concat(currentMaskColor === color.value ? 'active' : ''), style: { backgroundColor: color.value }, onClick: function (e) {
                                e.stopPropagation();
                                setMaskColor === null || setMaskColor === void 0 ? void 0 : setMaskColor(color.value);
                                setShowColorDropdown(false);
                            }, title: color.name }, color.name)); }) })))] })), jsx("div", __assign({ className: "opacity-control" }, { children: jsxs("div", __assign({ className: "button-content" }, { children: [jsx("input", { type: "range", min: "0", max: "100", value: currentOpacity ? currentOpacity * 100 : 50, onChange: function (e) {
                                setOpacity === null || setOpacity === void 0 ? void 0 : setOpacity(Number(e.target.value) / 100);
                                closeAllDropdowns();
                            }, onMouseDown: function (e) {
                                e.stopPropagation();
                                closeAllDropdowns();
                            }, title: "Opacity: ".concat(currentOpacity ? Math.round(currentOpacity * 100) : 50, "%") }), jsx("span", { children: "Opacity" })] })) })), jsxs("div", __assign({ className: "action-buttons" }, { children: [clearCanvas && (jsx("button", __assign({ onClick: function (e) {
                            e.stopPropagation();
                            clearCanvas();
                            closeAllDropdowns();
                        }, title: "Clear Mask" }, { children: jsxs("div", __assign({ className: "button-content" }, { children: [jsx(FontAwesomeIcon, { icon: faTrash, size: "lg" }), jsx("span", { children: "Clear" })] })) }))), onDownloadMask && (jsx("button", __assign({ onClick: function (e) {
                            e.stopPropagation();
                            onDownloadMask();
                            closeAllDropdowns();
                        }, title: "Download Mask" }, { children: jsxs("div", __assign({ className: "button-content" }, { children: [jsx(FontAwesomeIcon, { icon: faCircleDown, size: "lg" }), jsx("span", { children: "Download" })] })) })))] })), jsxs("div", __assign({ className: "dropdown-container" }, { children: [jsx("button", __assign({ className: "dropdown-button", onClick: handleZoomClick, title: "Zoom Level" }, { children: jsx("div", __assign({ className: "button-content" }, { children: jsxs("div", __assign({ className: "zoom-icon-text" }, { children: [jsx(FontAwesomeIcon, { icon: faMagnifyingGlass, size: "lg" }), jsxs("span", { children: [currentZoom, "%"] })] })) })) })), showZoomDropdown && (jsx("div", __assign({ className: "dropdown-menu zoom-dropdown" }, { children: zoomLevels.map(function (zoom) { return (jsxs("button", __assign({ className: "zoom-option ".concat(currentZoom === zoom ? 'active' : ''), onClick: function (e) {
                                e.stopPropagation();
                                handleZoomChange(zoom);
                            }, title: "".concat(zoom, "%") }, { children: [zoom, "%"] }), zoom)); }) })))] }))] })));
};

var lib$1 = {exports: {}};

var _FullInternals = {};

var _CoreInternals = {};

var Global = {};

var hasRequiredGlobal;

function requireGlobal () {
	if (hasRequiredGlobal) return Global;
	hasRequiredGlobal = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports._registerNode = exports.Konva = exports.glob = void 0;
		const PI_OVER_180 = Math.PI / 180;
		function detectBrowser() {
		    return (typeof window !== 'undefined' &&
		        ({}.toString.call(window) === '[object Window]' ||
		            {}.toString.call(window) === '[object global]'));
		}
		exports.glob = typeof commonjsGlobal !== 'undefined'
		    ? commonjsGlobal
		    : typeof window !== 'undefined'
		        ? window
		        : typeof WorkerGlobalScope !== 'undefined'
		            ? self
		            : {};
		exports.Konva = {
		    _global: exports.glob,
		    version: '9.3.20',
		    isBrowser: detectBrowser(),
		    isUnminified: /param/.test(function (param) { }.toString()),
		    dblClickWindow: 400,
		    getAngle(angle) {
		        return exports.Konva.angleDeg ? angle * PI_OVER_180 : angle;
		    },
		    enableTrace: false,
		    pointerEventsEnabled: true,
		    autoDrawEnabled: true,
		    hitOnDragEnabled: false,
		    capturePointerEventsEnabled: false,
		    _mouseListenClick: false,
		    _touchListenClick: false,
		    _pointerListenClick: false,
		    _mouseInDblClickWindow: false,
		    _touchInDblClickWindow: false,
		    _pointerInDblClickWindow: false,
		    _mouseDblClickPointerId: null,
		    _touchDblClickPointerId: null,
		    _pointerDblClickPointerId: null,
		    _fixTextRendering: false,
		    pixelRatio: (typeof window !== 'undefined' && window.devicePixelRatio) || 1,
		    dragDistance: 3,
		    angleDeg: true,
		    showWarnings: true,
		    dragButtons: [0, 1],
		    isDragging() {
		        return exports.Konva['DD'].isDragging;
		    },
		    isTransforming() {
		        var _a;
		        return (_a = exports.Konva['Transformer']) === null || _a === void 0 ? void 0 : _a.isTransforming();
		    },
		    isDragReady() {
		        return !!exports.Konva['DD'].node;
		    },
		    releaseCanvasOnDestroy: true,
		    document: exports.glob.document,
		    _injectGlobal(Konva) {
		        exports.glob.Konva = Konva;
		    },
		};
		const _registerNode = (NodeClass) => {
		    exports.Konva[NodeClass.prototype.getClassName()] = NodeClass;
		};
		exports._registerNode = _registerNode;
		exports.Konva._injectGlobal(exports.Konva); 
	} (Global));
	return Global;
}

var Util = {};

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return Util;
	hasRequiredUtil = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Util = exports.Transform = void 0;
		const Global_1 = requireGlobal();
		class Transform {
		    constructor(m = [1, 0, 0, 1, 0, 0]) {
		        this.dirty = false;
		        this.m = (m && m.slice()) || [1, 0, 0, 1, 0, 0];
		    }
		    reset() {
		        this.m[0] = 1;
		        this.m[1] = 0;
		        this.m[2] = 0;
		        this.m[3] = 1;
		        this.m[4] = 0;
		        this.m[5] = 0;
		    }
		    copy() {
		        return new Transform(this.m);
		    }
		    copyInto(tr) {
		        tr.m[0] = this.m[0];
		        tr.m[1] = this.m[1];
		        tr.m[2] = this.m[2];
		        tr.m[3] = this.m[3];
		        tr.m[4] = this.m[4];
		        tr.m[5] = this.m[5];
		    }
		    point(point) {
		        const m = this.m;
		        return {
		            x: m[0] * point.x + m[2] * point.y + m[4],
		            y: m[1] * point.x + m[3] * point.y + m[5],
		        };
		    }
		    translate(x, y) {
		        this.m[4] += this.m[0] * x + this.m[2] * y;
		        this.m[5] += this.m[1] * x + this.m[3] * y;
		        return this;
		    }
		    scale(sx, sy) {
		        this.m[0] *= sx;
		        this.m[1] *= sx;
		        this.m[2] *= sy;
		        this.m[3] *= sy;
		        return this;
		    }
		    rotate(rad) {
		        const c = Math.cos(rad);
		        const s = Math.sin(rad);
		        const m11 = this.m[0] * c + this.m[2] * s;
		        const m12 = this.m[1] * c + this.m[3] * s;
		        const m21 = this.m[0] * -s + this.m[2] * c;
		        const m22 = this.m[1] * -s + this.m[3] * c;
		        this.m[0] = m11;
		        this.m[1] = m12;
		        this.m[2] = m21;
		        this.m[3] = m22;
		        return this;
		    }
		    getTranslation() {
		        return {
		            x: this.m[4],
		            y: this.m[5],
		        };
		    }
		    skew(sx, sy) {
		        const m11 = this.m[0] + this.m[2] * sy;
		        const m12 = this.m[1] + this.m[3] * sy;
		        const m21 = this.m[2] + this.m[0] * sx;
		        const m22 = this.m[3] + this.m[1] * sx;
		        this.m[0] = m11;
		        this.m[1] = m12;
		        this.m[2] = m21;
		        this.m[3] = m22;
		        return this;
		    }
		    multiply(matrix) {
		        const m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1];
		        const m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1];
		        const m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3];
		        const m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];
		        const dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4];
		        const dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];
		        this.m[0] = m11;
		        this.m[1] = m12;
		        this.m[2] = m21;
		        this.m[3] = m22;
		        this.m[4] = dx;
		        this.m[5] = dy;
		        return this;
		    }
		    invert() {
		        const d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
		        const m0 = this.m[3] * d;
		        const m1 = -this.m[1] * d;
		        const m2 = -this.m[2] * d;
		        const m3 = this.m[0] * d;
		        const m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
		        const m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
		        this.m[0] = m0;
		        this.m[1] = m1;
		        this.m[2] = m2;
		        this.m[3] = m3;
		        this.m[4] = m4;
		        this.m[5] = m5;
		        return this;
		    }
		    getMatrix() {
		        return this.m;
		    }
		    decompose() {
		        const a = this.m[0];
		        const b = this.m[1];
		        const c = this.m[2];
		        const d = this.m[3];
		        const e = this.m[4];
		        const f = this.m[5];
		        const delta = a * d - b * c;
		        const result = {
		            x: e,
		            y: f,
		            rotation: 0,
		            scaleX: 0,
		            scaleY: 0,
		            skewX: 0,
		            skewY: 0,
		        };
		        if (a != 0 || b != 0) {
		            const r = Math.sqrt(a * a + b * b);
		            result.rotation = b > 0 ? Math.acos(a / r) : -Math.acos(a / r);
		            result.scaleX = r;
		            result.scaleY = delta / r;
		            result.skewX = (a * c + b * d) / delta;
		            result.skewY = 0;
		        }
		        else if (c != 0 || d != 0) {
		            const s = Math.sqrt(c * c + d * d);
		            result.rotation =
		                Math.PI / 2 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s));
		            result.scaleX = delta / s;
		            result.scaleY = s;
		            result.skewX = 0;
		            result.skewY = (a * c + b * d) / delta;
		        }
		        else ;
		        result.rotation = exports.Util._getRotation(result.rotation);
		        return result;
		    }
		}
		exports.Transform = Transform;
		const OBJECT_ARRAY = '[object Array]', OBJECT_NUMBER = '[object Number]', OBJECT_STRING = '[object String]', OBJECT_BOOLEAN = '[object Boolean]', PI_OVER_DEG180 = Math.PI / 180, DEG180_OVER_PI = 180 / Math.PI, HASH = '#', EMPTY_STRING = '', ZERO = '0', KONVA_WARNING = 'Konva warning: ', KONVA_ERROR = 'Konva error: ', RGB_PAREN = 'rgb(', COLORS = {
		    aliceblue: [240, 248, 255],
		    antiquewhite: [250, 235, 215],
		    aqua: [0, 255, 255],
		    aquamarine: [127, 255, 212],
		    azure: [240, 255, 255],
		    beige: [245, 245, 220],
		    bisque: [255, 228, 196],
		    black: [0, 0, 0],
		    blanchedalmond: [255, 235, 205],
		    blue: [0, 0, 255],
		    blueviolet: [138, 43, 226],
		    brown: [165, 42, 42],
		    burlywood: [222, 184, 135],
		    cadetblue: [95, 158, 160],
		    chartreuse: [127, 255, 0],
		    chocolate: [210, 105, 30],
		    coral: [255, 127, 80],
		    cornflowerblue: [100, 149, 237],
		    cornsilk: [255, 248, 220],
		    crimson: [220, 20, 60],
		    cyan: [0, 255, 255],
		    darkblue: [0, 0, 139],
		    darkcyan: [0, 139, 139],
		    darkgoldenrod: [184, 132, 11],
		    darkgray: [169, 169, 169],
		    darkgreen: [0, 100, 0],
		    darkgrey: [169, 169, 169],
		    darkkhaki: [189, 183, 107],
		    darkmagenta: [139, 0, 139],
		    darkolivegreen: [85, 107, 47],
		    darkorange: [255, 140, 0],
		    darkorchid: [153, 50, 204],
		    darkred: [139, 0, 0],
		    darksalmon: [233, 150, 122],
		    darkseagreen: [143, 188, 143],
		    darkslateblue: [72, 61, 139],
		    darkslategray: [47, 79, 79],
		    darkslategrey: [47, 79, 79],
		    darkturquoise: [0, 206, 209],
		    darkviolet: [148, 0, 211],
		    deeppink: [255, 20, 147],
		    deepskyblue: [0, 191, 255],
		    dimgray: [105, 105, 105],
		    dimgrey: [105, 105, 105],
		    dodgerblue: [30, 144, 255],
		    firebrick: [178, 34, 34],
		    floralwhite: [255, 255, 240],
		    forestgreen: [34, 139, 34],
		    fuchsia: [255, 0, 255],
		    gainsboro: [220, 220, 220],
		    ghostwhite: [248, 248, 255],
		    gold: [255, 215, 0],
		    goldenrod: [218, 165, 32],
		    gray: [128, 128, 128],
		    green: [0, 128, 0],
		    greenyellow: [173, 255, 47],
		    grey: [128, 128, 128],
		    honeydew: [240, 255, 240],
		    hotpink: [255, 105, 180],
		    indianred: [205, 92, 92],
		    indigo: [75, 0, 130],
		    ivory: [255, 255, 240],
		    khaki: [240, 230, 140],
		    lavender: [230, 230, 250],
		    lavenderblush: [255, 240, 245],
		    lawngreen: [124, 252, 0],
		    lemonchiffon: [255, 250, 205],
		    lightblue: [173, 216, 230],
		    lightcoral: [240, 128, 128],
		    lightcyan: [224, 255, 255],
		    lightgoldenrodyellow: [250, 250, 210],
		    lightgray: [211, 211, 211],
		    lightgreen: [144, 238, 144],
		    lightgrey: [211, 211, 211],
		    lightpink: [255, 182, 193],
		    lightsalmon: [255, 160, 122],
		    lightseagreen: [32, 178, 170],
		    lightskyblue: [135, 206, 250],
		    lightslategray: [119, 136, 153],
		    lightslategrey: [119, 136, 153],
		    lightsteelblue: [176, 196, 222],
		    lightyellow: [255, 255, 224],
		    lime: [0, 255, 0],
		    limegreen: [50, 205, 50],
		    linen: [250, 240, 230],
		    magenta: [255, 0, 255],
		    maroon: [128, 0, 0],
		    mediumaquamarine: [102, 205, 170],
		    mediumblue: [0, 0, 205],
		    mediumorchid: [186, 85, 211],
		    mediumpurple: [147, 112, 219],
		    mediumseagreen: [60, 179, 113],
		    mediumslateblue: [123, 104, 238],
		    mediumspringgreen: [0, 250, 154],
		    mediumturquoise: [72, 209, 204],
		    mediumvioletred: [199, 21, 133],
		    midnightblue: [25, 25, 112],
		    mintcream: [245, 255, 250],
		    mistyrose: [255, 228, 225],
		    moccasin: [255, 228, 181],
		    navajowhite: [255, 222, 173],
		    navy: [0, 0, 128],
		    oldlace: [253, 245, 230],
		    olive: [128, 128, 0],
		    olivedrab: [107, 142, 35],
		    orange: [255, 165, 0],
		    orangered: [255, 69, 0],
		    orchid: [218, 112, 214],
		    palegoldenrod: [238, 232, 170],
		    palegreen: [152, 251, 152],
		    paleturquoise: [175, 238, 238],
		    palevioletred: [219, 112, 147],
		    papayawhip: [255, 239, 213],
		    peachpuff: [255, 218, 185],
		    peru: [205, 133, 63],
		    pink: [255, 192, 203],
		    plum: [221, 160, 203],
		    powderblue: [176, 224, 230],
		    purple: [128, 0, 128],
		    rebeccapurple: [102, 51, 153],
		    red: [255, 0, 0],
		    rosybrown: [188, 143, 143],
		    royalblue: [65, 105, 225],
		    saddlebrown: [139, 69, 19],
		    salmon: [250, 128, 114],
		    sandybrown: [244, 164, 96],
		    seagreen: [46, 139, 87],
		    seashell: [255, 245, 238],
		    sienna: [160, 82, 45],
		    silver: [192, 192, 192],
		    skyblue: [135, 206, 235],
		    slateblue: [106, 90, 205],
		    slategray: [119, 128, 144],
		    slategrey: [119, 128, 144],
		    snow: [255, 255, 250],
		    springgreen: [0, 255, 127],
		    steelblue: [70, 130, 180],
		    tan: [210, 180, 140],
		    teal: [0, 128, 128],
		    thistle: [216, 191, 216],
		    transparent: [255, 255, 255, 0],
		    tomato: [255, 99, 71],
		    turquoise: [64, 224, 208],
		    violet: [238, 130, 238],
		    wheat: [245, 222, 179],
		    white: [255, 255, 255],
		    whitesmoke: [245, 245, 245],
		    yellow: [255, 255, 0],
		    yellowgreen: [154, 205, 5],
		}, RGB_REGEX = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/;
		let animQueue = [];
		const req = (typeof requestAnimationFrame !== 'undefined' && requestAnimationFrame) ||
		    function (f) {
		        setTimeout(f, 60);
		    };
		exports.Util = {
		    _isElement(obj) {
		        return !!(obj && obj.nodeType == 1);
		    },
		    _isFunction(obj) {
		        return !!(obj && obj.constructor && obj.call && obj.apply);
		    },
		    _isPlainObject(obj) {
		        return !!obj && obj.constructor === Object;
		    },
		    _isArray(obj) {
		        return Object.prototype.toString.call(obj) === OBJECT_ARRAY;
		    },
		    _isNumber(obj) {
		        return (Object.prototype.toString.call(obj) === OBJECT_NUMBER &&
		            !isNaN(obj) &&
		            isFinite(obj));
		    },
		    _isString(obj) {
		        return Object.prototype.toString.call(obj) === OBJECT_STRING;
		    },
		    _isBoolean(obj) {
		        return Object.prototype.toString.call(obj) === OBJECT_BOOLEAN;
		    },
		    isObject(val) {
		        return val instanceof Object;
		    },
		    isValidSelector(selector) {
		        if (typeof selector !== 'string') {
		            return false;
		        }
		        const firstChar = selector[0];
		        return (firstChar === '#' ||
		            firstChar === '.' ||
		            firstChar === firstChar.toUpperCase());
		    },
		    _sign(number) {
		        if (number === 0) {
		            return 1;
		        }
		        if (number > 0) {
		            return 1;
		        }
		        else {
		            return -1;
		        }
		    },
		    requestAnimFrame(callback) {
		        animQueue.push(callback);
		        if (animQueue.length === 1) {
		            req(function () {
		                const queue = animQueue;
		                animQueue = [];
		                queue.forEach(function (cb) {
		                    cb();
		                });
		            });
		        }
		    },
		    createCanvasElement() {
		        const canvas = document.createElement('canvas');
		        try {
		            canvas.style = canvas.style || {};
		        }
		        catch (e) { }
		        return canvas;
		    },
		    createImageElement() {
		        return document.createElement('img');
		    },
		    _isInDocument(el) {
		        while ((el = el.parentNode)) {
		            if (el == document) {
		                return true;
		            }
		        }
		        return false;
		    },
		    _urlToImage(url, callback) {
		        const imageObj = exports.Util.createImageElement();
		        imageObj.onload = function () {
		            callback(imageObj);
		        };
		        imageObj.src = url;
		    },
		    _rgbToHex(r, g, b) {
		        return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
		    },
		    _hexToRgb(hex) {
		        hex = hex.replace(HASH, EMPTY_STRING);
		        const bigint = parseInt(hex, 16);
		        return {
		            r: (bigint >> 16) & 255,
		            g: (bigint >> 8) & 255,
		            b: bigint & 255,
		        };
		    },
		    getRandomColor() {
		        let randColor = ((Math.random() * 0xffffff) << 0).toString(16);
		        while (randColor.length < 6) {
		            randColor = ZERO + randColor;
		        }
		        return HASH + randColor;
		    },
		    getRGB(color) {
		        let rgb;
		        if (color in COLORS) {
		            rgb = COLORS[color];
		            return {
		                r: rgb[0],
		                g: rgb[1],
		                b: rgb[2],
		            };
		        }
		        else if (color[0] === HASH) {
		            return this._hexToRgb(color.substring(1));
		        }
		        else if (color.substr(0, 4) === RGB_PAREN) {
		            rgb = RGB_REGEX.exec(color.replace(/ /g, ''));
		            return {
		                r: parseInt(rgb[1], 10),
		                g: parseInt(rgb[2], 10),
		                b: parseInt(rgb[3], 10),
		            };
		        }
		        else {
		            return {
		                r: 0,
		                g: 0,
		                b: 0,
		            };
		        }
		    },
		    colorToRGBA(str) {
		        str = str || 'black';
		        return (exports.Util._namedColorToRBA(str) ||
		            exports.Util._hex3ColorToRGBA(str) ||
		            exports.Util._hex4ColorToRGBA(str) ||
		            exports.Util._hex6ColorToRGBA(str) ||
		            exports.Util._hex8ColorToRGBA(str) ||
		            exports.Util._rgbColorToRGBA(str) ||
		            exports.Util._rgbaColorToRGBA(str) ||
		            exports.Util._hslColorToRGBA(str));
		    },
		    _namedColorToRBA(str) {
		        const c = COLORS[str.toLowerCase()];
		        if (!c) {
		            return null;
		        }
		        return {
		            r: c[0],
		            g: c[1],
		            b: c[2],
		            a: 1,
		        };
		    },
		    _rgbColorToRGBA(str) {
		        if (str.indexOf('rgb(') === 0) {
		            str = str.match(/rgb\(([^)]+)\)/)[1];
		            const parts = str.split(/ *, */).map(Number);
		            return {
		                r: parts[0],
		                g: parts[1],
		                b: parts[2],
		                a: 1,
		            };
		        }
		    },
		    _rgbaColorToRGBA(str) {
		        if (str.indexOf('rgba(') === 0) {
		            str = str.match(/rgba\(([^)]+)\)/)[1];
		            const parts = str.split(/ *, */).map((n, index) => {
		                if (n.slice(-1) === '%') {
		                    return index === 3 ? parseInt(n) / 100 : (parseInt(n) / 100) * 255;
		                }
		                return Number(n);
		            });
		            return {
		                r: parts[0],
		                g: parts[1],
		                b: parts[2],
		                a: parts[3],
		            };
		        }
		    },
		    _hex8ColorToRGBA(str) {
		        if (str[0] === '#' && str.length === 9) {
		            return {
		                r: parseInt(str.slice(1, 3), 16),
		                g: parseInt(str.slice(3, 5), 16),
		                b: parseInt(str.slice(5, 7), 16),
		                a: parseInt(str.slice(7, 9), 16) / 0xff,
		            };
		        }
		    },
		    _hex6ColorToRGBA(str) {
		        if (str[0] === '#' && str.length === 7) {
		            return {
		                r: parseInt(str.slice(1, 3), 16),
		                g: parseInt(str.slice(3, 5), 16),
		                b: parseInt(str.slice(5, 7), 16),
		                a: 1,
		            };
		        }
		    },
		    _hex4ColorToRGBA(str) {
		        if (str[0] === '#' && str.length === 5) {
		            return {
		                r: parseInt(str[1] + str[1], 16),
		                g: parseInt(str[2] + str[2], 16),
		                b: parseInt(str[3] + str[3], 16),
		                a: parseInt(str[4] + str[4], 16) / 0xff,
		            };
		        }
		    },
		    _hex3ColorToRGBA(str) {
		        if (str[0] === '#' && str.length === 4) {
		            return {
		                r: parseInt(str[1] + str[1], 16),
		                g: parseInt(str[2] + str[2], 16),
		                b: parseInt(str[3] + str[3], 16),
		                a: 1,
		            };
		        }
		    },
		    _hslColorToRGBA(str) {
		        if (/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.test(str)) {
		            const [_, ...hsl] = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(str);
		            const h = Number(hsl[0]) / 360;
		            const s = Number(hsl[1]) / 100;
		            const l = Number(hsl[2]) / 100;
		            let t2;
		            let t3;
		            let val;
		            if (s === 0) {
		                val = l * 255;
		                return {
		                    r: Math.round(val),
		                    g: Math.round(val),
		                    b: Math.round(val),
		                    a: 1,
		                };
		            }
		            if (l < 0.5) {
		                t2 = l * (1 + s);
		            }
		            else {
		                t2 = l + s - l * s;
		            }
		            const t1 = 2 * l - t2;
		            const rgb = [0, 0, 0];
		            for (let i = 0; i < 3; i++) {
		                t3 = h + (1 / 3) * -(i - 1);
		                if (t3 < 0) {
		                    t3++;
		                }
		                if (t3 > 1) {
		                    t3--;
		                }
		                if (6 * t3 < 1) {
		                    val = t1 + (t2 - t1) * 6 * t3;
		                }
		                else if (2 * t3 < 1) {
		                    val = t2;
		                }
		                else if (3 * t3 < 2) {
		                    val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		                }
		                else {
		                    val = t1;
		                }
		                rgb[i] = val * 255;
		            }
		            return {
		                r: Math.round(rgb[0]),
		                g: Math.round(rgb[1]),
		                b: Math.round(rgb[2]),
		                a: 1,
		            };
		        }
		    },
		    haveIntersection(r1, r2) {
		        return !(r2.x > r1.x + r1.width ||
		            r2.x + r2.width < r1.x ||
		            r2.y > r1.y + r1.height ||
		            r2.y + r2.height < r1.y);
		    },
		    cloneObject(obj) {
		        const retObj = {};
		        for (const key in obj) {
		            if (this._isPlainObject(obj[key])) {
		                retObj[key] = this.cloneObject(obj[key]);
		            }
		            else if (this._isArray(obj[key])) {
		                retObj[key] = this.cloneArray(obj[key]);
		            }
		            else {
		                retObj[key] = obj[key];
		            }
		        }
		        return retObj;
		    },
		    cloneArray(arr) {
		        return arr.slice(0);
		    },
		    degToRad(deg) {
		        return deg * PI_OVER_DEG180;
		    },
		    radToDeg(rad) {
		        return rad * DEG180_OVER_PI;
		    },
		    _degToRad(deg) {
		        exports.Util.warn('Util._degToRad is removed. Please use public Util.degToRad instead.');
		        return exports.Util.degToRad(deg);
		    },
		    _radToDeg(rad) {
		        exports.Util.warn('Util._radToDeg is removed. Please use public Util.radToDeg instead.');
		        return exports.Util.radToDeg(rad);
		    },
		    _getRotation(radians) {
		        return Global_1.Konva.angleDeg ? exports.Util.radToDeg(radians) : radians;
		    },
		    _capitalize(str) {
		        return str.charAt(0).toUpperCase() + str.slice(1);
		    },
		    throw(str) {
		        throw new Error(KONVA_ERROR + str);
		    },
		    error(str) {
		        console.error(KONVA_ERROR + str);
		    },
		    warn(str) {
		        if (!Global_1.Konva.showWarnings) {
		            return;
		        }
		        console.warn(KONVA_WARNING + str);
		    },
		    each(obj, func) {
		        for (const key in obj) {
		            func(key, obj[key]);
		        }
		    },
		    _inRange(val, left, right) {
		        return left <= val && val < right;
		    },
		    _getProjectionToSegment(x1, y1, x2, y2, x3, y3) {
		        let x, y, dist;
		        const pd2 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
		        if (pd2 == 0) {
		            x = x1;
		            y = y1;
		            dist = (x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2);
		        }
		        else {
		            const u = ((x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1)) / pd2;
		            if (u < 0) {
		                x = x1;
		                y = y1;
		                dist = (x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3);
		            }
		            else if (u > 1.0) {
		                x = x2;
		                y = y2;
		                dist = (x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3);
		            }
		            else {
		                x = x1 + u * (x2 - x1);
		                y = y1 + u * (y2 - y1);
		                dist = (x - x3) * (x - x3) + (y - y3) * (y - y3);
		            }
		        }
		        return [x, y, dist];
		    },
		    _getProjectionToLine(pt, line, isClosed) {
		        const pc = exports.Util.cloneObject(pt);
		        let dist = Number.MAX_VALUE;
		        line.forEach(function (p1, i) {
		            if (!isClosed && i === line.length - 1) {
		                return;
		            }
		            const p2 = line[(i + 1) % line.length];
		            const proj = exports.Util._getProjectionToSegment(p1.x, p1.y, p2.x, p2.y, pt.x, pt.y);
		            const px = proj[0], py = proj[1], pdist = proj[2];
		            if (pdist < dist) {
		                pc.x = px;
		                pc.y = py;
		                dist = pdist;
		            }
		        });
		        return pc;
		    },
		    _prepareArrayForTween(startArray, endArray, isClosed) {
		        const start = [], end = [];
		        if (startArray.length > endArray.length) {
		            const temp = endArray;
		            endArray = startArray;
		            startArray = temp;
		        }
		        for (let n = 0; n < startArray.length; n += 2) {
		            start.push({
		                x: startArray[n],
		                y: startArray[n + 1],
		            });
		        }
		        for (let n = 0; n < endArray.length; n += 2) {
		            end.push({
		                x: endArray[n],
		                y: endArray[n + 1],
		            });
		        }
		        const newStart = [];
		        end.forEach(function (point) {
		            const pr = exports.Util._getProjectionToLine(point, start, isClosed);
		            newStart.push(pr.x);
		            newStart.push(pr.y);
		        });
		        return newStart;
		    },
		    _prepareToStringify(obj) {
		        let desc;
		        obj.visitedByCircularReferenceRemoval = true;
		        for (const key in obj) {
		            if (!(obj.hasOwnProperty(key) && obj[key] && typeof obj[key] == 'object')) {
		                continue;
		            }
		            desc = Object.getOwnPropertyDescriptor(obj, key);
		            if (obj[key].visitedByCircularReferenceRemoval ||
		                exports.Util._isElement(obj[key])) {
		                if (desc.configurable) {
		                    delete obj[key];
		                }
		                else {
		                    return null;
		                }
		            }
		            else if (exports.Util._prepareToStringify(obj[key]) === null) {
		                if (desc.configurable) {
		                    delete obj[key];
		                }
		                else {
		                    return null;
		                }
		            }
		        }
		        delete obj.visitedByCircularReferenceRemoval;
		        return obj;
		    },
		    _assign(target, source) {
		        for (const key in source) {
		            target[key] = source[key];
		        }
		        return target;
		    },
		    _getFirstPointerId(evt) {
		        if (!evt.touches) {
		            return evt.pointerId || 999;
		        }
		        else {
		            return evt.changedTouches[0].identifier;
		        }
		    },
		    releaseCanvas(...canvases) {
		        if (!Global_1.Konva.releaseCanvasOnDestroy)
		            return;
		        canvases.forEach((c) => {
		            c.width = 0;
		            c.height = 0;
		        });
		    },
		    drawRoundedRectPath(context, width, height, cornerRadius) {
		        let topLeft = 0;
		        let topRight = 0;
		        let bottomLeft = 0;
		        let bottomRight = 0;
		        if (typeof cornerRadius === 'number') {
		            topLeft =
		                topRight =
		                    bottomLeft =
		                        bottomRight =
		                            Math.min(cornerRadius, width / 2, height / 2);
		        }
		        else {
		            topLeft = Math.min(cornerRadius[0] || 0, width / 2, height / 2);
		            topRight = Math.min(cornerRadius[1] || 0, width / 2, height / 2);
		            bottomRight = Math.min(cornerRadius[2] || 0, width / 2, height / 2);
		            bottomLeft = Math.min(cornerRadius[3] || 0, width / 2, height / 2);
		        }
		        context.moveTo(topLeft, 0);
		        context.lineTo(width - topRight, 0);
		        context.arc(width - topRight, topRight, topRight, (Math.PI * 3) / 2, 0, false);
		        context.lineTo(width, height - bottomRight);
		        context.arc(width - bottomRight, height - bottomRight, bottomRight, 0, Math.PI / 2, false);
		        context.lineTo(bottomLeft, height);
		        context.arc(bottomLeft, height - bottomLeft, bottomLeft, Math.PI / 2, Math.PI, false);
		        context.lineTo(0, topLeft);
		        context.arc(topLeft, topLeft, topLeft, Math.PI, (Math.PI * 3) / 2, false);
		    },
		}; 
	} (Util));
	return Util;
}

var Node$1 = {};

var Factory = {};

var Validators = {};

var hasRequiredValidators;

function requireValidators () {
	if (hasRequiredValidators) return Validators;
	hasRequiredValidators = 1;
	Object.defineProperty(Validators, "__esModule", { value: true });
	Validators.RGBComponent = RGBComponent;
	Validators.alphaComponent = alphaComponent;
	Validators.getNumberValidator = getNumberValidator;
	Validators.getNumberOrArrayOfNumbersValidator = getNumberOrArrayOfNumbersValidator;
	Validators.getNumberOrAutoValidator = getNumberOrAutoValidator;
	Validators.getStringValidator = getStringValidator;
	Validators.getStringOrGradientValidator = getStringOrGradientValidator;
	Validators.getFunctionValidator = getFunctionValidator;
	Validators.getNumberArrayValidator = getNumberArrayValidator;
	Validators.getBooleanValidator = getBooleanValidator;
	Validators.getComponentValidator = getComponentValidator;
	const Global_1 = requireGlobal();
	const Util_1 = requireUtil();
	function _formatValue(val) {
	    if (Util_1.Util._isString(val)) {
	        return '"' + val + '"';
	    }
	    if (Object.prototype.toString.call(val) === '[object Number]') {
	        return val;
	    }
	    if (Util_1.Util._isBoolean(val)) {
	        return val;
	    }
	    return Object.prototype.toString.call(val);
	}
	function RGBComponent(val) {
	    if (val > 255) {
	        return 255;
	    }
	    else if (val < 0) {
	        return 0;
	    }
	    return Math.round(val);
	}
	function alphaComponent(val) {
	    if (val > 1) {
	        return 1;
	    }
	    else if (val < 0.0001) {
	        return 0.0001;
	    }
	    return val;
	}
	function getNumberValidator() {
	    if (Global_1.Konva.isUnminified) {
	        return function (val, attr) {
	            if (!Util_1.Util._isNumber(val)) {
	                Util_1.Util.warn(_formatValue(val) +
	                    ' is a not valid value for "' +
	                    attr +
	                    '" attribute. The value should be a number.');
	            }
	            return val;
	        };
	    }
	}
	function getNumberOrArrayOfNumbersValidator(noOfElements) {
	    if (Global_1.Konva.isUnminified) {
	        return function (val, attr) {
	            let isNumber = Util_1.Util._isNumber(val);
	            let isValidArray = Util_1.Util._isArray(val) && val.length == noOfElements;
	            if (!isNumber && !isValidArray) {
	                Util_1.Util.warn(_formatValue(val) +
	                    ' is a not valid value for "' +
	                    attr +
	                    '" attribute. The value should be a number or Array<number>(' +
	                    noOfElements +
	                    ')');
	            }
	            return val;
	        };
	    }
	}
	function getNumberOrAutoValidator() {
	    if (Global_1.Konva.isUnminified) {
	        return function (val, attr) {
	            var isNumber = Util_1.Util._isNumber(val);
	            var isAuto = val === 'auto';
	            if (!(isNumber || isAuto)) {
	                Util_1.Util.warn(_formatValue(val) +
	                    ' is a not valid value for "' +
	                    attr +
	                    '" attribute. The value should be a number or "auto".');
	            }
	            return val;
	        };
	    }
	}
	function getStringValidator() {
	    if (Global_1.Konva.isUnminified) {
	        return function (val, attr) {
	            if (!Util_1.Util._isString(val)) {
	                Util_1.Util.warn(_formatValue(val) +
	                    ' is a not valid value for "' +
	                    attr +
	                    '" attribute. The value should be a string.');
	            }
	            return val;
	        };
	    }
	}
	function getStringOrGradientValidator() {
	    if (Global_1.Konva.isUnminified) {
	        return function (val, attr) {
	            const isString = Util_1.Util._isString(val);
	            const isGradient = Object.prototype.toString.call(val) === '[object CanvasGradient]' ||
	                (val && val['addColorStop']);
	            if (!(isString || isGradient)) {
	                Util_1.Util.warn(_formatValue(val) +
	                    ' is a not valid value for "' +
	                    attr +
	                    '" attribute. The value should be a string or a native gradient.');
	            }
	            return val;
	        };
	    }
	}
	function getFunctionValidator() {
	    if (Global_1.Konva.isUnminified) {
	        return function (val, attr) {
	            if (!Util_1.Util._isFunction(val)) {
	                Util_1.Util.warn(_formatValue(val) +
	                    ' is a not valid value for "' +
	                    attr +
	                    '" attribute. The value should be a function.');
	            }
	            return val;
	        };
	    }
	}
	function getNumberArrayValidator() {
	    if (Global_1.Konva.isUnminified) {
	        return function (val, attr) {
	            const TypedArray = Int8Array ? Object.getPrototypeOf(Int8Array) : null;
	            if (TypedArray && val instanceof TypedArray) {
	                return val;
	            }
	            if (!Util_1.Util._isArray(val)) {
	                Util_1.Util.warn(_formatValue(val) +
	                    ' is a not valid value for "' +
	                    attr +
	                    '" attribute. The value should be a array of numbers.');
	            }
	            else {
	                val.forEach(function (item) {
	                    if (!Util_1.Util._isNumber(item)) {
	                        Util_1.Util.warn('"' +
	                            attr +
	                            '" attribute has non numeric element ' +
	                            item +
	                            '. Make sure that all elements are numbers.');
	                    }
	                });
	            }
	            return val;
	        };
	    }
	}
	function getBooleanValidator() {
	    if (Global_1.Konva.isUnminified) {
	        return function (val, attr) {
	            var isBool = val === true || val === false;
	            if (!isBool) {
	                Util_1.Util.warn(_formatValue(val) +
	                    ' is a not valid value for "' +
	                    attr +
	                    '" attribute. The value should be a boolean.');
	            }
	            return val;
	        };
	    }
	}
	function getComponentValidator(components) {
	    if (Global_1.Konva.isUnminified) {
	        return function (val, attr) {
	            if (val === undefined || val === null) {
	                return val;
	            }
	            if (!Util_1.Util.isObject(val)) {
	                Util_1.Util.warn(_formatValue(val) +
	                    ' is a not valid value for "' +
	                    attr +
	                    '" attribute. The value should be an object with properties ' +
	                    components);
	            }
	            return val;
	        };
	    }
	}
	return Validators;
}

var hasRequiredFactory;

function requireFactory () {
	if (hasRequiredFactory) return Factory;
	hasRequiredFactory = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Factory = void 0;
		const Util_1 = requireUtil();
		const Validators_1 = requireValidators();
		const GET = 'get';
		const SET = 'set';
		exports.Factory = {
		    addGetterSetter(constructor, attr, def, validator, after) {
		        exports.Factory.addGetter(constructor, attr, def);
		        exports.Factory.addSetter(constructor, attr, validator, after);
		        exports.Factory.addOverloadedGetterSetter(constructor, attr);
		    },
		    addGetter(constructor, attr, def) {
		        var method = GET + Util_1.Util._capitalize(attr);
		        constructor.prototype[method] =
		            constructor.prototype[method] ||
		                function () {
		                    const val = this.attrs[attr];
		                    return val === undefined ? def : val;
		                };
		    },
		    addSetter(constructor, attr, validator, after) {
		        var method = SET + Util_1.Util._capitalize(attr);
		        if (!constructor.prototype[method]) {
		            exports.Factory.overWriteSetter(constructor, attr, validator, after);
		        }
		    },
		    overWriteSetter(constructor, attr, validator, after) {
		        var method = SET + Util_1.Util._capitalize(attr);
		        constructor.prototype[method] = function (val) {
		            if (validator && val !== undefined && val !== null) {
		                val = validator.call(this, val, attr);
		            }
		            this._setAttr(attr, val);
		            if (after) {
		                after.call(this);
		            }
		            return this;
		        };
		    },
		    addComponentsGetterSetter(constructor, attr, components, validator, after) {
		        const len = components.length, capitalize = Util_1.Util._capitalize, getter = GET + capitalize(attr), setter = SET + capitalize(attr);
		        constructor.prototype[getter] = function () {
		            const ret = {};
		            for (let n = 0; n < len; n++) {
		                const component = components[n];
		                ret[component] = this.getAttr(attr + capitalize(component));
		            }
		            return ret;
		        };
		        const basicValidator = (0, Validators_1.getComponentValidator)(components);
		        constructor.prototype[setter] = function (val) {
		            const oldVal = this.attrs[attr];
		            if (validator) {
		                val = validator.call(this, val, attr);
		            }
		            if (basicValidator) {
		                basicValidator.call(this, val, attr);
		            }
		            for (const key in val) {
		                if (!val.hasOwnProperty(key)) {
		                    continue;
		                }
		                this._setAttr(attr + capitalize(key), val[key]);
		            }
		            if (!val) {
		                components.forEach((component) => {
		                    this._setAttr(attr + capitalize(component), undefined);
		                });
		            }
		            this._fireChangeEvent(attr, oldVal, val);
		            if (after) {
		                after.call(this);
		            }
		            return this;
		        };
		        exports.Factory.addOverloadedGetterSetter(constructor, attr);
		    },
		    addOverloadedGetterSetter(constructor, attr) {
		        var capitalizedAttr = Util_1.Util._capitalize(attr), setter = SET + capitalizedAttr, getter = GET + capitalizedAttr;
		        constructor.prototype[attr] = function () {
		            if (arguments.length) {
		                this[setter](arguments[0]);
		                return this;
		            }
		            return this[getter]();
		        };
		    },
		    addDeprecatedGetterSetter(constructor, attr, def, validator) {
		        Util_1.Util.error('Adding deprecated ' + attr);
		        const method = GET + Util_1.Util._capitalize(attr);
		        const message = attr +
		            ' property is deprecated and will be removed soon. Look at Konva change log for more information.';
		        constructor.prototype[method] = function () {
		            Util_1.Util.error(message);
		            const val = this.attrs[attr];
		            return val === undefined ? def : val;
		        };
		        exports.Factory.addSetter(constructor, attr, validator, function () {
		            Util_1.Util.error(message);
		        });
		        exports.Factory.addOverloadedGetterSetter(constructor, attr);
		    },
		    backCompat(constructor, methods) {
		        Util_1.Util.each(methods, function (oldMethodName, newMethodName) {
		            const method = constructor.prototype[newMethodName];
		            const oldGetter = GET + Util_1.Util._capitalize(oldMethodName);
		            const oldSetter = SET + Util_1.Util._capitalize(oldMethodName);
		            function deprecated() {
		                method.apply(this, arguments);
		                Util_1.Util.error('"' +
		                    oldMethodName +
		                    '" method is deprecated and will be removed soon. Use ""' +
		                    newMethodName +
		                    '" instead.');
		            }
		            constructor.prototype[oldMethodName] = deprecated;
		            constructor.prototype[oldGetter] = deprecated;
		            constructor.prototype[oldSetter] = deprecated;
		        });
		    },
		    afterSetFilter() {
		        this._filterUpToDate = false;
		    },
		}; 
	} (Factory));
	return Factory;
}

var Canvas = {};

var Context = {};

var hasRequiredContext;

function requireContext () {
	if (hasRequiredContext) return Context;
	hasRequiredContext = 1;
	Object.defineProperty(Context, "__esModule", { value: true });
	Context.HitContext = Context.SceneContext = Context.Context = void 0;
	const Util_1 = requireUtil();
	const Global_1 = requireGlobal();
	function simplifyArray(arr) {
	    const retArr = [], len = arr.length, util = Util_1.Util;
	    for (let n = 0; n < len; n++) {
	        let val = arr[n];
	        if (util._isNumber(val)) {
	            val = Math.round(val * 1000) / 1000;
	        }
	        else if (!util._isString(val)) {
	            val = val + '';
	        }
	        retArr.push(val);
	    }
	    return retArr;
	}
	const COMMA = ',', OPEN_PAREN = '(', CLOSE_PAREN = ')', OPEN_PAREN_BRACKET = '([', CLOSE_BRACKET_PAREN = '])', SEMICOLON = ';', DOUBLE_PAREN = '()', EQUALS = '=', CONTEXT_METHODS = [
	    'arc',
	    'arcTo',
	    'beginPath',
	    'bezierCurveTo',
	    'clearRect',
	    'clip',
	    'closePath',
	    'createLinearGradient',
	    'createPattern',
	    'createRadialGradient',
	    'drawImage',
	    'ellipse',
	    'fill',
	    'fillText',
	    'getImageData',
	    'createImageData',
	    'lineTo',
	    'moveTo',
	    'putImageData',
	    'quadraticCurveTo',
	    'rect',
	    'roundRect',
	    'restore',
	    'rotate',
	    'save',
	    'scale',
	    'setLineDash',
	    'setTransform',
	    'stroke',
	    'strokeText',
	    'transform',
	    'translate',
	];
	const CONTEXT_PROPERTIES = [
	    'fillStyle',
	    'strokeStyle',
	    'shadowColor',
	    'shadowBlur',
	    'shadowOffsetX',
	    'shadowOffsetY',
	    'letterSpacing',
	    'lineCap',
	    'lineDashOffset',
	    'lineJoin',
	    'lineWidth',
	    'miterLimit',
	    'direction',
	    'font',
	    'textAlign',
	    'textBaseline',
	    'globalAlpha',
	    'globalCompositeOperation',
	    'imageSmoothingEnabled',
	];
	const traceArrMax = 100;
	let Context$1 = class Context {
	    constructor(canvas) {
	        this.canvas = canvas;
	        if (Global_1.Konva.enableTrace) {
	            this.traceArr = [];
	            this._enableTrace();
	        }
	    }
	    fillShape(shape) {
	        if (shape.fillEnabled()) {
	            this._fill(shape);
	        }
	    }
	    _fill(shape) {
	    }
	    strokeShape(shape) {
	        if (shape.hasStroke()) {
	            this._stroke(shape);
	        }
	    }
	    _stroke(shape) {
	    }
	    fillStrokeShape(shape) {
	        if (shape.attrs.fillAfterStrokeEnabled) {
	            this.strokeShape(shape);
	            this.fillShape(shape);
	        }
	        else {
	            this.fillShape(shape);
	            this.strokeShape(shape);
	        }
	    }
	    getTrace(relaxed, rounded) {
	        let traceArr = this.traceArr, len = traceArr.length, str = '', n, trace, method, args;
	        for (n = 0; n < len; n++) {
	            trace = traceArr[n];
	            method = trace.method;
	            if (method) {
	                args = trace.args;
	                str += method;
	                if (relaxed) {
	                    str += DOUBLE_PAREN;
	                }
	                else {
	                    if (Util_1.Util._isArray(args[0])) {
	                        str += OPEN_PAREN_BRACKET + args.join(COMMA) + CLOSE_BRACKET_PAREN;
	                    }
	                    else {
	                        if (rounded) {
	                            args = args.map((a) => typeof a === 'number' ? Math.floor(a) : a);
	                        }
	                        str += OPEN_PAREN + args.join(COMMA) + CLOSE_PAREN;
	                    }
	                }
	            }
	            else {
	                str += trace.property;
	                if (!relaxed) {
	                    str += EQUALS + trace.val;
	                }
	            }
	            str += SEMICOLON;
	        }
	        return str;
	    }
	    clearTrace() {
	        this.traceArr = [];
	    }
	    _trace(str) {
	        let traceArr = this.traceArr, len;
	        traceArr.push(str);
	        len = traceArr.length;
	        if (len >= traceArrMax) {
	            traceArr.shift();
	        }
	    }
	    reset() {
	        const pixelRatio = this.getCanvas().getPixelRatio();
	        this.setTransform(1 * pixelRatio, 0, 0, 1 * pixelRatio, 0, 0);
	    }
	    getCanvas() {
	        return this.canvas;
	    }
	    clear(bounds) {
	        const canvas = this.getCanvas();
	        if (bounds) {
	            this.clearRect(bounds.x || 0, bounds.y || 0, bounds.width || 0, bounds.height || 0);
	        }
	        else {
	            this.clearRect(0, 0, canvas.getWidth() / canvas.pixelRatio, canvas.getHeight() / canvas.pixelRatio);
	        }
	    }
	    _applyLineCap(shape) {
	        const lineCap = shape.attrs.lineCap;
	        if (lineCap) {
	            this.setAttr('lineCap', lineCap);
	        }
	    }
	    _applyOpacity(shape) {
	        const absOpacity = shape.getAbsoluteOpacity();
	        if (absOpacity !== 1) {
	            this.setAttr('globalAlpha', absOpacity);
	        }
	    }
	    _applyLineJoin(shape) {
	        const lineJoin = shape.attrs.lineJoin;
	        if (lineJoin) {
	            this.setAttr('lineJoin', lineJoin);
	        }
	    }
	    setAttr(attr, val) {
	        this._context[attr] = val;
	    }
	    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
	        this._context.arc(x, y, radius, startAngle, endAngle, counterClockwise);
	    }
	    arcTo(x1, y1, x2, y2, radius) {
	        this._context.arcTo(x1, y1, x2, y2, radius);
	    }
	    beginPath() {
	        this._context.beginPath();
	    }
	    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
	        this._context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
	    }
	    clearRect(x, y, width, height) {
	        this._context.clearRect(x, y, width, height);
	    }
	    clip(...args) {
	        this._context.clip.apply(this._context, args);
	    }
	    closePath() {
	        this._context.closePath();
	    }
	    createImageData(width, height) {
	        const a = arguments;
	        if (a.length === 2) {
	            return this._context.createImageData(width, height);
	        }
	        else if (a.length === 1) {
	            return this._context.createImageData(width);
	        }
	    }
	    createLinearGradient(x0, y0, x1, y1) {
	        return this._context.createLinearGradient(x0, y0, x1, y1);
	    }
	    createPattern(image, repetition) {
	        return this._context.createPattern(image, repetition);
	    }
	    createRadialGradient(x0, y0, r0, x1, y1, r1) {
	        return this._context.createRadialGradient(x0, y0, r0, x1, y1, r1);
	    }
	    drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {
	        const a = arguments, _context = this._context;
	        if (a.length === 3) {
	            _context.drawImage(image, sx, sy);
	        }
	        else if (a.length === 5) {
	            _context.drawImage(image, sx, sy, sWidth, sHeight);
	        }
	        else if (a.length === 9) {
	            _context.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
	        }
	    }
	    ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise) {
	        this._context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise);
	    }
	    isPointInPath(x, y, path, fillRule) {
	        if (path) {
	            return this._context.isPointInPath(path, x, y, fillRule);
	        }
	        return this._context.isPointInPath(x, y, fillRule);
	    }
	    fill(...args) {
	        this._context.fill.apply(this._context, args);
	    }
	    fillRect(x, y, width, height) {
	        this._context.fillRect(x, y, width, height);
	    }
	    strokeRect(x, y, width, height) {
	        this._context.strokeRect(x, y, width, height);
	    }
	    fillText(text, x, y, maxWidth) {
	        if (maxWidth) {
	            this._context.fillText(text, x, y, maxWidth);
	        }
	        else {
	            this._context.fillText(text, x, y);
	        }
	    }
	    measureText(text) {
	        return this._context.measureText(text);
	    }
	    getImageData(sx, sy, sw, sh) {
	        return this._context.getImageData(sx, sy, sw, sh);
	    }
	    lineTo(x, y) {
	        this._context.lineTo(x, y);
	    }
	    moveTo(x, y) {
	        this._context.moveTo(x, y);
	    }
	    rect(x, y, width, height) {
	        this._context.rect(x, y, width, height);
	    }
	    roundRect(x, y, width, height, radii) {
	        this._context.roundRect(x, y, width, height, radii);
	    }
	    putImageData(imageData, dx, dy) {
	        this._context.putImageData(imageData, dx, dy);
	    }
	    quadraticCurveTo(cpx, cpy, x, y) {
	        this._context.quadraticCurveTo(cpx, cpy, x, y);
	    }
	    restore() {
	        this._context.restore();
	    }
	    rotate(angle) {
	        this._context.rotate(angle);
	    }
	    save() {
	        this._context.save();
	    }
	    scale(x, y) {
	        this._context.scale(x, y);
	    }
	    setLineDash(segments) {
	        if (this._context.setLineDash) {
	            this._context.setLineDash(segments);
	        }
	        else if ('mozDash' in this._context) {
	            this._context['mozDash'] = segments;
	        }
	        else if ('webkitLineDash' in this._context) {
	            this._context['webkitLineDash'] = segments;
	        }
	    }
	    getLineDash() {
	        return this._context.getLineDash();
	    }
	    setTransform(a, b, c, d, e, f) {
	        this._context.setTransform(a, b, c, d, e, f);
	    }
	    stroke(path2d) {
	        if (path2d) {
	            this._context.stroke(path2d);
	        }
	        else {
	            this._context.stroke();
	        }
	    }
	    strokeText(text, x, y, maxWidth) {
	        this._context.strokeText(text, x, y, maxWidth);
	    }
	    transform(a, b, c, d, e, f) {
	        this._context.transform(a, b, c, d, e, f);
	    }
	    translate(x, y) {
	        this._context.translate(x, y);
	    }
	    _enableTrace() {
	        let that = this, len = CONTEXT_METHODS.length, origSetter = this.setAttr, n, args;
	        const func = function (methodName) {
	            let origMethod = that[methodName], ret;
	            that[methodName] = function () {
	                args = simplifyArray(Array.prototype.slice.call(arguments, 0));
	                ret = origMethod.apply(that, arguments);
	                that._trace({
	                    method: methodName,
	                    args: args,
	                });
	                return ret;
	            };
	        };
	        for (n = 0; n < len; n++) {
	            func(CONTEXT_METHODS[n]);
	        }
	        that.setAttr = function () {
	            origSetter.apply(that, arguments);
	            const prop = arguments[0];
	            let val = arguments[1];
	            if (prop === 'shadowOffsetX' ||
	                prop === 'shadowOffsetY' ||
	                prop === 'shadowBlur') {
	                val = val / this.canvas.getPixelRatio();
	            }
	            that._trace({
	                property: prop,
	                val: val,
	            });
	        };
	    }
	    _applyGlobalCompositeOperation(node) {
	        const op = node.attrs.globalCompositeOperation;
	        const def = !op || op === 'source-over';
	        if (!def) {
	            this.setAttr('globalCompositeOperation', op);
	        }
	    }
	};
	Context.Context = Context$1;
	CONTEXT_PROPERTIES.forEach(function (prop) {
	    Object.defineProperty(Context$1.prototype, prop, {
	        get() {
	            return this._context[prop];
	        },
	        set(val) {
	            this._context[prop] = val;
	        },
	    });
	});
	class SceneContext extends Context$1 {
	    constructor(canvas, { willReadFrequently = false } = {}) {
	        super(canvas);
	        this._context = canvas._canvas.getContext('2d', {
	            willReadFrequently,
	        });
	    }
	    _fillColor(shape) {
	        const fill = shape.fill();
	        this.setAttr('fillStyle', fill);
	        shape._fillFunc(this);
	    }
	    _fillPattern(shape) {
	        this.setAttr('fillStyle', shape._getFillPattern());
	        shape._fillFunc(this);
	    }
	    _fillLinearGradient(shape) {
	        const grd = shape._getLinearGradient();
	        if (grd) {
	            this.setAttr('fillStyle', grd);
	            shape._fillFunc(this);
	        }
	    }
	    _fillRadialGradient(shape) {
	        const grd = shape._getRadialGradient();
	        if (grd) {
	            this.setAttr('fillStyle', grd);
	            shape._fillFunc(this);
	        }
	    }
	    _fill(shape) {
	        const hasColor = shape.fill(), fillPriority = shape.getFillPriority();
	        if (hasColor && fillPriority === 'color') {
	            this._fillColor(shape);
	            return;
	        }
	        const hasPattern = shape.getFillPatternImage();
	        if (hasPattern && fillPriority === 'pattern') {
	            this._fillPattern(shape);
	            return;
	        }
	        const hasLinearGradient = shape.getFillLinearGradientColorStops();
	        if (hasLinearGradient && fillPriority === 'linear-gradient') {
	            this._fillLinearGradient(shape);
	            return;
	        }
	        const hasRadialGradient = shape.getFillRadialGradientColorStops();
	        if (hasRadialGradient && fillPriority === 'radial-gradient') {
	            this._fillRadialGradient(shape);
	            return;
	        }
	        if (hasColor) {
	            this._fillColor(shape);
	        }
	        else if (hasPattern) {
	            this._fillPattern(shape);
	        }
	        else if (hasLinearGradient) {
	            this._fillLinearGradient(shape);
	        }
	        else if (hasRadialGradient) {
	            this._fillRadialGradient(shape);
	        }
	    }
	    _strokeLinearGradient(shape) {
	        const start = shape.getStrokeLinearGradientStartPoint(), end = shape.getStrokeLinearGradientEndPoint(), colorStops = shape.getStrokeLinearGradientColorStops(), grd = this.createLinearGradient(start.x, start.y, end.x, end.y);
	        if (colorStops) {
	            for (let n = 0; n < colorStops.length; n += 2) {
	                grd.addColorStop(colorStops[n], colorStops[n + 1]);
	            }
	            this.setAttr('strokeStyle', grd);
	        }
	    }
	    _stroke(shape) {
	        const dash = shape.dash(), strokeScaleEnabled = shape.getStrokeScaleEnabled();
	        if (shape.hasStroke()) {
	            if (!strokeScaleEnabled) {
	                this.save();
	                const pixelRatio = this.getCanvas().getPixelRatio();
	                this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
	            }
	            this._applyLineCap(shape);
	            if (dash && shape.dashEnabled()) {
	                this.setLineDash(dash);
	                this.setAttr('lineDashOffset', shape.dashOffset());
	            }
	            this.setAttr('lineWidth', shape.strokeWidth());
	            if (!shape.getShadowForStrokeEnabled()) {
	                this.setAttr('shadowColor', 'rgba(0,0,0,0)');
	            }
	            const hasLinearGradient = shape.getStrokeLinearGradientColorStops();
	            if (hasLinearGradient) {
	                this._strokeLinearGradient(shape);
	            }
	            else {
	                this.setAttr('strokeStyle', shape.stroke());
	            }
	            shape._strokeFunc(this);
	            if (!strokeScaleEnabled) {
	                this.restore();
	            }
	        }
	    }
	    _applyShadow(shape) {
	        var _a, _b, _c;
	        const color = (_a = shape.getShadowRGBA()) !== null && _a !== void 0 ? _a : 'black', blur = (_b = shape.getShadowBlur()) !== null && _b !== void 0 ? _b : 5, offset = (_c = shape.getShadowOffset()) !== null && _c !== void 0 ? _c : {
	            x: 0,
	            y: 0,
	        }, scale = shape.getAbsoluteScale(), ratio = this.canvas.getPixelRatio(), scaleX = scale.x * ratio, scaleY = scale.y * ratio;
	        this.setAttr('shadowColor', color);
	        this.setAttr('shadowBlur', blur * Math.min(Math.abs(scaleX), Math.abs(scaleY)));
	        this.setAttr('shadowOffsetX', offset.x * scaleX);
	        this.setAttr('shadowOffsetY', offset.y * scaleY);
	    }
	}
	Context.SceneContext = SceneContext;
	class HitContext extends Context$1 {
	    constructor(canvas) {
	        super(canvas);
	        this._context = canvas._canvas.getContext('2d', {
	            willReadFrequently: true,
	        });
	    }
	    _fill(shape) {
	        this.save();
	        this.setAttr('fillStyle', shape.colorKey);
	        shape._fillFuncHit(this);
	        this.restore();
	    }
	    strokeShape(shape) {
	        if (shape.hasHitStroke()) {
	            this._stroke(shape);
	        }
	    }
	    _stroke(shape) {
	        if (shape.hasHitStroke()) {
	            const strokeScaleEnabled = shape.getStrokeScaleEnabled();
	            if (!strokeScaleEnabled) {
	                this.save();
	                const pixelRatio = this.getCanvas().getPixelRatio();
	                this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
	            }
	            this._applyLineCap(shape);
	            const hitStrokeWidth = shape.hitStrokeWidth();
	            const strokeWidth = hitStrokeWidth === 'auto' ? shape.strokeWidth() : hitStrokeWidth;
	            this.setAttr('lineWidth', strokeWidth);
	            this.setAttr('strokeStyle', shape.colorKey);
	            shape._strokeFuncHit(this);
	            if (!strokeScaleEnabled) {
	                this.restore();
	            }
	        }
	    }
	}
	Context.HitContext = HitContext;
	return Context;
}

var hasRequiredCanvas;

function requireCanvas () {
	if (hasRequiredCanvas) return Canvas;
	hasRequiredCanvas = 1;
	Object.defineProperty(Canvas, "__esModule", { value: true });
	Canvas.HitCanvas = Canvas.SceneCanvas = Canvas.Canvas = void 0;
	const Util_1 = requireUtil();
	const Context_1 = requireContext();
	const Global_1 = requireGlobal();
	let _pixelRatio;
	function getDevicePixelRatio() {
	    if (_pixelRatio) {
	        return _pixelRatio;
	    }
	    const canvas = Util_1.Util.createCanvasElement();
	    const context = canvas.getContext('2d');
	    _pixelRatio = (function () {
	        const devicePixelRatio = Global_1.Konva._global.devicePixelRatio || 1, backingStoreRatio = context.webkitBackingStorePixelRatio ||
	            context.mozBackingStorePixelRatio ||
	            context.msBackingStorePixelRatio ||
	            context.oBackingStorePixelRatio ||
	            context.backingStorePixelRatio ||
	            1;
	        return devicePixelRatio / backingStoreRatio;
	    })();
	    Util_1.Util.releaseCanvas(canvas);
	    return _pixelRatio;
	}
	let Canvas$1 = class Canvas {
	    constructor(config) {
	        this.pixelRatio = 1;
	        this.width = 0;
	        this.height = 0;
	        this.isCache = false;
	        const conf = config || {};
	        const pixelRatio = conf.pixelRatio || Global_1.Konva.pixelRatio || getDevicePixelRatio();
	        this.pixelRatio = pixelRatio;
	        this._canvas = Util_1.Util.createCanvasElement();
	        this._canvas.style.padding = '0';
	        this._canvas.style.margin = '0';
	        this._canvas.style.border = '0';
	        this._canvas.style.background = 'transparent';
	        this._canvas.style.position = 'absolute';
	        this._canvas.style.top = '0';
	        this._canvas.style.left = '0';
	    }
	    getContext() {
	        return this.context;
	    }
	    getPixelRatio() {
	        return this.pixelRatio;
	    }
	    setPixelRatio(pixelRatio) {
	        const previousRatio = this.pixelRatio;
	        this.pixelRatio = pixelRatio;
	        this.setSize(this.getWidth() / previousRatio, this.getHeight() / previousRatio);
	    }
	    setWidth(width) {
	        this.width = this._canvas.width = width * this.pixelRatio;
	        this._canvas.style.width = width + 'px';
	        const pixelRatio = this.pixelRatio, _context = this.getContext()._context;
	        _context.scale(pixelRatio, pixelRatio);
	    }
	    setHeight(height) {
	        this.height = this._canvas.height = height * this.pixelRatio;
	        this._canvas.style.height = height + 'px';
	        const pixelRatio = this.pixelRatio, _context = this.getContext()._context;
	        _context.scale(pixelRatio, pixelRatio);
	    }
	    getWidth() {
	        return this.width;
	    }
	    getHeight() {
	        return this.height;
	    }
	    setSize(width, height) {
	        this.setWidth(width || 0);
	        this.setHeight(height || 0);
	    }
	    toDataURL(mimeType, quality) {
	        try {
	            return this._canvas.toDataURL(mimeType, quality);
	        }
	        catch (e) {
	            try {
	                return this._canvas.toDataURL();
	            }
	            catch (err) {
	                Util_1.Util.error('Unable to get data URL. ' +
	                    err.message +
	                    ' For more info read https://konvajs.org/docs/posts/Tainted_Canvas.html.');
	                return '';
	            }
	        }
	    }
	};
	Canvas.Canvas = Canvas$1;
	class SceneCanvas extends Canvas$1 {
	    constructor(config = { width: 0, height: 0, willReadFrequently: false }) {
	        super(config);
	        this.context = new Context_1.SceneContext(this, {
	            willReadFrequently: config.willReadFrequently,
	        });
	        this.setSize(config.width, config.height);
	    }
	}
	Canvas.SceneCanvas = SceneCanvas;
	class HitCanvas extends Canvas$1 {
	    constructor(config = { width: 0, height: 0 }) {
	        super(config);
	        this.hitCanvas = true;
	        this.context = new Context_1.HitContext(this);
	        this.setSize(config.width, config.height);
	    }
	}
	Canvas.HitCanvas = HitCanvas;
	return Canvas;
}

var DragAndDrop = {};

var hasRequiredDragAndDrop;

function requireDragAndDrop () {
	if (hasRequiredDragAndDrop) return DragAndDrop;
	hasRequiredDragAndDrop = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.DD = void 0;
		const Global_1 = requireGlobal();
		const Util_1 = requireUtil();
		exports.DD = {
		    get isDragging() {
		        let flag = false;
		        exports.DD._dragElements.forEach((elem) => {
		            if (elem.dragStatus === 'dragging') {
		                flag = true;
		            }
		        });
		        return flag;
		    },
		    justDragged: false,
		    get node() {
		        let node;
		        exports.DD._dragElements.forEach((elem) => {
		            node = elem.node;
		        });
		        return node;
		    },
		    _dragElements: new Map(),
		    _drag(evt) {
		        const nodesToFireEvents = [];
		        exports.DD._dragElements.forEach((elem, key) => {
		            const { node } = elem;
		            const stage = node.getStage();
		            stage.setPointersPositions(evt);
		            if (elem.pointerId === undefined) {
		                elem.pointerId = Util_1.Util._getFirstPointerId(evt);
		            }
		            const pos = stage._changedPointerPositions.find((pos) => pos.id === elem.pointerId);
		            if (!pos) {
		                return;
		            }
		            if (elem.dragStatus !== 'dragging') {
		                const dragDistance = node.dragDistance();
		                const distance = Math.max(Math.abs(pos.x - elem.startPointerPos.x), Math.abs(pos.y - elem.startPointerPos.y));
		                if (distance < dragDistance) {
		                    return;
		                }
		                node.startDrag({ evt });
		                if (!node.isDragging()) {
		                    return;
		                }
		            }
		            node._setDragPosition(evt, elem);
		            nodesToFireEvents.push(node);
		        });
		        nodesToFireEvents.forEach((node) => {
		            node.fire('dragmove', {
		                type: 'dragmove',
		                target: node,
		                evt: evt,
		            }, true);
		        });
		    },
		    _endDragBefore(evt) {
		        const drawNodes = [];
		        exports.DD._dragElements.forEach((elem) => {
		            const { node } = elem;
		            const stage = node.getStage();
		            if (evt) {
		                stage.setPointersPositions(evt);
		            }
		            const pos = stage._changedPointerPositions.find((pos) => pos.id === elem.pointerId);
		            if (!pos) {
		                return;
		            }
		            if (elem.dragStatus === 'dragging' || elem.dragStatus === 'stopped') {
		                exports.DD.justDragged = true;
		                Global_1.Konva._mouseListenClick = false;
		                Global_1.Konva._touchListenClick = false;
		                Global_1.Konva._pointerListenClick = false;
		                elem.dragStatus = 'stopped';
		            }
		            const drawNode = elem.node.getLayer() ||
		                (elem.node instanceof Global_1.Konva['Stage'] && elem.node);
		            if (drawNode && drawNodes.indexOf(drawNode) === -1) {
		                drawNodes.push(drawNode);
		            }
		        });
		        drawNodes.forEach((drawNode) => {
		            drawNode.draw();
		        });
		    },
		    _endDragAfter(evt) {
		        exports.DD._dragElements.forEach((elem, key) => {
		            if (elem.dragStatus === 'stopped') {
		                elem.node.fire('dragend', {
		                    type: 'dragend',
		                    target: elem.node,
		                    evt: evt,
		                }, true);
		            }
		            if (elem.dragStatus !== 'dragging') {
		                exports.DD._dragElements.delete(key);
		            }
		        });
		    },
		};
		if (Global_1.Konva.isBrowser) {
		    window.addEventListener('mouseup', exports.DD._endDragBefore, true);
		    window.addEventListener('touchend', exports.DD._endDragBefore, true);
		    window.addEventListener('touchcancel', exports.DD._endDragBefore, true);
		    window.addEventListener('mousemove', exports.DD._drag);
		    window.addEventListener('touchmove', exports.DD._drag);
		    window.addEventListener('mouseup', exports.DD._endDragAfter, false);
		    window.addEventListener('touchend', exports.DD._endDragAfter, false);
		    window.addEventListener('touchcancel', exports.DD._endDragAfter, false);
		} 
	} (DragAndDrop));
	return DragAndDrop;
}

var hasRequiredNode;

function requireNode () {
	if (hasRequiredNode) return Node$1;
	hasRequiredNode = 1;
	Object.defineProperty(Node$1, "__esModule", { value: true });
	Node$1.Node = void 0;
	const Util_1 = requireUtil();
	const Factory_1 = requireFactory();
	const Canvas_1 = requireCanvas();
	const Global_1 = requireGlobal();
	const DragAndDrop_1 = requireDragAndDrop();
	const Validators_1 = requireValidators();
	const ABSOLUTE_OPACITY = 'absoluteOpacity', ALL_LISTENERS = 'allEventListeners', ABSOLUTE_TRANSFORM = 'absoluteTransform', ABSOLUTE_SCALE = 'absoluteScale', CANVAS = 'canvas', CHANGE = 'Change', CHILDREN = 'children', KONVA = 'konva', LISTENING = 'listening', MOUSEENTER = 'mouseenter', MOUSELEAVE = 'mouseleave', SET = 'set', SHAPE = 'Shape', SPACE = ' ', STAGE = 'stage', TRANSFORM = 'transform', UPPER_STAGE = 'Stage', VISIBLE = 'visible', TRANSFORM_CHANGE_STR = [
	    'xChange.konva',
	    'yChange.konva',
	    'scaleXChange.konva',
	    'scaleYChange.konva',
	    'skewXChange.konva',
	    'skewYChange.konva',
	    'rotationChange.konva',
	    'offsetXChange.konva',
	    'offsetYChange.konva',
	    'transformsEnabledChange.konva',
	].join(SPACE);
	let idCounter = 1;
	class Node {
	    constructor(config) {
	        this._id = idCounter++;
	        this.eventListeners = {};
	        this.attrs = {};
	        this.index = 0;
	        this._allEventListeners = null;
	        this.parent = null;
	        this._cache = new Map();
	        this._attachedDepsListeners = new Map();
	        this._lastPos = null;
	        this._batchingTransformChange = false;
	        this._needClearTransformCache = false;
	        this._filterUpToDate = false;
	        this._isUnderCache = false;
	        this._dragEventId = null;
	        this._shouldFireChangeEvents = false;
	        this.setAttrs(config);
	        this._shouldFireChangeEvents = true;
	    }
	    hasChildren() {
	        return false;
	    }
	    _clearCache(attr) {
	        if ((attr === TRANSFORM || attr === ABSOLUTE_TRANSFORM) &&
	            this._cache.get(attr)) {
	            this._cache.get(attr).dirty = true;
	        }
	        else if (attr) {
	            this._cache.delete(attr);
	        }
	        else {
	            this._cache.clear();
	        }
	    }
	    _getCache(attr, privateGetter) {
	        let cache = this._cache.get(attr);
	        const isTransform = attr === TRANSFORM || attr === ABSOLUTE_TRANSFORM;
	        const invalid = cache === undefined || (isTransform && cache.dirty === true);
	        if (invalid) {
	            cache = privateGetter.call(this);
	            this._cache.set(attr, cache);
	        }
	        return cache;
	    }
	    _calculate(name, deps, getter) {
	        if (!this._attachedDepsListeners.get(name)) {
	            const depsString = deps.map((dep) => dep + 'Change.konva').join(SPACE);
	            this.on(depsString, () => {
	                this._clearCache(name);
	            });
	            this._attachedDepsListeners.set(name, true);
	        }
	        return this._getCache(name, getter);
	    }
	    _getCanvasCache() {
	        return this._cache.get(CANVAS);
	    }
	    _clearSelfAndDescendantCache(attr) {
	        this._clearCache(attr);
	        if (attr === ABSOLUTE_TRANSFORM) {
	            this.fire('absoluteTransformChange');
	        }
	    }
	    clearCache() {
	        if (this._cache.has(CANVAS)) {
	            const { scene, filter, hit } = this._cache.get(CANVAS);
	            Util_1.Util.releaseCanvas(scene, filter, hit);
	            this._cache.delete(CANVAS);
	        }
	        this._clearSelfAndDescendantCache();
	        this._requestDraw();
	        return this;
	    }
	    cache(config) {
	        const conf = config || {};
	        let rect = {};
	        if (conf.x === undefined ||
	            conf.y === undefined ||
	            conf.width === undefined ||
	            conf.height === undefined) {
	            rect = this.getClientRect({
	                skipTransform: true,
	                relativeTo: this.getParent() || undefined,
	            });
	        }
	        let width = Math.ceil(conf.width || rect.width), height = Math.ceil(conf.height || rect.height), pixelRatio = conf.pixelRatio, x = conf.x === undefined ? Math.floor(rect.x) : conf.x, y = conf.y === undefined ? Math.floor(rect.y) : conf.y, offset = conf.offset || 0, drawBorder = conf.drawBorder || false, hitCanvasPixelRatio = conf.hitCanvasPixelRatio || 1;
	        if (!width || !height) {
	            Util_1.Util.error('Can not cache the node. Width or height of the node equals 0. Caching is skipped.');
	            return;
	        }
	        const extraPaddingX = Math.abs(Math.round(rect.x) - x) > 0.5 ? 1 : 0;
	        const extraPaddingY = Math.abs(Math.round(rect.y) - y) > 0.5 ? 1 : 0;
	        width += offset * 2 + extraPaddingX;
	        height += offset * 2 + extraPaddingY;
	        x -= offset;
	        y -= offset;
	        const cachedSceneCanvas = new Canvas_1.SceneCanvas({
	            pixelRatio: pixelRatio,
	            width: width,
	            height: height,
	        }), cachedFilterCanvas = new Canvas_1.SceneCanvas({
	            pixelRatio: pixelRatio,
	            width: 0,
	            height: 0,
	            willReadFrequently: true,
	        }), cachedHitCanvas = new Canvas_1.HitCanvas({
	            pixelRatio: hitCanvasPixelRatio,
	            width: width,
	            height: height,
	        }), sceneContext = cachedSceneCanvas.getContext(), hitContext = cachedHitCanvas.getContext();
	        cachedHitCanvas.isCache = true;
	        cachedSceneCanvas.isCache = true;
	        this._cache.delete(CANVAS);
	        this._filterUpToDate = false;
	        if (conf.imageSmoothingEnabled === false) {
	            cachedSceneCanvas.getContext()._context.imageSmoothingEnabled = false;
	            cachedFilterCanvas.getContext()._context.imageSmoothingEnabled = false;
	        }
	        sceneContext.save();
	        hitContext.save();
	        sceneContext.translate(-x, -y);
	        hitContext.translate(-x, -y);
	        this._isUnderCache = true;
	        this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
	        this._clearSelfAndDescendantCache(ABSOLUTE_SCALE);
	        this.drawScene(cachedSceneCanvas, this);
	        this.drawHit(cachedHitCanvas, this);
	        this._isUnderCache = false;
	        sceneContext.restore();
	        hitContext.restore();
	        if (drawBorder) {
	            sceneContext.save();
	            sceneContext.beginPath();
	            sceneContext.rect(0, 0, width, height);
	            sceneContext.closePath();
	            sceneContext.setAttr('strokeStyle', 'red');
	            sceneContext.setAttr('lineWidth', 5);
	            sceneContext.stroke();
	            sceneContext.restore();
	        }
	        this._cache.set(CANVAS, {
	            scene: cachedSceneCanvas,
	            filter: cachedFilterCanvas,
	            hit: cachedHitCanvas,
	            x: x,
	            y: y,
	        });
	        this._requestDraw();
	        return this;
	    }
	    isCached() {
	        return this._cache.has(CANVAS);
	    }
	    getClientRect(config) {
	        throw new Error('abstract "getClientRect" method call');
	    }
	    _transformedRect(rect, top) {
	        const points = [
	            { x: rect.x, y: rect.y },
	            { x: rect.x + rect.width, y: rect.y },
	            { x: rect.x + rect.width, y: rect.y + rect.height },
	            { x: rect.x, y: rect.y + rect.height },
	        ];
	        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
	        const trans = this.getAbsoluteTransform(top);
	        points.forEach(function (point) {
	            const transformed = trans.point(point);
	            if (minX === undefined) {
	                minX = maxX = transformed.x;
	                minY = maxY = transformed.y;
	            }
	            minX = Math.min(minX, transformed.x);
	            minY = Math.min(minY, transformed.y);
	            maxX = Math.max(maxX, transformed.x);
	            maxY = Math.max(maxY, transformed.y);
	        });
	        return {
	            x: minX,
	            y: minY,
	            width: maxX - minX,
	            height: maxY - minY,
	        };
	    }
	    _drawCachedSceneCanvas(context) {
	        context.save();
	        context._applyOpacity(this);
	        context._applyGlobalCompositeOperation(this);
	        const canvasCache = this._getCanvasCache();
	        context.translate(canvasCache.x, canvasCache.y);
	        const cacheCanvas = this._getCachedSceneCanvas();
	        const ratio = cacheCanvas.pixelRatio;
	        context.drawImage(cacheCanvas._canvas, 0, 0, cacheCanvas.width / ratio, cacheCanvas.height / ratio);
	        context.restore();
	    }
	    _drawCachedHitCanvas(context) {
	        const canvasCache = this._getCanvasCache(), hitCanvas = canvasCache.hit;
	        context.save();
	        context.translate(canvasCache.x, canvasCache.y);
	        context.drawImage(hitCanvas._canvas, 0, 0, hitCanvas.width / hitCanvas.pixelRatio, hitCanvas.height / hitCanvas.pixelRatio);
	        context.restore();
	    }
	    _getCachedSceneCanvas() {
	        let filters = this.filters(), cachedCanvas = this._getCanvasCache(), sceneCanvas = cachedCanvas.scene, filterCanvas = cachedCanvas.filter, filterContext = filterCanvas.getContext(), len, imageData, n, filter;
	        if (filters) {
	            if (!this._filterUpToDate) {
	                const ratio = sceneCanvas.pixelRatio;
	                filterCanvas.setSize(sceneCanvas.width / sceneCanvas.pixelRatio, sceneCanvas.height / sceneCanvas.pixelRatio);
	                try {
	                    len = filters.length;
	                    filterContext.clear();
	                    filterContext.drawImage(sceneCanvas._canvas, 0, 0, sceneCanvas.getWidth() / ratio, sceneCanvas.getHeight() / ratio);
	                    imageData = filterContext.getImageData(0, 0, filterCanvas.getWidth(), filterCanvas.getHeight());
	                    for (n = 0; n < len; n++) {
	                        filter = filters[n];
	                        if (typeof filter !== 'function') {
	                            Util_1.Util.error('Filter should be type of function, but got ' +
	                                typeof filter +
	                                ' instead. Please check correct filters');
	                            continue;
	                        }
	                        filter.call(this, imageData);
	                        filterContext.putImageData(imageData, 0, 0);
	                    }
	                }
	                catch (e) {
	                    Util_1.Util.error('Unable to apply filter. ' +
	                        e.message +
	                        ' This post my help you https://konvajs.org/docs/posts/Tainted_Canvas.html.');
	                }
	                this._filterUpToDate = true;
	            }
	            return filterCanvas;
	        }
	        return sceneCanvas;
	    }
	    on(evtStr, handler) {
	        this._cache && this._cache.delete(ALL_LISTENERS);
	        if (arguments.length === 3) {
	            return this._delegate.apply(this, arguments);
	        }
	        let events = evtStr.split(SPACE), len = events.length, n, event, parts, baseEvent, name;
	        for (n = 0; n < len; n++) {
	            event = events[n];
	            parts = event.split('.');
	            baseEvent = parts[0];
	            name = parts[1] || '';
	            if (!this.eventListeners[baseEvent]) {
	                this.eventListeners[baseEvent] = [];
	            }
	            this.eventListeners[baseEvent].push({
	                name: name,
	                handler: handler,
	            });
	        }
	        return this;
	    }
	    off(evtStr, callback) {
	        let events = (evtStr || '').split(SPACE), len = events.length, n, t, event, parts, baseEvent, name;
	        this._cache && this._cache.delete(ALL_LISTENERS);
	        if (!evtStr) {
	            for (t in this.eventListeners) {
	                this._off(t);
	            }
	        }
	        for (n = 0; n < len; n++) {
	            event = events[n];
	            parts = event.split('.');
	            baseEvent = parts[0];
	            name = parts[1];
	            if (baseEvent) {
	                if (this.eventListeners[baseEvent]) {
	                    this._off(baseEvent, name, callback);
	                }
	            }
	            else {
	                for (t in this.eventListeners) {
	                    this._off(t, name, callback);
	                }
	            }
	        }
	        return this;
	    }
	    dispatchEvent(evt) {
	        const e = {
	            target: this,
	            type: evt.type,
	            evt: evt,
	        };
	        this.fire(evt.type, e);
	        return this;
	    }
	    addEventListener(type, handler) {
	        this.on(type, function (evt) {
	            handler.call(this, evt.evt);
	        });
	        return this;
	    }
	    removeEventListener(type) {
	        this.off(type);
	        return this;
	    }
	    _delegate(event, selector, handler) {
	        const stopNode = this;
	        this.on(event, function (evt) {
	            const targets = evt.target.findAncestors(selector, true, stopNode);
	            for (let i = 0; i < targets.length; i++) {
	                evt = Util_1.Util.cloneObject(evt);
	                evt.currentTarget = targets[i];
	                handler.call(targets[i], evt);
	            }
	        });
	    }
	    remove() {
	        if (this.isDragging()) {
	            this.stopDrag();
	        }
	        DragAndDrop_1.DD._dragElements.delete(this._id);
	        this._remove();
	        return this;
	    }
	    _clearCaches() {
	        this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
	        this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
	        this._clearSelfAndDescendantCache(ABSOLUTE_SCALE);
	        this._clearSelfAndDescendantCache(STAGE);
	        this._clearSelfAndDescendantCache(VISIBLE);
	        this._clearSelfAndDescendantCache(LISTENING);
	    }
	    _remove() {
	        this._clearCaches();
	        const parent = this.getParent();
	        if (parent && parent.children) {
	            parent.children.splice(this.index, 1);
	            parent._setChildrenIndices();
	            this.parent = null;
	        }
	    }
	    destroy() {
	        this.remove();
	        this.clearCache();
	        return this;
	    }
	    getAttr(attr) {
	        const method = 'get' + Util_1.Util._capitalize(attr);
	        if (Util_1.Util._isFunction(this[method])) {
	            return this[method]();
	        }
	        return this.attrs[attr];
	    }
	    getAncestors() {
	        let parent = this.getParent(), ancestors = [];
	        while (parent) {
	            ancestors.push(parent);
	            parent = parent.getParent();
	        }
	        return ancestors;
	    }
	    getAttrs() {
	        return (this.attrs || {});
	    }
	    setAttrs(config) {
	        this._batchTransformChanges(() => {
	            let key, method;
	            if (!config) {
	                return this;
	            }
	            for (key in config) {
	                if (key === CHILDREN) {
	                    continue;
	                }
	                method = SET + Util_1.Util._capitalize(key);
	                if (Util_1.Util._isFunction(this[method])) {
	                    this[method](config[key]);
	                }
	                else {
	                    this._setAttr(key, config[key]);
	                }
	            }
	        });
	        return this;
	    }
	    isListening() {
	        return this._getCache(LISTENING, this._isListening);
	    }
	    _isListening(relativeTo) {
	        const listening = this.listening();
	        if (!listening) {
	            return false;
	        }
	        const parent = this.getParent();
	        if (parent && parent !== relativeTo && this !== relativeTo) {
	            return parent._isListening(relativeTo);
	        }
	        else {
	            return true;
	        }
	    }
	    isVisible() {
	        return this._getCache(VISIBLE, this._isVisible);
	    }
	    _isVisible(relativeTo) {
	        const visible = this.visible();
	        if (!visible) {
	            return false;
	        }
	        const parent = this.getParent();
	        if (parent && parent !== relativeTo && this !== relativeTo) {
	            return parent._isVisible(relativeTo);
	        }
	        else {
	            return true;
	        }
	    }
	    shouldDrawHit(top, skipDragCheck = false) {
	        if (top) {
	            return this._isVisible(top) && this._isListening(top);
	        }
	        const layer = this.getLayer();
	        let layerUnderDrag = false;
	        DragAndDrop_1.DD._dragElements.forEach((elem) => {
	            if (elem.dragStatus !== 'dragging') {
	                return;
	            }
	            else if (elem.node.nodeType === 'Stage') {
	                layerUnderDrag = true;
	            }
	            else if (elem.node.getLayer() === layer) {
	                layerUnderDrag = true;
	            }
	        });
	        const dragSkip = !skipDragCheck &&
	            !Global_1.Konva.hitOnDragEnabled &&
	            (layerUnderDrag || Global_1.Konva.isTransforming());
	        return this.isListening() && this.isVisible() && !dragSkip;
	    }
	    show() {
	        this.visible(true);
	        return this;
	    }
	    hide() {
	        this.visible(false);
	        return this;
	    }
	    getZIndex() {
	        return this.index || 0;
	    }
	    getAbsoluteZIndex() {
	        let depth = this.getDepth(), that = this, index = 0, nodes, len, n, child;
	        function addChildren(children) {
	            nodes = [];
	            len = children.length;
	            for (n = 0; n < len; n++) {
	                child = children[n];
	                index++;
	                if (child.nodeType !== SHAPE) {
	                    nodes = nodes.concat(child.getChildren().slice());
	                }
	                if (child._id === that._id) {
	                    n = len;
	                }
	            }
	            if (nodes.length > 0 && nodes[0].getDepth() <= depth) {
	                addChildren(nodes);
	            }
	        }
	        const stage = this.getStage();
	        if (that.nodeType !== UPPER_STAGE && stage) {
	            addChildren(stage.getChildren());
	        }
	        return index;
	    }
	    getDepth() {
	        let depth = 0, parent = this.parent;
	        while (parent) {
	            depth++;
	            parent = parent.parent;
	        }
	        return depth;
	    }
	    _batchTransformChanges(func) {
	        this._batchingTransformChange = true;
	        func();
	        this._batchingTransformChange = false;
	        if (this._needClearTransformCache) {
	            this._clearCache(TRANSFORM);
	            this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
	        }
	        this._needClearTransformCache = false;
	    }
	    setPosition(pos) {
	        this._batchTransformChanges(() => {
	            this.x(pos.x);
	            this.y(pos.y);
	        });
	        return this;
	    }
	    getPosition() {
	        return {
	            x: this.x(),
	            y: this.y(),
	        };
	    }
	    getRelativePointerPosition() {
	        const stage = this.getStage();
	        if (!stage) {
	            return null;
	        }
	        const pos = stage.getPointerPosition();
	        if (!pos) {
	            return null;
	        }
	        const transform = this.getAbsoluteTransform().copy();
	        transform.invert();
	        return transform.point(pos);
	    }
	    getAbsolutePosition(top) {
	        let haveCachedParent = false;
	        let parent = this.parent;
	        while (parent) {
	            if (parent.isCached()) {
	                haveCachedParent = true;
	                break;
	            }
	            parent = parent.parent;
	        }
	        if (haveCachedParent && !top) {
	            top = true;
	        }
	        const absoluteMatrix = this.getAbsoluteTransform(top).getMatrix(), absoluteTransform = new Util_1.Transform(), offset = this.offset();
	        absoluteTransform.m = absoluteMatrix.slice();
	        absoluteTransform.translate(offset.x, offset.y);
	        return absoluteTransform.getTranslation();
	    }
	    setAbsolutePosition(pos) {
	        const { x, y, ...origTrans } = this._clearTransform();
	        this.attrs.x = x;
	        this.attrs.y = y;
	        this._clearCache(TRANSFORM);
	        const it = this._getAbsoluteTransform().copy();
	        it.invert();
	        it.translate(pos.x, pos.y);
	        pos = {
	            x: this.attrs.x + it.getTranslation().x,
	            y: this.attrs.y + it.getTranslation().y,
	        };
	        this._setTransform(origTrans);
	        this.setPosition({ x: pos.x, y: pos.y });
	        this._clearCache(TRANSFORM);
	        this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
	        return this;
	    }
	    _setTransform(trans) {
	        let key;
	        for (key in trans) {
	            this.attrs[key] = trans[key];
	        }
	    }
	    _clearTransform() {
	        const trans = {
	            x: this.x(),
	            y: this.y(),
	            rotation: this.rotation(),
	            scaleX: this.scaleX(),
	            scaleY: this.scaleY(),
	            offsetX: this.offsetX(),
	            offsetY: this.offsetY(),
	            skewX: this.skewX(),
	            skewY: this.skewY(),
	        };
	        this.attrs.x = 0;
	        this.attrs.y = 0;
	        this.attrs.rotation = 0;
	        this.attrs.scaleX = 1;
	        this.attrs.scaleY = 1;
	        this.attrs.offsetX = 0;
	        this.attrs.offsetY = 0;
	        this.attrs.skewX = 0;
	        this.attrs.skewY = 0;
	        return trans;
	    }
	    move(change) {
	        let changeX = change.x, changeY = change.y, x = this.x(), y = this.y();
	        if (changeX !== undefined) {
	            x += changeX;
	        }
	        if (changeY !== undefined) {
	            y += changeY;
	        }
	        this.setPosition({ x: x, y: y });
	        return this;
	    }
	    _eachAncestorReverse(func, top) {
	        let family = [], parent = this.getParent(), len, n;
	        if (top && top._id === this._id) {
	            return;
	        }
	        family.unshift(this);
	        while (parent && (!top || parent._id !== top._id)) {
	            family.unshift(parent);
	            parent = parent.parent;
	        }
	        len = family.length;
	        for (n = 0; n < len; n++) {
	            func(family[n]);
	        }
	    }
	    rotate(theta) {
	        this.rotation(this.rotation() + theta);
	        return this;
	    }
	    moveToTop() {
	        if (!this.parent) {
	            Util_1.Util.warn('Node has no parent. moveToTop function is ignored.');
	            return false;
	        }
	        const index = this.index, len = this.parent.getChildren().length;
	        if (index < len - 1) {
	            this.parent.children.splice(index, 1);
	            this.parent.children.push(this);
	            this.parent._setChildrenIndices();
	            return true;
	        }
	        return false;
	    }
	    moveUp() {
	        if (!this.parent) {
	            Util_1.Util.warn('Node has no parent. moveUp function is ignored.');
	            return false;
	        }
	        const index = this.index, len = this.parent.getChildren().length;
	        if (index < len - 1) {
	            this.parent.children.splice(index, 1);
	            this.parent.children.splice(index + 1, 0, this);
	            this.parent._setChildrenIndices();
	            return true;
	        }
	        return false;
	    }
	    moveDown() {
	        if (!this.parent) {
	            Util_1.Util.warn('Node has no parent. moveDown function is ignored.');
	            return false;
	        }
	        const index = this.index;
	        if (index > 0) {
	            this.parent.children.splice(index, 1);
	            this.parent.children.splice(index - 1, 0, this);
	            this.parent._setChildrenIndices();
	            return true;
	        }
	        return false;
	    }
	    moveToBottom() {
	        if (!this.parent) {
	            Util_1.Util.warn('Node has no parent. moveToBottom function is ignored.');
	            return false;
	        }
	        const index = this.index;
	        if (index > 0) {
	            this.parent.children.splice(index, 1);
	            this.parent.children.unshift(this);
	            this.parent._setChildrenIndices();
	            return true;
	        }
	        return false;
	    }
	    setZIndex(zIndex) {
	        if (!this.parent) {
	            Util_1.Util.warn('Node has no parent. zIndex parameter is ignored.');
	            return this;
	        }
	        if (zIndex < 0 || zIndex >= this.parent.children.length) {
	            Util_1.Util.warn('Unexpected value ' +
	                zIndex +
	                ' for zIndex property. zIndex is just index of a node in children of its parent. Expected value is from 0 to ' +
	                (this.parent.children.length - 1) +
	                '.');
	        }
	        const index = this.index;
	        this.parent.children.splice(index, 1);
	        this.parent.children.splice(zIndex, 0, this);
	        this.parent._setChildrenIndices();
	        return this;
	    }
	    getAbsoluteOpacity() {
	        return this._getCache(ABSOLUTE_OPACITY, this._getAbsoluteOpacity);
	    }
	    _getAbsoluteOpacity() {
	        let absOpacity = this.opacity();
	        const parent = this.getParent();
	        if (parent && !parent._isUnderCache) {
	            absOpacity *= parent.getAbsoluteOpacity();
	        }
	        return absOpacity;
	    }
	    moveTo(newContainer) {
	        if (this.getParent() !== newContainer) {
	            this._remove();
	            newContainer.add(this);
	        }
	        return this;
	    }
	    toObject() {
	        let attrs = this.getAttrs(), key, val, getter, defaultValue, nonPlainObject;
	        const obj = {
	            attrs: {},
	            className: this.getClassName(),
	        };
	        for (key in attrs) {
	            val = attrs[key];
	            nonPlainObject =
	                Util_1.Util.isObject(val) && !Util_1.Util._isPlainObject(val) && !Util_1.Util._isArray(val);
	            if (nonPlainObject) {
	                continue;
	            }
	            getter = typeof this[key] === 'function' && this[key];
	            delete attrs[key];
	            defaultValue = getter ? getter.call(this) : null;
	            attrs[key] = val;
	            if (defaultValue !== val) {
	                obj.attrs[key] = val;
	            }
	        }
	        return Util_1.Util._prepareToStringify(obj);
	    }
	    toJSON() {
	        return JSON.stringify(this.toObject());
	    }
	    getParent() {
	        return this.parent;
	    }
	    findAncestors(selector, includeSelf, stopNode) {
	        const res = [];
	        if (includeSelf && this._isMatch(selector)) {
	            res.push(this);
	        }
	        let ancestor = this.parent;
	        while (ancestor) {
	            if (ancestor === stopNode) {
	                return res;
	            }
	            if (ancestor._isMatch(selector)) {
	                res.push(ancestor);
	            }
	            ancestor = ancestor.parent;
	        }
	        return res;
	    }
	    isAncestorOf(node) {
	        return false;
	    }
	    findAncestor(selector, includeSelf, stopNode) {
	        return this.findAncestors(selector, includeSelf, stopNode)[0];
	    }
	    _isMatch(selector) {
	        if (!selector) {
	            return false;
	        }
	        if (typeof selector === 'function') {
	            return selector(this);
	        }
	        let selectorArr = selector.replace(/ /g, '').split(','), len = selectorArr.length, n, sel;
	        for (n = 0; n < len; n++) {
	            sel = selectorArr[n];
	            if (!Util_1.Util.isValidSelector(sel)) {
	                Util_1.Util.warn('Selector "' +
	                    sel +
	                    '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".');
	                Util_1.Util.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".');
	                Util_1.Util.warn('Konva is awesome, right?');
	            }
	            if (sel.charAt(0) === '#') {
	                if (this.id() === sel.slice(1)) {
	                    return true;
	                }
	            }
	            else if (sel.charAt(0) === '.') {
	                if (this.hasName(sel.slice(1))) {
	                    return true;
	                }
	            }
	            else if (this.className === sel || this.nodeType === sel) {
	                return true;
	            }
	        }
	        return false;
	    }
	    getLayer() {
	        const parent = this.getParent();
	        return parent ? parent.getLayer() : null;
	    }
	    getStage() {
	        return this._getCache(STAGE, this._getStage);
	    }
	    _getStage() {
	        const parent = this.getParent();
	        if (parent) {
	            return parent.getStage();
	        }
	        else {
	            return null;
	        }
	    }
	    fire(eventType, evt = {}, bubble) {
	        evt.target = evt.target || this;
	        if (bubble) {
	            this._fireAndBubble(eventType, evt);
	        }
	        else {
	            this._fire(eventType, evt);
	        }
	        return this;
	    }
	    getAbsoluteTransform(top) {
	        if (top) {
	            return this._getAbsoluteTransform(top);
	        }
	        else {
	            return this._getCache(ABSOLUTE_TRANSFORM, this._getAbsoluteTransform);
	        }
	    }
	    _getAbsoluteTransform(top) {
	        let at;
	        if (top) {
	            at = new Util_1.Transform();
	            this._eachAncestorReverse(function (node) {
	                const transformsEnabled = node.transformsEnabled();
	                if (transformsEnabled === 'all') {
	                    at.multiply(node.getTransform());
	                }
	                else if (transformsEnabled === 'position') {
	                    at.translate(node.x() - node.offsetX(), node.y() - node.offsetY());
	                }
	            }, top);
	            return at;
	        }
	        else {
	            at = this._cache.get(ABSOLUTE_TRANSFORM) || new Util_1.Transform();
	            if (this.parent) {
	                this.parent.getAbsoluteTransform().copyInto(at);
	            }
	            else {
	                at.reset();
	            }
	            const transformsEnabled = this.transformsEnabled();
	            if (transformsEnabled === 'all') {
	                at.multiply(this.getTransform());
	            }
	            else if (transformsEnabled === 'position') {
	                const x = this.attrs.x || 0;
	                const y = this.attrs.y || 0;
	                const offsetX = this.attrs.offsetX || 0;
	                const offsetY = this.attrs.offsetY || 0;
	                at.translate(x - offsetX, y - offsetY);
	            }
	            at.dirty = false;
	            return at;
	        }
	    }
	    getAbsoluteScale(top) {
	        let parent = this;
	        while (parent) {
	            if (parent._isUnderCache) {
	                top = parent;
	            }
	            parent = parent.getParent();
	        }
	        const transform = this.getAbsoluteTransform(top);
	        const attrs = transform.decompose();
	        return {
	            x: attrs.scaleX,
	            y: attrs.scaleY,
	        };
	    }
	    getAbsoluteRotation() {
	        return this.getAbsoluteTransform().decompose().rotation;
	    }
	    getTransform() {
	        return this._getCache(TRANSFORM, this._getTransform);
	    }
	    _getTransform() {
	        var _a, _b;
	        const m = this._cache.get(TRANSFORM) || new Util_1.Transform();
	        m.reset();
	        const x = this.x(), y = this.y(), rotation = Global_1.Konva.getAngle(this.rotation()), scaleX = (_a = this.attrs.scaleX) !== null && _a !== void 0 ? _a : 1, scaleY = (_b = this.attrs.scaleY) !== null && _b !== void 0 ? _b : 1, skewX = this.attrs.skewX || 0, skewY = this.attrs.skewY || 0, offsetX = this.attrs.offsetX || 0, offsetY = this.attrs.offsetY || 0;
	        if (x !== 0 || y !== 0) {
	            m.translate(x, y);
	        }
	        if (rotation !== 0) {
	            m.rotate(rotation);
	        }
	        if (skewX !== 0 || skewY !== 0) {
	            m.skew(skewX, skewY);
	        }
	        if (scaleX !== 1 || scaleY !== 1) {
	            m.scale(scaleX, scaleY);
	        }
	        if (offsetX !== 0 || offsetY !== 0) {
	            m.translate(-1 * offsetX, -1 * offsetY);
	        }
	        m.dirty = false;
	        return m;
	    }
	    clone(obj) {
	        let attrs = Util_1.Util.cloneObject(this.attrs), key, allListeners, len, n, listener;
	        for (key in obj) {
	            attrs[key] = obj[key];
	        }
	        const node = new this.constructor(attrs);
	        for (key in this.eventListeners) {
	            allListeners = this.eventListeners[key];
	            len = allListeners.length;
	            for (n = 0; n < len; n++) {
	                listener = allListeners[n];
	                if (listener.name.indexOf(KONVA) < 0) {
	                    if (!node.eventListeners[key]) {
	                        node.eventListeners[key] = [];
	                    }
	                    node.eventListeners[key].push(listener);
	                }
	            }
	        }
	        return node;
	    }
	    _toKonvaCanvas(config) {
	        config = config || {};
	        const box = this.getClientRect();
	        const stage = this.getStage(), x = config.x !== undefined ? config.x : Math.floor(box.x), y = config.y !== undefined ? config.y : Math.floor(box.y), pixelRatio = config.pixelRatio || 1, canvas = new Canvas_1.SceneCanvas({
	            width: config.width || Math.ceil(box.width) || (stage ? stage.width() : 0),
	            height: config.height ||
	                Math.ceil(box.height) ||
	                (stage ? stage.height() : 0),
	            pixelRatio: pixelRatio,
	        }), context = canvas.getContext();
	        const bufferCanvas = new Canvas_1.SceneCanvas({
	            width: canvas.width / canvas.pixelRatio + Math.abs(x),
	            height: canvas.height / canvas.pixelRatio + Math.abs(y),
	            pixelRatio: canvas.pixelRatio,
	        });
	        if (config.imageSmoothingEnabled === false) {
	            context._context.imageSmoothingEnabled = false;
	        }
	        context.save();
	        if (x || y) {
	            context.translate(-1 * x, -1 * y);
	        }
	        this.drawScene(canvas, undefined, bufferCanvas);
	        context.restore();
	        return canvas;
	    }
	    toCanvas(config) {
	        return this._toKonvaCanvas(config)._canvas;
	    }
	    toDataURL(config) {
	        config = config || {};
	        const mimeType = config.mimeType || null, quality = config.quality || null;
	        const url = this._toKonvaCanvas(config).toDataURL(mimeType, quality);
	        if (config.callback) {
	            config.callback(url);
	        }
	        return url;
	    }
	    toImage(config) {
	        return new Promise((resolve, reject) => {
	            try {
	                const callback = config === null || config === void 0 ? void 0 : config.callback;
	                if (callback)
	                    delete config.callback;
	                Util_1.Util._urlToImage(this.toDataURL(config), function (img) {
	                    resolve(img);
	                    callback === null || callback === void 0 ? void 0 : callback(img);
	                });
	            }
	            catch (err) {
	                reject(err);
	            }
	        });
	    }
	    toBlob(config) {
	        return new Promise((resolve, reject) => {
	            try {
	                const callback = config === null || config === void 0 ? void 0 : config.callback;
	                if (callback)
	                    delete config.callback;
	                this.toCanvas(config).toBlob((blob) => {
	                    resolve(blob);
	                    callback === null || callback === void 0 ? void 0 : callback(blob);
	                }, config === null || config === void 0 ? void 0 : config.mimeType, config === null || config === void 0 ? void 0 : config.quality);
	            }
	            catch (err) {
	                reject(err);
	            }
	        });
	    }
	    setSize(size) {
	        this.width(size.width);
	        this.height(size.height);
	        return this;
	    }
	    getSize() {
	        return {
	            width: this.width(),
	            height: this.height(),
	        };
	    }
	    getClassName() {
	        return this.className || this.nodeType;
	    }
	    getType() {
	        return this.nodeType;
	    }
	    getDragDistance() {
	        if (this.attrs.dragDistance !== undefined) {
	            return this.attrs.dragDistance;
	        }
	        else if (this.parent) {
	            return this.parent.getDragDistance();
	        }
	        else {
	            return Global_1.Konva.dragDistance;
	        }
	    }
	    _off(type, name, callback) {
	        let evtListeners = this.eventListeners[type], i, evtName, handler;
	        for (i = 0; i < evtListeners.length; i++) {
	            evtName = evtListeners[i].name;
	            handler = evtListeners[i].handler;
	            if ((evtName !== 'konva' || name === 'konva') &&
	                (!name || evtName === name) &&
	                (!callback || callback === handler)) {
	                evtListeners.splice(i, 1);
	                if (evtListeners.length === 0) {
	                    delete this.eventListeners[type];
	                    break;
	                }
	                i--;
	            }
	        }
	    }
	    _fireChangeEvent(attr, oldVal, newVal) {
	        this._fire(attr + CHANGE, {
	            oldVal: oldVal,
	            newVal: newVal,
	        });
	    }
	    addName(name) {
	        if (!this.hasName(name)) {
	            const oldName = this.name();
	            const newName = oldName ? oldName + ' ' + name : name;
	            this.name(newName);
	        }
	        return this;
	    }
	    hasName(name) {
	        if (!name) {
	            return false;
	        }
	        const fullName = this.name();
	        if (!fullName) {
	            return false;
	        }
	        const names = (fullName || '').split(/\s/g);
	        return names.indexOf(name) !== -1;
	    }
	    removeName(name) {
	        const names = (this.name() || '').split(/\s/g);
	        const index = names.indexOf(name);
	        if (index !== -1) {
	            names.splice(index, 1);
	            this.name(names.join(' '));
	        }
	        return this;
	    }
	    setAttr(attr, val) {
	        const func = this[SET + Util_1.Util._capitalize(attr)];
	        if (Util_1.Util._isFunction(func)) {
	            func.call(this, val);
	        }
	        else {
	            this._setAttr(attr, val);
	        }
	        return this;
	    }
	    _requestDraw() {
	        if (Global_1.Konva.autoDrawEnabled) {
	            const drawNode = this.getLayer() || this.getStage();
	            drawNode === null || drawNode === void 0 ? void 0 : drawNode.batchDraw();
	        }
	    }
	    _setAttr(key, val) {
	        const oldVal = this.attrs[key];
	        if (oldVal === val && !Util_1.Util.isObject(val)) {
	            return;
	        }
	        if (val === undefined || val === null) {
	            delete this.attrs[key];
	        }
	        else {
	            this.attrs[key] = val;
	        }
	        if (this._shouldFireChangeEvents) {
	            this._fireChangeEvent(key, oldVal, val);
	        }
	        this._requestDraw();
	    }
	    _setComponentAttr(key, component, val) {
	        let oldVal;
	        if (val !== undefined) {
	            oldVal = this.attrs[key];
	            if (!oldVal) {
	                this.attrs[key] = this.getAttr(key);
	            }
	            this.attrs[key][component] = val;
	            this._fireChangeEvent(key, oldVal, val);
	        }
	    }
	    _fireAndBubble(eventType, evt, compareShape) {
	        if (evt && this.nodeType === SHAPE) {
	            evt.target = this;
	        }
	        const shouldStop = (eventType === MOUSEENTER || eventType === MOUSELEAVE) &&
	            ((compareShape &&
	                (this === compareShape ||
	                    (this.isAncestorOf && this.isAncestorOf(compareShape)))) ||
	                (this.nodeType === 'Stage' && !compareShape));
	        if (!shouldStop) {
	            this._fire(eventType, evt);
	            const stopBubble = (eventType === MOUSEENTER || eventType === MOUSELEAVE) &&
	                compareShape &&
	                compareShape.isAncestorOf &&
	                compareShape.isAncestorOf(this) &&
	                !compareShape.isAncestorOf(this.parent);
	            if (((evt && !evt.cancelBubble) || !evt) &&
	                this.parent &&
	                this.parent.isListening() &&
	                !stopBubble) {
	                if (compareShape && compareShape.parent) {
	                    this._fireAndBubble.call(this.parent, eventType, evt, compareShape);
	                }
	                else {
	                    this._fireAndBubble.call(this.parent, eventType, evt);
	                }
	            }
	        }
	    }
	    _getProtoListeners(eventType) {
	        var _a, _b, _c;
	        const allListeners = (_a = this._cache.get(ALL_LISTENERS)) !== null && _a !== void 0 ? _a : {};
	        let events = allListeners === null || allListeners === void 0 ? void 0 : allListeners[eventType];
	        if (events === undefined) {
	            events = [];
	            let obj = Object.getPrototypeOf(this);
	            while (obj) {
	                const hierarchyEvents = (_c = (_b = obj.eventListeners) === null || _b === void 0 ? void 0 : _b[eventType]) !== null && _c !== void 0 ? _c : [];
	                events.push(...hierarchyEvents);
	                obj = Object.getPrototypeOf(obj);
	            }
	            allListeners[eventType] = events;
	            this._cache.set(ALL_LISTENERS, allListeners);
	        }
	        return events;
	    }
	    _fire(eventType, evt) {
	        evt = evt || {};
	        evt.currentTarget = this;
	        evt.type = eventType;
	        const topListeners = this._getProtoListeners(eventType);
	        if (topListeners) {
	            for (var i = 0; i < topListeners.length; i++) {
	                topListeners[i].handler.call(this, evt);
	            }
	        }
	        const selfListeners = this.eventListeners[eventType];
	        if (selfListeners) {
	            for (var i = 0; i < selfListeners.length; i++) {
	                selfListeners[i].handler.call(this, evt);
	            }
	        }
	    }
	    draw() {
	        this.drawScene();
	        this.drawHit();
	        return this;
	    }
	    _createDragElement(evt) {
	        const pointerId = evt ? evt.pointerId : undefined;
	        const stage = this.getStage();
	        const ap = this.getAbsolutePosition();
	        if (!stage) {
	            return;
	        }
	        const pos = stage._getPointerById(pointerId) ||
	            stage._changedPointerPositions[0] ||
	            ap;
	        DragAndDrop_1.DD._dragElements.set(this._id, {
	            node: this,
	            startPointerPos: pos,
	            offset: {
	                x: pos.x - ap.x,
	                y: pos.y - ap.y,
	            },
	            dragStatus: 'ready',
	            pointerId,
	        });
	    }
	    startDrag(evt, bubbleEvent = true) {
	        if (!DragAndDrop_1.DD._dragElements.has(this._id)) {
	            this._createDragElement(evt);
	        }
	        const elem = DragAndDrop_1.DD._dragElements.get(this._id);
	        elem.dragStatus = 'dragging';
	        this.fire('dragstart', {
	            type: 'dragstart',
	            target: this,
	            evt: evt && evt.evt,
	        }, bubbleEvent);
	    }
	    _setDragPosition(evt, elem) {
	        const pos = this.getStage()._getPointerById(elem.pointerId);
	        if (!pos) {
	            return;
	        }
	        let newNodePos = {
	            x: pos.x - elem.offset.x,
	            y: pos.y - elem.offset.y,
	        };
	        const dbf = this.dragBoundFunc();
	        if (dbf !== undefined) {
	            const bounded = dbf.call(this, newNodePos, evt);
	            if (!bounded) {
	                Util_1.Util.warn('dragBoundFunc did not return any value. That is unexpected behavior. You must return new absolute position from dragBoundFunc.');
	            }
	            else {
	                newNodePos = bounded;
	            }
	        }
	        if (!this._lastPos ||
	            this._lastPos.x !== newNodePos.x ||
	            this._lastPos.y !== newNodePos.y) {
	            this.setAbsolutePosition(newNodePos);
	            this._requestDraw();
	        }
	        this._lastPos = newNodePos;
	    }
	    stopDrag(evt) {
	        const elem = DragAndDrop_1.DD._dragElements.get(this._id);
	        if (elem) {
	            elem.dragStatus = 'stopped';
	        }
	        DragAndDrop_1.DD._endDragBefore(evt);
	        DragAndDrop_1.DD._endDragAfter(evt);
	    }
	    setDraggable(draggable) {
	        this._setAttr('draggable', draggable);
	        this._dragChange();
	    }
	    isDragging() {
	        const elem = DragAndDrop_1.DD._dragElements.get(this._id);
	        return elem ? elem.dragStatus === 'dragging' : false;
	    }
	    _listenDrag() {
	        this._dragCleanup();
	        this.on('mousedown.konva touchstart.konva', function (evt) {
	            const shouldCheckButton = evt.evt['button'] !== undefined;
	            const canDrag = !shouldCheckButton || Global_1.Konva.dragButtons.indexOf(evt.evt['button']) >= 0;
	            if (!canDrag) {
	                return;
	            }
	            if (this.isDragging()) {
	                return;
	            }
	            let hasDraggingChild = false;
	            DragAndDrop_1.DD._dragElements.forEach((elem) => {
	                if (this.isAncestorOf(elem.node)) {
	                    hasDraggingChild = true;
	                }
	            });
	            if (!hasDraggingChild) {
	                this._createDragElement(evt);
	            }
	        });
	    }
	    _dragChange() {
	        if (this.attrs.draggable) {
	            this._listenDrag();
	        }
	        else {
	            this._dragCleanup();
	            const stage = this.getStage();
	            if (!stage) {
	                return;
	            }
	            const dragElement = DragAndDrop_1.DD._dragElements.get(this._id);
	            const isDragging = dragElement && dragElement.dragStatus === 'dragging';
	            const isReady = dragElement && dragElement.dragStatus === 'ready';
	            if (isDragging) {
	                this.stopDrag();
	            }
	            else if (isReady) {
	                DragAndDrop_1.DD._dragElements.delete(this._id);
	            }
	        }
	    }
	    _dragCleanup() {
	        this.off('mousedown.konva');
	        this.off('touchstart.konva');
	    }
	    isClientRectOnScreen(margin = { x: 0, y: 0 }) {
	        const stage = this.getStage();
	        if (!stage) {
	            return false;
	        }
	        const screenRect = {
	            x: -margin.x,
	            y: -margin.y,
	            width: stage.width() + 2 * margin.x,
	            height: stage.height() + 2 * margin.y,
	        };
	        return Util_1.Util.haveIntersection(screenRect, this.getClientRect());
	    }
	    static create(data, container) {
	        if (Util_1.Util._isString(data)) {
	            data = JSON.parse(data);
	        }
	        return this._createNode(data, container);
	    }
	    static _createNode(obj, container) {
	        let className = Node.prototype.getClassName.call(obj), children = obj.children, no, len, n;
	        if (container) {
	            obj.attrs.container = container;
	        }
	        if (!Global_1.Konva[className]) {
	            Util_1.Util.warn('Can not find a node with class name "' +
	                className +
	                '". Fallback to "Shape".');
	            className = 'Shape';
	        }
	        const Class = Global_1.Konva[className];
	        no = new Class(obj.attrs);
	        if (children) {
	            len = children.length;
	            for (n = 0; n < len; n++) {
	                no.add(Node._createNode(children[n]));
	            }
	        }
	        return no;
	    }
	}
	Node$1.Node = Node;
	Node.prototype.nodeType = 'Node';
	Node.prototype._attrsAffectingSize = [];
	Node.prototype.eventListeners = {};
	Node.prototype.on.call(Node.prototype, TRANSFORM_CHANGE_STR, function () {
	    if (this._batchingTransformChange) {
	        this._needClearTransformCache = true;
	        return;
	    }
	    this._clearCache(TRANSFORM);
	    this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
	});
	Node.prototype.on.call(Node.prototype, 'visibleChange.konva', function () {
	    this._clearSelfAndDescendantCache(VISIBLE);
	});
	Node.prototype.on.call(Node.prototype, 'listeningChange.konva', function () {
	    this._clearSelfAndDescendantCache(LISTENING);
	});
	Node.prototype.on.call(Node.prototype, 'opacityChange.konva', function () {
	    this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
	});
	const addGetterSetter = Factory_1.Factory.addGetterSetter;
	addGetterSetter(Node, 'zIndex');
	addGetterSetter(Node, 'absolutePosition');
	addGetterSetter(Node, 'position');
	addGetterSetter(Node, 'x', 0, (0, Validators_1.getNumberValidator)());
	addGetterSetter(Node, 'y', 0, (0, Validators_1.getNumberValidator)());
	addGetterSetter(Node, 'globalCompositeOperation', 'source-over', (0, Validators_1.getStringValidator)());
	addGetterSetter(Node, 'opacity', 1, (0, Validators_1.getNumberValidator)());
	addGetterSetter(Node, 'name', '', (0, Validators_1.getStringValidator)());
	addGetterSetter(Node, 'id', '', (0, Validators_1.getStringValidator)());
	addGetterSetter(Node, 'rotation', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addComponentsGetterSetter(Node, 'scale', ['x', 'y']);
	addGetterSetter(Node, 'scaleX', 1, (0, Validators_1.getNumberValidator)());
	addGetterSetter(Node, 'scaleY', 1, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addComponentsGetterSetter(Node, 'skew', ['x', 'y']);
	addGetterSetter(Node, 'skewX', 0, (0, Validators_1.getNumberValidator)());
	addGetterSetter(Node, 'skewY', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addComponentsGetterSetter(Node, 'offset', ['x', 'y']);
	addGetterSetter(Node, 'offsetX', 0, (0, Validators_1.getNumberValidator)());
	addGetterSetter(Node, 'offsetY', 0, (0, Validators_1.getNumberValidator)());
	addGetterSetter(Node, 'dragDistance', undefined, (0, Validators_1.getNumberValidator)());
	addGetterSetter(Node, 'width', 0, (0, Validators_1.getNumberValidator)());
	addGetterSetter(Node, 'height', 0, (0, Validators_1.getNumberValidator)());
	addGetterSetter(Node, 'listening', true, (0, Validators_1.getBooleanValidator)());
	addGetterSetter(Node, 'preventDefault', true, (0, Validators_1.getBooleanValidator)());
	addGetterSetter(Node, 'filters', undefined, function (val) {
	    this._filterUpToDate = false;
	    return val;
	});
	addGetterSetter(Node, 'visible', true, (0, Validators_1.getBooleanValidator)());
	addGetterSetter(Node, 'transformsEnabled', 'all', (0, Validators_1.getStringValidator)());
	addGetterSetter(Node, 'size');
	addGetterSetter(Node, 'dragBoundFunc');
	addGetterSetter(Node, 'draggable', false, (0, Validators_1.getBooleanValidator)());
	Factory_1.Factory.backCompat(Node, {
	    rotateDeg: 'rotate',
	    setRotationDeg: 'setRotation',
	    getRotationDeg: 'getRotation',
	});
	return Node$1;
}

var Container = {};

var hasRequiredContainer;

function requireContainer () {
	if (hasRequiredContainer) return Container;
	hasRequiredContainer = 1;
	Object.defineProperty(Container, "__esModule", { value: true });
	Container.Container = void 0;
	const Factory_1 = requireFactory();
	const Node_1 = requireNode();
	const Validators_1 = requireValidators();
	let Container$1 = class Container extends Node_1.Node {
	    constructor() {
	        super(...arguments);
	        this.children = [];
	    }
	    getChildren(filterFunc) {
	        if (!filterFunc) {
	            return this.children || [];
	        }
	        const children = this.children || [];
	        const results = [];
	        children.forEach(function (child) {
	            if (filterFunc(child)) {
	                results.push(child);
	            }
	        });
	        return results;
	    }
	    hasChildren() {
	        return this.getChildren().length > 0;
	    }
	    removeChildren() {
	        this.getChildren().forEach((child) => {
	            child.parent = null;
	            child.index = 0;
	            child.remove();
	        });
	        this.children = [];
	        this._requestDraw();
	        return this;
	    }
	    destroyChildren() {
	        this.getChildren().forEach((child) => {
	            child.parent = null;
	            child.index = 0;
	            child.destroy();
	        });
	        this.children = [];
	        this._requestDraw();
	        return this;
	    }
	    add(...children) {
	        if (children.length === 0) {
	            return this;
	        }
	        if (children.length > 1) {
	            for (let i = 0; i < children.length; i++) {
	                this.add(children[i]);
	            }
	            return this;
	        }
	        const child = children[0];
	        if (child.getParent()) {
	            child.moveTo(this);
	            return this;
	        }
	        this._validateAdd(child);
	        child.index = this.getChildren().length;
	        child.parent = this;
	        child._clearCaches();
	        this.getChildren().push(child);
	        this._fire('add', {
	            child: child,
	        });
	        this._requestDraw();
	        return this;
	    }
	    destroy() {
	        if (this.hasChildren()) {
	            this.destroyChildren();
	        }
	        super.destroy();
	        return this;
	    }
	    find(selector) {
	        return this._generalFind(selector, false);
	    }
	    findOne(selector) {
	        const result = this._generalFind(selector, true);
	        return result.length > 0 ? result[0] : undefined;
	    }
	    _generalFind(selector, findOne) {
	        const retArr = [];
	        this._descendants((node) => {
	            const valid = node._isMatch(selector);
	            if (valid) {
	                retArr.push(node);
	            }
	            if (valid && findOne) {
	                return true;
	            }
	            return false;
	        });
	        return retArr;
	    }
	    _descendants(fn) {
	        let shouldStop = false;
	        const children = this.getChildren();
	        for (const child of children) {
	            shouldStop = fn(child);
	            if (shouldStop) {
	                return true;
	            }
	            if (!child.hasChildren()) {
	                continue;
	            }
	            shouldStop = child._descendants(fn);
	            if (shouldStop) {
	                return true;
	            }
	        }
	        return false;
	    }
	    toObject() {
	        const obj = Node_1.Node.prototype.toObject.call(this);
	        obj.children = [];
	        this.getChildren().forEach((child) => {
	            obj.children.push(child.toObject());
	        });
	        return obj;
	    }
	    isAncestorOf(node) {
	        let parent = node.getParent();
	        while (parent) {
	            if (parent._id === this._id) {
	                return true;
	            }
	            parent = parent.getParent();
	        }
	        return false;
	    }
	    clone(obj) {
	        const node = Node_1.Node.prototype.clone.call(this, obj);
	        this.getChildren().forEach(function (no) {
	            node.add(no.clone());
	        });
	        return node;
	    }
	    getAllIntersections(pos) {
	        const arr = [];
	        this.find('Shape').forEach((shape) => {
	            if (shape.isVisible() && shape.intersects(pos)) {
	                arr.push(shape);
	            }
	        });
	        return arr;
	    }
	    _clearSelfAndDescendantCache(attr) {
	        var _a;
	        super._clearSelfAndDescendantCache(attr);
	        if (this.isCached()) {
	            return;
	        }
	        (_a = this.children) === null || _a === void 0 ? void 0 : _a.forEach(function (node) {
	            node._clearSelfAndDescendantCache(attr);
	        });
	    }
	    _setChildrenIndices() {
	        var _a;
	        (_a = this.children) === null || _a === void 0 ? void 0 : _a.forEach(function (child, n) {
	            child.index = n;
	        });
	        this._requestDraw();
	    }
	    drawScene(can, top, bufferCanvas) {
	        const layer = this.getLayer(), canvas = can || (layer && layer.getCanvas()), context = canvas && canvas.getContext(), cachedCanvas = this._getCanvasCache(), cachedSceneCanvas = cachedCanvas && cachedCanvas.scene;
	        const caching = canvas && canvas.isCache;
	        if (!this.isVisible() && !caching) {
	            return this;
	        }
	        if (cachedSceneCanvas) {
	            context.save();
	            const m = this.getAbsoluteTransform(top).getMatrix();
	            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
	            this._drawCachedSceneCanvas(context);
	            context.restore();
	        }
	        else {
	            this._drawChildren('drawScene', canvas, top, bufferCanvas);
	        }
	        return this;
	    }
	    drawHit(can, top) {
	        if (!this.shouldDrawHit(top)) {
	            return this;
	        }
	        const layer = this.getLayer(), canvas = can || (layer && layer.hitCanvas), context = canvas && canvas.getContext(), cachedCanvas = this._getCanvasCache(), cachedHitCanvas = cachedCanvas && cachedCanvas.hit;
	        if (cachedHitCanvas) {
	            context.save();
	            const m = this.getAbsoluteTransform(top).getMatrix();
	            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
	            this._drawCachedHitCanvas(context);
	            context.restore();
	        }
	        else {
	            this._drawChildren('drawHit', canvas, top);
	        }
	        return this;
	    }
	    _drawChildren(drawMethod, canvas, top, bufferCanvas) {
	        var _a;
	        const context = canvas && canvas.getContext(), clipWidth = this.clipWidth(), clipHeight = this.clipHeight(), clipFunc = this.clipFunc(), hasClip = (typeof clipWidth === 'number' && typeof clipHeight === 'number') ||
	            clipFunc;
	        const selfCache = top === this;
	        if (hasClip) {
	            context.save();
	            const transform = this.getAbsoluteTransform(top);
	            let m = transform.getMatrix();
	            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
	            context.beginPath();
	            let clipArgs;
	            if (clipFunc) {
	                clipArgs = clipFunc.call(this, context, this);
	            }
	            else {
	                const clipX = this.clipX();
	                const clipY = this.clipY();
	                context.rect(clipX || 0, clipY || 0, clipWidth, clipHeight);
	            }
	            context.clip.apply(context, clipArgs);
	            m = transform.copy().invert().getMatrix();
	            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
	        }
	        const hasComposition = !selfCache &&
	            this.globalCompositeOperation() !== 'source-over' &&
	            drawMethod === 'drawScene';
	        if (hasComposition) {
	            context.save();
	            context._applyGlobalCompositeOperation(this);
	        }
	        (_a = this.children) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {
	            child[drawMethod](canvas, top, bufferCanvas);
	        });
	        if (hasComposition) {
	            context.restore();
	        }
	        if (hasClip) {
	            context.restore();
	        }
	    }
	    getClientRect(config = {}) {
	        var _a;
	        const skipTransform = config.skipTransform;
	        const relativeTo = config.relativeTo;
	        let minX, minY, maxX, maxY;
	        let selfRect = {
	            x: Infinity,
	            y: Infinity,
	            width: 0,
	            height: 0,
	        };
	        const that = this;
	        (_a = this.children) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {
	            if (!child.visible()) {
	                return;
	            }
	            const rect = child.getClientRect({
	                relativeTo: that,
	                skipShadow: config.skipShadow,
	                skipStroke: config.skipStroke,
	            });
	            if (rect.width === 0 && rect.height === 0) {
	                return;
	            }
	            if (minX === undefined) {
	                minX = rect.x;
	                minY = rect.y;
	                maxX = rect.x + rect.width;
	                maxY = rect.y + rect.height;
	            }
	            else {
	                minX = Math.min(minX, rect.x);
	                minY = Math.min(minY, rect.y);
	                maxX = Math.max(maxX, rect.x + rect.width);
	                maxY = Math.max(maxY, rect.y + rect.height);
	            }
	        });
	        const shapes = this.find('Shape');
	        let hasVisible = false;
	        for (let i = 0; i < shapes.length; i++) {
	            const shape = shapes[i];
	            if (shape._isVisible(this)) {
	                hasVisible = true;
	                break;
	            }
	        }
	        if (hasVisible && minX !== undefined) {
	            selfRect = {
	                x: minX,
	                y: minY,
	                width: maxX - minX,
	                height: maxY - minY,
	            };
	        }
	        else {
	            selfRect = {
	                x: 0,
	                y: 0,
	                width: 0,
	                height: 0,
	            };
	        }
	        if (!skipTransform) {
	            return this._transformedRect(selfRect, relativeTo);
	        }
	        return selfRect;
	    }
	};
	Container.Container = Container$1;
	Factory_1.Factory.addComponentsGetterSetter(Container$1, 'clip', [
	    'x',
	    'y',
	    'width',
	    'height',
	]);
	Factory_1.Factory.addGetterSetter(Container$1, 'clipX', undefined, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Container$1, 'clipY', undefined, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Container$1, 'clipWidth', undefined, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Container$1, 'clipHeight', undefined, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Container$1, 'clipFunc');
	return Container;
}

var Stage$1 = {};

var PointerEvents = {};

var hasRequiredPointerEvents;

function requirePointerEvents () {
	if (hasRequiredPointerEvents) return PointerEvents;
	hasRequiredPointerEvents = 1;
	Object.defineProperty(PointerEvents, "__esModule", { value: true });
	PointerEvents.getCapturedShape = getCapturedShape;
	PointerEvents.createEvent = createEvent;
	PointerEvents.hasPointerCapture = hasPointerCapture;
	PointerEvents.setPointerCapture = setPointerCapture;
	PointerEvents.releaseCapture = releaseCapture;
	const Global_1 = requireGlobal();
	const Captures = new Map();
	const SUPPORT_POINTER_EVENTS = Global_1.Konva._global['PointerEvent'] !== undefined;
	function getCapturedShape(pointerId) {
	    return Captures.get(pointerId);
	}
	function createEvent(evt) {
	    return {
	        evt,
	        pointerId: evt.pointerId,
	    };
	}
	function hasPointerCapture(pointerId, shape) {
	    return Captures.get(pointerId) === shape;
	}
	function setPointerCapture(pointerId, shape) {
	    releaseCapture(pointerId);
	    const stage = shape.getStage();
	    if (!stage)
	        return;
	    Captures.set(pointerId, shape);
	    if (SUPPORT_POINTER_EVENTS) {
	        shape._fire('gotpointercapture', createEvent(new PointerEvent('gotpointercapture')));
	    }
	}
	function releaseCapture(pointerId, target) {
	    const shape = Captures.get(pointerId);
	    if (!shape)
	        return;
	    const stage = shape.getStage();
	    if (stage && stage.content) ;
	    Captures.delete(pointerId);
	    if (SUPPORT_POINTER_EVENTS) {
	        shape._fire('lostpointercapture', createEvent(new PointerEvent('lostpointercapture')));
	    }
	}
	return PointerEvents;
}

var hasRequiredStage;

function requireStage () {
	if (hasRequiredStage) return Stage$1;
	hasRequiredStage = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Stage = exports.stages = void 0;
		const Util_1 = requireUtil();
		const Factory_1 = requireFactory();
		const Container_1 = requireContainer();
		const Global_1 = requireGlobal();
		const Canvas_1 = requireCanvas();
		const DragAndDrop_1 = requireDragAndDrop();
		const Global_2 = requireGlobal();
		const PointerEvents = requirePointerEvents();
		const STAGE = 'Stage', STRING = 'string', PX = 'px', MOUSEOUT = 'mouseout', MOUSELEAVE = 'mouseleave', MOUSEOVER = 'mouseover', MOUSEENTER = 'mouseenter', MOUSEMOVE = 'mousemove', MOUSEDOWN = 'mousedown', MOUSEUP = 'mouseup', POINTERMOVE = 'pointermove', POINTERDOWN = 'pointerdown', POINTERUP = 'pointerup', POINTERCANCEL = 'pointercancel', LOSTPOINTERCAPTURE = 'lostpointercapture', POINTEROUT = 'pointerout', POINTERLEAVE = 'pointerleave', POINTEROVER = 'pointerover', POINTERENTER = 'pointerenter', CONTEXTMENU = 'contextmenu', TOUCHSTART = 'touchstart', TOUCHEND = 'touchend', TOUCHMOVE = 'touchmove', TOUCHCANCEL = 'touchcancel', WHEEL = 'wheel', MAX_LAYERS_NUMBER = 5, EVENTS = [
		    [MOUSEENTER, '_pointerenter'],
		    [MOUSEDOWN, '_pointerdown'],
		    [MOUSEMOVE, '_pointermove'],
		    [MOUSEUP, '_pointerup'],
		    [MOUSELEAVE, '_pointerleave'],
		    [TOUCHSTART, '_pointerdown'],
		    [TOUCHMOVE, '_pointermove'],
		    [TOUCHEND, '_pointerup'],
		    [TOUCHCANCEL, '_pointercancel'],
		    [MOUSEOVER, '_pointerover'],
		    [WHEEL, '_wheel'],
		    [CONTEXTMENU, '_contextmenu'],
		    [POINTERDOWN, '_pointerdown'],
		    [POINTERMOVE, '_pointermove'],
		    [POINTERUP, '_pointerup'],
		    [POINTERCANCEL, '_pointercancel'],
		    [LOSTPOINTERCAPTURE, '_lostpointercapture'],
		];
		const EVENTS_MAP = {
		    mouse: {
		        [POINTEROUT]: MOUSEOUT,
		        [POINTERLEAVE]: MOUSELEAVE,
		        [POINTEROVER]: MOUSEOVER,
		        [POINTERENTER]: MOUSEENTER,
		        [POINTERMOVE]: MOUSEMOVE,
		        [POINTERDOWN]: MOUSEDOWN,
		        [POINTERUP]: MOUSEUP,
		        [POINTERCANCEL]: 'mousecancel',
		        pointerclick: 'click',
		        pointerdblclick: 'dblclick',
		    },
		    touch: {
		        [POINTEROUT]: 'touchout',
		        [POINTERLEAVE]: 'touchleave',
		        [POINTEROVER]: 'touchover',
		        [POINTERENTER]: 'touchenter',
		        [POINTERMOVE]: TOUCHMOVE,
		        [POINTERDOWN]: TOUCHSTART,
		        [POINTERUP]: TOUCHEND,
		        [POINTERCANCEL]: TOUCHCANCEL,
		        pointerclick: 'tap',
		        pointerdblclick: 'dbltap',
		    },
		    pointer: {
		        [POINTEROUT]: POINTEROUT,
		        [POINTERLEAVE]: POINTERLEAVE,
		        [POINTEROVER]: POINTEROVER,
		        [POINTERENTER]: POINTERENTER,
		        [POINTERMOVE]: POINTERMOVE,
		        [POINTERDOWN]: POINTERDOWN,
		        [POINTERUP]: POINTERUP,
		        [POINTERCANCEL]: POINTERCANCEL,
		        pointerclick: 'pointerclick',
		        pointerdblclick: 'pointerdblclick',
		    },
		};
		const getEventType = (type) => {
		    if (type.indexOf('pointer') >= 0) {
		        return 'pointer';
		    }
		    if (type.indexOf('touch') >= 0) {
		        return 'touch';
		    }
		    return 'mouse';
		};
		const getEventsMap = (eventType) => {
		    const type = getEventType(eventType);
		    if (type === 'pointer') {
		        return Global_1.Konva.pointerEventsEnabled && EVENTS_MAP.pointer;
		    }
		    if (type === 'touch') {
		        return EVENTS_MAP.touch;
		    }
		    if (type === 'mouse') {
		        return EVENTS_MAP.mouse;
		    }
		};
		function checkNoClip(attrs = {}) {
		    if (attrs.clipFunc || attrs.clipWidth || attrs.clipHeight) {
		        Util_1.Util.warn('Stage does not support clipping. Please use clip for Layers or Groups.');
		    }
		    return attrs;
		}
		const NO_POINTERS_MESSAGE = `Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);`;
		exports.stages = [];
		class Stage extends Container_1.Container {
		    constructor(config) {
		        super(checkNoClip(config));
		        this._pointerPositions = [];
		        this._changedPointerPositions = [];
		        this._buildDOM();
		        this._bindContentEvents();
		        exports.stages.push(this);
		        this.on('widthChange.konva heightChange.konva', this._resizeDOM);
		        this.on('visibleChange.konva', this._checkVisibility);
		        this.on('clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva', () => {
		            checkNoClip(this.attrs);
		        });
		        this._checkVisibility();
		    }
		    _validateAdd(child) {
		        const isLayer = child.getType() === 'Layer';
		        const isFastLayer = child.getType() === 'FastLayer';
		        const valid = isLayer || isFastLayer;
		        if (!valid) {
		            Util_1.Util.throw('You may only add layers to the stage.');
		        }
		    }
		    _checkVisibility() {
		        if (!this.content) {
		            return;
		        }
		        const style = this.visible() ? '' : 'none';
		        this.content.style.display = style;
		    }
		    setContainer(container) {
		        if (typeof container === STRING) {
		            if (container.charAt(0) === '.') {
		                const className = container.slice(1);
		                container = document.getElementsByClassName(className)[0];
		            }
		            else {
		                var id;
		                if (container.charAt(0) !== '#') {
		                    id = container;
		                }
		                else {
		                    id = container.slice(1);
		                }
		                container = document.getElementById(id);
		            }
		            if (!container) {
		                throw 'Can not find container in document with id ' + id;
		            }
		        }
		        this._setAttr('container', container);
		        if (this.content) {
		            if (this.content.parentElement) {
		                this.content.parentElement.removeChild(this.content);
		            }
		            container.appendChild(this.content);
		        }
		        return this;
		    }
		    shouldDrawHit() {
		        return true;
		    }
		    clear() {
		        const layers = this.children, len = layers.length;
		        for (let n = 0; n < len; n++) {
		            layers[n].clear();
		        }
		        return this;
		    }
		    clone(obj) {
		        if (!obj) {
		            obj = {};
		        }
		        obj.container =
		            typeof document !== 'undefined' && document.createElement('div');
		        return Container_1.Container.prototype.clone.call(this, obj);
		    }
		    destroy() {
		        super.destroy();
		        const content = this.content;
		        if (content && Util_1.Util._isInDocument(content)) {
		            this.container().removeChild(content);
		        }
		        const index = exports.stages.indexOf(this);
		        if (index > -1) {
		            exports.stages.splice(index, 1);
		        }
		        Util_1.Util.releaseCanvas(this.bufferCanvas._canvas, this.bufferHitCanvas._canvas);
		        return this;
		    }
		    getPointerPosition() {
		        const pos = this._pointerPositions[0] || this._changedPointerPositions[0];
		        if (!pos) {
		            Util_1.Util.warn(NO_POINTERS_MESSAGE);
		            return null;
		        }
		        return {
		            x: pos.x,
		            y: pos.y,
		        };
		    }
		    _getPointerById(id) {
		        return this._pointerPositions.find((p) => p.id === id);
		    }
		    getPointersPositions() {
		        return this._pointerPositions;
		    }
		    getStage() {
		        return this;
		    }
		    getContent() {
		        return this.content;
		    }
		    _toKonvaCanvas(config) {
		        config = config || {};
		        config.x = config.x || 0;
		        config.y = config.y || 0;
		        config.width = config.width || this.width();
		        config.height = config.height || this.height();
		        const canvas = new Canvas_1.SceneCanvas({
		            width: config.width,
		            height: config.height,
		            pixelRatio: config.pixelRatio || 1,
		        });
		        const _context = canvas.getContext()._context;
		        const layers = this.children;
		        if (config.x || config.y) {
		            _context.translate(-1 * config.x, -1 * config.y);
		        }
		        layers.forEach(function (layer) {
		            if (!layer.isVisible()) {
		                return;
		            }
		            const layerCanvas = layer._toKonvaCanvas(config);
		            _context.drawImage(layerCanvas._canvas, config.x, config.y, layerCanvas.getWidth() / layerCanvas.getPixelRatio(), layerCanvas.getHeight() / layerCanvas.getPixelRatio());
		        });
		        return canvas;
		    }
		    getIntersection(pos) {
		        if (!pos) {
		            return null;
		        }
		        const layers = this.children, len = layers.length, end = len - 1;
		        for (let n = end; n >= 0; n--) {
		            const shape = layers[n].getIntersection(pos);
		            if (shape) {
		                return shape;
		            }
		        }
		        return null;
		    }
		    _resizeDOM() {
		        const width = this.width();
		        const height = this.height();
		        if (this.content) {
		            this.content.style.width = width + PX;
		            this.content.style.height = height + PX;
		        }
		        this.bufferCanvas.setSize(width, height);
		        this.bufferHitCanvas.setSize(width, height);
		        this.children.forEach((layer) => {
		            layer.setSize({ width, height });
		            layer.draw();
		        });
		    }
		    add(layer, ...rest) {
		        if (arguments.length > 1) {
		            for (let i = 0; i < arguments.length; i++) {
		                this.add(arguments[i]);
		            }
		            return this;
		        }
		        super.add(layer);
		        const length = this.children.length;
		        if (length > MAX_LAYERS_NUMBER) {
		            Util_1.Util.warn('The stage has ' +
		                length +
		                ' layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group.');
		        }
		        layer.setSize({ width: this.width(), height: this.height() });
		        layer.draw();
		        if (Global_1.Konva.isBrowser) {
		            this.content.appendChild(layer.canvas._canvas);
		        }
		        return this;
		    }
		    getParent() {
		        return null;
		    }
		    getLayer() {
		        return null;
		    }
		    hasPointerCapture(pointerId) {
		        return PointerEvents.hasPointerCapture(pointerId, this);
		    }
		    setPointerCapture(pointerId) {
		        PointerEvents.setPointerCapture(pointerId, this);
		    }
		    releaseCapture(pointerId) {
		        PointerEvents.releaseCapture(pointerId, this);
		    }
		    getLayers() {
		        return this.children;
		    }
		    _bindContentEvents() {
		        if (!Global_1.Konva.isBrowser) {
		            return;
		        }
		        EVENTS.forEach(([event, methodName]) => {
		            this.content.addEventListener(event, (evt) => {
		                this[methodName](evt);
		            }, { passive: false });
		        });
		    }
		    _pointerenter(evt) {
		        this.setPointersPositions(evt);
		        const events = getEventsMap(evt.type);
		        if (events) {
		            this._fire(events.pointerenter, {
		                evt: evt,
		                target: this,
		                currentTarget: this,
		            });
		        }
		    }
		    _pointerover(evt) {
		        this.setPointersPositions(evt);
		        const events = getEventsMap(evt.type);
		        if (events) {
		            this._fire(events.pointerover, {
		                evt: evt,
		                target: this,
		                currentTarget: this,
		            });
		        }
		    }
		    _getTargetShape(evenType) {
		        let shape = this[evenType + 'targetShape'];
		        if (shape && !shape.getStage()) {
		            shape = null;
		        }
		        return shape;
		    }
		    _pointerleave(evt) {
		        const events = getEventsMap(evt.type);
		        const eventType = getEventType(evt.type);
		        if (!events) {
		            return;
		        }
		        this.setPointersPositions(evt);
		        const targetShape = this._getTargetShape(eventType);
		        const eventsEnabled = !(Global_1.Konva.isDragging() || Global_1.Konva.isTransforming()) || Global_1.Konva.hitOnDragEnabled;
		        if (targetShape && eventsEnabled) {
		            targetShape._fireAndBubble(events.pointerout, { evt: evt });
		            targetShape._fireAndBubble(events.pointerleave, { evt: evt });
		            this._fire(events.pointerleave, {
		                evt: evt,
		                target: this,
		                currentTarget: this,
		            });
		            this[eventType + 'targetShape'] = null;
		        }
		        else if (eventsEnabled) {
		            this._fire(events.pointerleave, {
		                evt: evt,
		                target: this,
		                currentTarget: this,
		            });
		            this._fire(events.pointerout, {
		                evt: evt,
		                target: this,
		                currentTarget: this,
		            });
		        }
		        this.pointerPos = null;
		        this._pointerPositions = [];
		    }
		    _pointerdown(evt) {
		        const events = getEventsMap(evt.type);
		        const eventType = getEventType(evt.type);
		        if (!events) {
		            return;
		        }
		        this.setPointersPositions(evt);
		        let triggeredOnShape = false;
		        this._changedPointerPositions.forEach((pos) => {
		            const shape = this.getIntersection(pos);
		            DragAndDrop_1.DD.justDragged = false;
		            Global_1.Konva['_' + eventType + 'ListenClick'] = true;
		            if (!shape || !shape.isListening()) {
		                this[eventType + 'ClickStartShape'] = undefined;
		                return;
		            }
		            if (Global_1.Konva.capturePointerEventsEnabled) {
		                shape.setPointerCapture(pos.id);
		            }
		            this[eventType + 'ClickStartShape'] = shape;
		            shape._fireAndBubble(events.pointerdown, {
		                evt: evt,
		                pointerId: pos.id,
		            });
		            triggeredOnShape = true;
		            const isTouch = evt.type.indexOf('touch') >= 0;
		            if (shape.preventDefault() && evt.cancelable && isTouch) {
		                evt.preventDefault();
		            }
		        });
		        if (!triggeredOnShape) {
		            this._fire(events.pointerdown, {
		                evt: evt,
		                target: this,
		                currentTarget: this,
		                pointerId: this._pointerPositions[0].id,
		            });
		        }
		    }
		    _pointermove(evt) {
		        const events = getEventsMap(evt.type);
		        const eventType = getEventType(evt.type);
		        if (!events) {
		            return;
		        }
		        if (Global_1.Konva.isDragging() && DragAndDrop_1.DD.node.preventDefault() && evt.cancelable) {
		            evt.preventDefault();
		        }
		        this.setPointersPositions(evt);
		        const eventsEnabled = !(Global_1.Konva.isDragging() || Global_1.Konva.isTransforming()) || Global_1.Konva.hitOnDragEnabled;
		        if (!eventsEnabled) {
		            return;
		        }
		        const processedShapesIds = {};
		        let triggeredOnShape = false;
		        const targetShape = this._getTargetShape(eventType);
		        this._changedPointerPositions.forEach((pos) => {
		            const shape = (PointerEvents.getCapturedShape(pos.id) ||
		                this.getIntersection(pos));
		            const pointerId = pos.id;
		            const event = { evt: evt, pointerId };
		            const differentTarget = targetShape !== shape;
		            if (differentTarget && targetShape) {
		                targetShape._fireAndBubble(events.pointerout, { ...event }, shape);
		                targetShape._fireAndBubble(events.pointerleave, { ...event }, shape);
		            }
		            if (shape) {
		                if (processedShapesIds[shape._id]) {
		                    return;
		                }
		                processedShapesIds[shape._id] = true;
		            }
		            if (shape && shape.isListening()) {
		                triggeredOnShape = true;
		                if (differentTarget) {
		                    shape._fireAndBubble(events.pointerover, { ...event }, targetShape);
		                    shape._fireAndBubble(events.pointerenter, { ...event }, targetShape);
		                    this[eventType + 'targetShape'] = shape;
		                }
		                shape._fireAndBubble(events.pointermove, { ...event });
		            }
		            else {
		                if (targetShape) {
		                    this._fire(events.pointerover, {
		                        evt: evt,
		                        target: this,
		                        currentTarget: this,
		                        pointerId,
		                    });
		                    this[eventType + 'targetShape'] = null;
		                }
		            }
		        });
		        if (!triggeredOnShape) {
		            this._fire(events.pointermove, {
		                evt: evt,
		                target: this,
		                currentTarget: this,
		                pointerId: this._changedPointerPositions[0].id,
		            });
		        }
		    }
		    _pointerup(evt) {
		        const events = getEventsMap(evt.type);
		        const eventType = getEventType(evt.type);
		        if (!events) {
		            return;
		        }
		        this.setPointersPositions(evt);
		        const clickStartShape = this[eventType + 'ClickStartShape'];
		        const clickEndShape = this[eventType + 'ClickEndShape'];
		        const processedShapesIds = {};
		        let triggeredOnShape = false;
		        this._changedPointerPositions.forEach((pos) => {
		            const shape = (PointerEvents.getCapturedShape(pos.id) ||
		                this.getIntersection(pos));
		            if (shape) {
		                shape.releaseCapture(pos.id);
		                if (processedShapesIds[shape._id]) {
		                    return;
		                }
		                processedShapesIds[shape._id] = true;
		            }
		            const pointerId = pos.id;
		            const event = { evt: evt, pointerId };
		            let fireDblClick = false;
		            if (Global_1.Konva['_' + eventType + 'InDblClickWindow']) {
		                fireDblClick = true;
		                clearTimeout(this[eventType + 'DblTimeout']);
		            }
		            else if (!DragAndDrop_1.DD.justDragged) {
		                Global_1.Konva['_' + eventType + 'InDblClickWindow'] = true;
		                clearTimeout(this[eventType + 'DblTimeout']);
		            }
		            this[eventType + 'DblTimeout'] = setTimeout(function () {
		                Global_1.Konva['_' + eventType + 'InDblClickWindow'] = false;
		            }, Global_1.Konva.dblClickWindow);
		            if (shape && shape.isListening()) {
		                triggeredOnShape = true;
		                this[eventType + 'ClickEndShape'] = shape;
		                shape._fireAndBubble(events.pointerup, { ...event });
		                if (Global_1.Konva['_' + eventType + 'ListenClick'] &&
		                    clickStartShape &&
		                    clickStartShape === shape) {
		                    shape._fireAndBubble(events.pointerclick, { ...event });
		                    if (fireDblClick && clickEndShape && clickEndShape === shape) {
		                        shape._fireAndBubble(events.pointerdblclick, { ...event });
		                    }
		                }
		            }
		            else {
		                this[eventType + 'ClickEndShape'] = null;
		                if (Global_1.Konva['_' + eventType + 'ListenClick']) {
		                    this._fire(events.pointerclick, {
		                        evt: evt,
		                        target: this,
		                        currentTarget: this,
		                        pointerId,
		                    });
		                }
		                if (fireDblClick) {
		                    this._fire(events.pointerdblclick, {
		                        evt: evt,
		                        target: this,
		                        currentTarget: this,
		                        pointerId,
		                    });
		                }
		            }
		        });
		        if (!triggeredOnShape) {
		            this._fire(events.pointerup, {
		                evt: evt,
		                target: this,
		                currentTarget: this,
		                pointerId: this._changedPointerPositions[0].id,
		            });
		        }
		        Global_1.Konva['_' + eventType + 'ListenClick'] = false;
		        if (evt.cancelable && eventType !== 'touch' && eventType !== 'pointer') {
		            evt.preventDefault();
		        }
		    }
		    _contextmenu(evt) {
		        this.setPointersPositions(evt);
		        const shape = this.getIntersection(this.getPointerPosition());
		        if (shape && shape.isListening()) {
		            shape._fireAndBubble(CONTEXTMENU, { evt: evt });
		        }
		        else {
		            this._fire(CONTEXTMENU, {
		                evt: evt,
		                target: this,
		                currentTarget: this,
		            });
		        }
		    }
		    _wheel(evt) {
		        this.setPointersPositions(evt);
		        const shape = this.getIntersection(this.getPointerPosition());
		        if (shape && shape.isListening()) {
		            shape._fireAndBubble(WHEEL, { evt: evt });
		        }
		        else {
		            this._fire(WHEEL, {
		                evt: evt,
		                target: this,
		                currentTarget: this,
		            });
		        }
		    }
		    _pointercancel(evt) {
		        this.setPointersPositions(evt);
		        const shape = PointerEvents.getCapturedShape(evt.pointerId) ||
		            this.getIntersection(this.getPointerPosition());
		        if (shape) {
		            shape._fireAndBubble(POINTERUP, PointerEvents.createEvent(evt));
		        }
		        PointerEvents.releaseCapture(evt.pointerId);
		    }
		    _lostpointercapture(evt) {
		        PointerEvents.releaseCapture(evt.pointerId);
		    }
		    setPointersPositions(evt) {
		        const contentPosition = this._getContentPosition();
		        let x = null, y = null;
		        evt = evt ? evt : window.event;
		        if (evt.touches !== undefined) {
		            this._pointerPositions = [];
		            this._changedPointerPositions = [];
		            Array.prototype.forEach.call(evt.touches, (touch) => {
		                this._pointerPositions.push({
		                    id: touch.identifier,
		                    x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,
		                    y: (touch.clientY - contentPosition.top) / contentPosition.scaleY,
		                });
		            });
		            Array.prototype.forEach.call(evt.changedTouches || evt.touches, (touch) => {
		                this._changedPointerPositions.push({
		                    id: touch.identifier,
		                    x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,
		                    y: (touch.clientY - contentPosition.top) / contentPosition.scaleY,
		                });
		            });
		        }
		        else {
		            x = (evt.clientX - contentPosition.left) / contentPosition.scaleX;
		            y = (evt.clientY - contentPosition.top) / contentPosition.scaleY;
		            this.pointerPos = {
		                x: x,
		                y: y,
		            };
		            this._pointerPositions = [{ x, y, id: Util_1.Util._getFirstPointerId(evt) }];
		            this._changedPointerPositions = [
		                { x, y, id: Util_1.Util._getFirstPointerId(evt) },
		            ];
		        }
		    }
		    _setPointerPosition(evt) {
		        Util_1.Util.warn('Method _setPointerPosition is deprecated. Use "stage.setPointersPositions(event)" instead.');
		        this.setPointersPositions(evt);
		    }
		    _getContentPosition() {
		        if (!this.content || !this.content.getBoundingClientRect) {
		            return {
		                top: 0,
		                left: 0,
		                scaleX: 1,
		                scaleY: 1,
		            };
		        }
		        const rect = this.content.getBoundingClientRect();
		        return {
		            top: rect.top,
		            left: rect.left,
		            scaleX: rect.width / this.content.clientWidth || 1,
		            scaleY: rect.height / this.content.clientHeight || 1,
		        };
		    }
		    _buildDOM() {
		        this.bufferCanvas = new Canvas_1.SceneCanvas({
		            width: this.width(),
		            height: this.height(),
		        });
		        this.bufferHitCanvas = new Canvas_1.HitCanvas({
		            pixelRatio: 1,
		            width: this.width(),
		            height: this.height(),
		        });
		        if (!Global_1.Konva.isBrowser) {
		            return;
		        }
		        const container = this.container();
		        if (!container) {
		            throw 'Stage has no container. A container is required.';
		        }
		        container.innerHTML = '';
		        this.content = document.createElement('div');
		        this.content.style.position = 'relative';
		        this.content.style.userSelect = 'none';
		        this.content.className = 'konvajs-content';
		        this.content.setAttribute('role', 'presentation');
		        container.appendChild(this.content);
		        this._resizeDOM();
		    }
		    cache() {
		        Util_1.Util.warn('Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.');
		        return this;
		    }
		    clearCache() {
		        return this;
		    }
		    batchDraw() {
		        this.getChildren().forEach(function (layer) {
		            layer.batchDraw();
		        });
		        return this;
		    }
		}
		exports.Stage = Stage;
		Stage.prototype.nodeType = STAGE;
		(0, Global_2._registerNode)(Stage);
		Factory_1.Factory.addGetterSetter(Stage, 'container');
		if (Global_1.Konva.isBrowser) {
		    document.addEventListener('visibilitychange', () => {
		        exports.stages.forEach((stage) => {
		            stage.batchDraw();
		        });
		    });
		} 
	} (Stage$1));
	return Stage$1;
}

var Layer$1 = {};

var Shape = {};

var hasRequiredShape;

function requireShape () {
	if (hasRequiredShape) return Shape;
	hasRequiredShape = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Shape = exports.shapes = void 0;
		const Global_1 = requireGlobal();
		const Util_1 = requireUtil();
		const Factory_1 = requireFactory();
		const Node_1 = requireNode();
		const Validators_1 = requireValidators();
		const Global_2 = requireGlobal();
		const PointerEvents = requirePointerEvents();
		const HAS_SHADOW = 'hasShadow';
		const SHADOW_RGBA = 'shadowRGBA';
		const patternImage = 'patternImage';
		const linearGradient = 'linearGradient';
		const radialGradient = 'radialGradient';
		let dummyContext;
		function getDummyContext() {
		    if (dummyContext) {
		        return dummyContext;
		    }
		    dummyContext = Util_1.Util.createCanvasElement().getContext('2d');
		    return dummyContext;
		}
		exports.shapes = {};
		function _fillFunc(context) {
		    const fillRule = this.attrs.fillRule;
		    if (fillRule) {
		        context.fill(fillRule);
		    }
		    else {
		        context.fill();
		    }
		}
		function _strokeFunc(context) {
		    context.stroke();
		}
		function _fillFuncHit(context) {
		    const fillRule = this.attrs.fillRule;
		    if (fillRule) {
		        context.fill(fillRule);
		    }
		    else {
		        context.fill();
		    }
		}
		function _strokeFuncHit(context) {
		    context.stroke();
		}
		function _clearHasShadowCache() {
		    this._clearCache(HAS_SHADOW);
		}
		function _clearGetShadowRGBACache() {
		    this._clearCache(SHADOW_RGBA);
		}
		function _clearFillPatternCache() {
		    this._clearCache(patternImage);
		}
		function _clearLinearGradientCache() {
		    this._clearCache(linearGradient);
		}
		function _clearRadialGradientCache() {
		    this._clearCache(radialGradient);
		}
		class Shape extends Node_1.Node {
		    constructor(config) {
		        super(config);
		        let key;
		        while (true) {
		            key = Util_1.Util.getRandomColor();
		            if (key && !(key in exports.shapes)) {
		                break;
		            }
		        }
		        this.colorKey = key;
		        exports.shapes[key] = this;
		    }
		    getContext() {
		        Util_1.Util.warn('shape.getContext() method is deprecated. Please do not use it.');
		        return this.getLayer().getContext();
		    }
		    getCanvas() {
		        Util_1.Util.warn('shape.getCanvas() method is deprecated. Please do not use it.');
		        return this.getLayer().getCanvas();
		    }
		    getSceneFunc() {
		        return this.attrs.sceneFunc || this['_sceneFunc'];
		    }
		    getHitFunc() {
		        return this.attrs.hitFunc || this['_hitFunc'];
		    }
		    hasShadow() {
		        return this._getCache(HAS_SHADOW, this._hasShadow);
		    }
		    _hasShadow() {
		        return (this.shadowEnabled() &&
		            this.shadowOpacity() !== 0 &&
		            !!(this.shadowColor() ||
		                this.shadowBlur() ||
		                this.shadowOffsetX() ||
		                this.shadowOffsetY()));
		    }
		    _getFillPattern() {
		        return this._getCache(patternImage, this.__getFillPattern);
		    }
		    __getFillPattern() {
		        if (this.fillPatternImage()) {
		            const ctx = getDummyContext();
		            const pattern = ctx.createPattern(this.fillPatternImage(), this.fillPatternRepeat() || 'repeat');
		            if (pattern && pattern.setTransform) {
		                const tr = new Util_1.Transform();
		                tr.translate(this.fillPatternX(), this.fillPatternY());
		                tr.rotate(Global_1.Konva.getAngle(this.fillPatternRotation()));
		                tr.scale(this.fillPatternScaleX(), this.fillPatternScaleY());
		                tr.translate(-1 * this.fillPatternOffsetX(), -1 * this.fillPatternOffsetY());
		                const m = tr.getMatrix();
		                const matrix = typeof DOMMatrix === 'undefined'
		                    ? {
		                        a: m[0],
		                        b: m[1],
		                        c: m[2],
		                        d: m[3],
		                        e: m[4],
		                        f: m[5],
		                    }
		                    : new DOMMatrix(m);
		                pattern.setTransform(matrix);
		            }
		            return pattern;
		        }
		    }
		    _getLinearGradient() {
		        return this._getCache(linearGradient, this.__getLinearGradient);
		    }
		    __getLinearGradient() {
		        const colorStops = this.fillLinearGradientColorStops();
		        if (colorStops) {
		            const ctx = getDummyContext();
		            const start = this.fillLinearGradientStartPoint();
		            const end = this.fillLinearGradientEndPoint();
		            const grd = ctx.createLinearGradient(start.x, start.y, end.x, end.y);
		            for (let n = 0; n < colorStops.length; n += 2) {
		                grd.addColorStop(colorStops[n], colorStops[n + 1]);
		            }
		            return grd;
		        }
		    }
		    _getRadialGradient() {
		        return this._getCache(radialGradient, this.__getRadialGradient);
		    }
		    __getRadialGradient() {
		        const colorStops = this.fillRadialGradientColorStops();
		        if (colorStops) {
		            const ctx = getDummyContext();
		            const start = this.fillRadialGradientStartPoint();
		            const end = this.fillRadialGradientEndPoint();
		            const grd = ctx.createRadialGradient(start.x, start.y, this.fillRadialGradientStartRadius(), end.x, end.y, this.fillRadialGradientEndRadius());
		            for (let n = 0; n < colorStops.length; n += 2) {
		                grd.addColorStop(colorStops[n], colorStops[n + 1]);
		            }
		            return grd;
		        }
		    }
		    getShadowRGBA() {
		        return this._getCache(SHADOW_RGBA, this._getShadowRGBA);
		    }
		    _getShadowRGBA() {
		        if (!this.hasShadow()) {
		            return;
		        }
		        const rgba = Util_1.Util.colorToRGBA(this.shadowColor());
		        if (rgba) {
		            return ('rgba(' +
		                rgba.r +
		                ',' +
		                rgba.g +
		                ',' +
		                rgba.b +
		                ',' +
		                rgba.a * (this.shadowOpacity() || 1) +
		                ')');
		        }
		    }
		    hasFill() {
		        return this._calculate('hasFill', [
		            'fillEnabled',
		            'fill',
		            'fillPatternImage',
		            'fillLinearGradientColorStops',
		            'fillRadialGradientColorStops',
		        ], () => {
		            return (this.fillEnabled() &&
		                !!(this.fill() ||
		                    this.fillPatternImage() ||
		                    this.fillLinearGradientColorStops() ||
		                    this.fillRadialGradientColorStops()));
		        });
		    }
		    hasStroke() {
		        return this._calculate('hasStroke', [
		            'strokeEnabled',
		            'strokeWidth',
		            'stroke',
		            'strokeLinearGradientColorStops',
		        ], () => {
		            return (this.strokeEnabled() &&
		                this.strokeWidth() &&
		                !!(this.stroke() || this.strokeLinearGradientColorStops()));
		        });
		    }
		    hasHitStroke() {
		        const width = this.hitStrokeWidth();
		        if (width === 'auto') {
		            return this.hasStroke();
		        }
		        return this.strokeEnabled() && !!width;
		    }
		    intersects(point) {
		        const stage = this.getStage();
		        if (!stage) {
		            return false;
		        }
		        const bufferHitCanvas = stage.bufferHitCanvas;
		        bufferHitCanvas.getContext().clear();
		        this.drawHit(bufferHitCanvas, undefined, true);
		        const p = bufferHitCanvas.context.getImageData(Math.round(point.x), Math.round(point.y), 1, 1).data;
		        return p[3] > 0;
		    }
		    destroy() {
		        Node_1.Node.prototype.destroy.call(this);
		        delete exports.shapes[this.colorKey];
		        delete this.colorKey;
		        return this;
		    }
		    _useBufferCanvas(forceFill) {
		        var _a;
		        const perfectDrawEnabled = (_a = this.attrs.perfectDrawEnabled) !== null && _a !== void 0 ? _a : true;
		        if (!perfectDrawEnabled) {
		            return false;
		        }
		        const hasFill = forceFill || this.hasFill();
		        const hasStroke = this.hasStroke();
		        const isTransparent = this.getAbsoluteOpacity() !== 1;
		        if (hasFill && hasStroke && isTransparent) {
		            return true;
		        }
		        const hasShadow = this.hasShadow();
		        const strokeForShadow = this.shadowForStrokeEnabled();
		        if (hasFill && hasStroke && hasShadow && strokeForShadow) {
		            return true;
		        }
		        return false;
		    }
		    setStrokeHitEnabled(val) {
		        Util_1.Util.warn('strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead.');
		        if (val) {
		            this.hitStrokeWidth('auto');
		        }
		        else {
		            this.hitStrokeWidth(0);
		        }
		    }
		    getStrokeHitEnabled() {
		        if (this.hitStrokeWidth() === 0) {
		            return false;
		        }
		        else {
		            return true;
		        }
		    }
		    getSelfRect() {
		        const size = this.size();
		        return {
		            x: this._centroid ? -size.width / 2 : 0,
		            y: this._centroid ? -size.height / 2 : 0,
		            width: size.width,
		            height: size.height,
		        };
		    }
		    getClientRect(config = {}) {
		        let hasCachedParent = false;
		        let parent = this.getParent();
		        while (parent) {
		            if (parent.isCached()) {
		                hasCachedParent = true;
		                break;
		            }
		            parent = parent.getParent();
		        }
		        const skipTransform = config.skipTransform;
		        const relativeTo = config.relativeTo || (hasCachedParent && this.getStage()) || undefined;
		        const fillRect = this.getSelfRect();
		        const applyStroke = !config.skipStroke && this.hasStroke();
		        const strokeWidth = (applyStroke && this.strokeWidth()) || 0;
		        const fillAndStrokeWidth = fillRect.width + strokeWidth;
		        const fillAndStrokeHeight = fillRect.height + strokeWidth;
		        const applyShadow = !config.skipShadow && this.hasShadow();
		        const shadowOffsetX = applyShadow ? this.shadowOffsetX() : 0;
		        const shadowOffsetY = applyShadow ? this.shadowOffsetY() : 0;
		        const preWidth = fillAndStrokeWidth + Math.abs(shadowOffsetX);
		        const preHeight = fillAndStrokeHeight + Math.abs(shadowOffsetY);
		        const blurRadius = (applyShadow && this.shadowBlur()) || 0;
		        const width = preWidth + blurRadius * 2;
		        const height = preHeight + blurRadius * 2;
		        const rect = {
		            width: width,
		            height: height,
		            x: -(strokeWidth / 2 + blurRadius) +
		                Math.min(shadowOffsetX, 0) +
		                fillRect.x,
		            y: -(strokeWidth / 2 + blurRadius) +
		                Math.min(shadowOffsetY, 0) +
		                fillRect.y,
		        };
		        if (!skipTransform) {
		            return this._transformedRect(rect, relativeTo);
		        }
		        return rect;
		    }
		    drawScene(can, top, bufferCanvas) {
		        const layer = this.getLayer();
		        let canvas = can || layer.getCanvas(), context = canvas.getContext(), cachedCanvas = this._getCanvasCache(), drawFunc = this.getSceneFunc(), hasShadow = this.hasShadow(), stage, bufferContext;
		        const skipBuffer = canvas.isCache;
		        const cachingSelf = top === this;
		        if (!this.isVisible() && !cachingSelf) {
		            return this;
		        }
		        if (cachedCanvas) {
		            context.save();
		            const m = this.getAbsoluteTransform(top).getMatrix();
		            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
		            this._drawCachedSceneCanvas(context);
		            context.restore();
		            return this;
		        }
		        if (!drawFunc) {
		            return this;
		        }
		        context.save();
		        if (this._useBufferCanvas() && !skipBuffer) {
		            stage = this.getStage();
		            const bc = bufferCanvas || stage.bufferCanvas;
		            bufferContext = bc.getContext();
		            bufferContext.clear();
		            bufferContext.save();
		            bufferContext._applyLineJoin(this);
		            var o = this.getAbsoluteTransform(top).getMatrix();
		            bufferContext.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
		            drawFunc.call(this, bufferContext, this);
		            bufferContext.restore();
		            const ratio = bc.pixelRatio;
		            if (hasShadow) {
		                context._applyShadow(this);
		            }
		            context._applyOpacity(this);
		            context._applyGlobalCompositeOperation(this);
		            context.drawImage(bc._canvas, 0, 0, bc.width / ratio, bc.height / ratio);
		        }
		        else {
		            context._applyLineJoin(this);
		            if (!cachingSelf) {
		                var o = this.getAbsoluteTransform(top).getMatrix();
		                context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
		                context._applyOpacity(this);
		                context._applyGlobalCompositeOperation(this);
		            }
		            if (hasShadow) {
		                context._applyShadow(this);
		            }
		            drawFunc.call(this, context, this);
		        }
		        context.restore();
		        return this;
		    }
		    drawHit(can, top, skipDragCheck = false) {
		        if (!this.shouldDrawHit(top, skipDragCheck)) {
		            return this;
		        }
		        const layer = this.getLayer(), canvas = can || layer.hitCanvas, context = canvas && canvas.getContext(), drawFunc = this.hitFunc() || this.sceneFunc(), cachedCanvas = this._getCanvasCache(), cachedHitCanvas = cachedCanvas && cachedCanvas.hit;
		        if (!this.colorKey) {
		            Util_1.Util.warn('Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()');
		        }
		        if (cachedHitCanvas) {
		            context.save();
		            const m = this.getAbsoluteTransform(top).getMatrix();
		            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
		            this._drawCachedHitCanvas(context);
		            context.restore();
		            return this;
		        }
		        if (!drawFunc) {
		            return this;
		        }
		        context.save();
		        context._applyLineJoin(this);
		        const selfCache = this === top;
		        if (!selfCache) {
		            const o = this.getAbsoluteTransform(top).getMatrix();
		            context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
		        }
		        drawFunc.call(this, context, this);
		        context.restore();
		        return this;
		    }
		    drawHitFromCache(alphaThreshold = 0) {
		        const cachedCanvas = this._getCanvasCache(), sceneCanvas = this._getCachedSceneCanvas(), hitCanvas = cachedCanvas.hit, hitContext = hitCanvas.getContext(), hitWidth = hitCanvas.getWidth(), hitHeight = hitCanvas.getHeight();
		        hitContext.clear();
		        hitContext.drawImage(sceneCanvas._canvas, 0, 0, hitWidth, hitHeight);
		        try {
		            const hitImageData = hitContext.getImageData(0, 0, hitWidth, hitHeight);
		            const hitData = hitImageData.data;
		            const len = hitData.length;
		            const rgbColorKey = Util_1.Util._hexToRgb(this.colorKey);
		            for (let i = 0; i < len; i += 4) {
		                const alpha = hitData[i + 3];
		                if (alpha > alphaThreshold) {
		                    hitData[i] = rgbColorKey.r;
		                    hitData[i + 1] = rgbColorKey.g;
		                    hitData[i + 2] = rgbColorKey.b;
		                    hitData[i + 3] = 255;
		                }
		                else {
		                    hitData[i + 3] = 0;
		                }
		            }
		            hitContext.putImageData(hitImageData, 0, 0);
		        }
		        catch (e) {
		            Util_1.Util.error('Unable to draw hit graph from cached scene canvas. ' + e.message);
		        }
		        return this;
		    }
		    hasPointerCapture(pointerId) {
		        return PointerEvents.hasPointerCapture(pointerId, this);
		    }
		    setPointerCapture(pointerId) {
		        PointerEvents.setPointerCapture(pointerId, this);
		    }
		    releaseCapture(pointerId) {
		        PointerEvents.releaseCapture(pointerId, this);
		    }
		}
		exports.Shape = Shape;
		Shape.prototype._fillFunc = _fillFunc;
		Shape.prototype._strokeFunc = _strokeFunc;
		Shape.prototype._fillFuncHit = _fillFuncHit;
		Shape.prototype._strokeFuncHit = _strokeFuncHit;
		Shape.prototype._centroid = false;
		Shape.prototype.nodeType = 'Shape';
		(0, Global_2._registerNode)(Shape);
		Shape.prototype.eventListeners = {};
		Shape.prototype.on.call(Shape.prototype, 'shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearHasShadowCache);
		Shape.prototype.on.call(Shape.prototype, 'shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearGetShadowRGBACache);
		Shape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva', _clearFillPatternCache);
		Shape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva', _clearLinearGradientCache);
		Shape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva', _clearRadialGradientCache);
		Factory_1.Factory.addGetterSetter(Shape, 'stroke', undefined, (0, Validators_1.getStringOrGradientValidator)());
		Factory_1.Factory.addGetterSetter(Shape, 'strokeWidth', 2, (0, Validators_1.getNumberValidator)());
		Factory_1.Factory.addGetterSetter(Shape, 'fillAfterStrokeEnabled', false);
		Factory_1.Factory.addGetterSetter(Shape, 'hitStrokeWidth', 'auto', (0, Validators_1.getNumberOrAutoValidator)());
		Factory_1.Factory.addGetterSetter(Shape, 'strokeHitEnabled', true, (0, Validators_1.getBooleanValidator)());
		Factory_1.Factory.addGetterSetter(Shape, 'perfectDrawEnabled', true, (0, Validators_1.getBooleanValidator)());
		Factory_1.Factory.addGetterSetter(Shape, 'shadowForStrokeEnabled', true, (0, Validators_1.getBooleanValidator)());
		Factory_1.Factory.addGetterSetter(Shape, 'lineJoin');
		Factory_1.Factory.addGetterSetter(Shape, 'lineCap');
		Factory_1.Factory.addGetterSetter(Shape, 'sceneFunc');
		Factory_1.Factory.addGetterSetter(Shape, 'hitFunc');
		Factory_1.Factory.addGetterSetter(Shape, 'dash');
		Factory_1.Factory.addGetterSetter(Shape, 'dashOffset', 0, (0, Validators_1.getNumberValidator)());
		Factory_1.Factory.addGetterSetter(Shape, 'shadowColor', undefined, (0, Validators_1.getStringValidator)());
		Factory_1.Factory.addGetterSetter(Shape, 'shadowBlur', 0, (0, Validators_1.getNumberValidator)());
		Factory_1.Factory.addGetterSetter(Shape, 'shadowOpacity', 1, (0, Validators_1.getNumberValidator)());
		Factory_1.Factory.addComponentsGetterSetter(Shape, 'shadowOffset', ['x', 'y']);
		Factory_1.Factory.addGetterSetter(Shape, 'shadowOffsetX', 0, (0, Validators_1.getNumberValidator)());
		Factory_1.Factory.addGetterSetter(Shape, 'shadowOffsetY', 0, (0, Validators_1.getNumberValidator)());
		Factory_1.Factory.addGetterSetter(Shape, 'fillPatternImage');
		Factory_1.Factory.addGetterSetter(Shape, 'fill', undefined, (0, Validators_1.getStringOrGradientValidator)());
		Factory_1.Factory.addGetterSetter(Shape, 'fillPatternX', 0, (0, Validators_1.getNumberValidator)());
		Factory_1.Factory.addGetterSetter(Shape, 'fillPatternY', 0, (0, Validators_1.getNumberValidator)());
		Factory_1.Factory.addGetterSetter(Shape, 'fillLinearGradientColorStops');
		Factory_1.Factory.addGetterSetter(Shape, 'strokeLinearGradientColorStops');
		Factory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientStartRadius', 0);
		Factory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientEndRadius', 0);
		Factory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientColorStops');
		Factory_1.Factory.addGetterSetter(Shape, 'fillPatternRepeat', 'repeat');
		Factory_1.Factory.addGetterSetter(Shape, 'fillEnabled', true);
		Factory_1.Factory.addGetterSetter(Shape, 'strokeEnabled', true);
		Factory_1.Factory.addGetterSetter(Shape, 'shadowEnabled', true);
		Factory_1.Factory.addGetterSetter(Shape, 'dashEnabled', true);
		Factory_1.Factory.addGetterSetter(Shape, 'strokeScaleEnabled', true);
		Factory_1.Factory.addGetterSetter(Shape, 'fillPriority', 'color');
		Factory_1.Factory.addComponentsGetterSetter(Shape, 'fillPatternOffset', ['x', 'y']);
		Factory_1.Factory.addGetterSetter(Shape, 'fillPatternOffsetX', 0, (0, Validators_1.getNumberValidator)());
		Factory_1.Factory.addGetterSetter(Shape, 'fillPatternOffsetY', 0, (0, Validators_1.getNumberValidator)());
		Factory_1.Factory.addComponentsGetterSetter(Shape, 'fillPatternScale', ['x', 'y']);
		Factory_1.Factory.addGetterSetter(Shape, 'fillPatternScaleX', 1, (0, Validators_1.getNumberValidator)());
		Factory_1.Factory.addGetterSetter(Shape, 'fillPatternScaleY', 1, (0, Validators_1.getNumberValidator)());
		Factory_1.Factory.addComponentsGetterSetter(Shape, 'fillLinearGradientStartPoint', [
		    'x',
		    'y',
		]);
		Factory_1.Factory.addComponentsGetterSetter(Shape, 'strokeLinearGradientStartPoint', [
		    'x',
		    'y',
		]);
		Factory_1.Factory.addGetterSetter(Shape, 'fillLinearGradientStartPointX', 0);
		Factory_1.Factory.addGetterSetter(Shape, 'strokeLinearGradientStartPointX', 0);
		Factory_1.Factory.addGetterSetter(Shape, 'fillLinearGradientStartPointY', 0);
		Factory_1.Factory.addGetterSetter(Shape, 'strokeLinearGradientStartPointY', 0);
		Factory_1.Factory.addComponentsGetterSetter(Shape, 'fillLinearGradientEndPoint', [
		    'x',
		    'y',
		]);
		Factory_1.Factory.addComponentsGetterSetter(Shape, 'strokeLinearGradientEndPoint', [
		    'x',
		    'y',
		]);
		Factory_1.Factory.addGetterSetter(Shape, 'fillLinearGradientEndPointX', 0);
		Factory_1.Factory.addGetterSetter(Shape, 'strokeLinearGradientEndPointX', 0);
		Factory_1.Factory.addGetterSetter(Shape, 'fillLinearGradientEndPointY', 0);
		Factory_1.Factory.addGetterSetter(Shape, 'strokeLinearGradientEndPointY', 0);
		Factory_1.Factory.addComponentsGetterSetter(Shape, 'fillRadialGradientStartPoint', [
		    'x',
		    'y',
		]);
		Factory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientStartPointX', 0);
		Factory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientStartPointY', 0);
		Factory_1.Factory.addComponentsGetterSetter(Shape, 'fillRadialGradientEndPoint', [
		    'x',
		    'y',
		]);
		Factory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientEndPointX', 0);
		Factory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientEndPointY', 0);
		Factory_1.Factory.addGetterSetter(Shape, 'fillPatternRotation', 0);
		Factory_1.Factory.addGetterSetter(Shape, 'fillRule', undefined, (0, Validators_1.getStringValidator)());
		Factory_1.Factory.backCompat(Shape, {
		    dashArray: 'dash',
		    getDashArray: 'getDash',
		    setDashArray: 'getDash',
		    drawFunc: 'sceneFunc',
		    getDrawFunc: 'getSceneFunc',
		    setDrawFunc: 'setSceneFunc',
		    drawHitFunc: 'hitFunc',
		    getDrawHitFunc: 'getHitFunc',
		    setDrawHitFunc: 'setHitFunc',
		}); 
	} (Shape));
	return Shape;
}

var hasRequiredLayer;

function requireLayer () {
	if (hasRequiredLayer) return Layer$1;
	hasRequiredLayer = 1;
	Object.defineProperty(Layer$1, "__esModule", { value: true });
	Layer$1.Layer = void 0;
	const Util_1 = requireUtil();
	const Container_1 = requireContainer();
	const Node_1 = requireNode();
	const Factory_1 = requireFactory();
	const Canvas_1 = requireCanvas();
	const Validators_1 = requireValidators();
	const Shape_1 = requireShape();
	const Global_1 = requireGlobal();
	const HASH = '#', BEFORE_DRAW = 'beforeDraw', DRAW = 'draw', INTERSECTION_OFFSETS = [
	    { x: 0, y: 0 },
	    { x: -1, y: -1 },
	    { x: 1, y: -1 },
	    { x: 1, y: 1 },
	    { x: -1, y: 1 },
	], INTERSECTION_OFFSETS_LEN = INTERSECTION_OFFSETS.length;
	class Layer extends Container_1.Container {
	    constructor(config) {
	        super(config);
	        this.canvas = new Canvas_1.SceneCanvas();
	        this.hitCanvas = new Canvas_1.HitCanvas({
	            pixelRatio: 1,
	        });
	        this._waitingForDraw = false;
	        this.on('visibleChange.konva', this._checkVisibility);
	        this._checkVisibility();
	        this.on('imageSmoothingEnabledChange.konva', this._setSmoothEnabled);
	        this._setSmoothEnabled();
	    }
	    createPNGStream() {
	        const c = this.canvas._canvas;
	        return c.createPNGStream();
	    }
	    getCanvas() {
	        return this.canvas;
	    }
	    getNativeCanvasElement() {
	        return this.canvas._canvas;
	    }
	    getHitCanvas() {
	        return this.hitCanvas;
	    }
	    getContext() {
	        return this.getCanvas().getContext();
	    }
	    clear(bounds) {
	        this.getContext().clear(bounds);
	        this.getHitCanvas().getContext().clear(bounds);
	        return this;
	    }
	    setZIndex(index) {
	        super.setZIndex(index);
	        const stage = this.getStage();
	        if (stage && stage.content) {
	            stage.content.removeChild(this.getNativeCanvasElement());
	            if (index < stage.children.length - 1) {
	                stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[index + 1].getCanvas()._canvas);
	            }
	            else {
	                stage.content.appendChild(this.getNativeCanvasElement());
	            }
	        }
	        return this;
	    }
	    moveToTop() {
	        Node_1.Node.prototype.moveToTop.call(this);
	        const stage = this.getStage();
	        if (stage && stage.content) {
	            stage.content.removeChild(this.getNativeCanvasElement());
	            stage.content.appendChild(this.getNativeCanvasElement());
	        }
	        return true;
	    }
	    moveUp() {
	        const moved = Node_1.Node.prototype.moveUp.call(this);
	        if (!moved) {
	            return false;
	        }
	        const stage = this.getStage();
	        if (!stage || !stage.content) {
	            return false;
	        }
	        stage.content.removeChild(this.getNativeCanvasElement());
	        if (this.index < stage.children.length - 1) {
	            stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[this.index + 1].getCanvas()._canvas);
	        }
	        else {
	            stage.content.appendChild(this.getNativeCanvasElement());
	        }
	        return true;
	    }
	    moveDown() {
	        if (Node_1.Node.prototype.moveDown.call(this)) {
	            const stage = this.getStage();
	            if (stage) {
	                const children = stage.children;
	                if (stage.content) {
	                    stage.content.removeChild(this.getNativeCanvasElement());
	                    stage.content.insertBefore(this.getNativeCanvasElement(), children[this.index + 1].getCanvas()._canvas);
	                }
	            }
	            return true;
	        }
	        return false;
	    }
	    moveToBottom() {
	        if (Node_1.Node.prototype.moveToBottom.call(this)) {
	            const stage = this.getStage();
	            if (stage) {
	                const children = stage.children;
	                if (stage.content) {
	                    stage.content.removeChild(this.getNativeCanvasElement());
	                    stage.content.insertBefore(this.getNativeCanvasElement(), children[1].getCanvas()._canvas);
	                }
	            }
	            return true;
	        }
	        return false;
	    }
	    getLayer() {
	        return this;
	    }
	    remove() {
	        const _canvas = this.getNativeCanvasElement();
	        Node_1.Node.prototype.remove.call(this);
	        if (_canvas && _canvas.parentNode && Util_1.Util._isInDocument(_canvas)) {
	            _canvas.parentNode.removeChild(_canvas);
	        }
	        return this;
	    }
	    getStage() {
	        return this.parent;
	    }
	    setSize({ width, height }) {
	        this.canvas.setSize(width, height);
	        this.hitCanvas.setSize(width, height);
	        this._setSmoothEnabled();
	        return this;
	    }
	    _validateAdd(child) {
	        const type = child.getType();
	        if (type !== 'Group' && type !== 'Shape') {
	            Util_1.Util.throw('You may only add groups and shapes to a layer.');
	        }
	    }
	    _toKonvaCanvas(config) {
	        config = config || {};
	        config.width = config.width || this.getWidth();
	        config.height = config.height || this.getHeight();
	        config.x = config.x !== undefined ? config.x : this.x();
	        config.y = config.y !== undefined ? config.y : this.y();
	        return Node_1.Node.prototype._toKonvaCanvas.call(this, config);
	    }
	    _checkVisibility() {
	        const visible = this.visible();
	        if (visible) {
	            this.canvas._canvas.style.display = 'block';
	        }
	        else {
	            this.canvas._canvas.style.display = 'none';
	        }
	    }
	    _setSmoothEnabled() {
	        this.getContext()._context.imageSmoothingEnabled =
	            this.imageSmoothingEnabled();
	    }
	    getWidth() {
	        if (this.parent) {
	            return this.parent.width();
	        }
	    }
	    setWidth() {
	        Util_1.Util.warn('Can not change width of layer. Use "stage.width(value)" function instead.');
	    }
	    getHeight() {
	        if (this.parent) {
	            return this.parent.height();
	        }
	    }
	    setHeight() {
	        Util_1.Util.warn('Can not change height of layer. Use "stage.height(value)" function instead.');
	    }
	    batchDraw() {
	        if (!this._waitingForDraw) {
	            this._waitingForDraw = true;
	            Util_1.Util.requestAnimFrame(() => {
	                this.draw();
	                this._waitingForDraw = false;
	            });
	        }
	        return this;
	    }
	    getIntersection(pos) {
	        if (!this.isListening() || !this.isVisible()) {
	            return null;
	        }
	        let spiralSearchDistance = 1;
	        let continueSearch = false;
	        while (true) {
	            for (let i = 0; i < INTERSECTION_OFFSETS_LEN; i++) {
	                const intersectionOffset = INTERSECTION_OFFSETS[i];
	                const obj = this._getIntersection({
	                    x: pos.x + intersectionOffset.x * spiralSearchDistance,
	                    y: pos.y + intersectionOffset.y * spiralSearchDistance,
	                });
	                const shape = obj.shape;
	                if (shape) {
	                    return shape;
	                }
	                continueSearch = !!obj.antialiased;
	                if (!obj.antialiased) {
	                    break;
	                }
	            }
	            if (continueSearch) {
	                spiralSearchDistance += 1;
	            }
	            else {
	                return null;
	            }
	        }
	    }
	    _getIntersection(pos) {
	        const ratio = this.hitCanvas.pixelRatio;
	        const p = this.hitCanvas.context.getImageData(Math.round(pos.x * ratio), Math.round(pos.y * ratio), 1, 1).data;
	        const p3 = p[3];
	        if (p3 === 255) {
	            const colorKey = Util_1.Util._rgbToHex(p[0], p[1], p[2]);
	            const shape = Shape_1.shapes[HASH + colorKey];
	            if (shape) {
	                return {
	                    shape: shape,
	                };
	            }
	            return {
	                antialiased: true,
	            };
	        }
	        else if (p3 > 0) {
	            return {
	                antialiased: true,
	            };
	        }
	        return {};
	    }
	    drawScene(can, top) {
	        const layer = this.getLayer(), canvas = can || (layer && layer.getCanvas());
	        this._fire(BEFORE_DRAW, {
	            node: this,
	        });
	        if (this.clearBeforeDraw()) {
	            canvas.getContext().clear();
	        }
	        Container_1.Container.prototype.drawScene.call(this, canvas, top);
	        this._fire(DRAW, {
	            node: this,
	        });
	        return this;
	    }
	    drawHit(can, top) {
	        const layer = this.getLayer(), canvas = can || (layer && layer.hitCanvas);
	        if (layer && layer.clearBeforeDraw()) {
	            layer.getHitCanvas().getContext().clear();
	        }
	        Container_1.Container.prototype.drawHit.call(this, canvas, top);
	        return this;
	    }
	    enableHitGraph() {
	        this.hitGraphEnabled(true);
	        return this;
	    }
	    disableHitGraph() {
	        this.hitGraphEnabled(false);
	        return this;
	    }
	    setHitGraphEnabled(val) {
	        Util_1.Util.warn('hitGraphEnabled method is deprecated. Please use layer.listening() instead.');
	        this.listening(val);
	    }
	    getHitGraphEnabled(val) {
	        Util_1.Util.warn('hitGraphEnabled method is deprecated. Please use layer.listening() instead.');
	        return this.listening();
	    }
	    toggleHitCanvas() {
	        if (!this.parent || !this.parent['content']) {
	            return;
	        }
	        const parent = this.parent;
	        const added = !!this.hitCanvas._canvas.parentNode;
	        if (added) {
	            parent.content.removeChild(this.hitCanvas._canvas);
	        }
	        else {
	            parent.content.appendChild(this.hitCanvas._canvas);
	        }
	    }
	    destroy() {
	        Util_1.Util.releaseCanvas(this.getNativeCanvasElement(), this.getHitCanvas()._canvas);
	        return super.destroy();
	    }
	}
	Layer$1.Layer = Layer;
	Layer.prototype.nodeType = 'Layer';
	(0, Global_1._registerNode)(Layer);
	Factory_1.Factory.addGetterSetter(Layer, 'imageSmoothingEnabled', true);
	Factory_1.Factory.addGetterSetter(Layer, 'clearBeforeDraw', true);
	Factory_1.Factory.addGetterSetter(Layer, 'hitGraphEnabled', true, (0, Validators_1.getBooleanValidator)());
	return Layer$1;
}

var FastLayer = {};

var hasRequiredFastLayer;

function requireFastLayer () {
	if (hasRequiredFastLayer) return FastLayer;
	hasRequiredFastLayer = 1;
	Object.defineProperty(FastLayer, "__esModule", { value: true });
	FastLayer.FastLayer = void 0;
	const Util_1 = requireUtil();
	const Layer_1 = requireLayer();
	const Global_1 = requireGlobal();
	let FastLayer$1 = class FastLayer extends Layer_1.Layer {
	    constructor(attrs) {
	        super(attrs);
	        this.listening(false);
	        Util_1.Util.warn('Konva.Fast layer is deprecated. Please use "new Konva.Layer({ listening: false })" instead.');
	    }
	};
	FastLayer.FastLayer = FastLayer$1;
	FastLayer$1.prototype.nodeType = 'FastLayer';
	(0, Global_1._registerNode)(FastLayer$1);
	return FastLayer;
}

var Group$1 = {};

var hasRequiredGroup;

function requireGroup () {
	if (hasRequiredGroup) return Group$1;
	hasRequiredGroup = 1;
	Object.defineProperty(Group$1, "__esModule", { value: true });
	Group$1.Group = void 0;
	const Util_1 = requireUtil();
	const Container_1 = requireContainer();
	const Global_1 = requireGlobal();
	class Group extends Container_1.Container {
	    _validateAdd(child) {
	        const type = child.getType();
	        if (type !== 'Group' && type !== 'Shape') {
	            Util_1.Util.throw('You may only add groups and shapes to groups.');
	        }
	    }
	}
	Group$1.Group = Group;
	Group.prototype.nodeType = 'Group';
	(0, Global_1._registerNode)(Group);
	return Group$1;
}

var Animation = {};

var hasRequiredAnimation;

function requireAnimation () {
	if (hasRequiredAnimation) return Animation;
	hasRequiredAnimation = 1;
	Object.defineProperty(Animation, "__esModule", { value: true });
	Animation.Animation = void 0;
	const Global_1 = requireGlobal();
	const Util_1 = requireUtil();
	const now = (function () {
	    if (Global_1.glob.performance && Global_1.glob.performance.now) {
	        return function () {
	            return Global_1.glob.performance.now();
	        };
	    }
	    return function () {
	        return new Date().getTime();
	    };
	})();
	let Animation$1 = class Animation {
	    constructor(func, layers) {
	        this.id = Animation.animIdCounter++;
	        this.frame = {
	            time: 0,
	            timeDiff: 0,
	            lastTime: now(),
	            frameRate: 0,
	        };
	        this.func = func;
	        this.setLayers(layers);
	    }
	    setLayers(layers) {
	        let lays = [];
	        if (layers) {
	            lays = Array.isArray(layers) ? layers : [layers];
	        }
	        this.layers = lays;
	        return this;
	    }
	    getLayers() {
	        return this.layers;
	    }
	    addLayer(layer) {
	        const layers = this.layers;
	        const len = layers.length;
	        for (let n = 0; n < len; n++) {
	            if (layers[n]._id === layer._id) {
	                return false;
	            }
	        }
	        this.layers.push(layer);
	        return true;
	    }
	    isRunning() {
	        const a = Animation;
	        const animations = a.animations;
	        const len = animations.length;
	        for (let n = 0; n < len; n++) {
	            if (animations[n].id === this.id) {
	                return true;
	            }
	        }
	        return false;
	    }
	    start() {
	        this.stop();
	        this.frame.timeDiff = 0;
	        this.frame.lastTime = now();
	        Animation._addAnimation(this);
	        return this;
	    }
	    stop() {
	        Animation._removeAnimation(this);
	        return this;
	    }
	    _updateFrameObject(time) {
	        this.frame.timeDiff = time - this.frame.lastTime;
	        this.frame.lastTime = time;
	        this.frame.time += this.frame.timeDiff;
	        this.frame.frameRate = 1000 / this.frame.timeDiff;
	    }
	    static _addAnimation(anim) {
	        this.animations.push(anim);
	        this._handleAnimation();
	    }
	    static _removeAnimation(anim) {
	        const id = anim.id;
	        const animations = this.animations;
	        const len = animations.length;
	        for (let n = 0; n < len; n++) {
	            if (animations[n].id === id) {
	                this.animations.splice(n, 1);
	                break;
	            }
	        }
	    }
	    static _runFrames() {
	        const layerHash = {};
	        const animations = this.animations;
	        for (let n = 0; n < animations.length; n++) {
	            const anim = animations[n];
	            const layers = anim.layers;
	            const func = anim.func;
	            anim._updateFrameObject(now());
	            const layersLen = layers.length;
	            let needRedraw;
	            if (func) {
	                needRedraw = func.call(anim, anim.frame) !== false;
	            }
	            else {
	                needRedraw = true;
	            }
	            if (!needRedraw) {
	                continue;
	            }
	            for (let i = 0; i < layersLen; i++) {
	                const layer = layers[i];
	                if (layer._id !== undefined) {
	                    layerHash[layer._id] = layer;
	                }
	            }
	        }
	        for (const key in layerHash) {
	            if (!layerHash.hasOwnProperty(key)) {
	                continue;
	            }
	            layerHash[key].batchDraw();
	        }
	    }
	    static _animationLoop() {
	        const Anim = Animation;
	        if (Anim.animations.length) {
	            Anim._runFrames();
	            Util_1.Util.requestAnimFrame(Anim._animationLoop);
	        }
	        else {
	            Anim.animRunning = false;
	        }
	    }
	    static _handleAnimation() {
	        if (!this.animRunning) {
	            this.animRunning = true;
	            Util_1.Util.requestAnimFrame(this._animationLoop);
	        }
	    }
	};
	Animation.Animation = Animation$1;
	Animation$1.animations = [];
	Animation$1.animIdCounter = 0;
	Animation$1.animRunning = false;
	return Animation;
}

var Tween = {};

var hasRequiredTween;

function requireTween () {
	if (hasRequiredTween) return Tween;
	hasRequiredTween = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Easings = exports.Tween = void 0;
		const Util_1 = requireUtil();
		const Animation_1 = requireAnimation();
		const Node_1 = requireNode();
		const Global_1 = requireGlobal();
		const blacklist = {
		    node: 1,
		    duration: 1,
		    easing: 1,
		    onFinish: 1,
		    yoyo: 1,
		}, PAUSED = 1, PLAYING = 2, REVERSING = 3, colorAttrs = ['fill', 'stroke', 'shadowColor'];
		let idCounter = 0;
		class TweenEngine {
		    constructor(prop, propFunc, func, begin, finish, duration, yoyo) {
		        this.prop = prop;
		        this.propFunc = propFunc;
		        this.begin = begin;
		        this._pos = begin;
		        this.duration = duration;
		        this._change = 0;
		        this.prevPos = 0;
		        this.yoyo = yoyo;
		        this._time = 0;
		        this._position = 0;
		        this._startTime = 0;
		        this._finish = 0;
		        this.func = func;
		        this._change = finish - this.begin;
		        this.pause();
		    }
		    fire(str) {
		        const handler = this[str];
		        if (handler) {
		            handler();
		        }
		    }
		    setTime(t) {
		        if (t > this.duration) {
		            if (this.yoyo) {
		                this._time = this.duration;
		                this.reverse();
		            }
		            else {
		                this.finish();
		            }
		        }
		        else if (t < 0) {
		            if (this.yoyo) {
		                this._time = 0;
		                this.play();
		            }
		            else {
		                this.reset();
		            }
		        }
		        else {
		            this._time = t;
		            this.update();
		        }
		    }
		    getTime() {
		        return this._time;
		    }
		    setPosition(p) {
		        this.prevPos = this._pos;
		        this.propFunc(p);
		        this._pos = p;
		    }
		    getPosition(t) {
		        if (t === undefined) {
		            t = this._time;
		        }
		        return this.func(t, this.begin, this._change, this.duration);
		    }
		    play() {
		        this.state = PLAYING;
		        this._startTime = this.getTimer() - this._time;
		        this.onEnterFrame();
		        this.fire('onPlay');
		    }
		    reverse() {
		        this.state = REVERSING;
		        this._time = this.duration - this._time;
		        this._startTime = this.getTimer() - this._time;
		        this.onEnterFrame();
		        this.fire('onReverse');
		    }
		    seek(t) {
		        this.pause();
		        this._time = t;
		        this.update();
		        this.fire('onSeek');
		    }
		    reset() {
		        this.pause();
		        this._time = 0;
		        this.update();
		        this.fire('onReset');
		    }
		    finish() {
		        this.pause();
		        this._time = this.duration;
		        this.update();
		        this.fire('onFinish');
		    }
		    update() {
		        this.setPosition(this.getPosition(this._time));
		        this.fire('onUpdate');
		    }
		    onEnterFrame() {
		        const t = this.getTimer() - this._startTime;
		        if (this.state === PLAYING) {
		            this.setTime(t);
		        }
		        else if (this.state === REVERSING) {
		            this.setTime(this.duration - t);
		        }
		    }
		    pause() {
		        this.state = PAUSED;
		        this.fire('onPause');
		    }
		    getTimer() {
		        return new Date().getTime();
		    }
		}
		class Tween {
		    constructor(config) {
		        const that = this, node = config.node, nodeId = node._id, easing = config.easing || exports.Easings.Linear, yoyo = !!config.yoyo;
		        let duration, key;
		        if (typeof config.duration === 'undefined') {
		            duration = 0.3;
		        }
		        else if (config.duration === 0) {
		            duration = 0.001;
		        }
		        else {
		            duration = config.duration;
		        }
		        this.node = node;
		        this._id = idCounter++;
		        const layers = node.getLayer() ||
		            (node instanceof Global_1.Konva['Stage'] ? node.getLayers() : null);
		        if (!layers) {
		            Util_1.Util.error('Tween constructor have `node` that is not in a layer. Please add node into layer first.');
		        }
		        this.anim = new Animation_1.Animation(function () {
		            that.tween.onEnterFrame();
		        }, layers);
		        this.tween = new TweenEngine(key, function (i) {
		            that._tweenFunc(i);
		        }, easing, 0, 1, duration * 1000, yoyo);
		        this._addListeners();
		        if (!Tween.attrs[nodeId]) {
		            Tween.attrs[nodeId] = {};
		        }
		        if (!Tween.attrs[nodeId][this._id]) {
		            Tween.attrs[nodeId][this._id] = {};
		        }
		        if (!Tween.tweens[nodeId]) {
		            Tween.tweens[nodeId] = {};
		        }
		        for (key in config) {
		            if (blacklist[key] === undefined) {
		                this._addAttr(key, config[key]);
		            }
		        }
		        this.reset();
		        this.onFinish = config.onFinish;
		        this.onReset = config.onReset;
		        this.onUpdate = config.onUpdate;
		    }
		    _addAttr(key, end) {
		        const node = this.node, nodeId = node._id;
		        let diff, len, trueEnd, trueStart, endRGBA;
		        const tweenId = Tween.tweens[nodeId][key];
		        if (tweenId) {
		            delete Tween.attrs[nodeId][tweenId][key];
		        }
		        let start = node.getAttr(key);
		        if (Util_1.Util._isArray(end)) {
		            diff = [];
		            len = Math.max(end.length, start.length);
		            if (key === 'points' && end.length !== start.length) {
		                if (end.length > start.length) {
		                    trueStart = start;
		                    start = Util_1.Util._prepareArrayForTween(start, end, node.closed());
		                }
		                else {
		                    trueEnd = end;
		                    end = Util_1.Util._prepareArrayForTween(end, start, node.closed());
		                }
		            }
		            if (key.indexOf('fill') === 0) {
		                for (let n = 0; n < len; n++) {
		                    if (n % 2 === 0) {
		                        diff.push(end[n] - start[n]);
		                    }
		                    else {
		                        const startRGBA = Util_1.Util.colorToRGBA(start[n]);
		                        endRGBA = Util_1.Util.colorToRGBA(end[n]);
		                        start[n] = startRGBA;
		                        diff.push({
		                            r: endRGBA.r - startRGBA.r,
		                            g: endRGBA.g - startRGBA.g,
		                            b: endRGBA.b - startRGBA.b,
		                            a: endRGBA.a - startRGBA.a,
		                        });
		                    }
		                }
		            }
		            else {
		                for (let n = 0; n < len; n++) {
		                    diff.push(end[n] - start[n]);
		                }
		            }
		        }
		        else if (colorAttrs.indexOf(key) !== -1) {
		            start = Util_1.Util.colorToRGBA(start);
		            endRGBA = Util_1.Util.colorToRGBA(end);
		            diff = {
		                r: endRGBA.r - start.r,
		                g: endRGBA.g - start.g,
		                b: endRGBA.b - start.b,
		                a: endRGBA.a - start.a,
		            };
		        }
		        else {
		            diff = end - start;
		        }
		        Tween.attrs[nodeId][this._id][key] = {
		            start: start,
		            diff: diff,
		            end: end,
		            trueEnd: trueEnd,
		            trueStart: trueStart,
		        };
		        Tween.tweens[nodeId][key] = this._id;
		    }
		    _tweenFunc(i) {
		        const node = this.node, attrs = Tween.attrs[node._id][this._id];
		        let key, attr, start, diff, newVal, n, len, end;
		        for (key in attrs) {
		            attr = attrs[key];
		            start = attr.start;
		            diff = attr.diff;
		            end = attr.end;
		            if (Util_1.Util._isArray(start)) {
		                newVal = [];
		                len = Math.max(start.length, end.length);
		                if (key.indexOf('fill') === 0) {
		                    for (n = 0; n < len; n++) {
		                        if (n % 2 === 0) {
		                            newVal.push((start[n] || 0) + diff[n] * i);
		                        }
		                        else {
		                            newVal.push('rgba(' +
		                                Math.round(start[n].r + diff[n].r * i) +
		                                ',' +
		                                Math.round(start[n].g + diff[n].g * i) +
		                                ',' +
		                                Math.round(start[n].b + diff[n].b * i) +
		                                ',' +
		                                (start[n].a + diff[n].a * i) +
		                                ')');
		                        }
		                    }
		                }
		                else {
		                    for (n = 0; n < len; n++) {
		                        newVal.push((start[n] || 0) + diff[n] * i);
		                    }
		                }
		            }
		            else if (colorAttrs.indexOf(key) !== -1) {
		                newVal =
		                    'rgba(' +
		                        Math.round(start.r + diff.r * i) +
		                        ',' +
		                        Math.round(start.g + diff.g * i) +
		                        ',' +
		                        Math.round(start.b + diff.b * i) +
		                        ',' +
		                        (start.a + diff.a * i) +
		                        ')';
		            }
		            else {
		                newVal = start + diff * i;
		            }
		            node.setAttr(key, newVal);
		        }
		    }
		    _addListeners() {
		        this.tween.onPlay = () => {
		            this.anim.start();
		        };
		        this.tween.onReverse = () => {
		            this.anim.start();
		        };
		        this.tween.onPause = () => {
		            this.anim.stop();
		        };
		        this.tween.onFinish = () => {
		            const node = this.node;
		            const attrs = Tween.attrs[node._id][this._id];
		            if (attrs.points && attrs.points.trueEnd) {
		                node.setAttr('points', attrs.points.trueEnd);
		            }
		            if (this.onFinish) {
		                this.onFinish.call(this);
		            }
		        };
		        this.tween.onReset = () => {
		            const node = this.node;
		            const attrs = Tween.attrs[node._id][this._id];
		            if (attrs.points && attrs.points.trueStart) {
		                node.points(attrs.points.trueStart);
		            }
		            if (this.onReset) {
		                this.onReset();
		            }
		        };
		        this.tween.onUpdate = () => {
		            if (this.onUpdate) {
		                this.onUpdate.call(this);
		            }
		        };
		    }
		    play() {
		        this.tween.play();
		        return this;
		    }
		    reverse() {
		        this.tween.reverse();
		        return this;
		    }
		    reset() {
		        this.tween.reset();
		        return this;
		    }
		    seek(t) {
		        this.tween.seek(t * 1000);
		        return this;
		    }
		    pause() {
		        this.tween.pause();
		        return this;
		    }
		    finish() {
		        this.tween.finish();
		        return this;
		    }
		    destroy() {
		        const nodeId = this.node._id, thisId = this._id, attrs = Tween.tweens[nodeId];
		        this.pause();
		        for (const key in attrs) {
		            delete Tween.tweens[nodeId][key];
		        }
		        delete Tween.attrs[nodeId][thisId];
		    }
		}
		exports.Tween = Tween;
		Tween.attrs = {};
		Tween.tweens = {};
		Node_1.Node.prototype.to = function (params) {
		    const onFinish = params.onFinish;
		    params.node = this;
		    params.onFinish = function () {
		        this.destroy();
		        if (onFinish) {
		            onFinish();
		        }
		    };
		    const tween = new Tween(params);
		    tween.play();
		};
		exports.Easings = {
		    BackEaseIn(t, b, c, d) {
		        const s = 1.70158;
		        return c * (t /= d) * t * ((s + 1) * t - s) + b;
		    },
		    BackEaseOut(t, b, c, d) {
		        const s = 1.70158;
		        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
		    },
		    BackEaseInOut(t, b, c, d) {
		        let s = 1.70158;
		        if ((t /= d / 2) < 1) {
		            return (c / 2) * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
		        }
		        return (c / 2) * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
		    },
		    ElasticEaseIn(t, b, c, d, a, p) {
		        let s = 0;
		        if (t === 0) {
		            return b;
		        }
		        if ((t /= d) === 1) {
		            return b + c;
		        }
		        if (!p) {
		            p = d * 0.3;
		        }
		        if (!a || a < Math.abs(c)) {
		            a = c;
		            s = p / 4;
		        }
		        else {
		            s = (p / (2 * Math.PI)) * Math.asin(c / a);
		        }
		        return (-(a *
		            Math.pow(2, 10 * (t -= 1)) *
		            Math.sin(((t * d - s) * (2 * Math.PI)) / p)) + b);
		    },
		    ElasticEaseOut(t, b, c, d, a, p) {
		        let s = 0;
		        if (t === 0) {
		            return b;
		        }
		        if ((t /= d) === 1) {
		            return b + c;
		        }
		        if (!p) {
		            p = d * 0.3;
		        }
		        if (!a || a < Math.abs(c)) {
		            a = c;
		            s = p / 4;
		        }
		        else {
		            s = (p / (2 * Math.PI)) * Math.asin(c / a);
		        }
		        return (a * Math.pow(2, -10 * t) * Math.sin(((t * d - s) * (2 * Math.PI)) / p) +
		            c +
		            b);
		    },
		    ElasticEaseInOut(t, b, c, d, a, p) {
		        let s = 0;
		        if (t === 0) {
		            return b;
		        }
		        if ((t /= d / 2) === 2) {
		            return b + c;
		        }
		        if (!p) {
		            p = d * (0.3 * 1.5);
		        }
		        if (!a || a < Math.abs(c)) {
		            a = c;
		            s = p / 4;
		        }
		        else {
		            s = (p / (2 * Math.PI)) * Math.asin(c / a);
		        }
		        if (t < 1) {
		            return (-0.5 *
		                (a *
		                    Math.pow(2, 10 * (t -= 1)) *
		                    Math.sin(((t * d - s) * (2 * Math.PI)) / p)) +
		                b);
		        }
		        return (a *
		            Math.pow(2, -10 * (t -= 1)) *
		            Math.sin(((t * d - s) * (2 * Math.PI)) / p) *
		            0.5 +
		            c +
		            b);
		    },
		    BounceEaseOut(t, b, c, d) {
		        if ((t /= d) < 1 / 2.75) {
		            return c * (7.5625 * t * t) + b;
		        }
		        else if (t < 2 / 2.75) {
		            return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
		        }
		        else if (t < 2.5 / 2.75) {
		            return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
		        }
		        else {
		            return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
		        }
		    },
		    BounceEaseIn(t, b, c, d) {
		        return c - exports.Easings.BounceEaseOut(d - t, 0, c, d) + b;
		    },
		    BounceEaseInOut(t, b, c, d) {
		        if (t < d / 2) {
		            return exports.Easings.BounceEaseIn(t * 2, 0, c, d) * 0.5 + b;
		        }
		        else {
		            return exports.Easings.BounceEaseOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
		        }
		    },
		    EaseIn(t, b, c, d) {
		        return c * (t /= d) * t + b;
		    },
		    EaseOut(t, b, c, d) {
		        return -c * (t /= d) * (t - 2) + b;
		    },
		    EaseInOut(t, b, c, d) {
		        if ((t /= d / 2) < 1) {
		            return (c / 2) * t * t + b;
		        }
		        return (-c / 2) * (--t * (t - 2) - 1) + b;
		    },
		    StrongEaseIn(t, b, c, d) {
		        return c * (t /= d) * t * t * t * t + b;
		    },
		    StrongEaseOut(t, b, c, d) {
		        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
		    },
		    StrongEaseInOut(t, b, c, d) {
		        if ((t /= d / 2) < 1) {
		            return (c / 2) * t * t * t * t * t + b;
		        }
		        return (c / 2) * ((t -= 2) * t * t * t * t + 2) + b;
		    },
		    Linear(t, b, c, d) {
		        return (c * t) / d + b;
		    },
		}; 
	} (Tween));
	return Tween;
}

var hasRequired_CoreInternals;

function require_CoreInternals () {
	if (hasRequired_CoreInternals) return _CoreInternals;
	hasRequired_CoreInternals = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Konva = void 0;
		const Global_1 = requireGlobal();
		const Util_1 = requireUtil();
		const Node_1 = requireNode();
		const Container_1 = requireContainer();
		const Stage_1 = requireStage();
		const Layer_1 = requireLayer();
		const FastLayer_1 = requireFastLayer();
		const Group_1 = requireGroup();
		const DragAndDrop_1 = requireDragAndDrop();
		const Shape_1 = requireShape();
		const Animation_1 = requireAnimation();
		const Tween_1 = requireTween();
		const Context_1 = requireContext();
		const Canvas_1 = requireCanvas();
		exports.Konva = Util_1.Util._assign(Global_1.Konva, {
		    Util: Util_1.Util,
		    Transform: Util_1.Transform,
		    Node: Node_1.Node,
		    Container: Container_1.Container,
		    Stage: Stage_1.Stage,
		    stages: Stage_1.stages,
		    Layer: Layer_1.Layer,
		    FastLayer: FastLayer_1.FastLayer,
		    Group: Group_1.Group,
		    DD: DragAndDrop_1.DD,
		    Shape: Shape_1.Shape,
		    shapes: Shape_1.shapes,
		    Animation: Animation_1.Animation,
		    Tween: Tween_1.Tween,
		    Easings: Tween_1.Easings,
		    Context: Context_1.Context,
		    Canvas: Canvas_1.Canvas,
		});
		exports.default = exports.Konva; 
	} (_CoreInternals));
	return _CoreInternals;
}

var Arc = {};

var hasRequiredArc;

function requireArc () {
	if (hasRequiredArc) return Arc;
	hasRequiredArc = 1;
	Object.defineProperty(Arc, "__esModule", { value: true });
	Arc.Arc = void 0;
	const Factory_1 = requireFactory();
	const Shape_1 = requireShape();
	const Global_1 = requireGlobal();
	const Validators_1 = requireValidators();
	const Global_2 = requireGlobal();
	let Arc$1 = class Arc extends Shape_1.Shape {
	    _sceneFunc(context) {
	        const angle = Global_1.Konva.getAngle(this.angle()), clockwise = this.clockwise();
	        context.beginPath();
	        context.arc(0, 0, this.outerRadius(), 0, angle, clockwise);
	        context.arc(0, 0, this.innerRadius(), angle, 0, !clockwise);
	        context.closePath();
	        context.fillStrokeShape(this);
	    }
	    getWidth() {
	        return this.outerRadius() * 2;
	    }
	    getHeight() {
	        return this.outerRadius() * 2;
	    }
	    setWidth(width) {
	        this.outerRadius(width / 2);
	    }
	    setHeight(height) {
	        this.outerRadius(height / 2);
	    }
	    getSelfRect() {
	        const innerRadius = this.innerRadius();
	        const outerRadius = this.outerRadius();
	        const clockwise = this.clockwise();
	        const angle = Global_1.Konva.getAngle(clockwise ? 360 - this.angle() : this.angle());
	        const boundLeftRatio = Math.cos(Math.min(angle, Math.PI));
	        const boundRightRatio = 1;
	        const boundTopRatio = Math.sin(Math.min(Math.max(Math.PI, angle), (3 * Math.PI) / 2));
	        const boundBottomRatio = Math.sin(Math.min(angle, Math.PI / 2));
	        const boundLeft = boundLeftRatio * (boundLeftRatio > 0 ? innerRadius : outerRadius);
	        const boundRight = boundRightRatio * (outerRadius );
	        const boundTop = boundTopRatio * (boundTopRatio > 0 ? innerRadius : outerRadius);
	        const boundBottom = boundBottomRatio * (boundBottomRatio > 0 ? outerRadius : innerRadius);
	        return {
	            x: boundLeft,
	            y: clockwise ? -1 * boundBottom : boundTop,
	            width: boundRight - boundLeft,
	            height: boundBottom - boundTop,
	        };
	    }
	};
	Arc.Arc = Arc$1;
	Arc$1.prototype._centroid = true;
	Arc$1.prototype.className = 'Arc';
	Arc$1.prototype._attrsAffectingSize = [
	    'innerRadius',
	    'outerRadius',
	    'angle',
	    'clockwise',
	];
	(0, Global_2._registerNode)(Arc$1);
	Factory_1.Factory.addGetterSetter(Arc$1, 'innerRadius', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Arc$1, 'outerRadius', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Arc$1, 'angle', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Arc$1, 'clockwise', false, (0, Validators_1.getBooleanValidator)());
	return Arc;
}

var Arrow = {};

var Line$1 = {};

var hasRequiredLine;

function requireLine () {
	if (hasRequiredLine) return Line$1;
	hasRequiredLine = 1;
	Object.defineProperty(Line$1, "__esModule", { value: true });
	Line$1.Line = void 0;
	const Factory_1 = requireFactory();
	const Global_1 = requireGlobal();
	const Shape_1 = requireShape();
	const Validators_1 = requireValidators();
	function getControlPoints(x0, y0, x1, y1, x2, y2, t) {
	    const d01 = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2)), d12 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)), fa = (t * d01) / (d01 + d12), fb = (t * d12) / (d01 + d12), p1x = x1 - fa * (x2 - x0), p1y = y1 - fa * (y2 - y0), p2x = x1 + fb * (x2 - x0), p2y = y1 + fb * (y2 - y0);
	    return [p1x, p1y, p2x, p2y];
	}
	function expandPoints(p, tension) {
	    const len = p.length, allPoints = [];
	    for (let n = 2; n < len - 2; n += 2) {
	        const cp = getControlPoints(p[n - 2], p[n - 1], p[n], p[n + 1], p[n + 2], p[n + 3], tension);
	        if (isNaN(cp[0])) {
	            continue;
	        }
	        allPoints.push(cp[0]);
	        allPoints.push(cp[1]);
	        allPoints.push(p[n]);
	        allPoints.push(p[n + 1]);
	        allPoints.push(cp[2]);
	        allPoints.push(cp[3]);
	    }
	    return allPoints;
	}
	class Line extends Shape_1.Shape {
	    constructor(config) {
	        super(config);
	        this.on('pointsChange.konva tensionChange.konva closedChange.konva bezierChange.konva', function () {
	            this._clearCache('tensionPoints');
	        });
	    }
	    _sceneFunc(context) {
	        let points = this.points(), length = points.length, tension = this.tension(), closed = this.closed(), bezier = this.bezier(), tp, len, n;
	        if (!length) {
	            return;
	        }
	        context.beginPath();
	        context.moveTo(points[0], points[1]);
	        if (tension !== 0 && length > 4) {
	            tp = this.getTensionPoints();
	            len = tp.length;
	            n = closed ? 0 : 4;
	            if (!closed) {
	                context.quadraticCurveTo(tp[0], tp[1], tp[2], tp[3]);
	            }
	            while (n < len - 2) {
	                context.bezierCurveTo(tp[n++], tp[n++], tp[n++], tp[n++], tp[n++], tp[n++]);
	            }
	            if (!closed) {
	                context.quadraticCurveTo(tp[len - 2], tp[len - 1], points[length - 2], points[length - 1]);
	            }
	        }
	        else if (bezier) {
	            n = 2;
	            while (n < length) {
	                context.bezierCurveTo(points[n++], points[n++], points[n++], points[n++], points[n++], points[n++]);
	            }
	        }
	        else {
	            for (n = 2; n < length; n += 2) {
	                context.lineTo(points[n], points[n + 1]);
	            }
	        }
	        if (closed) {
	            context.closePath();
	            context.fillStrokeShape(this);
	        }
	        else {
	            context.strokeShape(this);
	        }
	    }
	    getTensionPoints() {
	        return this._getCache('tensionPoints', this._getTensionPoints);
	    }
	    _getTensionPoints() {
	        if (this.closed()) {
	            return this._getTensionPointsClosed();
	        }
	        else {
	            return expandPoints(this.points(), this.tension());
	        }
	    }
	    _getTensionPointsClosed() {
	        const p = this.points(), len = p.length, tension = this.tension(), firstControlPoints = getControlPoints(p[len - 2], p[len - 1], p[0], p[1], p[2], p[3], tension), lastControlPoints = getControlPoints(p[len - 4], p[len - 3], p[len - 2], p[len - 1], p[0], p[1], tension), middle = expandPoints(p, tension), tp = [firstControlPoints[2], firstControlPoints[3]]
	            .concat(middle)
	            .concat([
	            lastControlPoints[0],
	            lastControlPoints[1],
	            p[len - 2],
	            p[len - 1],
	            lastControlPoints[2],
	            lastControlPoints[3],
	            firstControlPoints[0],
	            firstControlPoints[1],
	            p[0],
	            p[1],
	        ]);
	        return tp;
	    }
	    getWidth() {
	        return this.getSelfRect().width;
	    }
	    getHeight() {
	        return this.getSelfRect().height;
	    }
	    getSelfRect() {
	        let points = this.points();
	        if (points.length < 4) {
	            return {
	                x: points[0] || 0,
	                y: points[1] || 0,
	                width: 0,
	                height: 0,
	            };
	        }
	        if (this.tension() !== 0) {
	            points = [
	                points[0],
	                points[1],
	                ...this._getTensionPoints(),
	                points[points.length - 2],
	                points[points.length - 1],
	            ];
	        }
	        else {
	            points = this.points();
	        }
	        let minX = points[0];
	        let maxX = points[0];
	        let minY = points[1];
	        let maxY = points[1];
	        let x, y;
	        for (let i = 0; i < points.length / 2; i++) {
	            x = points[i * 2];
	            y = points[i * 2 + 1];
	            minX = Math.min(minX, x);
	            maxX = Math.max(maxX, x);
	            minY = Math.min(minY, y);
	            maxY = Math.max(maxY, y);
	        }
	        return {
	            x: minX,
	            y: minY,
	            width: maxX - minX,
	            height: maxY - minY,
	        };
	    }
	}
	Line$1.Line = Line;
	Line.prototype.className = 'Line';
	Line.prototype._attrsAffectingSize = ['points', 'bezier', 'tension'];
	(0, Global_1._registerNode)(Line);
	Factory_1.Factory.addGetterSetter(Line, 'closed', false);
	Factory_1.Factory.addGetterSetter(Line, 'bezier', false);
	Factory_1.Factory.addGetterSetter(Line, 'tension', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Line, 'points', [], (0, Validators_1.getNumberArrayValidator)());
	return Line$1;
}

var Path = {};

var BezierFunctions = {};

var hasRequiredBezierFunctions;

function requireBezierFunctions () {
	if (hasRequiredBezierFunctions) return BezierFunctions;
	hasRequiredBezierFunctions = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.t2length = exports.getQuadraticArcLength = exports.getCubicArcLength = exports.binomialCoefficients = exports.cValues = exports.tValues = void 0;
		exports.tValues = [
		    [],
		    [],
		    [
		        -0.5773502691896257,
		        0.5773502691896257645091487805019574556476,
		    ],
		    [
		        0, -0.7745966692414834,
		        0.7745966692414833770358530799564799221665,
		    ],
		    [
		        -0.33998104358485626,
		        0.3399810435848562648026657591032446872005,
		        -0.8611363115940526,
		        0.8611363115940525752239464888928095050957,
		    ],
		    [
		        0, -0.5384693101056831,
		        0.5384693101056830910363144207002088049672,
		        -0.906179845938664,
		        0.9061798459386639927976268782993929651256,
		    ],
		    [
		        0.6612093864662645136613995950199053470064,
		        -0.6612093864662645,
		        -0.2386191860831969,
		        0.2386191860831969086305017216807119354186,
		        -0.932469514203152,
		        0.9324695142031520278123015544939946091347,
		    ],
		    [
		        0, 0.4058451513773971669066064120769614633473,
		        -0.4058451513773972,
		        -0.7415311855993945,
		        0.7415311855993944398638647732807884070741,
		        -0.9491079123427585,
		        0.9491079123427585245261896840478512624007,
		    ],
		    [
		        -0.1834346424956498,
		        0.1834346424956498049394761423601839806667,
		        -0.525532409916329,
		        0.5255324099163289858177390491892463490419,
		        -0.7966664774136267,
		        0.7966664774136267395915539364758304368371,
		        -0.9602898564975363,
		        0.9602898564975362316835608685694729904282,
		    ],
		    [
		        0, -0.8360311073266358,
		        0.8360311073266357942994297880697348765441,
		        -0.9681602395076261,
		        0.9681602395076260898355762029036728700494,
		        -0.3242534234038089,
		        0.3242534234038089290385380146433366085719,
		        -0.6133714327005904,
		        0.6133714327005903973087020393414741847857,
		    ],
		    [
		        -0.14887433898163122,
		        0.1488743389816312108848260011297199846175,
		        -0.4333953941292472,
		        0.4333953941292471907992659431657841622,
		        -0.6794095682990244,
		        0.6794095682990244062343273651148735757692,
		        -0.8650633666889845,
		        0.8650633666889845107320966884234930485275,
		        -0.9739065285171717,
		        0.9739065285171717200779640120844520534282,
		    ],
		    [
		        0, -0.26954315595234496,
		        0.2695431559523449723315319854008615246796,
		        -0.5190961292068118,
		        0.5190961292068118159257256694586095544802,
		        -0.7301520055740494,
		        0.7301520055740493240934162520311534580496,
		        -0.8870625997680953,
		        0.8870625997680952990751577693039272666316,
		        -0.978228658146057,
		        0.9782286581460569928039380011228573907714,
		    ],
		    [
		        -0.1252334085114689,
		        0.1252334085114689154724413694638531299833,
		        -0.3678314989981802,
		        0.3678314989981801937526915366437175612563,
		        -0.5873179542866175,
		        0.587317954286617447296702418940534280369,
		        -0.7699026741943047,
		        0.7699026741943046870368938332128180759849,
		        -0.9041172563704749,
		        0.9041172563704748566784658661190961925375,
		        -0.9815606342467192,
		        0.9815606342467192506905490901492808229601,
		    ],
		    [
		        0, -0.2304583159551348,
		        0.2304583159551347940655281210979888352115,
		        -0.44849275103644687,
		        0.4484927510364468528779128521276398678019,
		        -0.6423493394403402,
		        0.6423493394403402206439846069955156500716,
		        -0.8015780907333099,
		        0.8015780907333099127942064895828598903056,
		        -0.9175983992229779,
		        0.9175983992229779652065478365007195123904,
		        -0.9841830547185881,
		        0.9841830547185881494728294488071096110649,
		    ],
		    [
		        -0.10805494870734367,
		        0.1080549487073436620662446502198347476119,
		        -0.31911236892788974,
		        0.3191123689278897604356718241684754668342,
		        -0.5152486363581541,
		        0.5152486363581540919652907185511886623088,
		        -0.6872929048116855,
		        0.6872929048116854701480198030193341375384,
		        -0.827201315069765,
		        0.8272013150697649931897947426503949610397,
		        -0.9284348836635735,
		        0.928434883663573517336391139377874264477,
		        -0.9862838086968123,
		        0.986283808696812338841597266704052801676,
		    ],
		    [
		        0, -0.20119409399743451,
		        0.2011940939974345223006283033945962078128,
		        -0.3941513470775634,
		        0.3941513470775633698972073709810454683627,
		        -0.5709721726085388,
		        0.5709721726085388475372267372539106412383,
		        -0.7244177313601701,
		        0.7244177313601700474161860546139380096308,
		        -0.8482065834104272,
		        0.8482065834104272162006483207742168513662,
		        -0.937273392400706,
		        0.9372733924007059043077589477102094712439,
		        -0.9879925180204854,
		        0.9879925180204854284895657185866125811469,
		    ],
		    [
		        -0.09501250983763744,
		        0.0950125098376374401853193354249580631303,
		        -0.2816035507792589,
		        0.281603550779258913230460501460496106486,
		        -0.45801677765722737,
		        0.45801677765722738634241944298357757354,
		        -0.6178762444026438,
		        0.6178762444026437484466717640487910189918,
		        -0.755404408355003,
		        0.7554044083550030338951011948474422683538,
		        -0.8656312023878318,
		        0.8656312023878317438804678977123931323873,
		        -0.9445750230732326,
		        0.9445750230732325760779884155346083450911,
		        -0.9894009349916499,
		        0.9894009349916499325961541734503326274262,
		    ],
		    [
		        0, -0.17848418149584785,
		        0.1784841814958478558506774936540655574754,
		        -0.3512317634538763,
		        0.3512317634538763152971855170953460050405,
		        -0.5126905370864769,
		        0.5126905370864769678862465686295518745829,
		        -0.6576711592166907,
		        0.6576711592166907658503022166430023351478,
		        -0.7815140038968014,
		        0.7815140038968014069252300555204760502239,
		        -0.8802391537269859,
		        0.8802391537269859021229556944881556926234,
		        -0.9506755217687678,
		        0.9506755217687677612227169578958030214433,
		        -0.9905754753144174,
		        0.9905754753144173356754340199406652765077,
		    ],
		    [
		        -0.0847750130417353,
		        0.0847750130417353012422618529357838117333,
		        -0.2518862256915055,
		        0.2518862256915055095889728548779112301628,
		        -0.41175116146284263,
		        0.4117511614628426460359317938330516370789,
		        -0.5597708310739475,
		        0.5597708310739475346078715485253291369276,
		        -0.6916870430603532,
		        0.6916870430603532078748910812888483894522,
		        -0.8037049589725231,
		        0.8037049589725231156824174550145907971032,
		        -0.8926024664975557,
		        0.8926024664975557392060605911271455154078,
		        -0.9558239495713977,
		        0.9558239495713977551811958929297763099728,
		        -0.9915651684209309,
		        0.9915651684209309467300160047061507702525,
		    ],
		    [
		        0, -0.16035864564022537,
		        0.1603586456402253758680961157407435495048,
		        -0.31656409996362983,
		        0.3165640999636298319901173288498449178922,
		        -0.46457074137596094,
		        0.4645707413759609457172671481041023679762,
		        -0.600545304661681,
		        0.6005453046616810234696381649462392798683,
		        -0.7209661773352294,
		        0.7209661773352293786170958608237816296571,
		        -0.8227146565371428,
		        0.8227146565371428249789224867127139017745,
		        -0.9031559036148179,
		        0.9031559036148179016426609285323124878093,
		        -0.96020815213483,
		        0.960208152134830030852778840687651526615,
		        -0.9924068438435844,
		        0.9924068438435844031890176702532604935893,
		    ],
		    [
		        -0.07652652113349734,
		        0.0765265211334973337546404093988382110047,
		        -0.22778585114164507,
		        0.227785851141645078080496195368574624743,
		        -0.37370608871541955,
		        0.3737060887154195606725481770249272373957,
		        -0.5108670019508271,
		        0.5108670019508270980043640509552509984254,
		        -0.636053680726515,
		        0.6360536807265150254528366962262859367433,
		        -0.7463319064601508,
		        0.7463319064601507926143050703556415903107,
		        -0.8391169718222188,
		        0.8391169718222188233945290617015206853296,
		        -0.912234428251326,
		        0.9122344282513259058677524412032981130491,
		        -0.9639719272779138,
		        0.963971927277913791267666131197277221912,
		        -0.9931285991850949,
		        0.9931285991850949247861223884713202782226,
		    ],
		    [
		        0, -0.1455618541608951,
		        0.1455618541608950909370309823386863301163,
		        -0.2880213168024011,
		        0.288021316802401096600792516064600319909,
		        -0.4243421202074388,
		        0.4243421202074387835736688885437880520964,
		        -0.5516188358872198,
		        0.551618835887219807059018796724313286622,
		        -0.6671388041974123,
		        0.667138804197412319305966669990339162597,
		        -0.7684399634756779,
		        0.7684399634756779086158778513062280348209,
		        -0.8533633645833173,
		        0.8533633645833172836472506385875676702761,
		        -0.9200993341504008,
		        0.9200993341504008287901871337149688941591,
		        -0.9672268385663063,
		        0.9672268385663062943166222149076951614246,
		        -0.9937521706203895,
		        0.9937521706203895002602420359379409291933,
		    ],
		    [
		        -0.06973927331972223,
		        0.0697392733197222212138417961186280818222,
		        -0.20786042668822127,
		        0.2078604266882212854788465339195457342156,
		        -0.34193582089208424,
		        0.3419358208920842251581474204273796195591,
		        -0.469355837986757,
		        0.4693558379867570264063307109664063460953,
		        -0.5876404035069116,
		        0.5876404035069115929588769276386473488776,
		        -0.6944872631866827,
		        0.6944872631866827800506898357622567712673,
		        -0.7878168059792081,
		        0.7878168059792081620042779554083515213881,
		        -0.8658125777203002,
		        0.8658125777203001365364256370193787290847,
		        -0.926956772187174,
		        0.9269567721871740005206929392590531966353,
		        -0.9700604978354287,
		        0.9700604978354287271239509867652687108059,
		        -0.9942945854823992,
		        0.994294585482399292073031421161298980393,
		    ],
		    [
		        0, -0.1332568242984661,
		        0.1332568242984661109317426822417661370104,
		        -0.26413568097034495,
		        0.264135680970344930533869538283309602979,
		        -0.3903010380302908,
		        0.390301038030290831421488872880605458578,
		        -0.5095014778460075,
		        0.5095014778460075496897930478668464305448,
		        -0.6196098757636461,
		        0.6196098757636461563850973116495956533871,
		        -0.7186613631319502,
		        0.7186613631319501944616244837486188483299,
		        -0.8048884016188399,
		        0.8048884016188398921511184069967785579414,
		        -0.8767523582704416,
		        0.8767523582704416673781568859341456716389,
		        -0.9329710868260161,
		        0.9329710868260161023491969890384229782357,
		        -0.9725424712181152,
		        0.9725424712181152319560240768207773751816,
		        -0.9947693349975522,
		        0.9947693349975521235239257154455743605736,
		    ],
		    [
		        -0.06405689286260563,
		        0.0640568928626056260850430826247450385909,
		        -0.1911188674736163,
		        0.1911188674736163091586398207570696318404,
		        -0.3150426796961634,
		        0.3150426796961633743867932913198102407864,
		        -0.4337935076260451,
		        0.4337935076260451384870842319133497124524,
		        -0.5454214713888396,
		        0.5454214713888395356583756172183723700107,
		        -0.6480936519369755,
		        0.6480936519369755692524957869107476266696,
		        -0.7401241915785544,
		        0.7401241915785543642438281030999784255232,
		        -0.820001985973903,
		        0.8200019859739029219539498726697452080761,
		        -0.8864155270044011,
		        0.8864155270044010342131543419821967550873,
		        -0.9382745520027328,
		        0.9382745520027327585236490017087214496548,
		        -0.9747285559713095,
		        0.9747285559713094981983919930081690617411,
		        -0.9951872199970213,
		        0.9951872199970213601799974097007368118745,
		    ],
		];
		exports.cValues = [
		    [],
		    [],
		    [1.0, 1.0],
		    [
		        0.8888888888888888888888888888888888888888,
		        0.5555555555555555555555555555555555555555,
		        0.5555555555555555555555555555555555555555,
		    ],
		    [
		        0.6521451548625461426269360507780005927646,
		        0.6521451548625461426269360507780005927646,
		        0.3478548451374538573730639492219994072353,
		        0.3478548451374538573730639492219994072353,
		    ],
		    [
		        0.5688888888888888888888888888888888888888,
		        0.4786286704993664680412915148356381929122,
		        0.4786286704993664680412915148356381929122,
		        0.2369268850561890875142640407199173626432,
		        0.2369268850561890875142640407199173626432,
		    ],
		    [
		        0.3607615730481386075698335138377161116615,
		        0.3607615730481386075698335138377161116615,
		        0.4679139345726910473898703439895509948116,
		        0.4679139345726910473898703439895509948116,
		        0.1713244923791703450402961421727328935268,
		        0.1713244923791703450402961421727328935268,
		    ],
		    [
		        0.4179591836734693877551020408163265306122,
		        0.3818300505051189449503697754889751338783,
		        0.3818300505051189449503697754889751338783,
		        0.2797053914892766679014677714237795824869,
		        0.2797053914892766679014677714237795824869,
		        0.1294849661688696932706114326790820183285,
		        0.1294849661688696932706114326790820183285,
		    ],
		    [
		        0.3626837833783619829651504492771956121941,
		        0.3626837833783619829651504492771956121941,
		        0.3137066458778872873379622019866013132603,
		        0.3137066458778872873379622019866013132603,
		        0.2223810344533744705443559944262408844301,
		        0.2223810344533744705443559944262408844301,
		        0.1012285362903762591525313543099621901153,
		        0.1012285362903762591525313543099621901153,
		    ],
		    [
		        0.3302393550012597631645250692869740488788,
		        0.1806481606948574040584720312429128095143,
		        0.1806481606948574040584720312429128095143,
		        0.0812743883615744119718921581105236506756,
		        0.0812743883615744119718921581105236506756,
		        0.3123470770400028400686304065844436655987,
		        0.3123470770400028400686304065844436655987,
		        0.2606106964029354623187428694186328497718,
		        0.2606106964029354623187428694186328497718,
		    ],
		    [
		        0.295524224714752870173892994651338329421,
		        0.295524224714752870173892994651338329421,
		        0.2692667193099963550912269215694693528597,
		        0.2692667193099963550912269215694693528597,
		        0.2190863625159820439955349342281631924587,
		        0.2190863625159820439955349342281631924587,
		        0.1494513491505805931457763396576973324025,
		        0.1494513491505805931457763396576973324025,
		        0.0666713443086881375935688098933317928578,
		        0.0666713443086881375935688098933317928578,
		    ],
		    [
		        0.272925086777900630714483528336342189156,
		        0.2628045445102466621806888698905091953727,
		        0.2628045445102466621806888698905091953727,
		        0.2331937645919904799185237048431751394317,
		        0.2331937645919904799185237048431751394317,
		        0.1862902109277342514260976414316558916912,
		        0.1862902109277342514260976414316558916912,
		        0.1255803694649046246346942992239401001976,
		        0.1255803694649046246346942992239401001976,
		        0.0556685671161736664827537204425485787285,
		        0.0556685671161736664827537204425485787285,
		    ],
		    [
		        0.2491470458134027850005624360429512108304,
		        0.2491470458134027850005624360429512108304,
		        0.2334925365383548087608498989248780562594,
		        0.2334925365383548087608498989248780562594,
		        0.2031674267230659217490644558097983765065,
		        0.2031674267230659217490644558097983765065,
		        0.160078328543346226334652529543359071872,
		        0.160078328543346226334652529543359071872,
		        0.1069393259953184309602547181939962242145,
		        0.1069393259953184309602547181939962242145,
		        0.047175336386511827194615961485017060317,
		        0.047175336386511827194615961485017060317,
		    ],
		    [
		        0.2325515532308739101945895152688359481566,
		        0.2262831802628972384120901860397766184347,
		        0.2262831802628972384120901860397766184347,
		        0.2078160475368885023125232193060527633865,
		        0.2078160475368885023125232193060527633865,
		        0.1781459807619457382800466919960979955128,
		        0.1781459807619457382800466919960979955128,
		        0.1388735102197872384636017768688714676218,
		        0.1388735102197872384636017768688714676218,
		        0.0921214998377284479144217759537971209236,
		        0.0921214998377284479144217759537971209236,
		        0.0404840047653158795200215922009860600419,
		        0.0404840047653158795200215922009860600419,
		    ],
		    [
		        0.2152638534631577901958764433162600352749,
		        0.2152638534631577901958764433162600352749,
		        0.2051984637212956039659240656612180557103,
		        0.2051984637212956039659240656612180557103,
		        0.1855383974779378137417165901251570362489,
		        0.1855383974779378137417165901251570362489,
		        0.1572031671581935345696019386238421566056,
		        0.1572031671581935345696019386238421566056,
		        0.1215185706879031846894148090724766259566,
		        0.1215185706879031846894148090724766259566,
		        0.0801580871597602098056332770628543095836,
		        0.0801580871597602098056332770628543095836,
		        0.0351194603317518630318328761381917806197,
		        0.0351194603317518630318328761381917806197,
		    ],
		    [
		        0.2025782419255612728806201999675193148386,
		        0.1984314853271115764561183264438393248186,
		        0.1984314853271115764561183264438393248186,
		        0.1861610000155622110268005618664228245062,
		        0.1861610000155622110268005618664228245062,
		        0.1662692058169939335532008604812088111309,
		        0.1662692058169939335532008604812088111309,
		        0.1395706779261543144478047945110283225208,
		        0.1395706779261543144478047945110283225208,
		        0.1071592204671719350118695466858693034155,
		        0.1071592204671719350118695466858693034155,
		        0.0703660474881081247092674164506673384667,
		        0.0703660474881081247092674164506673384667,
		        0.0307532419961172683546283935772044177217,
		        0.0307532419961172683546283935772044177217,
		    ],
		    [
		        0.1894506104550684962853967232082831051469,
		        0.1894506104550684962853967232082831051469,
		        0.1826034150449235888667636679692199393835,
		        0.1826034150449235888667636679692199393835,
		        0.1691565193950025381893120790303599622116,
		        0.1691565193950025381893120790303599622116,
		        0.1495959888165767320815017305474785489704,
		        0.1495959888165767320815017305474785489704,
		        0.1246289712555338720524762821920164201448,
		        0.1246289712555338720524762821920164201448,
		        0.0951585116824927848099251076022462263552,
		        0.0951585116824927848099251076022462263552,
		        0.0622535239386478928628438369943776942749,
		        0.0622535239386478928628438369943776942749,
		        0.0271524594117540948517805724560181035122,
		        0.0271524594117540948517805724560181035122,
		    ],
		    [
		        0.1794464703562065254582656442618856214487,
		        0.1765627053669926463252709901131972391509,
		        0.1765627053669926463252709901131972391509,
		        0.1680041021564500445099706637883231550211,
		        0.1680041021564500445099706637883231550211,
		        0.1540457610768102880814315948019586119404,
		        0.1540457610768102880814315948019586119404,
		        0.1351363684685254732863199817023501973721,
		        0.1351363684685254732863199817023501973721,
		        0.1118838471934039710947883856263559267358,
		        0.1118838471934039710947883856263559267358,
		        0.0850361483171791808835353701910620738504,
		        0.0850361483171791808835353701910620738504,
		        0.0554595293739872011294401653582446605128,
		        0.0554595293739872011294401653582446605128,
		        0.0241483028685479319601100262875653246916,
		        0.0241483028685479319601100262875653246916,
		    ],
		    [
		        0.1691423829631435918406564701349866103341,
		        0.1691423829631435918406564701349866103341,
		        0.1642764837458327229860537764659275904123,
		        0.1642764837458327229860537764659275904123,
		        0.1546846751262652449254180038363747721932,
		        0.1546846751262652449254180038363747721932,
		        0.1406429146706506512047313037519472280955,
		        0.1406429146706506512047313037519472280955,
		        0.1225552067114784601845191268002015552281,
		        0.1225552067114784601845191268002015552281,
		        0.1009420441062871655628139849248346070628,
		        0.1009420441062871655628139849248346070628,
		        0.0764257302548890565291296776166365256053,
		        0.0764257302548890565291296776166365256053,
		        0.0497145488949697964533349462026386416808,
		        0.0497145488949697964533349462026386416808,
		        0.0216160135264833103133427102664524693876,
		        0.0216160135264833103133427102664524693876,
		    ],
		    [
		        0.1610544498487836959791636253209167350399,
		        0.1589688433939543476499564394650472016787,
		        0.1589688433939543476499564394650472016787,
		        0.152766042065859666778855400897662998461,
		        0.152766042065859666778855400897662998461,
		        0.1426067021736066117757461094419029724756,
		        0.1426067021736066117757461094419029724756,
		        0.1287539625393362276755157848568771170558,
		        0.1287539625393362276755157848568771170558,
		        0.1115666455473339947160239016817659974813,
		        0.1115666455473339947160239016817659974813,
		        0.0914900216224499994644620941238396526609,
		        0.0914900216224499994644620941238396526609,
		        0.0690445427376412265807082580060130449618,
		        0.0690445427376412265807082580060130449618,
		        0.0448142267656996003328381574019942119517,
		        0.0448142267656996003328381574019942119517,
		        0.0194617882297264770363120414644384357529,
		        0.0194617882297264770363120414644384357529,
		    ],
		    [
		        0.1527533871307258506980843319550975934919,
		        0.1527533871307258506980843319550975934919,
		        0.1491729864726037467878287370019694366926,
		        0.1491729864726037467878287370019694366926,
		        0.1420961093183820513292983250671649330345,
		        0.1420961093183820513292983250671649330345,
		        0.1316886384491766268984944997481631349161,
		        0.1316886384491766268984944997481631349161,
		        0.118194531961518417312377377711382287005,
		        0.118194531961518417312377377711382287005,
		        0.1019301198172404350367501354803498761666,
		        0.1019301198172404350367501354803498761666,
		        0.0832767415767047487247581432220462061001,
		        0.0832767415767047487247581432220462061001,
		        0.0626720483341090635695065351870416063516,
		        0.0626720483341090635695065351870416063516,
		        0.040601429800386941331039952274932109879,
		        0.040601429800386941331039952274932109879,
		        0.0176140071391521183118619623518528163621,
		        0.0176140071391521183118619623518528163621,
		    ],
		    [
		        0.1460811336496904271919851476833711882448,
		        0.1445244039899700590638271665537525436099,
		        0.1445244039899700590638271665537525436099,
		        0.1398873947910731547221334238675831108927,
		        0.1398873947910731547221334238675831108927,
		        0.132268938633337461781052574496775604329,
		        0.132268938633337461781052574496775604329,
		        0.1218314160537285341953671771257335983563,
		        0.1218314160537285341953671771257335983563,
		        0.1087972991671483776634745780701056420336,
		        0.1087972991671483776634745780701056420336,
		        0.0934444234560338615532897411139320884835,
		        0.0934444234560338615532897411139320884835,
		        0.0761001136283793020170516533001831792261,
		        0.0761001136283793020170516533001831792261,
		        0.0571344254268572082836358264724479574912,
		        0.0571344254268572082836358264724479574912,
		        0.0369537897708524937999506682993296661889,
		        0.0369537897708524937999506682993296661889,
		        0.0160172282577743333242246168584710152658,
		        0.0160172282577743333242246168584710152658,
		    ],
		    [
		        0.1392518728556319933754102483418099578739,
		        0.1392518728556319933754102483418099578739,
		        0.1365414983460151713525738312315173965863,
		        0.1365414983460151713525738312315173965863,
		        0.1311735047870623707329649925303074458757,
		        0.1311735047870623707329649925303074458757,
		        0.1232523768105124242855609861548144719594,
		        0.1232523768105124242855609861548144719594,
		        0.1129322960805392183934006074217843191142,
		        0.1129322960805392183934006074217843191142,
		        0.1004141444428809649320788378305362823508,
		        0.1004141444428809649320788378305362823508,
		        0.0859416062170677274144436813727028661891,
		        0.0859416062170677274144436813727028661891,
		        0.0697964684245204880949614189302176573987,
		        0.0697964684245204880949614189302176573987,
		        0.0522933351526832859403120512732112561121,
		        0.0522933351526832859403120512732112561121,
		        0.0337749015848141547933022468659129013491,
		        0.0337749015848141547933022468659129013491,
		        0.0146279952982722006849910980471854451902,
		        0.0146279952982722006849910980471854451902,
		    ],
		    [
		        0.1336545721861061753514571105458443385831,
		        0.132462039404696617371642464703316925805,
		        0.132462039404696617371642464703316925805,
		        0.1289057221880821499785953393997936532597,
		        0.1289057221880821499785953393997936532597,
		        0.1230490843067295304675784006720096548158,
		        0.1230490843067295304675784006720096548158,
		        0.1149966402224113649416435129339613014914,
		        0.1149966402224113649416435129339613014914,
		        0.1048920914645414100740861850147438548584,
		        0.1048920914645414100740861850147438548584,
		        0.0929157660600351474770186173697646486034,
		        0.0929157660600351474770186173697646486034,
		        0.0792814117767189549228925247420432269137,
		        0.0792814117767189549228925247420432269137,
		        0.0642324214085258521271696151589109980391,
		        0.0642324214085258521271696151589109980391,
		        0.0480376717310846685716410716320339965612,
		        0.0480376717310846685716410716320339965612,
		        0.0309880058569794443106942196418845053837,
		        0.0309880058569794443106942196418845053837,
		        0.0134118594871417720813094934586150649766,
		        0.0134118594871417720813094934586150649766,
		    ],
		    [
		        0.1279381953467521569740561652246953718517,
		        0.1279381953467521569740561652246953718517,
		        0.1258374563468282961213753825111836887264,
		        0.1258374563468282961213753825111836887264,
		        0.121670472927803391204463153476262425607,
		        0.121670472927803391204463153476262425607,
		        0.1155056680537256013533444839067835598622,
		        0.1155056680537256013533444839067835598622,
		        0.1074442701159656347825773424466062227946,
		        0.1074442701159656347825773424466062227946,
		        0.0976186521041138882698806644642471544279,
		        0.0976186521041138882698806644642471544279,
		        0.086190161531953275917185202983742667185,
		        0.086190161531953275917185202983742667185,
		        0.0733464814110803057340336152531165181193,
		        0.0733464814110803057340336152531165181193,
		        0.0592985849154367807463677585001085845412,
		        0.0592985849154367807463677585001085845412,
		        0.0442774388174198061686027482113382288593,
		        0.0442774388174198061686027482113382288593,
		        0.0285313886289336631813078159518782864491,
		        0.0285313886289336631813078159518782864491,
		        0.0123412297999871995468056670700372915759,
		        0.0123412297999871995468056670700372915759,
		    ],
		];
		exports.binomialCoefficients = [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]];
		const getCubicArcLength = (xs, ys, t) => {
		    let sum;
		    let correctedT;
		    const n = 20;
		    const z = t / 2;
		    sum = 0;
		    for (let i = 0; i < n; i++) {
		        correctedT = z * exports.tValues[n][i] + z;
		        sum += exports.cValues[n][i] * BFunc(xs, ys, correctedT);
		    }
		    return z * sum;
		};
		exports.getCubicArcLength = getCubicArcLength;
		const getQuadraticArcLength = (xs, ys, t) => {
		    if (t === undefined) {
		        t = 1;
		    }
		    const ax = xs[0] - 2 * xs[1] + xs[2];
		    const ay = ys[0] - 2 * ys[1] + ys[2];
		    const bx = 2 * xs[1] - 2 * xs[0];
		    const by = 2 * ys[1] - 2 * ys[0];
		    const A = 4 * (ax * ax + ay * ay);
		    const B = 4 * (ax * bx + ay * by);
		    const C = bx * bx + by * by;
		    if (A === 0) {
		        return (t * Math.sqrt(Math.pow(xs[2] - xs[0], 2) + Math.pow(ys[2] - ys[0], 2)));
		    }
		    const b = B / (2 * A);
		    const c = C / A;
		    const u = t + b;
		    const k = c - b * b;
		    const uuk = u * u + k > 0 ? Math.sqrt(u * u + k) : 0;
		    const bbk = b * b + k > 0 ? Math.sqrt(b * b + k) : 0;
		    const term = b + Math.sqrt(b * b + k) !== 0
		        ? k * Math.log(Math.abs((u + uuk) / (b + bbk)))
		        : 0;
		    return (Math.sqrt(A) / 2) * (u * uuk - b * bbk + term);
		};
		exports.getQuadraticArcLength = getQuadraticArcLength;
		function BFunc(xs, ys, t) {
		    const xbase = getDerivative(1, t, xs);
		    const ybase = getDerivative(1, t, ys);
		    const combined = xbase * xbase + ybase * ybase;
		    return Math.sqrt(combined);
		}
		const getDerivative = (derivative, t, vs) => {
		    const n = vs.length - 1;
		    let _vs;
		    let value;
		    if (n === 0) {
		        return 0;
		    }
		    if (derivative === 0) {
		        value = 0;
		        for (let k = 0; k <= n; k++) {
		            value +=
		                exports.binomialCoefficients[n][k] *
		                    Math.pow(1 - t, n - k) *
		                    Math.pow(t, k) *
		                    vs[k];
		        }
		        return value;
		    }
		    else {
		        _vs = new Array(n);
		        for (let k = 0; k < n; k++) {
		            _vs[k] = n * (vs[k + 1] - vs[k]);
		        }
		        return getDerivative(derivative - 1, t, _vs);
		    }
		};
		const t2length = (length, totalLength, func) => {
		    let error = 1;
		    let t = length / totalLength;
		    let step = (length - func(t)) / totalLength;
		    let numIterations = 0;
		    while (error > 0.001) {
		        const increasedTLength = func(t + step);
		        const increasedTError = Math.abs(length - increasedTLength) / totalLength;
		        if (increasedTError < error) {
		            error = increasedTError;
		            t += step;
		        }
		        else {
		            const decreasedTLength = func(t - step);
		            const decreasedTError = Math.abs(length - decreasedTLength) / totalLength;
		            if (decreasedTError < error) {
		                error = decreasedTError;
		                t -= step;
		            }
		            else {
		                step /= 2;
		            }
		        }
		        numIterations++;
		        if (numIterations > 500) {
		            break;
		        }
		    }
		    return t;
		};
		exports.t2length = t2length; 
	} (BezierFunctions));
	return BezierFunctions;
}

var hasRequiredPath;

function requirePath () {
	if (hasRequiredPath) return Path;
	hasRequiredPath = 1;
	Object.defineProperty(Path, "__esModule", { value: true });
	Path.Path = void 0;
	const Factory_1 = requireFactory();
	const Shape_1 = requireShape();
	const Global_1 = requireGlobal();
	const BezierFunctions_1 = requireBezierFunctions();
	let Path$1 = class Path extends Shape_1.Shape {
	    constructor(config) {
	        super(config);
	        this.dataArray = [];
	        this.pathLength = 0;
	        this._readDataAttribute();
	        this.on('dataChange.konva', function () {
	            this._readDataAttribute();
	        });
	    }
	    _readDataAttribute() {
	        this.dataArray = Path.parsePathData(this.data());
	        this.pathLength = Path.getPathLength(this.dataArray);
	    }
	    _sceneFunc(context) {
	        const ca = this.dataArray;
	        context.beginPath();
	        let isClosed = false;
	        for (let n = 0; n < ca.length; n++) {
	            const c = ca[n].command;
	            const p = ca[n].points;
	            switch (c) {
	                case 'L':
	                    context.lineTo(p[0], p[1]);
	                    break;
	                case 'M':
	                    context.moveTo(p[0], p[1]);
	                    break;
	                case 'C':
	                    context.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5]);
	                    break;
	                case 'Q':
	                    context.quadraticCurveTo(p[0], p[1], p[2], p[3]);
	                    break;
	                case 'A':
	                    var cx = p[0], cy = p[1], rx = p[2], ry = p[3], theta = p[4], dTheta = p[5], psi = p[6], fs = p[7];
	                    var r = rx > ry ? rx : ry;
	                    var scaleX = rx > ry ? 1 : rx / ry;
	                    var scaleY = rx > ry ? ry / rx : 1;
	                    context.translate(cx, cy);
	                    context.rotate(psi);
	                    context.scale(scaleX, scaleY);
	                    context.arc(0, 0, r, theta, theta + dTheta, 1 - fs);
	                    context.scale(1 / scaleX, 1 / scaleY);
	                    context.rotate(-psi);
	                    context.translate(-cx, -cy);
	                    break;
	                case 'z':
	                    isClosed = true;
	                    context.closePath();
	                    break;
	            }
	        }
	        if (!isClosed && !this.hasFill()) {
	            context.strokeShape(this);
	        }
	        else {
	            context.fillStrokeShape(this);
	        }
	    }
	    getSelfRect() {
	        let points = [];
	        this.dataArray.forEach(function (data) {
	            if (data.command === 'A') {
	                const start = data.points[4];
	                const dTheta = data.points[5];
	                const end = data.points[4] + dTheta;
	                let inc = Math.PI / 180.0;
	                if (Math.abs(start - end) < inc) {
	                    inc = Math.abs(start - end);
	                }
	                if (dTheta < 0) {
	                    for (let t = start - inc; t > end; t -= inc) {
	                        const point = Path.getPointOnEllipticalArc(data.points[0], data.points[1], data.points[2], data.points[3], t, 0);
	                        points.push(point.x, point.y);
	                    }
	                }
	                else {
	                    for (let t = start + inc; t < end; t += inc) {
	                        const point = Path.getPointOnEllipticalArc(data.points[0], data.points[1], data.points[2], data.points[3], t, 0);
	                        points.push(point.x, point.y);
	                    }
	                }
	            }
	            else if (data.command === 'C') {
	                for (let t = 0.0; t <= 1; t += 0.01) {
	                    const point = Path.getPointOnCubicBezier(t, data.start.x, data.start.y, data.points[0], data.points[1], data.points[2], data.points[3], data.points[4], data.points[5]);
	                    points.push(point.x, point.y);
	                }
	            }
	            else {
	                points = points.concat(data.points);
	            }
	        });
	        let minX = points[0];
	        let maxX = points[0];
	        let minY = points[1];
	        let maxY = points[1];
	        let x, y;
	        for (let i = 0; i < points.length / 2; i++) {
	            x = points[i * 2];
	            y = points[i * 2 + 1];
	            if (!isNaN(x)) {
	                minX = Math.min(minX, x);
	                maxX = Math.max(maxX, x);
	            }
	            if (!isNaN(y)) {
	                minY = Math.min(minY, y);
	                maxY = Math.max(maxY, y);
	            }
	        }
	        return {
	            x: minX,
	            y: minY,
	            width: maxX - minX,
	            height: maxY - minY,
	        };
	    }
	    getLength() {
	        return this.pathLength;
	    }
	    getPointAtLength(length) {
	        return Path.getPointAtLengthOfDataArray(length, this.dataArray);
	    }
	    static getLineLength(x1, y1, x2, y2) {
	        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
	    }
	    static getPathLength(dataArray) {
	        let pathLength = 0;
	        for (let i = 0; i < dataArray.length; ++i) {
	            pathLength += dataArray[i].pathLength;
	        }
	        return pathLength;
	    }
	    static getPointAtLengthOfDataArray(length, dataArray) {
	        let points, i = 0, ii = dataArray.length;
	        if (!ii) {
	            return null;
	        }
	        while (i < ii && length > dataArray[i].pathLength) {
	            length -= dataArray[i].pathLength;
	            ++i;
	        }
	        if (i === ii) {
	            points = dataArray[i - 1].points.slice(-2);
	            return {
	                x: points[0],
	                y: points[1],
	            };
	        }
	        if (length < 0.01) {
	            points = dataArray[i].points.slice(0, 2);
	            return {
	                x: points[0],
	                y: points[1],
	            };
	        }
	        const cp = dataArray[i];
	        const p = cp.points;
	        switch (cp.command) {
	            case 'L':
	                return Path.getPointOnLine(length, cp.start.x, cp.start.y, p[0], p[1]);
	            case 'C':
	                return Path.getPointOnCubicBezier((0, BezierFunctions_1.t2length)(length, Path.getPathLength(dataArray), (i) => {
	                    return (0, BezierFunctions_1.getCubicArcLength)([cp.start.x, p[0], p[2], p[4]], [cp.start.y, p[1], p[3], p[5]], i);
	                }), cp.start.x, cp.start.y, p[0], p[1], p[2], p[3], p[4], p[5]);
	            case 'Q':
	                return Path.getPointOnQuadraticBezier((0, BezierFunctions_1.t2length)(length, Path.getPathLength(dataArray), (i) => {
	                    return (0, BezierFunctions_1.getQuadraticArcLength)([cp.start.x, p[0], p[2]], [cp.start.y, p[1], p[3]], i);
	                }), cp.start.x, cp.start.y, p[0], p[1], p[2], p[3]);
	            case 'A':
	                var cx = p[0], cy = p[1], rx = p[2], ry = p[3], theta = p[4], dTheta = p[5], psi = p[6];
	                theta += (dTheta * length) / cp.pathLength;
	                return Path.getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi);
	        }
	        return null;
	    }
	    static getPointOnLine(dist, P1x, P1y, P2x, P2y, fromX, fromY) {
	        fromX = fromX !== null && fromX !== void 0 ? fromX : P1x;
	        fromY = fromY !== null && fromY !== void 0 ? fromY : P1y;
	        const len = this.getLineLength(P1x, P1y, P2x, P2y);
	        if (len < 1e-10) {
	            return { x: P1x, y: P1y };
	        }
	        if (P2x === P1x) {
	            return { x: fromX, y: fromY + (P2y > P1y ? dist : -dist) };
	        }
	        const m = (P2y - P1y) / (P2x - P1x);
	        const run = Math.sqrt((dist * dist) / (1 + m * m)) * (P2x < P1x ? -1 : 1);
	        const rise = m * run;
	        if (Math.abs(fromY - P1y - m * (fromX - P1x)) < 1e-10) {
	            return { x: fromX + run, y: fromY + rise };
	        }
	        const u = ((fromX - P1x) * (P2x - P1x) + (fromY - P1y) * (P2y - P1y)) / (len * len);
	        const ix = P1x + u * (P2x - P1x);
	        const iy = P1y + u * (P2y - P1y);
	        const pRise = this.getLineLength(fromX, fromY, ix, iy);
	        const pRun = Math.sqrt(dist * dist - pRise * pRise);
	        const adjustedRun = Math.sqrt((pRun * pRun) / (1 + m * m)) * (P2x < P1x ? -1 : 1);
	        const adjustedRise = m * adjustedRun;
	        return { x: ix + adjustedRun, y: iy + adjustedRise };
	    }
	    static getPointOnCubicBezier(pct, P1x, P1y, P2x, P2y, P3x, P3y, P4x, P4y) {
	        function CB1(t) {
	            return t * t * t;
	        }
	        function CB2(t) {
	            return 3 * t * t * (1 - t);
	        }
	        function CB3(t) {
	            return 3 * t * (1 - t) * (1 - t);
	        }
	        function CB4(t) {
	            return (1 - t) * (1 - t) * (1 - t);
	        }
	        const x = P4x * CB1(pct) + P3x * CB2(pct) + P2x * CB3(pct) + P1x * CB4(pct);
	        const y = P4y * CB1(pct) + P3y * CB2(pct) + P2y * CB3(pct) + P1y * CB4(pct);
	        return {
	            x: x,
	            y: y,
	        };
	    }
	    static getPointOnQuadraticBezier(pct, P1x, P1y, P2x, P2y, P3x, P3y) {
	        function QB1(t) {
	            return t * t;
	        }
	        function QB2(t) {
	            return 2 * t * (1 - t);
	        }
	        function QB3(t) {
	            return (1 - t) * (1 - t);
	        }
	        const x = P3x * QB1(pct) + P2x * QB2(pct) + P1x * QB3(pct);
	        const y = P3y * QB1(pct) + P2y * QB2(pct) + P1y * QB3(pct);
	        return {
	            x: x,
	            y: y,
	        };
	    }
	    static getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {
	        const cosPsi = Math.cos(psi), sinPsi = Math.sin(psi);
	        const pt = {
	            x: rx * Math.cos(theta),
	            y: ry * Math.sin(theta),
	        };
	        return {
	            x: cx + (pt.x * cosPsi - pt.y * sinPsi),
	            y: cy + (pt.x * sinPsi + pt.y * cosPsi),
	        };
	    }
	    static parsePathData(data) {
	        if (!data) {
	            return [];
	        }
	        let cs = data;
	        const cc = [
	            'm',
	            'M',
	            'l',
	            'L',
	            'v',
	            'V',
	            'h',
	            'H',
	            'z',
	            'Z',
	            'c',
	            'C',
	            'q',
	            'Q',
	            't',
	            'T',
	            's',
	            'S',
	            'a',
	            'A',
	        ];
	        cs = cs.replace(new RegExp(' ', 'g'), ',');
	        for (var n = 0; n < cc.length; n++) {
	            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
	        }
	        const arr = cs.split('|');
	        const ca = [];
	        const coords = [];
	        let cpx = 0;
	        let cpy = 0;
	        const re = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/gi;
	        let match;
	        for (n = 1; n < arr.length; n++) {
	            let str = arr[n];
	            let c = str.charAt(0);
	            str = str.slice(1);
	            coords.length = 0;
	            while ((match = re.exec(str))) {
	                coords.push(match[0]);
	            }
	            const p = [];
	            for (let j = 0, jlen = coords.length; j < jlen; j++) {
	                if (coords[j] === '00') {
	                    p.push(0, 0);
	                    continue;
	                }
	                const parsed = parseFloat(coords[j]);
	                if (!isNaN(parsed)) {
	                    p.push(parsed);
	                }
	                else {
	                    p.push(0);
	                }
	            }
	            while (p.length > 0) {
	                if (isNaN(p[0])) {
	                    break;
	                }
	                let cmd = '';
	                let points = [];
	                const startX = cpx, startY = cpy;
	                var prevCmd, ctlPtx, ctlPty;
	                var rx, ry, psi, fa, fs, x1, y1;
	                switch (c) {
	                    case 'l':
	                        cpx += p.shift();
	                        cpy += p.shift();
	                        cmd = 'L';
	                        points.push(cpx, cpy);
	                        break;
	                    case 'L':
	                        cpx = p.shift();
	                        cpy = p.shift();
	                        points.push(cpx, cpy);
	                        break;
	                    case 'm':
	                        var dx = p.shift();
	                        var dy = p.shift();
	                        cpx += dx;
	                        cpy += dy;
	                        cmd = 'M';
	                        if (ca.length > 2 && ca[ca.length - 1].command === 'z') {
	                            for (let idx = ca.length - 2; idx >= 0; idx--) {
	                                if (ca[idx].command === 'M') {
	                                    cpx = ca[idx].points[0] + dx;
	                                    cpy = ca[idx].points[1] + dy;
	                                    break;
	                                }
	                            }
	                        }
	                        points.push(cpx, cpy);
	                        c = 'l';
	                        break;
	                    case 'M':
	                        cpx = p.shift();
	                        cpy = p.shift();
	                        cmd = 'M';
	                        points.push(cpx, cpy);
	                        c = 'L';
	                        break;
	                    case 'h':
	                        cpx += p.shift();
	                        cmd = 'L';
	                        points.push(cpx, cpy);
	                        break;
	                    case 'H':
	                        cpx = p.shift();
	                        cmd = 'L';
	                        points.push(cpx, cpy);
	                        break;
	                    case 'v':
	                        cpy += p.shift();
	                        cmd = 'L';
	                        points.push(cpx, cpy);
	                        break;
	                    case 'V':
	                        cpy = p.shift();
	                        cmd = 'L';
	                        points.push(cpx, cpy);
	                        break;
	                    case 'C':
	                        points.push(p.shift(), p.shift(), p.shift(), p.shift());
	                        cpx = p.shift();
	                        cpy = p.shift();
	                        points.push(cpx, cpy);
	                        break;
	                    case 'c':
	                        points.push(cpx + p.shift(), cpy + p.shift(), cpx + p.shift(), cpy + p.shift());
	                        cpx += p.shift();
	                        cpy += p.shift();
	                        cmd = 'C';
	                        points.push(cpx, cpy);
	                        break;
	                    case 'S':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        prevCmd = ca[ca.length - 1];
	                        if (prevCmd.command === 'C') {
	                            ctlPtx = cpx + (cpx - prevCmd.points[2]);
	                            ctlPty = cpy + (cpy - prevCmd.points[3]);
	                        }
	                        points.push(ctlPtx, ctlPty, p.shift(), p.shift());
	                        cpx = p.shift();
	                        cpy = p.shift();
	                        cmd = 'C';
	                        points.push(cpx, cpy);
	                        break;
	                    case 's':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        prevCmd = ca[ca.length - 1];
	                        if (prevCmd.command === 'C') {
	                            ctlPtx = cpx + (cpx - prevCmd.points[2]);
	                            ctlPty = cpy + (cpy - prevCmd.points[3]);
	                        }
	                        points.push(ctlPtx, ctlPty, cpx + p.shift(), cpy + p.shift());
	                        cpx += p.shift();
	                        cpy += p.shift();
	                        cmd = 'C';
	                        points.push(cpx, cpy);
	                        break;
	                    case 'Q':
	                        points.push(p.shift(), p.shift());
	                        cpx = p.shift();
	                        cpy = p.shift();
	                        points.push(cpx, cpy);
	                        break;
	                    case 'q':
	                        points.push(cpx + p.shift(), cpy + p.shift());
	                        cpx += p.shift();
	                        cpy += p.shift();
	                        cmd = 'Q';
	                        points.push(cpx, cpy);
	                        break;
	                    case 'T':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        prevCmd = ca[ca.length - 1];
	                        if (prevCmd.command === 'Q') {
	                            ctlPtx = cpx + (cpx - prevCmd.points[0]);
	                            ctlPty = cpy + (cpy - prevCmd.points[1]);
	                        }
	                        cpx = p.shift();
	                        cpy = p.shift();
	                        cmd = 'Q';
	                        points.push(ctlPtx, ctlPty, cpx, cpy);
	                        break;
	                    case 't':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        prevCmd = ca[ca.length - 1];
	                        if (prevCmd.command === 'Q') {
	                            ctlPtx = cpx + (cpx - prevCmd.points[0]);
	                            ctlPty = cpy + (cpy - prevCmd.points[1]);
	                        }
	                        cpx += p.shift();
	                        cpy += p.shift();
	                        cmd = 'Q';
	                        points.push(ctlPtx, ctlPty, cpx, cpy);
	                        break;
	                    case 'A':
	                        rx = p.shift();
	                        ry = p.shift();
	                        psi = p.shift();
	                        fa = p.shift();
	                        fs = p.shift();
	                        x1 = cpx;
	                        y1 = cpy;
	                        cpx = p.shift();
	                        cpy = p.shift();
	                        cmd = 'A';
	                        points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
	                        break;
	                    case 'a':
	                        rx = p.shift();
	                        ry = p.shift();
	                        psi = p.shift();
	                        fa = p.shift();
	                        fs = p.shift();
	                        x1 = cpx;
	                        y1 = cpy;
	                        cpx += p.shift();
	                        cpy += p.shift();
	                        cmd = 'A';
	                        points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
	                        break;
	                }
	                ca.push({
	                    command: cmd || c,
	                    points: points,
	                    start: {
	                        x: startX,
	                        y: startY,
	                    },
	                    pathLength: this.calcLength(startX, startY, cmd || c, points),
	                });
	            }
	            if (c === 'z' || c === 'Z') {
	                ca.push({
	                    command: 'z',
	                    points: [],
	                    start: undefined,
	                    pathLength: 0,
	                });
	            }
	        }
	        return ca;
	    }
	    static calcLength(x, y, cmd, points) {
	        let len, p1, p2, t;
	        const path = Path;
	        switch (cmd) {
	            case 'L':
	                return path.getLineLength(x, y, points[0], points[1]);
	            case 'C':
	                return (0, BezierFunctions_1.getCubicArcLength)([x, points[0], points[2], points[4]], [y, points[1], points[3], points[5]], 1);
	            case 'Q':
	                return (0, BezierFunctions_1.getQuadraticArcLength)([x, points[0], points[2]], [y, points[1], points[3]], 1);
	            case 'A':
	                len = 0.0;
	                var start = points[4];
	                var dTheta = points[5];
	                var end = points[4] + dTheta;
	                var inc = Math.PI / 180.0;
	                if (Math.abs(start - end) < inc) {
	                    inc = Math.abs(start - end);
	                }
	                p1 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);
	                if (dTheta < 0) {
	                    for (t = start - inc; t > end; t -= inc) {
	                        p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
	                        len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
	                        p1 = p2;
	                    }
	                }
	                else {
	                    for (t = start + inc; t < end; t += inc) {
	                        p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
	                        len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
	                        p1 = p2;
	                    }
	                }
	                p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);
	                len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
	                return len;
	        }
	        return 0;
	    }
	    static convertEndpointToCenterParameterization(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg) {
	        const psi = psiDeg * (Math.PI / 180.0);
	        const xp = (Math.cos(psi) * (x1 - x2)) / 2.0 + (Math.sin(psi) * (y1 - y2)) / 2.0;
	        const yp = (-1 * Math.sin(psi) * (x1 - x2)) / 2.0 +
	            (Math.cos(psi) * (y1 - y2)) / 2.0;
	        const lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);
	        if (lambda > 1) {
	            rx *= Math.sqrt(lambda);
	            ry *= Math.sqrt(lambda);
	        }
	        let f = Math.sqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) /
	            (rx * rx * (yp * yp) + ry * ry * (xp * xp)));
	        if (fa === fs) {
	            f *= -1;
	        }
	        if (isNaN(f)) {
	            f = 0;
	        }
	        const cxp = (f * rx * yp) / ry;
	        const cyp = (f * -ry * xp) / rx;
	        const cx = (x1 + x2) / 2.0 + Math.cos(psi) * cxp - Math.sin(psi) * cyp;
	        const cy = (y1 + y2) / 2.0 + Math.sin(psi) * cxp + Math.cos(psi) * cyp;
	        const vMag = function (v) {
	            return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
	        };
	        const vRatio = function (u, v) {
	            return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
	        };
	        const vAngle = function (u, v) {
	            return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
	        };
	        const theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
	        const u = [(xp - cxp) / rx, (yp - cyp) / ry];
	        const v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
	        let dTheta = vAngle(u, v);
	        if (vRatio(u, v) <= -1) {
	            dTheta = Math.PI;
	        }
	        if (vRatio(u, v) >= 1) {
	            dTheta = 0;
	        }
	        if (fs === 0 && dTheta > 0) {
	            dTheta = dTheta - 2 * Math.PI;
	        }
	        if (fs === 1 && dTheta < 0) {
	            dTheta = dTheta + 2 * Math.PI;
	        }
	        return [cx, cy, rx, ry, theta, dTheta, psi, fs];
	    }
	};
	Path.Path = Path$1;
	Path$1.prototype.className = 'Path';
	Path$1.prototype._attrsAffectingSize = ['data'];
	(0, Global_1._registerNode)(Path$1);
	Factory_1.Factory.addGetterSetter(Path$1, 'data');
	return Path;
}

var hasRequiredArrow;

function requireArrow () {
	if (hasRequiredArrow) return Arrow;
	hasRequiredArrow = 1;
	Object.defineProperty(Arrow, "__esModule", { value: true });
	Arrow.Arrow = void 0;
	const Factory_1 = requireFactory();
	const Line_1 = requireLine();
	const Validators_1 = requireValidators();
	const Global_1 = requireGlobal();
	const Path_1 = requirePath();
	let Arrow$1 = class Arrow extends Line_1.Line {
	    _sceneFunc(ctx) {
	        super._sceneFunc(ctx);
	        const PI2 = Math.PI * 2;
	        const points = this.points();
	        let tp = points;
	        const fromTension = this.tension() !== 0 && points.length > 4;
	        if (fromTension) {
	            tp = this.getTensionPoints();
	        }
	        const length = this.pointerLength();
	        const n = points.length;
	        let dx, dy;
	        if (fromTension) {
	            const lp = [
	                tp[tp.length - 4],
	                tp[tp.length - 3],
	                tp[tp.length - 2],
	                tp[tp.length - 1],
	                points[n - 2],
	                points[n - 1],
	            ];
	            const lastLength = Path_1.Path.calcLength(tp[tp.length - 4], tp[tp.length - 3], 'C', lp);
	            const previous = Path_1.Path.getPointOnQuadraticBezier(Math.min(1, 1 - length / lastLength), lp[0], lp[1], lp[2], lp[3], lp[4], lp[5]);
	            dx = points[n - 2] - previous.x;
	            dy = points[n - 1] - previous.y;
	        }
	        else {
	            dx = points[n - 2] - points[n - 4];
	            dy = points[n - 1] - points[n - 3];
	        }
	        const radians = (Math.atan2(dy, dx) + PI2) % PI2;
	        const width = this.pointerWidth();
	        if (this.pointerAtEnding()) {
	            ctx.save();
	            ctx.beginPath();
	            ctx.translate(points[n - 2], points[n - 1]);
	            ctx.rotate(radians);
	            ctx.moveTo(0, 0);
	            ctx.lineTo(-length, width / 2);
	            ctx.lineTo(-length, -width / 2);
	            ctx.closePath();
	            ctx.restore();
	            this.__fillStroke(ctx);
	        }
	        if (this.pointerAtBeginning()) {
	            ctx.save();
	            ctx.beginPath();
	            ctx.translate(points[0], points[1]);
	            if (fromTension) {
	                dx = (tp[0] + tp[2]) / 2 - points[0];
	                dy = (tp[1] + tp[3]) / 2 - points[1];
	            }
	            else {
	                dx = points[2] - points[0];
	                dy = points[3] - points[1];
	            }
	            ctx.rotate((Math.atan2(-dy, -dx) + PI2) % PI2);
	            ctx.moveTo(0, 0);
	            ctx.lineTo(-length, width / 2);
	            ctx.lineTo(-length, -width / 2);
	            ctx.closePath();
	            ctx.restore();
	            this.__fillStroke(ctx);
	        }
	    }
	    __fillStroke(ctx) {
	        const isDashEnabled = this.dashEnabled();
	        if (isDashEnabled) {
	            this.attrs.dashEnabled = false;
	            ctx.setLineDash([]);
	        }
	        ctx.fillStrokeShape(this);
	        if (isDashEnabled) {
	            this.attrs.dashEnabled = true;
	        }
	    }
	    getSelfRect() {
	        const lineRect = super.getSelfRect();
	        const offset = this.pointerWidth() / 2;
	        return {
	            x: lineRect.x,
	            y: lineRect.y - offset,
	            width: lineRect.width,
	            height: lineRect.height + offset * 2,
	        };
	    }
	};
	Arrow.Arrow = Arrow$1;
	Arrow$1.prototype.className = 'Arrow';
	(0, Global_1._registerNode)(Arrow$1);
	Factory_1.Factory.addGetterSetter(Arrow$1, 'pointerLength', 10, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Arrow$1, 'pointerWidth', 10, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Arrow$1, 'pointerAtBeginning', false);
	Factory_1.Factory.addGetterSetter(Arrow$1, 'pointerAtEnding', true);
	return Arrow;
}

var Circle$1 = {};

var hasRequiredCircle;

function requireCircle () {
	if (hasRequiredCircle) return Circle$1;
	hasRequiredCircle = 1;
	Object.defineProperty(Circle$1, "__esModule", { value: true });
	Circle$1.Circle = void 0;
	const Factory_1 = requireFactory();
	const Shape_1 = requireShape();
	const Validators_1 = requireValidators();
	const Global_1 = requireGlobal();
	class Circle extends Shape_1.Shape {
	    _sceneFunc(context) {
	        context.beginPath();
	        context.arc(0, 0, this.attrs.radius || 0, 0, Math.PI * 2, false);
	        context.closePath();
	        context.fillStrokeShape(this);
	    }
	    getWidth() {
	        return this.radius() * 2;
	    }
	    getHeight() {
	        return this.radius() * 2;
	    }
	    setWidth(width) {
	        if (this.radius() !== width / 2) {
	            this.radius(width / 2);
	        }
	    }
	    setHeight(height) {
	        if (this.radius() !== height / 2) {
	            this.radius(height / 2);
	        }
	    }
	}
	Circle$1.Circle = Circle;
	Circle.prototype._centroid = true;
	Circle.prototype.className = 'Circle';
	Circle.prototype._attrsAffectingSize = ['radius'];
	(0, Global_1._registerNode)(Circle);
	Factory_1.Factory.addGetterSetter(Circle, 'radius', 0, (0, Validators_1.getNumberValidator)());
	return Circle$1;
}

var Ellipse = {};

var hasRequiredEllipse;

function requireEllipse () {
	if (hasRequiredEllipse) return Ellipse;
	hasRequiredEllipse = 1;
	Object.defineProperty(Ellipse, "__esModule", { value: true });
	Ellipse.Ellipse = void 0;
	const Factory_1 = requireFactory();
	const Shape_1 = requireShape();
	const Validators_1 = requireValidators();
	const Global_1 = requireGlobal();
	let Ellipse$1 = class Ellipse extends Shape_1.Shape {
	    _sceneFunc(context) {
	        const rx = this.radiusX(), ry = this.radiusY();
	        context.beginPath();
	        context.save();
	        if (rx !== ry) {
	            context.scale(1, ry / rx);
	        }
	        context.arc(0, 0, rx, 0, Math.PI * 2, false);
	        context.restore();
	        context.closePath();
	        context.fillStrokeShape(this);
	    }
	    getWidth() {
	        return this.radiusX() * 2;
	    }
	    getHeight() {
	        return this.radiusY() * 2;
	    }
	    setWidth(width) {
	        this.radiusX(width / 2);
	    }
	    setHeight(height) {
	        this.radiusY(height / 2);
	    }
	};
	Ellipse.Ellipse = Ellipse$1;
	Ellipse$1.prototype.className = 'Ellipse';
	Ellipse$1.prototype._centroid = true;
	Ellipse$1.prototype._attrsAffectingSize = ['radiusX', 'radiusY'];
	(0, Global_1._registerNode)(Ellipse$1);
	Factory_1.Factory.addComponentsGetterSetter(Ellipse$1, 'radius', ['x', 'y']);
	Factory_1.Factory.addGetterSetter(Ellipse$1, 'radiusX', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Ellipse$1, 'radiusY', 0, (0, Validators_1.getNumberValidator)());
	return Ellipse;
}

var Image$1 = {};

var hasRequiredImage;

function requireImage () {
	if (hasRequiredImage) return Image$1;
	hasRequiredImage = 1;
	Object.defineProperty(Image$1, "__esModule", { value: true });
	Image$1.Image = void 0;
	const Util_1 = requireUtil();
	const Factory_1 = requireFactory();
	const Shape_1 = requireShape();
	const Global_1 = requireGlobal();
	const Validators_1 = requireValidators();
	class Image extends Shape_1.Shape {
	    constructor(attrs) {
	        super(attrs);
	        this._loadListener = () => {
	            this._requestDraw();
	        };
	        this.on('imageChange.konva', (props) => {
	            this._removeImageLoad(props.oldVal);
	            this._setImageLoad();
	        });
	        this._setImageLoad();
	    }
	    _setImageLoad() {
	        const image = this.image();
	        if (image && image.complete) {
	            return;
	        }
	        if (image && image.readyState === 4) {
	            return;
	        }
	        if (image && image['addEventListener']) {
	            image['addEventListener']('load', this._loadListener);
	        }
	    }
	    _removeImageLoad(image) {
	        if (image && image['removeEventListener']) {
	            image['removeEventListener']('load', this._loadListener);
	        }
	    }
	    destroy() {
	        this._removeImageLoad(this.image());
	        super.destroy();
	        return this;
	    }
	    _useBufferCanvas() {
	        const hasCornerRadius = !!this.cornerRadius();
	        const hasShadow = this.hasShadow();
	        if (hasCornerRadius && hasShadow) {
	            return true;
	        }
	        return super._useBufferCanvas(true);
	    }
	    _sceneFunc(context) {
	        const width = this.getWidth();
	        const height = this.getHeight();
	        const cornerRadius = this.cornerRadius();
	        const image = this.attrs.image;
	        let params;
	        if (image) {
	            const cropWidth = this.attrs.cropWidth;
	            const cropHeight = this.attrs.cropHeight;
	            if (cropWidth && cropHeight) {
	                params = [
	                    image,
	                    this.cropX(),
	                    this.cropY(),
	                    cropWidth,
	                    cropHeight,
	                    0,
	                    0,
	                    width,
	                    height,
	                ];
	            }
	            else {
	                params = [image, 0, 0, width, height];
	            }
	        }
	        if (this.hasFill() || this.hasStroke() || cornerRadius) {
	            context.beginPath();
	            cornerRadius
	                ? Util_1.Util.drawRoundedRectPath(context, width, height, cornerRadius)
	                : context.rect(0, 0, width, height);
	            context.closePath();
	            context.fillStrokeShape(this);
	        }
	        if (image) {
	            if (cornerRadius) {
	                context.clip();
	            }
	            context.drawImage.apply(context, params);
	        }
	    }
	    _hitFunc(context) {
	        const width = this.width(), height = this.height(), cornerRadius = this.cornerRadius();
	        context.beginPath();
	        if (!cornerRadius) {
	            context.rect(0, 0, width, height);
	        }
	        else {
	            Util_1.Util.drawRoundedRectPath(context, width, height, cornerRadius);
	        }
	        context.closePath();
	        context.fillStrokeShape(this);
	    }
	    getWidth() {
	        var _a, _b;
	        return (_a = this.attrs.width) !== null && _a !== void 0 ? _a : (_b = this.image()) === null || _b === void 0 ? void 0 : _b.width;
	    }
	    getHeight() {
	        var _a, _b;
	        return (_a = this.attrs.height) !== null && _a !== void 0 ? _a : (_b = this.image()) === null || _b === void 0 ? void 0 : _b.height;
	    }
	    static fromURL(url, callback, onError = null) {
	        const img = Util_1.Util.createImageElement();
	        img.onload = function () {
	            const image = new Image({
	                image: img,
	            });
	            callback(image);
	        };
	        img.onerror = onError;
	        img.crossOrigin = 'Anonymous';
	        img.src = url;
	    }
	}
	Image$1.Image = Image;
	Image.prototype.className = 'Image';
	(0, Global_1._registerNode)(Image);
	Factory_1.Factory.addGetterSetter(Image, 'cornerRadius', 0, (0, Validators_1.getNumberOrArrayOfNumbersValidator)(4));
	Factory_1.Factory.addGetterSetter(Image, 'image');
	Factory_1.Factory.addComponentsGetterSetter(Image, 'crop', ['x', 'y', 'width', 'height']);
	Factory_1.Factory.addGetterSetter(Image, 'cropX', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Image, 'cropY', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Image, 'cropWidth', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Image, 'cropHeight', 0, (0, Validators_1.getNumberValidator)());
	return Image$1;
}

var Label = {};

var hasRequiredLabel;

function requireLabel () {
	if (hasRequiredLabel) return Label;
	hasRequiredLabel = 1;
	Object.defineProperty(Label, "__esModule", { value: true });
	Label.Tag = Label.Label = void 0;
	const Factory_1 = requireFactory();
	const Shape_1 = requireShape();
	const Group_1 = requireGroup();
	const Validators_1 = requireValidators();
	const Global_1 = requireGlobal();
	const ATTR_CHANGE_LIST = [
	    'fontFamily',
	    'fontSize',
	    'fontStyle',
	    'padding',
	    'lineHeight',
	    'text',
	    'width',
	    'height',
	    'pointerDirection',
	    'pointerWidth',
	    'pointerHeight',
	], CHANGE_KONVA = 'Change.konva', NONE = 'none', UP = 'up', RIGHT = 'right', DOWN = 'down', LEFT = 'left', attrChangeListLen = ATTR_CHANGE_LIST.length;
	let Label$1 = class Label extends Group_1.Group {
	    constructor(config) {
	        super(config);
	        this.on('add.konva', function (evt) {
	            this._addListeners(evt.child);
	            this._sync();
	        });
	    }
	    getText() {
	        return this.find('Text')[0];
	    }
	    getTag() {
	        return this.find('Tag')[0];
	    }
	    _addListeners(text) {
	        let that = this, n;
	        const func = function () {
	            that._sync();
	        };
	        for (n = 0; n < attrChangeListLen; n++) {
	            text.on(ATTR_CHANGE_LIST[n] + CHANGE_KONVA, func);
	        }
	    }
	    getWidth() {
	        return this.getText().width();
	    }
	    getHeight() {
	        return this.getText().height();
	    }
	    _sync() {
	        let text = this.getText(), tag = this.getTag(), width, height, pointerDirection, pointerWidth, x, y, pointerHeight;
	        if (text && tag) {
	            width = text.width();
	            height = text.height();
	            pointerDirection = tag.pointerDirection();
	            pointerWidth = tag.pointerWidth();
	            pointerHeight = tag.pointerHeight();
	            x = 0;
	            y = 0;
	            switch (pointerDirection) {
	                case UP:
	                    x = width / 2;
	                    y = -1 * pointerHeight;
	                    break;
	                case RIGHT:
	                    x = width + pointerWidth;
	                    y = height / 2;
	                    break;
	                case DOWN:
	                    x = width / 2;
	                    y = height + pointerHeight;
	                    break;
	                case LEFT:
	                    x = -1 * pointerWidth;
	                    y = height / 2;
	                    break;
	            }
	            tag.setAttrs({
	                x: -1 * x,
	                y: -1 * y,
	                width: width,
	                height: height,
	            });
	            text.setAttrs({
	                x: -1 * x,
	                y: -1 * y,
	            });
	        }
	    }
	};
	Label.Label = Label$1;
	Label$1.prototype.className = 'Label';
	(0, Global_1._registerNode)(Label$1);
	class Tag extends Shape_1.Shape {
	    _sceneFunc(context) {
	        const width = this.width(), height = this.height(), pointerDirection = this.pointerDirection(), pointerWidth = this.pointerWidth(), pointerHeight = this.pointerHeight(), cornerRadius = this.cornerRadius();
	        let topLeft = 0;
	        let topRight = 0;
	        let bottomLeft = 0;
	        let bottomRight = 0;
	        if (typeof cornerRadius === 'number') {
	            topLeft =
	                topRight =
	                    bottomLeft =
	                        bottomRight =
	                            Math.min(cornerRadius, width / 2, height / 2);
	        }
	        else {
	            topLeft = Math.min(cornerRadius[0] || 0, width / 2, height / 2);
	            topRight = Math.min(cornerRadius[1] || 0, width / 2, height / 2);
	            bottomRight = Math.min(cornerRadius[2] || 0, width / 2, height / 2);
	            bottomLeft = Math.min(cornerRadius[3] || 0, width / 2, height / 2);
	        }
	        context.beginPath();
	        context.moveTo(topLeft, 0);
	        if (pointerDirection === UP) {
	            context.lineTo((width - pointerWidth) / 2, 0);
	            context.lineTo(width / 2, -1 * pointerHeight);
	            context.lineTo((width + pointerWidth) / 2, 0);
	        }
	        context.lineTo(width - topRight, 0);
	        context.arc(width - topRight, topRight, topRight, (Math.PI * 3) / 2, 0, false);
	        if (pointerDirection === RIGHT) {
	            context.lineTo(width, (height - pointerHeight) / 2);
	            context.lineTo(width + pointerWidth, height / 2);
	            context.lineTo(width, (height + pointerHeight) / 2);
	        }
	        context.lineTo(width, height - bottomRight);
	        context.arc(width - bottomRight, height - bottomRight, bottomRight, 0, Math.PI / 2, false);
	        if (pointerDirection === DOWN) {
	            context.lineTo((width + pointerWidth) / 2, height);
	            context.lineTo(width / 2, height + pointerHeight);
	            context.lineTo((width - pointerWidth) / 2, height);
	        }
	        context.lineTo(bottomLeft, height);
	        context.arc(bottomLeft, height - bottomLeft, bottomLeft, Math.PI / 2, Math.PI, false);
	        if (pointerDirection === LEFT) {
	            context.lineTo(0, (height + pointerHeight) / 2);
	            context.lineTo(-1 * pointerWidth, height / 2);
	            context.lineTo(0, (height - pointerHeight) / 2);
	        }
	        context.lineTo(0, topLeft);
	        context.arc(topLeft, topLeft, topLeft, Math.PI, (Math.PI * 3) / 2, false);
	        context.closePath();
	        context.fillStrokeShape(this);
	    }
	    getSelfRect() {
	        let x = 0, y = 0, pointerWidth = this.pointerWidth(), pointerHeight = this.pointerHeight(), direction = this.pointerDirection(), width = this.width(), height = this.height();
	        if (direction === UP) {
	            y -= pointerHeight;
	            height += pointerHeight;
	        }
	        else if (direction === DOWN) {
	            height += pointerHeight;
	        }
	        else if (direction === LEFT) {
	            x -= pointerWidth * 1.5;
	            width += pointerWidth;
	        }
	        else if (direction === RIGHT) {
	            width += pointerWidth * 1.5;
	        }
	        return {
	            x: x,
	            y: y,
	            width: width,
	            height: height,
	        };
	    }
	}
	Label.Tag = Tag;
	Tag.prototype.className = 'Tag';
	(0, Global_1._registerNode)(Tag);
	Factory_1.Factory.addGetterSetter(Tag, 'pointerDirection', NONE);
	Factory_1.Factory.addGetterSetter(Tag, 'pointerWidth', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Tag, 'pointerHeight', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Tag, 'cornerRadius', 0, (0, Validators_1.getNumberOrArrayOfNumbersValidator)(4));
	return Label;
}

var Rect$1 = {};

var hasRequiredRect;

function requireRect () {
	if (hasRequiredRect) return Rect$1;
	hasRequiredRect = 1;
	Object.defineProperty(Rect$1, "__esModule", { value: true });
	Rect$1.Rect = void 0;
	const Factory_1 = requireFactory();
	const Shape_1 = requireShape();
	const Global_1 = requireGlobal();
	const Util_1 = requireUtil();
	const Validators_1 = requireValidators();
	class Rect extends Shape_1.Shape {
	    _sceneFunc(context) {
	        const cornerRadius = this.cornerRadius(), width = this.width(), height = this.height();
	        context.beginPath();
	        if (!cornerRadius) {
	            context.rect(0, 0, width, height);
	        }
	        else {
	            Util_1.Util.drawRoundedRectPath(context, width, height, cornerRadius);
	        }
	        context.closePath();
	        context.fillStrokeShape(this);
	    }
	}
	Rect$1.Rect = Rect;
	Rect.prototype.className = 'Rect';
	(0, Global_1._registerNode)(Rect);
	Factory_1.Factory.addGetterSetter(Rect, 'cornerRadius', 0, (0, Validators_1.getNumberOrArrayOfNumbersValidator)(4));
	return Rect$1;
}

var RegularPolygon = {};

var hasRequiredRegularPolygon;

function requireRegularPolygon () {
	if (hasRequiredRegularPolygon) return RegularPolygon;
	hasRequiredRegularPolygon = 1;
	Object.defineProperty(RegularPolygon, "__esModule", { value: true });
	RegularPolygon.RegularPolygon = void 0;
	const Factory_1 = requireFactory();
	const Shape_1 = requireShape();
	const Validators_1 = requireValidators();
	const Global_1 = requireGlobal();
	let RegularPolygon$1 = class RegularPolygon extends Shape_1.Shape {
	    _sceneFunc(context) {
	        const points = this._getPoints();
	        context.beginPath();
	        context.moveTo(points[0].x, points[0].y);
	        for (let n = 1; n < points.length; n++) {
	            context.lineTo(points[n].x, points[n].y);
	        }
	        context.closePath();
	        context.fillStrokeShape(this);
	    }
	    _getPoints() {
	        const sides = this.attrs.sides;
	        const radius = this.attrs.radius || 0;
	        const points = [];
	        for (let n = 0; n < sides; n++) {
	            points.push({
	                x: radius * Math.sin((n * 2 * Math.PI) / sides),
	                y: -1 * radius * Math.cos((n * 2 * Math.PI) / sides),
	            });
	        }
	        return points;
	    }
	    getSelfRect() {
	        const points = this._getPoints();
	        let minX = points[0].x;
	        let maxX = points[0].y;
	        let minY = points[0].x;
	        let maxY = points[0].y;
	        points.forEach((point) => {
	            minX = Math.min(minX, point.x);
	            maxX = Math.max(maxX, point.x);
	            minY = Math.min(minY, point.y);
	            maxY = Math.max(maxY, point.y);
	        });
	        return {
	            x: minX,
	            y: minY,
	            width: maxX - minX,
	            height: maxY - minY,
	        };
	    }
	    getWidth() {
	        return this.radius() * 2;
	    }
	    getHeight() {
	        return this.radius() * 2;
	    }
	    setWidth(width) {
	        this.radius(width / 2);
	    }
	    setHeight(height) {
	        this.radius(height / 2);
	    }
	};
	RegularPolygon.RegularPolygon = RegularPolygon$1;
	RegularPolygon$1.prototype.className = 'RegularPolygon';
	RegularPolygon$1.prototype._centroid = true;
	RegularPolygon$1.prototype._attrsAffectingSize = ['radius'];
	(0, Global_1._registerNode)(RegularPolygon$1);
	Factory_1.Factory.addGetterSetter(RegularPolygon$1, 'radius', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(RegularPolygon$1, 'sides', 0, (0, Validators_1.getNumberValidator)());
	return RegularPolygon;
}

var Ring = {};

var hasRequiredRing;

function requireRing () {
	if (hasRequiredRing) return Ring;
	hasRequiredRing = 1;
	Object.defineProperty(Ring, "__esModule", { value: true });
	Ring.Ring = void 0;
	const Factory_1 = requireFactory();
	const Shape_1 = requireShape();
	const Validators_1 = requireValidators();
	const Global_1 = requireGlobal();
	const PIx2 = Math.PI * 2;
	let Ring$1 = class Ring extends Shape_1.Shape {
	    _sceneFunc(context) {
	        context.beginPath();
	        context.arc(0, 0, this.innerRadius(), 0, PIx2, false);
	        context.moveTo(this.outerRadius(), 0);
	        context.arc(0, 0, this.outerRadius(), PIx2, 0, true);
	        context.closePath();
	        context.fillStrokeShape(this);
	    }
	    getWidth() {
	        return this.outerRadius() * 2;
	    }
	    getHeight() {
	        return this.outerRadius() * 2;
	    }
	    setWidth(width) {
	        this.outerRadius(width / 2);
	    }
	    setHeight(height) {
	        this.outerRadius(height / 2);
	    }
	};
	Ring.Ring = Ring$1;
	Ring$1.prototype.className = 'Ring';
	Ring$1.prototype._centroid = true;
	Ring$1.prototype._attrsAffectingSize = ['innerRadius', 'outerRadius'];
	(0, Global_1._registerNode)(Ring$1);
	Factory_1.Factory.addGetterSetter(Ring$1, 'innerRadius', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Ring$1, 'outerRadius', 0, (0, Validators_1.getNumberValidator)());
	return Ring;
}

var Sprite = {};

var hasRequiredSprite;

function requireSprite () {
	if (hasRequiredSprite) return Sprite;
	hasRequiredSprite = 1;
	Object.defineProperty(Sprite, "__esModule", { value: true });
	Sprite.Sprite = void 0;
	const Factory_1 = requireFactory();
	const Shape_1 = requireShape();
	const Animation_1 = requireAnimation();
	const Validators_1 = requireValidators();
	const Global_1 = requireGlobal();
	let Sprite$1 = class Sprite extends Shape_1.Shape {
	    constructor(config) {
	        super(config);
	        this._updated = true;
	        this.anim = new Animation_1.Animation(() => {
	            const updated = this._updated;
	            this._updated = false;
	            return updated;
	        });
	        this.on('animationChange.konva', function () {
	            this.frameIndex(0);
	        });
	        this.on('frameIndexChange.konva', function () {
	            this._updated = true;
	        });
	        this.on('frameRateChange.konva', function () {
	            if (!this.anim.isRunning()) {
	                return;
	            }
	            clearInterval(this.interval);
	            this._setInterval();
	        });
	    }
	    _sceneFunc(context) {
	        const anim = this.animation(), index = this.frameIndex(), ix4 = index * 4, set = this.animations()[anim], offsets = this.frameOffsets(), x = set[ix4 + 0], y = set[ix4 + 1], width = set[ix4 + 2], height = set[ix4 + 3], image = this.image();
	        if (this.hasFill() || this.hasStroke()) {
	            context.beginPath();
	            context.rect(0, 0, width, height);
	            context.closePath();
	            context.fillStrokeShape(this);
	        }
	        if (image) {
	            if (offsets) {
	                const offset = offsets[anim], ix2 = index * 2;
	                context.drawImage(image, x, y, width, height, offset[ix2 + 0], offset[ix2 + 1], width, height);
	            }
	            else {
	                context.drawImage(image, x, y, width, height, 0, 0, width, height);
	            }
	        }
	    }
	    _hitFunc(context) {
	        const anim = this.animation(), index = this.frameIndex(), ix4 = index * 4, set = this.animations()[anim], offsets = this.frameOffsets(), width = set[ix4 + 2], height = set[ix4 + 3];
	        context.beginPath();
	        if (offsets) {
	            const offset = offsets[anim];
	            const ix2 = index * 2;
	            context.rect(offset[ix2 + 0], offset[ix2 + 1], width, height);
	        }
	        else {
	            context.rect(0, 0, width, height);
	        }
	        context.closePath();
	        context.fillShape(this);
	    }
	    _useBufferCanvas() {
	        return super._useBufferCanvas(true);
	    }
	    _setInterval() {
	        const that = this;
	        this.interval = setInterval(function () {
	            that._updateIndex();
	        }, 1000 / this.frameRate());
	    }
	    start() {
	        if (this.isRunning()) {
	            return;
	        }
	        const layer = this.getLayer();
	        this.anim.setLayers(layer);
	        this._setInterval();
	        this.anim.start();
	    }
	    stop() {
	        this.anim.stop();
	        clearInterval(this.interval);
	    }
	    isRunning() {
	        return this.anim.isRunning();
	    }
	    _updateIndex() {
	        const index = this.frameIndex(), animation = this.animation(), animations = this.animations(), anim = animations[animation], len = anim.length / 4;
	        if (index < len - 1) {
	            this.frameIndex(index + 1);
	        }
	        else {
	            this.frameIndex(0);
	        }
	    }
	};
	Sprite.Sprite = Sprite$1;
	Sprite$1.prototype.className = 'Sprite';
	(0, Global_1._registerNode)(Sprite$1);
	Factory_1.Factory.addGetterSetter(Sprite$1, 'animation');
	Factory_1.Factory.addGetterSetter(Sprite$1, 'animations');
	Factory_1.Factory.addGetterSetter(Sprite$1, 'frameOffsets');
	Factory_1.Factory.addGetterSetter(Sprite$1, 'image');
	Factory_1.Factory.addGetterSetter(Sprite$1, 'frameIndex', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Sprite$1, 'frameRate', 17, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.backCompat(Sprite$1, {
	    index: 'frameIndex',
	    getIndex: 'getFrameIndex',
	    setIndex: 'setFrameIndex',
	});
	return Sprite;
}

var Star = {};

var hasRequiredStar;

function requireStar () {
	if (hasRequiredStar) return Star;
	hasRequiredStar = 1;
	Object.defineProperty(Star, "__esModule", { value: true });
	Star.Star = void 0;
	const Factory_1 = requireFactory();
	const Shape_1 = requireShape();
	const Validators_1 = requireValidators();
	const Global_1 = requireGlobal();
	let Star$1 = class Star extends Shape_1.Shape {
	    _sceneFunc(context) {
	        const innerRadius = this.innerRadius(), outerRadius = this.outerRadius(), numPoints = this.numPoints();
	        context.beginPath();
	        context.moveTo(0, 0 - outerRadius);
	        for (let n = 1; n < numPoints * 2; n++) {
	            const radius = n % 2 === 0 ? outerRadius : innerRadius;
	            const x = radius * Math.sin((n * Math.PI) / numPoints);
	            const y = -1 * radius * Math.cos((n * Math.PI) / numPoints);
	            context.lineTo(x, y);
	        }
	        context.closePath();
	        context.fillStrokeShape(this);
	    }
	    getWidth() {
	        return this.outerRadius() * 2;
	    }
	    getHeight() {
	        return this.outerRadius() * 2;
	    }
	    setWidth(width) {
	        this.outerRadius(width / 2);
	    }
	    setHeight(height) {
	        this.outerRadius(height / 2);
	    }
	};
	Star.Star = Star$1;
	Star$1.prototype.className = 'Star';
	Star$1.prototype._centroid = true;
	Star$1.prototype._attrsAffectingSize = ['innerRadius', 'outerRadius'];
	(0, Global_1._registerNode)(Star$1);
	Factory_1.Factory.addGetterSetter(Star$1, 'numPoints', 5, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Star$1, 'innerRadius', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Star$1, 'outerRadius', 0, (0, Validators_1.getNumberValidator)());
	return Star;
}

var Text = {};

var hasRequiredText;

function requireText () {
	if (hasRequiredText) return Text;
	hasRequiredText = 1;
	Object.defineProperty(Text, "__esModule", { value: true });
	Text.Text = void 0;
	Text.stringToArray = stringToArray;
	const Util_1 = requireUtil();
	const Factory_1 = requireFactory();
	const Shape_1 = requireShape();
	const Global_1 = requireGlobal();
	const Validators_1 = requireValidators();
	const Global_2 = requireGlobal();
	function stringToArray(string) {
	    return [...string].reduce((acc, char, index, array) => {
	        if (/\p{Emoji}/u.test(char)) {
	            const nextChar = array[index + 1];
	            if (nextChar && /\p{Emoji_Modifier}|\u200D/u.test(nextChar)) {
	                acc.push(char + nextChar);
	                array[index + 1] = '';
	            }
	            else {
	                acc.push(char);
	            }
	        }
	        else if (/\p{Regional_Indicator}{2}/u.test(char + (array[index + 1] || ''))) {
	            acc.push(char + array[index + 1]);
	        }
	        else if (index > 0 && /\p{Mn}|\p{Me}|\p{Mc}/u.test(char)) {
	            acc[acc.length - 1] += char;
	        }
	        else if (char) {
	            acc.push(char);
	        }
	        return acc;
	    }, []);
	}
	const AUTO = 'auto', CENTER = 'center', INHERIT = 'inherit', JUSTIFY = 'justify', CHANGE_KONVA = 'Change.konva', CONTEXT_2D = '2d', DASH = '-', LEFT = 'left', TEXT = 'text', TEXT_UPPER = 'Text', TOP = 'top', BOTTOM = 'bottom', MIDDLE = 'middle', NORMAL = 'normal', PX_SPACE = 'px ', SPACE = ' ', RIGHT = 'right', RTL = 'rtl', WORD = 'word', CHAR = 'char', NONE = 'none', ELLIPSIS = '…', ATTR_CHANGE_LIST = [
	    'direction',
	    'fontFamily',
	    'fontSize',
	    'fontStyle',
	    'fontVariant',
	    'padding',
	    'align',
	    'verticalAlign',
	    'lineHeight',
	    'text',
	    'width',
	    'height',
	    'wrap',
	    'ellipsis',
	    'letterSpacing',
	], attrChangeListLen = ATTR_CHANGE_LIST.length;
	function normalizeFontFamily(fontFamily) {
	    return fontFamily
	        .split(',')
	        .map((family) => {
	        family = family.trim();
	        const hasSpace = family.indexOf(' ') >= 0;
	        const hasQuotes = family.indexOf('"') >= 0 || family.indexOf("'") >= 0;
	        if (hasSpace && !hasQuotes) {
	            family = `"${family}"`;
	        }
	        return family;
	    })
	        .join(', ');
	}
	let dummyContext;
	function getDummyContext() {
	    if (dummyContext) {
	        return dummyContext;
	    }
	    dummyContext = Util_1.Util.createCanvasElement().getContext(CONTEXT_2D);
	    return dummyContext;
	}
	function _fillFunc(context) {
	    context.fillText(this._partialText, this._partialTextX, this._partialTextY);
	}
	function _strokeFunc(context) {
	    context.setAttr('miterLimit', 2);
	    context.strokeText(this._partialText, this._partialTextX, this._partialTextY);
	}
	function checkDefaultFill(config) {
	    config = config || {};
	    if (!config.fillLinearGradientColorStops &&
	        !config.fillRadialGradientColorStops &&
	        !config.fillPatternImage) {
	        config.fill = config.fill || 'black';
	    }
	    return config;
	}
	let Text$1 = class Text extends Shape_1.Shape {
	    constructor(config) {
	        super(checkDefaultFill(config));
	        this._partialTextX = 0;
	        this._partialTextY = 0;
	        for (let n = 0; n < attrChangeListLen; n++) {
	            this.on(ATTR_CHANGE_LIST[n] + CHANGE_KONVA, this._setTextData);
	        }
	        this._setTextData();
	    }
	    _sceneFunc(context) {
	        const textArr = this.textArr, textArrLen = textArr.length;
	        if (!this.text()) {
	            return;
	        }
	        let padding = this.padding(), fontSize = this.fontSize(), lineHeightPx = this.lineHeight() * fontSize, verticalAlign = this.verticalAlign(), direction = this.direction(), alignY = 0, align = this.align(), totalWidth = this.getWidth(), letterSpacing = this.letterSpacing(), fill = this.fill(), textDecoration = this.textDecoration(), shouldUnderline = textDecoration.indexOf('underline') !== -1, shouldLineThrough = textDecoration.indexOf('line-through') !== -1, n;
	        direction = direction === INHERIT ? context.direction : direction;
	        let translateY = lineHeightPx / 2;
	        let baseline = MIDDLE;
	        if (Global_1.Konva._fixTextRendering) {
	            const metrics = this.measureSize('M');
	            baseline = 'alphabetic';
	            translateY =
	                (metrics.fontBoundingBoxAscent - metrics.fontBoundingBoxDescent) / 2 +
	                    lineHeightPx / 2;
	        }
	        var lineTranslateX = 0;
	        var lineTranslateY = 0;
	        if (direction === RTL) {
	            context.setAttr('direction', direction);
	        }
	        context.setAttr('font', this._getContextFont());
	        context.setAttr('textBaseline', baseline);
	        context.setAttr('textAlign', LEFT);
	        if (verticalAlign === MIDDLE) {
	            alignY = (this.getHeight() - textArrLen * lineHeightPx - padding * 2) / 2;
	        }
	        else if (verticalAlign === BOTTOM) {
	            alignY = this.getHeight() - textArrLen * lineHeightPx - padding * 2;
	        }
	        context.translate(padding, alignY + padding);
	        for (n = 0; n < textArrLen; n++) {
	            var lineTranslateX = 0;
	            var lineTranslateY = 0;
	            var obj = textArr[n], text = obj.text, width = obj.width, lastLine = obj.lastInParagraph, spacesNumber, lineWidth;
	            context.save();
	            if (align === RIGHT) {
	                lineTranslateX += totalWidth - width - padding * 2;
	            }
	            else if (align === CENTER) {
	                lineTranslateX += (totalWidth - width - padding * 2) / 2;
	            }
	            if (shouldUnderline) {
	                context.save();
	                context.beginPath();
	                const yOffset = Global_1.Konva._fixTextRendering
	                    ? Math.round(fontSize / 4)
	                    : Math.round(fontSize / 2);
	                const x = lineTranslateX;
	                const y = translateY + lineTranslateY + yOffset;
	                context.moveTo(x, y);
	                spacesNumber = text.split(' ').length - 1;
	                lineWidth =
	                    align === JUSTIFY && !lastLine ? totalWidth - padding * 2 : width;
	                context.lineTo(x + Math.round(lineWidth), y);
	                context.lineWidth = fontSize / 15;
	                const gradient = this._getLinearGradient();
	                context.strokeStyle = gradient || fill;
	                context.stroke();
	                context.restore();
	            }
	            if (shouldLineThrough) {
	                context.save();
	                context.beginPath();
	                const yOffset = Global_1.Konva._fixTextRendering ? -Math.round(fontSize / 4) : 0;
	                context.moveTo(lineTranslateX, translateY + lineTranslateY + yOffset);
	                spacesNumber = text.split(' ').length - 1;
	                lineWidth =
	                    align === JUSTIFY && !lastLine ? totalWidth - padding * 2 : width;
	                context.lineTo(lineTranslateX + Math.round(lineWidth), translateY + lineTranslateY + yOffset);
	                context.lineWidth = fontSize / 15;
	                const gradient = this._getLinearGradient();
	                context.strokeStyle = gradient || fill;
	                context.stroke();
	                context.restore();
	            }
	            if (direction !== RTL && (letterSpacing !== 0 || align === JUSTIFY)) {
	                spacesNumber = text.split(' ').length - 1;
	                const array = stringToArray(text);
	                for (let li = 0; li < array.length; li++) {
	                    const letter = array[li];
	                    if (letter === ' ' && !lastLine && align === JUSTIFY) {
	                        lineTranslateX += (totalWidth - padding * 2 - width) / spacesNumber;
	                    }
	                    this._partialTextX = lineTranslateX;
	                    this._partialTextY = translateY + lineTranslateY;
	                    this._partialText = letter;
	                    context.fillStrokeShape(this);
	                    lineTranslateX += this.measureSize(letter).width + letterSpacing;
	                }
	            }
	            else {
	                if (letterSpacing !== 0) {
	                    context.setAttr('letterSpacing', `${letterSpacing}px`);
	                }
	                this._partialTextX = lineTranslateX;
	                this._partialTextY = translateY + lineTranslateY;
	                this._partialText = text;
	                context.fillStrokeShape(this);
	            }
	            context.restore();
	            if (textArrLen > 1) {
	                translateY += lineHeightPx;
	            }
	        }
	    }
	    _hitFunc(context) {
	        const width = this.getWidth(), height = this.getHeight();
	        context.beginPath();
	        context.rect(0, 0, width, height);
	        context.closePath();
	        context.fillStrokeShape(this);
	    }
	    setText(text) {
	        const str = Util_1.Util._isString(text)
	            ? text
	            : text === null || text === undefined
	                ? ''
	                : text + '';
	        this._setAttr(TEXT, str);
	        return this;
	    }
	    getWidth() {
	        const isAuto = this.attrs.width === AUTO || this.attrs.width === undefined;
	        return isAuto ? this.getTextWidth() + this.padding() * 2 : this.attrs.width;
	    }
	    getHeight() {
	        const isAuto = this.attrs.height === AUTO || this.attrs.height === undefined;
	        return isAuto
	            ? this.fontSize() * this.textArr.length * this.lineHeight() +
	                this.padding() * 2
	            : this.attrs.height;
	    }
	    getTextWidth() {
	        return this.textWidth;
	    }
	    getTextHeight() {
	        Util_1.Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');
	        return this.textHeight;
	    }
	    measureSize(text) {
	        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
	        let _context = getDummyContext(), fontSize = this.fontSize(), metrics;
	        _context.save();
	        _context.font = this._getContextFont();
	        metrics = _context.measureText(text);
	        _context.restore();
	        const scaleFactor = fontSize / 100;
	        return {
	            actualBoundingBoxAscent: (_a = metrics.actualBoundingBoxAscent) !== null && _a !== void 0 ? _a : 71.58203125 * scaleFactor,
	            actualBoundingBoxDescent: (_b = metrics.actualBoundingBoxDescent) !== null && _b !== void 0 ? _b : 0,
	            actualBoundingBoxLeft: (_c = metrics.actualBoundingBoxLeft) !== null && _c !== void 0 ? _c : -7.421875 * scaleFactor,
	            actualBoundingBoxRight: (_d = metrics.actualBoundingBoxRight) !== null && _d !== void 0 ? _d : 75.732421875 * scaleFactor,
	            alphabeticBaseline: (_e = metrics.alphabeticBaseline) !== null && _e !== void 0 ? _e : 0,
	            emHeightAscent: (_f = metrics.emHeightAscent) !== null && _f !== void 0 ? _f : 100 * scaleFactor,
	            emHeightDescent: (_g = metrics.emHeightDescent) !== null && _g !== void 0 ? _g : -20 * scaleFactor,
	            fontBoundingBoxAscent: (_h = metrics.fontBoundingBoxAscent) !== null && _h !== void 0 ? _h : 91 * scaleFactor,
	            fontBoundingBoxDescent: (_j = metrics.fontBoundingBoxDescent) !== null && _j !== void 0 ? _j : 21 * scaleFactor,
	            hangingBaseline: (_k = metrics.hangingBaseline) !== null && _k !== void 0 ? _k : 72.80000305175781 * scaleFactor,
	            ideographicBaseline: (_l = metrics.ideographicBaseline) !== null && _l !== void 0 ? _l : -21 * scaleFactor,
	            width: metrics.width,
	            height: fontSize,
	        };
	    }
	    _getContextFont() {
	        return (this.fontStyle() +
	            SPACE +
	            this.fontVariant() +
	            SPACE +
	            (this.fontSize() + PX_SPACE) +
	            normalizeFontFamily(this.fontFamily()));
	    }
	    _addTextLine(line) {
	        const align = this.align();
	        if (align === JUSTIFY) {
	            line = line.trim();
	        }
	        const width = this._getTextWidth(line);
	        return this.textArr.push({
	            text: line,
	            width: width,
	            lastInParagraph: false,
	        });
	    }
	    _getTextWidth(text) {
	        const letterSpacing = this.letterSpacing();
	        const length = text.length;
	        return getDummyContext().measureText(text).width + letterSpacing * length;
	    }
	    _setTextData() {
	        let lines = this.text().split('\n'), fontSize = +this.fontSize(), textWidth = 0, lineHeightPx = this.lineHeight() * fontSize, width = this.attrs.width, height = this.attrs.height, fixedWidth = width !== AUTO && width !== undefined, fixedHeight = height !== AUTO && height !== undefined, padding = this.padding(), maxWidth = width - padding * 2, maxHeightPx = height - padding * 2, currentHeightPx = 0, wrap = this.wrap(), shouldWrap = wrap !== NONE, wrapAtWord = wrap !== CHAR && shouldWrap, shouldAddEllipsis = this.ellipsis();
	        this.textArr = [];
	        getDummyContext().font = this._getContextFont();
	        const additionalWidth = shouldAddEllipsis
	            ? this._getTextWidth(ELLIPSIS)
	            : 0;
	        for (let i = 0, max = lines.length; i < max; ++i) {
	            let line = lines[i];
	            let lineWidth = this._getTextWidth(line);
	            if (fixedWidth && lineWidth > maxWidth) {
	                while (line.length > 0) {
	                    let low = 0, high = stringToArray(line).length, match = '', matchWidth = 0;
	                    while (low < high) {
	                        const mid = (low + high) >>> 1, lineArray = stringToArray(line), substr = lineArray.slice(0, mid + 1).join(''), substrWidth = this._getTextWidth(substr);
	                        const shouldConsiderEllipsis = shouldAddEllipsis &&
	                            fixedHeight &&
	                            currentHeightPx + lineHeightPx > maxHeightPx;
	                        const effectiveWidth = shouldConsiderEllipsis
	                            ? substrWidth + additionalWidth
	                            : substrWidth;
	                        if (effectiveWidth <= maxWidth) {
	                            low = mid + 1;
	                            match = substr;
	                            matchWidth = substrWidth;
	                        }
	                        else {
	                            high = mid;
	                        }
	                    }
	                    if (match) {
	                        if (wrapAtWord) {
	                            const lineArray = stringToArray(line);
	                            const matchArray = stringToArray(match);
	                            const nextChar = lineArray[matchArray.length];
	                            const nextIsSpaceOrDash = nextChar === SPACE || nextChar === DASH;
	                            let wrapIndex;
	                            if (nextIsSpaceOrDash && matchWidth <= maxWidth) {
	                                wrapIndex = matchArray.length;
	                            }
	                            else {
	                                const lastSpaceIndex = matchArray.lastIndexOf(SPACE);
	                                const lastDashIndex = matchArray.lastIndexOf(DASH);
	                                wrapIndex = Math.max(lastSpaceIndex, lastDashIndex) + 1;
	                            }
	                            if (wrapIndex > 0) {
	                                low = wrapIndex;
	                                match = lineArray.slice(0, low).join('');
	                                matchWidth = this._getTextWidth(match);
	                            }
	                        }
	                        match = match.trimRight();
	                        this._addTextLine(match);
	                        textWidth = Math.max(textWidth, matchWidth);
	                        currentHeightPx += lineHeightPx;
	                        const shouldHandleEllipsis = this._shouldHandleEllipsis(currentHeightPx);
	                        if (shouldHandleEllipsis) {
	                            this._tryToAddEllipsisToLastLine();
	                            break;
	                        }
	                        const lineArray = stringToArray(line);
	                        line = lineArray.slice(low).join('').trimLeft();
	                        if (line.length > 0) {
	                            lineWidth = this._getTextWidth(line);
	                            if (lineWidth <= maxWidth) {
	                                this._addTextLine(line);
	                                currentHeightPx += lineHeightPx;
	                                textWidth = Math.max(textWidth, lineWidth);
	                                break;
	                            }
	                        }
	                    }
	                    else {
	                        break;
	                    }
	                }
	            }
	            else {
	                this._addTextLine(line);
	                currentHeightPx += lineHeightPx;
	                textWidth = Math.max(textWidth, lineWidth);
	                if (this._shouldHandleEllipsis(currentHeightPx) && i < max - 1) {
	                    this._tryToAddEllipsisToLastLine();
	                }
	            }
	            if (this.textArr[this.textArr.length - 1]) {
	                this.textArr[this.textArr.length - 1].lastInParagraph = true;
	            }
	            if (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx) {
	                break;
	            }
	        }
	        this.textHeight = fontSize;
	        this.textWidth = textWidth;
	    }
	    _shouldHandleEllipsis(currentHeightPx) {
	        const fontSize = +this.fontSize(), lineHeightPx = this.lineHeight() * fontSize, height = this.attrs.height, fixedHeight = height !== AUTO && height !== undefined, padding = this.padding(), maxHeightPx = height - padding * 2, wrap = this.wrap(), shouldWrap = wrap !== NONE;
	        return (!shouldWrap ||
	            (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx));
	    }
	    _tryToAddEllipsisToLastLine() {
	        const width = this.attrs.width, fixedWidth = width !== AUTO && width !== undefined, padding = this.padding(), maxWidth = width - padding * 2, shouldAddEllipsis = this.ellipsis();
	        const lastLine = this.textArr[this.textArr.length - 1];
	        if (!lastLine || !shouldAddEllipsis) {
	            return;
	        }
	        if (fixedWidth) {
	            const haveSpace = this._getTextWidth(lastLine.text + ELLIPSIS) < maxWidth;
	            if (!haveSpace) {
	                lastLine.text = lastLine.text.slice(0, lastLine.text.length - 3);
	            }
	        }
	        this.textArr.splice(this.textArr.length - 1, 1);
	        this._addTextLine(lastLine.text + ELLIPSIS);
	    }
	    getStrokeScaleEnabled() {
	        return true;
	    }
	    _useBufferCanvas() {
	        const hasLine = this.textDecoration().indexOf('underline') !== -1 ||
	            this.textDecoration().indexOf('line-through') !== -1;
	        const hasShadow = this.hasShadow();
	        if (hasLine && hasShadow) {
	            return true;
	        }
	        return super._useBufferCanvas();
	    }
	};
	Text.Text = Text$1;
	Text$1.prototype._fillFunc = _fillFunc;
	Text$1.prototype._strokeFunc = _strokeFunc;
	Text$1.prototype.className = TEXT_UPPER;
	Text$1.prototype._attrsAffectingSize = [
	    'text',
	    'fontSize',
	    'padding',
	    'wrap',
	    'lineHeight',
	    'letterSpacing',
	];
	(0, Global_2._registerNode)(Text$1);
	Factory_1.Factory.overWriteSetter(Text$1, 'width', (0, Validators_1.getNumberOrAutoValidator)());
	Factory_1.Factory.overWriteSetter(Text$1, 'height', (0, Validators_1.getNumberOrAutoValidator)());
	Factory_1.Factory.addGetterSetter(Text$1, 'direction', INHERIT);
	Factory_1.Factory.addGetterSetter(Text$1, 'fontFamily', 'Arial');
	Factory_1.Factory.addGetterSetter(Text$1, 'fontSize', 12, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Text$1, 'fontStyle', NORMAL);
	Factory_1.Factory.addGetterSetter(Text$1, 'fontVariant', NORMAL);
	Factory_1.Factory.addGetterSetter(Text$1, 'padding', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Text$1, 'align', LEFT);
	Factory_1.Factory.addGetterSetter(Text$1, 'verticalAlign', TOP);
	Factory_1.Factory.addGetterSetter(Text$1, 'lineHeight', 1, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Text$1, 'wrap', WORD);
	Factory_1.Factory.addGetterSetter(Text$1, 'ellipsis', false, (0, Validators_1.getBooleanValidator)());
	Factory_1.Factory.addGetterSetter(Text$1, 'letterSpacing', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Text$1, 'text', '', (0, Validators_1.getStringValidator)());
	Factory_1.Factory.addGetterSetter(Text$1, 'textDecoration', '');
	return Text;
}

var TextPath = {};

var hasRequiredTextPath;

function requireTextPath () {
	if (hasRequiredTextPath) return TextPath;
	hasRequiredTextPath = 1;
	Object.defineProperty(TextPath, "__esModule", { value: true });
	TextPath.TextPath = void 0;
	const Util_1 = requireUtil();
	const Factory_1 = requireFactory();
	const Shape_1 = requireShape();
	const Path_1 = requirePath();
	const Text_1 = requireText();
	const Validators_1 = requireValidators();
	const Global_1 = requireGlobal();
	const EMPTY_STRING = '', NORMAL = 'normal';
	function _fillFunc(context) {
	    context.fillText(this.partialText, 0, 0);
	}
	function _strokeFunc(context) {
	    context.strokeText(this.partialText, 0, 0);
	}
	let TextPath$1 = class TextPath extends Shape_1.Shape {
	    constructor(config) {
	        super(config);
	        this.dummyCanvas = Util_1.Util.createCanvasElement();
	        this.dataArray = [];
	        this._readDataAttribute();
	        this.on('dataChange.konva', function () {
	            this._readDataAttribute();
	            this._setTextData();
	        });
	        this.on('textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva fontFamilyChange.konva', this._setTextData);
	        this._setTextData();
	    }
	    _getTextPathLength() {
	        return Path_1.Path.getPathLength(this.dataArray);
	    }
	    _getPointAtLength(length) {
	        if (!this.attrs.data) {
	            return null;
	        }
	        const totalLength = this.pathLength;
	        if (length - 1 > totalLength) {
	            return null;
	        }
	        return Path_1.Path.getPointAtLengthOfDataArray(length, this.dataArray);
	    }
	    _readDataAttribute() {
	        this.dataArray = Path_1.Path.parsePathData(this.attrs.data);
	        this.pathLength = this._getTextPathLength();
	    }
	    _sceneFunc(context) {
	        context.setAttr('font', this._getContextFont());
	        context.setAttr('textBaseline', this.textBaseline());
	        context.setAttr('textAlign', 'left');
	        context.save();
	        const textDecoration = this.textDecoration();
	        const fill = this.fill();
	        const fontSize = this.fontSize();
	        const glyphInfo = this.glyphInfo;
	        if (textDecoration === 'underline') {
	            context.beginPath();
	        }
	        for (let i = 0; i < glyphInfo.length; i++) {
	            context.save();
	            const p0 = glyphInfo[i].p0;
	            context.translate(p0.x, p0.y);
	            context.rotate(glyphInfo[i].rotation);
	            this.partialText = glyphInfo[i].text;
	            context.fillStrokeShape(this);
	            if (textDecoration === 'underline') {
	                if (i === 0) {
	                    context.moveTo(0, fontSize / 2 + 1);
	                }
	                context.lineTo(fontSize, fontSize / 2 + 1);
	            }
	            context.restore();
	        }
	        if (textDecoration === 'underline') {
	            context.strokeStyle = fill;
	            context.lineWidth = fontSize / 20;
	            context.stroke();
	        }
	        context.restore();
	    }
	    _hitFunc(context) {
	        context.beginPath();
	        const glyphInfo = this.glyphInfo;
	        if (glyphInfo.length >= 1) {
	            const p0 = glyphInfo[0].p0;
	            context.moveTo(p0.x, p0.y);
	        }
	        for (let i = 0; i < glyphInfo.length; i++) {
	            const p1 = glyphInfo[i].p1;
	            context.lineTo(p1.x, p1.y);
	        }
	        context.setAttr('lineWidth', this.fontSize());
	        context.setAttr('strokeStyle', this.colorKey);
	        context.stroke();
	    }
	    getTextWidth() {
	        return this.textWidth;
	    }
	    getTextHeight() {
	        Util_1.Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');
	        return this.textHeight;
	    }
	    setText(text) {
	        return Text_1.Text.prototype.setText.call(this, text);
	    }
	    _getContextFont() {
	        return Text_1.Text.prototype._getContextFont.call(this);
	    }
	    _getTextSize(text) {
	        const dummyCanvas = this.dummyCanvas;
	        const _context = dummyCanvas.getContext('2d');
	        _context.save();
	        _context.font = this._getContextFont();
	        const metrics = _context.measureText(text);
	        _context.restore();
	        return {
	            width: metrics.width,
	            height: parseInt(`${this.fontSize()}`, 10),
	        };
	    }
	    _setTextData() {
	        const { width, height } = this._getTextSize(this.attrs.text);
	        this.textWidth = width;
	        this.textHeight = height;
	        this.glyphInfo = [];
	        if (!this.attrs.data) {
	            return null;
	        }
	        const letterSpacing = this.letterSpacing();
	        const align = this.align();
	        const kerningFunc = this.kerningFunc();
	        const textWidth = Math.max(this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing, 0);
	        let offset = 0;
	        if (align === 'center') {
	            offset = Math.max(0, this.pathLength / 2 - textWidth / 2);
	        }
	        if (align === 'right') {
	            offset = Math.max(0, this.pathLength - textWidth);
	        }
	        const charArr = (0, Text_1.stringToArray)(this.text());
	        let offsetToGlyph = offset;
	        for (let i = 0; i < charArr.length; i++) {
	            const charStartPoint = this._getPointAtLength(offsetToGlyph);
	            if (!charStartPoint)
	                return;
	            let glyphWidth = this._getTextSize(charArr[i]).width + letterSpacing;
	            if (charArr[i] === ' ' && align === 'justify') {
	                const numberOfSpaces = this.text().split(' ').length - 1;
	                glyphWidth += (this.pathLength - textWidth) / numberOfSpaces;
	            }
	            const charEndPoint = this._getPointAtLength(offsetToGlyph + glyphWidth);
	            if (!charEndPoint)
	                return;
	            const width = Path_1.Path.getLineLength(charStartPoint.x, charStartPoint.y, charEndPoint.x, charEndPoint.y);
	            let kern = 0;
	            if (kerningFunc) {
	                try {
	                    kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();
	                }
	                catch (e) {
	                    kern = 0;
	                }
	            }
	            charStartPoint.x += kern;
	            charEndPoint.x += kern;
	            this.textWidth += kern;
	            const midpoint = Path_1.Path.getPointOnLine(kern + width / 2.0, charStartPoint.x, charStartPoint.y, charEndPoint.x, charEndPoint.y);
	            const rotation = Math.atan2(charEndPoint.y - charStartPoint.y, charEndPoint.x - charStartPoint.x);
	            this.glyphInfo.push({
	                transposeX: midpoint.x,
	                transposeY: midpoint.y,
	                text: charArr[i],
	                rotation: rotation,
	                p0: charStartPoint,
	                p1: charEndPoint,
	            });
	            offsetToGlyph += glyphWidth;
	        }
	    }
	    getSelfRect() {
	        if (!this.glyphInfo.length) {
	            return {
	                x: 0,
	                y: 0,
	                width: 0,
	                height: 0,
	            };
	        }
	        const points = [];
	        this.glyphInfo.forEach(function (info) {
	            points.push(info.p0.x);
	            points.push(info.p0.y);
	            points.push(info.p1.x);
	            points.push(info.p1.y);
	        });
	        let minX = points[0] || 0;
	        let maxX = points[0] || 0;
	        let minY = points[1] || 0;
	        let maxY = points[1] || 0;
	        let x, y;
	        for (let i = 0; i < points.length / 2; i++) {
	            x = points[i * 2];
	            y = points[i * 2 + 1];
	            minX = Math.min(minX, x);
	            maxX = Math.max(maxX, x);
	            minY = Math.min(minY, y);
	            maxY = Math.max(maxY, y);
	        }
	        const fontSize = this.fontSize();
	        return {
	            x: minX - fontSize / 2,
	            y: minY - fontSize / 2,
	            width: maxX - minX + fontSize,
	            height: maxY - minY + fontSize,
	        };
	    }
	    destroy() {
	        Util_1.Util.releaseCanvas(this.dummyCanvas);
	        return super.destroy();
	    }
	};
	TextPath.TextPath = TextPath$1;
	TextPath$1.prototype._fillFunc = _fillFunc;
	TextPath$1.prototype._strokeFunc = _strokeFunc;
	TextPath$1.prototype._fillFuncHit = _fillFunc;
	TextPath$1.prototype._strokeFuncHit = _strokeFunc;
	TextPath$1.prototype.className = 'TextPath';
	TextPath$1.prototype._attrsAffectingSize = ['text', 'fontSize', 'data'];
	(0, Global_1._registerNode)(TextPath$1);
	Factory_1.Factory.addGetterSetter(TextPath$1, 'data');
	Factory_1.Factory.addGetterSetter(TextPath$1, 'fontFamily', 'Arial');
	Factory_1.Factory.addGetterSetter(TextPath$1, 'fontSize', 12, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(TextPath$1, 'fontStyle', NORMAL);
	Factory_1.Factory.addGetterSetter(TextPath$1, 'align', 'left');
	Factory_1.Factory.addGetterSetter(TextPath$1, 'letterSpacing', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(TextPath$1, 'textBaseline', 'middle');
	Factory_1.Factory.addGetterSetter(TextPath$1, 'fontVariant', NORMAL);
	Factory_1.Factory.addGetterSetter(TextPath$1, 'text', EMPTY_STRING);
	Factory_1.Factory.addGetterSetter(TextPath$1, 'textDecoration', '');
	Factory_1.Factory.addGetterSetter(TextPath$1, 'kerningFunc', undefined);
	return TextPath;
}

var Transformer = {};

var hasRequiredTransformer;

function requireTransformer () {
	if (hasRequiredTransformer) return Transformer;
	hasRequiredTransformer = 1;
	Object.defineProperty(Transformer, "__esModule", { value: true });
	Transformer.Transformer = void 0;
	const Util_1 = requireUtil();
	const Factory_1 = requireFactory();
	const Node_1 = requireNode();
	const Shape_1 = requireShape();
	const Rect_1 = requireRect();
	const Group_1 = requireGroup();
	const Global_1 = requireGlobal();
	const Validators_1 = requireValidators();
	const Global_2 = requireGlobal();
	const EVENTS_NAME = 'tr-konva';
	const ATTR_CHANGE_LIST = [
	    'resizeEnabledChange',
	    'rotateAnchorOffsetChange',
	    'rotateEnabledChange',
	    'enabledAnchorsChange',
	    'anchorSizeChange',
	    'borderEnabledChange',
	    'borderStrokeChange',
	    'borderStrokeWidthChange',
	    'borderDashChange',
	    'anchorStrokeChange',
	    'anchorStrokeWidthChange',
	    'anchorFillChange',
	    'anchorCornerRadiusChange',
	    'ignoreStrokeChange',
	    'anchorStyleFuncChange',
	]
	    .map((e) => e + `.${EVENTS_NAME}`)
	    .join(' ');
	const NODES_RECT = 'nodesRect';
	const TRANSFORM_CHANGE_STR = [
	    'widthChange',
	    'heightChange',
	    'scaleXChange',
	    'scaleYChange',
	    'skewXChange',
	    'skewYChange',
	    'rotationChange',
	    'offsetXChange',
	    'offsetYChange',
	    'transformsEnabledChange',
	    'strokeWidthChange',
	];
	const ANGLES = {
	    'top-left': -45,
	    'top-center': 0,
	    'top-right': 45,
	    'middle-right': -90,
	    'middle-left': 90,
	    'bottom-left': -135,
	    'bottom-center': 180,
	    'bottom-right': 135,
	};
	const TOUCH_DEVICE = 'ontouchstart' in Global_1.Konva._global;
	function getCursor(anchorName, rad, rotateCursor) {
	    if (anchorName === 'rotater') {
	        return rotateCursor;
	    }
	    rad += Util_1.Util.degToRad(ANGLES[anchorName] || 0);
	    const angle = ((Util_1.Util.radToDeg(rad) % 360) + 360) % 360;
	    if (Util_1.Util._inRange(angle, 315 + 22.5, 360) || Util_1.Util._inRange(angle, 0, 22.5)) {
	        return 'ns-resize';
	    }
	    else if (Util_1.Util._inRange(angle, 45 - 22.5, 45 + 22.5)) {
	        return 'nesw-resize';
	    }
	    else if (Util_1.Util._inRange(angle, 90 - 22.5, 90 + 22.5)) {
	        return 'ew-resize';
	    }
	    else if (Util_1.Util._inRange(angle, 135 - 22.5, 135 + 22.5)) {
	        return 'nwse-resize';
	    }
	    else if (Util_1.Util._inRange(angle, 180 - 22.5, 180 + 22.5)) {
	        return 'ns-resize';
	    }
	    else if (Util_1.Util._inRange(angle, 225 - 22.5, 225 + 22.5)) {
	        return 'nesw-resize';
	    }
	    else if (Util_1.Util._inRange(angle, 270 - 22.5, 270 + 22.5)) {
	        return 'ew-resize';
	    }
	    else if (Util_1.Util._inRange(angle, 315 - 22.5, 315 + 22.5)) {
	        return 'nwse-resize';
	    }
	    else {
	        Util_1.Util.error('Transformer has unknown angle for cursor detection: ' + angle);
	        return 'pointer';
	    }
	}
	const ANCHORS_NAMES = [
	    'top-left',
	    'top-center',
	    'top-right',
	    'middle-right',
	    'middle-left',
	    'bottom-left',
	    'bottom-center',
	    'bottom-right',
	];
	function getCenter(shape) {
	    return {
	        x: shape.x +
	            (shape.width / 2) * Math.cos(shape.rotation) +
	            (shape.height / 2) * Math.sin(-shape.rotation),
	        y: shape.y +
	            (shape.height / 2) * Math.cos(shape.rotation) +
	            (shape.width / 2) * Math.sin(shape.rotation),
	    };
	}
	function rotateAroundPoint(shape, angleRad, point) {
	    const x = point.x +
	        (shape.x - point.x) * Math.cos(angleRad) -
	        (shape.y - point.y) * Math.sin(angleRad);
	    const y = point.y +
	        (shape.x - point.x) * Math.sin(angleRad) +
	        (shape.y - point.y) * Math.cos(angleRad);
	    return {
	        ...shape,
	        rotation: shape.rotation + angleRad,
	        x,
	        y,
	    };
	}
	function rotateAroundCenter(shape, deltaRad) {
	    const center = getCenter(shape);
	    return rotateAroundPoint(shape, deltaRad, center);
	}
	function getSnap(snaps, newRotationRad, tol) {
	    let snapped = newRotationRad;
	    for (let i = 0; i < snaps.length; i++) {
	        const angle = Global_1.Konva.getAngle(snaps[i]);
	        const absDiff = Math.abs(angle - newRotationRad) % (Math.PI * 2);
	        const dif = Math.min(absDiff, Math.PI * 2 - absDiff);
	        if (dif < tol) {
	            snapped = angle;
	        }
	    }
	    return snapped;
	}
	let activeTransformersCount = 0;
	let Transformer$1 = class Transformer extends Group_1.Group {
	    constructor(config) {
	        super(config);
	        this._movingAnchorName = null;
	        this._transforming = false;
	        this._createElements();
	        this._handleMouseMove = this._handleMouseMove.bind(this);
	        this._handleMouseUp = this._handleMouseUp.bind(this);
	        this.update = this.update.bind(this);
	        this.on(ATTR_CHANGE_LIST, this.update);
	        if (this.getNode()) {
	            this.update();
	        }
	    }
	    attachTo(node) {
	        this.setNode(node);
	        return this;
	    }
	    setNode(node) {
	        Util_1.Util.warn('tr.setNode(shape), tr.node(shape) and tr.attachTo(shape) methods are deprecated. Please use tr.nodes(nodesArray) instead.');
	        return this.setNodes([node]);
	    }
	    getNode() {
	        return this._nodes && this._nodes[0];
	    }
	    _getEventNamespace() {
	        return EVENTS_NAME + this._id;
	    }
	    setNodes(nodes = []) {
	        if (this._nodes && this._nodes.length) {
	            this.detach();
	        }
	        const filteredNodes = nodes.filter((node) => {
	            if (node.isAncestorOf(this)) {
	                Util_1.Util.error('Konva.Transformer cannot be an a child of the node you are trying to attach');
	                return false;
	            }
	            return true;
	        });
	        this._nodes = nodes = filteredNodes;
	        if (nodes.length === 1 && this.useSingleNodeRotation()) {
	            this.rotation(nodes[0].getAbsoluteRotation());
	        }
	        else {
	            this.rotation(0);
	        }
	        this._nodes.forEach((node) => {
	            const onChange = () => {
	                if (this.nodes().length === 1 && this.useSingleNodeRotation()) {
	                    this.rotation(this.nodes()[0].getAbsoluteRotation());
	                }
	                this._resetTransformCache();
	                if (!this._transforming && !this.isDragging()) {
	                    this.update();
	                }
	            };
	            if (node._attrsAffectingSize.length) {
	                const additionalEvents = node._attrsAffectingSize
	                    .map((prop) => prop + 'Change.' + this._getEventNamespace())
	                    .join(' ');
	                node.on(additionalEvents, onChange);
	            }
	            node.on(TRANSFORM_CHANGE_STR.map((e) => e + `.${this._getEventNamespace()}`).join(' '), onChange);
	            node.on(`absoluteTransformChange.${this._getEventNamespace()}`, onChange);
	            this._proxyDrag(node);
	        });
	        this._resetTransformCache();
	        const elementsCreated = !!this.findOne('.top-left');
	        if (elementsCreated) {
	            this.update();
	        }
	        return this;
	    }
	    _proxyDrag(node) {
	        let lastPos;
	        node.on(`dragstart.${this._getEventNamespace()}`, (e) => {
	            lastPos = node.getAbsolutePosition();
	            if (!this.isDragging() && node !== this.findOne('.back')) {
	                this.startDrag(e, false);
	            }
	        });
	        node.on(`dragmove.${this._getEventNamespace()}`, (e) => {
	            if (!lastPos) {
	                return;
	            }
	            const abs = node.getAbsolutePosition();
	            const dx = abs.x - lastPos.x;
	            const dy = abs.y - lastPos.y;
	            this.nodes().forEach((otherNode) => {
	                if (otherNode === node) {
	                    return;
	                }
	                if (otherNode.isDragging()) {
	                    return;
	                }
	                const otherAbs = otherNode.getAbsolutePosition();
	                otherNode.setAbsolutePosition({
	                    x: otherAbs.x + dx,
	                    y: otherAbs.y + dy,
	                });
	                otherNode.startDrag(e);
	            });
	            lastPos = null;
	        });
	    }
	    getNodes() {
	        return this._nodes || [];
	    }
	    getActiveAnchor() {
	        return this._movingAnchorName;
	    }
	    detach() {
	        if (this._nodes) {
	            this._nodes.forEach((node) => {
	                node.off('.' + this._getEventNamespace());
	            });
	        }
	        this._nodes = [];
	        this._resetTransformCache();
	    }
	    _resetTransformCache() {
	        this._clearCache(NODES_RECT);
	        this._clearCache('transform');
	        this._clearSelfAndDescendantCache('absoluteTransform');
	    }
	    _getNodeRect() {
	        return this._getCache(NODES_RECT, this.__getNodeRect);
	    }
	    __getNodeShape(node, rot = this.rotation(), relative) {
	        const rect = node.getClientRect({
	            skipTransform: true,
	            skipShadow: true,
	            skipStroke: this.ignoreStroke(),
	        });
	        const absScale = node.getAbsoluteScale(relative);
	        const absPos = node.getAbsolutePosition(relative);
	        const dx = rect.x * absScale.x - node.offsetX() * absScale.x;
	        const dy = rect.y * absScale.y - node.offsetY() * absScale.y;
	        const rotation = (Global_1.Konva.getAngle(node.getAbsoluteRotation()) + Math.PI * 2) %
	            (Math.PI * 2);
	        const box = {
	            x: absPos.x + dx * Math.cos(rotation) + dy * Math.sin(-rotation),
	            y: absPos.y + dy * Math.cos(rotation) + dx * Math.sin(rotation),
	            width: rect.width * absScale.x,
	            height: rect.height * absScale.y,
	            rotation: rotation,
	        };
	        return rotateAroundPoint(box, -Global_1.Konva.getAngle(rot), {
	            x: 0,
	            y: 0,
	        });
	    }
	    __getNodeRect() {
	        const node = this.getNode();
	        if (!node) {
	            return {
	                x: -1e8,
	                y: -1e8,
	                width: 0,
	                height: 0,
	                rotation: 0,
	            };
	        }
	        const totalPoints = [];
	        this.nodes().map((node) => {
	            const box = node.getClientRect({
	                skipTransform: true,
	                skipShadow: true,
	                skipStroke: this.ignoreStroke(),
	            });
	            const points = [
	                { x: box.x, y: box.y },
	                { x: box.x + box.width, y: box.y },
	                { x: box.x + box.width, y: box.y + box.height },
	                { x: box.x, y: box.y + box.height },
	            ];
	            const trans = node.getAbsoluteTransform();
	            points.forEach(function (point) {
	                const transformed = trans.point(point);
	                totalPoints.push(transformed);
	            });
	        });
	        const tr = new Util_1.Transform();
	        tr.rotate(-Global_1.Konva.getAngle(this.rotation()));
	        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
	        totalPoints.forEach(function (point) {
	            const transformed = tr.point(point);
	            if (minX === undefined) {
	                minX = maxX = transformed.x;
	                minY = maxY = transformed.y;
	            }
	            minX = Math.min(minX, transformed.x);
	            minY = Math.min(minY, transformed.y);
	            maxX = Math.max(maxX, transformed.x);
	            maxY = Math.max(maxY, transformed.y);
	        });
	        tr.invert();
	        const p = tr.point({ x: minX, y: minY });
	        return {
	            x: p.x,
	            y: p.y,
	            width: maxX - minX,
	            height: maxY - minY,
	            rotation: Global_1.Konva.getAngle(this.rotation()),
	        };
	    }
	    getX() {
	        return this._getNodeRect().x;
	    }
	    getY() {
	        return this._getNodeRect().y;
	    }
	    getWidth() {
	        return this._getNodeRect().width;
	    }
	    getHeight() {
	        return this._getNodeRect().height;
	    }
	    _createElements() {
	        this._createBack();
	        ANCHORS_NAMES.forEach((name) => {
	            this._createAnchor(name);
	        });
	        this._createAnchor('rotater');
	    }
	    _createAnchor(name) {
	        const anchor = new Rect_1.Rect({
	            stroke: 'rgb(0, 161, 255)',
	            fill: 'white',
	            strokeWidth: 1,
	            name: name + ' _anchor',
	            dragDistance: 0,
	            draggable: true,
	            hitStrokeWidth: TOUCH_DEVICE ? 10 : 'auto',
	        });
	        const self = this;
	        anchor.on('mousedown touchstart', function (e) {
	            self._handleMouseDown(e);
	        });
	        anchor.on('dragstart', (e) => {
	            anchor.stopDrag();
	            e.cancelBubble = true;
	        });
	        anchor.on('dragend', (e) => {
	            e.cancelBubble = true;
	        });
	        anchor.on('mouseenter', () => {
	            const rad = Global_1.Konva.getAngle(this.rotation());
	            const rotateCursor = this.rotateAnchorCursor();
	            const cursor = getCursor(name, rad, rotateCursor);
	            anchor.getStage().content &&
	                (anchor.getStage().content.style.cursor = cursor);
	            this._cursorChange = true;
	        });
	        anchor.on('mouseout', () => {
	            anchor.getStage().content &&
	                (anchor.getStage().content.style.cursor = '');
	            this._cursorChange = false;
	        });
	        this.add(anchor);
	    }
	    _createBack() {
	        const back = new Shape_1.Shape({
	            name: 'back',
	            width: 0,
	            height: 0,
	            draggable: true,
	            sceneFunc(ctx, shape) {
	                const tr = shape.getParent();
	                const padding = tr.padding();
	                ctx.beginPath();
	                ctx.rect(-padding, -padding, shape.width() + padding * 2, shape.height() + padding * 2);
	                ctx.moveTo(shape.width() / 2, -padding);
	                if (tr.rotateEnabled() && tr.rotateLineVisible()) {
	                    ctx.lineTo(shape.width() / 2, -tr.rotateAnchorOffset() * Util_1.Util._sign(shape.height()) - padding);
	                }
	                ctx.fillStrokeShape(shape);
	            },
	            hitFunc: (ctx, shape) => {
	                if (!this.shouldOverdrawWholeArea()) {
	                    return;
	                }
	                const padding = this.padding();
	                ctx.beginPath();
	                ctx.rect(-padding, -padding, shape.width() + padding * 2, shape.height() + padding * 2);
	                ctx.fillStrokeShape(shape);
	            },
	        });
	        this.add(back);
	        this._proxyDrag(back);
	        back.on('dragstart', (e) => {
	            e.cancelBubble = true;
	        });
	        back.on('dragmove', (e) => {
	            e.cancelBubble = true;
	        });
	        back.on('dragend', (e) => {
	            e.cancelBubble = true;
	        });
	        this.on('dragmove', (e) => {
	            this.update();
	        });
	    }
	    _handleMouseDown(e) {
	        if (this._transforming) {
	            return;
	        }
	        this._movingAnchorName = e.target.name().split(' ')[0];
	        const attrs = this._getNodeRect();
	        const width = attrs.width;
	        const height = attrs.height;
	        const hypotenuse = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));
	        this.sin = Math.abs(height / hypotenuse);
	        this.cos = Math.abs(width / hypotenuse);
	        if (typeof window !== 'undefined') {
	            window.addEventListener('mousemove', this._handleMouseMove);
	            window.addEventListener('touchmove', this._handleMouseMove);
	            window.addEventListener('mouseup', this._handleMouseUp, true);
	            window.addEventListener('touchend', this._handleMouseUp, true);
	        }
	        this._transforming = true;
	        const ap = e.target.getAbsolutePosition();
	        const pos = e.target.getStage().getPointerPosition();
	        this._anchorDragOffset = {
	            x: pos.x - ap.x,
	            y: pos.y - ap.y,
	        };
	        activeTransformersCount++;
	        this._fire('transformstart', { evt: e.evt, target: this.getNode() });
	        this._nodes.forEach((target) => {
	            target._fire('transformstart', { evt: e.evt, target });
	        });
	    }
	    _handleMouseMove(e) {
	        let x, y, newHypotenuse;
	        const anchorNode = this.findOne('.' + this._movingAnchorName);
	        const stage = anchorNode.getStage();
	        stage.setPointersPositions(e);
	        const pp = stage.getPointerPosition();
	        let newNodePos = {
	            x: pp.x - this._anchorDragOffset.x,
	            y: pp.y - this._anchorDragOffset.y,
	        };
	        const oldAbs = anchorNode.getAbsolutePosition();
	        if (this.anchorDragBoundFunc()) {
	            newNodePos = this.anchorDragBoundFunc()(oldAbs, newNodePos, e);
	        }
	        anchorNode.setAbsolutePosition(newNodePos);
	        const newAbs = anchorNode.getAbsolutePosition();
	        if (oldAbs.x === newAbs.x && oldAbs.y === newAbs.y) {
	            return;
	        }
	        if (this._movingAnchorName === 'rotater') {
	            const attrs = this._getNodeRect();
	            x = anchorNode.x() - attrs.width / 2;
	            y = -anchorNode.y() + attrs.height / 2;
	            let delta = Math.atan2(-y, x) + Math.PI / 2;
	            if (attrs.height < 0) {
	                delta -= Math.PI;
	            }
	            const oldRotation = Global_1.Konva.getAngle(this.rotation());
	            const newRotation = oldRotation + delta;
	            const tol = Global_1.Konva.getAngle(this.rotationSnapTolerance());
	            const snappedRot = getSnap(this.rotationSnaps(), newRotation, tol);
	            const diff = snappedRot - attrs.rotation;
	            const shape = rotateAroundCenter(attrs, diff);
	            this._fitNodesInto(shape, e);
	            return;
	        }
	        const shiftBehavior = this.shiftBehavior();
	        let keepProportion;
	        if (shiftBehavior === 'inverted') {
	            keepProportion = this.keepRatio() && !e.shiftKey;
	        }
	        else if (shiftBehavior === 'none') {
	            keepProportion = this.keepRatio();
	        }
	        else {
	            keepProportion = this.keepRatio() || e.shiftKey;
	        }
	        var centeredScaling = this.centeredScaling() || e.altKey;
	        if (this._movingAnchorName === 'top-left') {
	            if (keepProportion) {
	                var comparePoint = centeredScaling
	                    ? {
	                        x: this.width() / 2,
	                        y: this.height() / 2,
	                    }
	                    : {
	                        x: this.findOne('.bottom-right').x(),
	                        y: this.findOne('.bottom-right').y(),
	                    };
	                newHypotenuse = Math.sqrt(Math.pow(comparePoint.x - anchorNode.x(), 2) +
	                    Math.pow(comparePoint.y - anchorNode.y(), 2));
	                var reverseX = this.findOne('.top-left').x() > comparePoint.x ? -1 : 1;
	                var reverseY = this.findOne('.top-left').y() > comparePoint.y ? -1 : 1;
	                x = newHypotenuse * this.cos * reverseX;
	                y = newHypotenuse * this.sin * reverseY;
	                this.findOne('.top-left').x(comparePoint.x - x);
	                this.findOne('.top-left').y(comparePoint.y - y);
	            }
	        }
	        else if (this._movingAnchorName === 'top-center') {
	            this.findOne('.top-left').y(anchorNode.y());
	        }
	        else if (this._movingAnchorName === 'top-right') {
	            if (keepProportion) {
	                var comparePoint = centeredScaling
	                    ? {
	                        x: this.width() / 2,
	                        y: this.height() / 2,
	                    }
	                    : {
	                        x: this.findOne('.bottom-left').x(),
	                        y: this.findOne('.bottom-left').y(),
	                    };
	                newHypotenuse = Math.sqrt(Math.pow(anchorNode.x() - comparePoint.x, 2) +
	                    Math.pow(comparePoint.y - anchorNode.y(), 2));
	                var reverseX = this.findOne('.top-right').x() < comparePoint.x ? -1 : 1;
	                var reverseY = this.findOne('.top-right').y() > comparePoint.y ? -1 : 1;
	                x = newHypotenuse * this.cos * reverseX;
	                y = newHypotenuse * this.sin * reverseY;
	                this.findOne('.top-right').x(comparePoint.x + x);
	                this.findOne('.top-right').y(comparePoint.y - y);
	            }
	            var pos = anchorNode.position();
	            this.findOne('.top-left').y(pos.y);
	            this.findOne('.bottom-right').x(pos.x);
	        }
	        else if (this._movingAnchorName === 'middle-left') {
	            this.findOne('.top-left').x(anchorNode.x());
	        }
	        else if (this._movingAnchorName === 'middle-right') {
	            this.findOne('.bottom-right').x(anchorNode.x());
	        }
	        else if (this._movingAnchorName === 'bottom-left') {
	            if (keepProportion) {
	                var comparePoint = centeredScaling
	                    ? {
	                        x: this.width() / 2,
	                        y: this.height() / 2,
	                    }
	                    : {
	                        x: this.findOne('.top-right').x(),
	                        y: this.findOne('.top-right').y(),
	                    };
	                newHypotenuse = Math.sqrt(Math.pow(comparePoint.x - anchorNode.x(), 2) +
	                    Math.pow(anchorNode.y() - comparePoint.y, 2));
	                var reverseX = comparePoint.x < anchorNode.x() ? -1 : 1;
	                var reverseY = anchorNode.y() < comparePoint.y ? -1 : 1;
	                x = newHypotenuse * this.cos * reverseX;
	                y = newHypotenuse * this.sin * reverseY;
	                anchorNode.x(comparePoint.x - x);
	                anchorNode.y(comparePoint.y + y);
	            }
	            pos = anchorNode.position();
	            this.findOne('.top-left').x(pos.x);
	            this.findOne('.bottom-right').y(pos.y);
	        }
	        else if (this._movingAnchorName === 'bottom-center') {
	            this.findOne('.bottom-right').y(anchorNode.y());
	        }
	        else if (this._movingAnchorName === 'bottom-right') {
	            if (keepProportion) {
	                var comparePoint = centeredScaling
	                    ? {
	                        x: this.width() / 2,
	                        y: this.height() / 2,
	                    }
	                    : {
	                        x: this.findOne('.top-left').x(),
	                        y: this.findOne('.top-left').y(),
	                    };
	                newHypotenuse = Math.sqrt(Math.pow(anchorNode.x() - comparePoint.x, 2) +
	                    Math.pow(anchorNode.y() - comparePoint.y, 2));
	                var reverseX = this.findOne('.bottom-right').x() < comparePoint.x ? -1 : 1;
	                var reverseY = this.findOne('.bottom-right').y() < comparePoint.y ? -1 : 1;
	                x = newHypotenuse * this.cos * reverseX;
	                y = newHypotenuse * this.sin * reverseY;
	                this.findOne('.bottom-right').x(comparePoint.x + x);
	                this.findOne('.bottom-right').y(comparePoint.y + y);
	            }
	        }
	        else {
	            console.error(new Error('Wrong position argument of selection resizer: ' +
	                this._movingAnchorName));
	        }
	        var centeredScaling = this.centeredScaling() || e.altKey;
	        if (centeredScaling) {
	            const topLeft = this.findOne('.top-left');
	            const bottomRight = this.findOne('.bottom-right');
	            const topOffsetX = topLeft.x();
	            const topOffsetY = topLeft.y();
	            const bottomOffsetX = this.getWidth() - bottomRight.x();
	            const bottomOffsetY = this.getHeight() - bottomRight.y();
	            bottomRight.move({
	                x: -topOffsetX,
	                y: -topOffsetY,
	            });
	            topLeft.move({
	                x: bottomOffsetX,
	                y: bottomOffsetY,
	            });
	        }
	        const absPos = this.findOne('.top-left').getAbsolutePosition();
	        x = absPos.x;
	        y = absPos.y;
	        const width = this.findOne('.bottom-right').x() - this.findOne('.top-left').x();
	        const height = this.findOne('.bottom-right').y() - this.findOne('.top-left').y();
	        this._fitNodesInto({
	            x: x,
	            y: y,
	            width: width,
	            height: height,
	            rotation: Global_1.Konva.getAngle(this.rotation()),
	        }, e);
	    }
	    _handleMouseUp(e) {
	        this._removeEvents(e);
	    }
	    getAbsoluteTransform() {
	        return this.getTransform();
	    }
	    _removeEvents(e) {
	        var _a;
	        if (this._transforming) {
	            this._transforming = false;
	            if (typeof window !== 'undefined') {
	                window.removeEventListener('mousemove', this._handleMouseMove);
	                window.removeEventListener('touchmove', this._handleMouseMove);
	                window.removeEventListener('mouseup', this._handleMouseUp, true);
	                window.removeEventListener('touchend', this._handleMouseUp, true);
	            }
	            const node = this.getNode();
	            activeTransformersCount--;
	            this._fire('transformend', { evt: e, target: node });
	            (_a = this.getLayer()) === null || _a === void 0 ? void 0 : _a.batchDraw();
	            if (node) {
	                this._nodes.forEach((target) => {
	                    var _a;
	                    target._fire('transformend', { evt: e, target });
	                    (_a = target.getLayer()) === null || _a === void 0 ? void 0 : _a.batchDraw();
	                });
	            }
	            this._movingAnchorName = null;
	        }
	    }
	    _fitNodesInto(newAttrs, evt) {
	        const oldAttrs = this._getNodeRect();
	        const minSize = 1;
	        if (Util_1.Util._inRange(newAttrs.width, -this.padding() * 2 - minSize, minSize)) {
	            this.update();
	            return;
	        }
	        if (Util_1.Util._inRange(newAttrs.height, -this.padding() * 2 - minSize, minSize)) {
	            this.update();
	            return;
	        }
	        const t = new Util_1.Transform();
	        t.rotate(Global_1.Konva.getAngle(this.rotation()));
	        if (this._movingAnchorName &&
	            newAttrs.width < 0 &&
	            this._movingAnchorName.indexOf('left') >= 0) {
	            const offset = t.point({
	                x: -this.padding() * 2,
	                y: 0,
	            });
	            newAttrs.x += offset.x;
	            newAttrs.y += offset.y;
	            newAttrs.width += this.padding() * 2;
	            this._movingAnchorName = this._movingAnchorName.replace('left', 'right');
	            this._anchorDragOffset.x -= offset.x;
	            this._anchorDragOffset.y -= offset.y;
	        }
	        else if (this._movingAnchorName &&
	            newAttrs.width < 0 &&
	            this._movingAnchorName.indexOf('right') >= 0) {
	            const offset = t.point({
	                x: this.padding() * 2,
	                y: 0,
	            });
	            this._movingAnchorName = this._movingAnchorName.replace('right', 'left');
	            this._anchorDragOffset.x -= offset.x;
	            this._anchorDragOffset.y -= offset.y;
	            newAttrs.width += this.padding() * 2;
	        }
	        if (this._movingAnchorName &&
	            newAttrs.height < 0 &&
	            this._movingAnchorName.indexOf('top') >= 0) {
	            const offset = t.point({
	                x: 0,
	                y: -this.padding() * 2,
	            });
	            newAttrs.x += offset.x;
	            newAttrs.y += offset.y;
	            this._movingAnchorName = this._movingAnchorName.replace('top', 'bottom');
	            this._anchorDragOffset.x -= offset.x;
	            this._anchorDragOffset.y -= offset.y;
	            newAttrs.height += this.padding() * 2;
	        }
	        else if (this._movingAnchorName &&
	            newAttrs.height < 0 &&
	            this._movingAnchorName.indexOf('bottom') >= 0) {
	            const offset = t.point({
	                x: 0,
	                y: this.padding() * 2,
	            });
	            this._movingAnchorName = this._movingAnchorName.replace('bottom', 'top');
	            this._anchorDragOffset.x -= offset.x;
	            this._anchorDragOffset.y -= offset.y;
	            newAttrs.height += this.padding() * 2;
	        }
	        if (this.boundBoxFunc()) {
	            const bounded = this.boundBoxFunc()(oldAttrs, newAttrs);
	            if (bounded) {
	                newAttrs = bounded;
	            }
	            else {
	                Util_1.Util.warn('boundBoxFunc returned falsy. You should return new bound rect from it!');
	            }
	        }
	        const baseSize = 10000000;
	        const oldTr = new Util_1.Transform();
	        oldTr.translate(oldAttrs.x, oldAttrs.y);
	        oldTr.rotate(oldAttrs.rotation);
	        oldTr.scale(oldAttrs.width / baseSize, oldAttrs.height / baseSize);
	        const newTr = new Util_1.Transform();
	        const newScaleX = newAttrs.width / baseSize;
	        const newScaleY = newAttrs.height / baseSize;
	        if (this.flipEnabled() === false) {
	            newTr.translate(newAttrs.x, newAttrs.y);
	            newTr.rotate(newAttrs.rotation);
	            newTr.translate(newAttrs.width < 0 ? newAttrs.width : 0, newAttrs.height < 0 ? newAttrs.height : 0);
	            newTr.scale(Math.abs(newScaleX), Math.abs(newScaleY));
	        }
	        else {
	            newTr.translate(newAttrs.x, newAttrs.y);
	            newTr.rotate(newAttrs.rotation);
	            newTr.scale(newScaleX, newScaleY);
	        }
	        const delta = newTr.multiply(oldTr.invert());
	        this._nodes.forEach((node) => {
	            var _a;
	            const parentTransform = node.getParent().getAbsoluteTransform();
	            const localTransform = node.getTransform().copy();
	            localTransform.translate(node.offsetX(), node.offsetY());
	            const newLocalTransform = new Util_1.Transform();
	            newLocalTransform
	                .multiply(parentTransform.copy().invert())
	                .multiply(delta)
	                .multiply(parentTransform)
	                .multiply(localTransform);
	            const attrs = newLocalTransform.decompose();
	            node.setAttrs(attrs);
	            (_a = node.getLayer()) === null || _a === void 0 ? void 0 : _a.batchDraw();
	        });
	        this.rotation(Util_1.Util._getRotation(newAttrs.rotation));
	        this._nodes.forEach((node) => {
	            this._fire('transform', { evt: evt, target: node });
	            node._fire('transform', { evt: evt, target: node });
	        });
	        this._resetTransformCache();
	        this.update();
	        this.getLayer().batchDraw();
	    }
	    forceUpdate() {
	        this._resetTransformCache();
	        this.update();
	    }
	    _batchChangeChild(selector, attrs) {
	        const anchor = this.findOne(selector);
	        anchor.setAttrs(attrs);
	    }
	    update() {
	        var _a;
	        const attrs = this._getNodeRect();
	        this.rotation(Util_1.Util._getRotation(attrs.rotation));
	        const width = attrs.width;
	        const height = attrs.height;
	        const enabledAnchors = this.enabledAnchors();
	        const resizeEnabled = this.resizeEnabled();
	        const padding = this.padding();
	        const anchorSize = this.anchorSize();
	        const anchors = this.find('._anchor');
	        anchors.forEach((node) => {
	            node.setAttrs({
	                width: anchorSize,
	                height: anchorSize,
	                offsetX: anchorSize / 2,
	                offsetY: anchorSize / 2,
	                stroke: this.anchorStroke(),
	                strokeWidth: this.anchorStrokeWidth(),
	                fill: this.anchorFill(),
	                cornerRadius: this.anchorCornerRadius(),
	            });
	        });
	        this._batchChangeChild('.top-left', {
	            x: 0,
	            y: 0,
	            offsetX: anchorSize / 2 + padding,
	            offsetY: anchorSize / 2 + padding,
	            visible: resizeEnabled && enabledAnchors.indexOf('top-left') >= 0,
	        });
	        this._batchChangeChild('.top-center', {
	            x: width / 2,
	            y: 0,
	            offsetY: anchorSize / 2 + padding,
	            visible: resizeEnabled && enabledAnchors.indexOf('top-center') >= 0,
	        });
	        this._batchChangeChild('.top-right', {
	            x: width,
	            y: 0,
	            offsetX: anchorSize / 2 - padding,
	            offsetY: anchorSize / 2 + padding,
	            visible: resizeEnabled && enabledAnchors.indexOf('top-right') >= 0,
	        });
	        this._batchChangeChild('.middle-left', {
	            x: 0,
	            y: height / 2,
	            offsetX: anchorSize / 2 + padding,
	            visible: resizeEnabled && enabledAnchors.indexOf('middle-left') >= 0,
	        });
	        this._batchChangeChild('.middle-right', {
	            x: width,
	            y: height / 2,
	            offsetX: anchorSize / 2 - padding,
	            visible: resizeEnabled && enabledAnchors.indexOf('middle-right') >= 0,
	        });
	        this._batchChangeChild('.bottom-left', {
	            x: 0,
	            y: height,
	            offsetX: anchorSize / 2 + padding,
	            offsetY: anchorSize / 2 - padding,
	            visible: resizeEnabled && enabledAnchors.indexOf('bottom-left') >= 0,
	        });
	        this._batchChangeChild('.bottom-center', {
	            x: width / 2,
	            y: height,
	            offsetY: anchorSize / 2 - padding,
	            visible: resizeEnabled && enabledAnchors.indexOf('bottom-center') >= 0,
	        });
	        this._batchChangeChild('.bottom-right', {
	            x: width,
	            y: height,
	            offsetX: anchorSize / 2 - padding,
	            offsetY: anchorSize / 2 - padding,
	            visible: resizeEnabled && enabledAnchors.indexOf('bottom-right') >= 0,
	        });
	        this._batchChangeChild('.rotater', {
	            x: width / 2,
	            y: -this.rotateAnchorOffset() * Util_1.Util._sign(height) - padding,
	            visible: this.rotateEnabled(),
	        });
	        this._batchChangeChild('.back', {
	            width: width,
	            height: height,
	            visible: this.borderEnabled(),
	            stroke: this.borderStroke(),
	            strokeWidth: this.borderStrokeWidth(),
	            dash: this.borderDash(),
	            x: 0,
	            y: 0,
	        });
	        const styleFunc = this.anchorStyleFunc();
	        if (styleFunc) {
	            anchors.forEach((node) => {
	                styleFunc(node);
	            });
	        }
	        (_a = this.getLayer()) === null || _a === void 0 ? void 0 : _a.batchDraw();
	    }
	    isTransforming() {
	        return this._transforming;
	    }
	    stopTransform() {
	        if (this._transforming) {
	            this._removeEvents();
	            const anchorNode = this.findOne('.' + this._movingAnchorName);
	            if (anchorNode) {
	                anchorNode.stopDrag();
	            }
	        }
	    }
	    destroy() {
	        if (this.getStage() && this._cursorChange) {
	            this.getStage().content && (this.getStage().content.style.cursor = '');
	        }
	        Group_1.Group.prototype.destroy.call(this);
	        this.detach();
	        this._removeEvents();
	        return this;
	    }
	    toObject() {
	        return Node_1.Node.prototype.toObject.call(this);
	    }
	    clone(obj) {
	        const node = Node_1.Node.prototype.clone.call(this, obj);
	        return node;
	    }
	    getClientRect() {
	        if (this.nodes().length > 0) {
	            return super.getClientRect();
	        }
	        else {
	            return { x: 0, y: 0, width: 0, height: 0 };
	        }
	    }
	};
	Transformer.Transformer = Transformer$1;
	Transformer$1.isTransforming = () => {
	    return activeTransformersCount > 0;
	};
	function validateAnchors(val) {
	    if (!(val instanceof Array)) {
	        Util_1.Util.warn('enabledAnchors value should be an array');
	    }
	    if (val instanceof Array) {
	        val.forEach(function (name) {
	            if (ANCHORS_NAMES.indexOf(name) === -1) {
	                Util_1.Util.warn('Unknown anchor name: ' +
	                    name +
	                    '. Available names are: ' +
	                    ANCHORS_NAMES.join(', '));
	            }
	        });
	    }
	    return val || [];
	}
	Transformer$1.prototype.className = 'Transformer';
	(0, Global_2._registerNode)(Transformer$1);
	Factory_1.Factory.addGetterSetter(Transformer$1, 'enabledAnchors', ANCHORS_NAMES, validateAnchors);
	Factory_1.Factory.addGetterSetter(Transformer$1, 'flipEnabled', true, (0, Validators_1.getBooleanValidator)());
	Factory_1.Factory.addGetterSetter(Transformer$1, 'resizeEnabled', true);
	Factory_1.Factory.addGetterSetter(Transformer$1, 'anchorSize', 10, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Transformer$1, 'rotateEnabled', true);
	Factory_1.Factory.addGetterSetter(Transformer$1, 'rotateLineVisible', true);
	Factory_1.Factory.addGetterSetter(Transformer$1, 'rotationSnaps', []);
	Factory_1.Factory.addGetterSetter(Transformer$1, 'rotateAnchorOffset', 50, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Transformer$1, 'rotateAnchorCursor', 'crosshair');
	Factory_1.Factory.addGetterSetter(Transformer$1, 'rotationSnapTolerance', 5, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Transformer$1, 'borderEnabled', true);
	Factory_1.Factory.addGetterSetter(Transformer$1, 'anchorStroke', 'rgb(0, 161, 255)');
	Factory_1.Factory.addGetterSetter(Transformer$1, 'anchorStrokeWidth', 1, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Transformer$1, 'anchorFill', 'white');
	Factory_1.Factory.addGetterSetter(Transformer$1, 'anchorCornerRadius', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Transformer$1, 'borderStroke', 'rgb(0, 161, 255)');
	Factory_1.Factory.addGetterSetter(Transformer$1, 'borderStrokeWidth', 1, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Transformer$1, 'borderDash');
	Factory_1.Factory.addGetterSetter(Transformer$1, 'keepRatio', true);
	Factory_1.Factory.addGetterSetter(Transformer$1, 'shiftBehavior', 'default');
	Factory_1.Factory.addGetterSetter(Transformer$1, 'centeredScaling', false);
	Factory_1.Factory.addGetterSetter(Transformer$1, 'ignoreStroke', false);
	Factory_1.Factory.addGetterSetter(Transformer$1, 'padding', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Transformer$1, 'nodes');
	Factory_1.Factory.addGetterSetter(Transformer$1, 'node');
	Factory_1.Factory.addGetterSetter(Transformer$1, 'boundBoxFunc');
	Factory_1.Factory.addGetterSetter(Transformer$1, 'anchorDragBoundFunc');
	Factory_1.Factory.addGetterSetter(Transformer$1, 'anchorStyleFunc');
	Factory_1.Factory.addGetterSetter(Transformer$1, 'shouldOverdrawWholeArea', false);
	Factory_1.Factory.addGetterSetter(Transformer$1, 'useSingleNodeRotation', true);
	Factory_1.Factory.backCompat(Transformer$1, {
	    lineEnabled: 'borderEnabled',
	    rotateHandlerOffset: 'rotateAnchorOffset',
	    enabledHandlers: 'enabledAnchors',
	});
	return Transformer;
}

var Wedge = {};

var hasRequiredWedge;

function requireWedge () {
	if (hasRequiredWedge) return Wedge;
	hasRequiredWedge = 1;
	Object.defineProperty(Wedge, "__esModule", { value: true });
	Wedge.Wedge = void 0;
	const Factory_1 = requireFactory();
	const Shape_1 = requireShape();
	const Global_1 = requireGlobal();
	const Validators_1 = requireValidators();
	const Global_2 = requireGlobal();
	let Wedge$1 = class Wedge extends Shape_1.Shape {
	    _sceneFunc(context) {
	        context.beginPath();
	        context.arc(0, 0, this.radius(), 0, Global_1.Konva.getAngle(this.angle()), this.clockwise());
	        context.lineTo(0, 0);
	        context.closePath();
	        context.fillStrokeShape(this);
	    }
	    getWidth() {
	        return this.radius() * 2;
	    }
	    getHeight() {
	        return this.radius() * 2;
	    }
	    setWidth(width) {
	        this.radius(width / 2);
	    }
	    setHeight(height) {
	        this.radius(height / 2);
	    }
	};
	Wedge.Wedge = Wedge$1;
	Wedge$1.prototype.className = 'Wedge';
	Wedge$1.prototype._centroid = true;
	Wedge$1.prototype._attrsAffectingSize = ['radius'];
	(0, Global_2._registerNode)(Wedge$1);
	Factory_1.Factory.addGetterSetter(Wedge$1, 'radius', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Wedge$1, 'angle', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Wedge$1, 'clockwise', false);
	Factory_1.Factory.backCompat(Wedge$1, {
	    angleDeg: 'angle',
	    getAngleDeg: 'getAngle',
	    setAngleDeg: 'setAngle',
	});
	return Wedge;
}

var Blur = {};

var hasRequiredBlur;

function requireBlur () {
	if (hasRequiredBlur) return Blur;
	hasRequiredBlur = 1;
	Object.defineProperty(Blur, "__esModule", { value: true });
	Blur.Blur = void 0;
	const Factory_1 = requireFactory();
	const Node_1 = requireNode();
	const Validators_1 = requireValidators();
	function BlurStack() {
	    this.r = 0;
	    this.g = 0;
	    this.b = 0;
	    this.a = 0;
	    this.next = null;
	}
	const mul_table = [
	    512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292,
	    512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292,
	    273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259,
	    496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292,
	    282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373,
	    364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259,
	    507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381,
	    374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292,
	    287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461,
	    454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373,
	    368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309,
	    305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259,
	    257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442,
	    437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381,
	    377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332,
	    329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292,
	    289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259,
	];
	const shg_table = [
	    9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17,
	    17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19,
	    19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
	    20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
	    21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22,
	    22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
	    22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23,
	    23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
	    23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
	    23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
	    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
	    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
	    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
	    24, 24, 24, 24, 24, 24, 24,
	];
	function filterGaussBlurRGBA(imageData, radius) {
	    const pixels = imageData.data, width = imageData.width, height = imageData.height;
	    let x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, r_out_sum, g_out_sum, b_out_sum, a_out_sum, r_in_sum, g_in_sum, b_in_sum, a_in_sum, pr, pg, pb, pa, rbs;
	    const div = radius + radius + 1, widthMinus1 = width - 1, heightMinus1 = height - 1, radiusPlus1 = radius + 1, sumFactor = (radiusPlus1 * (radiusPlus1 + 1)) / 2, stackStart = new BlurStack(), mul_sum = mul_table[radius], shg_sum = shg_table[radius];
	    let stackEnd = null, stack = stackStart, stackIn = null, stackOut = null;
	    for (i = 1; i < div; i++) {
	        stack = stack.next = new BlurStack();
	        if (i === radiusPlus1) {
	            stackEnd = stack;
	        }
	    }
	    stack.next = stackStart;
	    yw = yi = 0;
	    for (y = 0; y < height; y++) {
	        r_in_sum =
	            g_in_sum =
	                b_in_sum =
	                    a_in_sum =
	                        r_sum =
	                            g_sum =
	                                b_sum =
	                                    a_sum =
	                                        0;
	        r_out_sum = radiusPlus1 * (pr = pixels[yi]);
	        g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
	        b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
	        a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
	        r_sum += sumFactor * pr;
	        g_sum += sumFactor * pg;
	        b_sum += sumFactor * pb;
	        a_sum += sumFactor * pa;
	        stack = stackStart;
	        for (i = 0; i < radiusPlus1; i++) {
	            stack.r = pr;
	            stack.g = pg;
	            stack.b = pb;
	            stack.a = pa;
	            stack = stack.next;
	        }
	        for (i = 1; i < radiusPlus1; i++) {
	            p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
	            r_sum += (stack.r = pr = pixels[p]) * (rbs = radiusPlus1 - i);
	            g_sum += (stack.g = pg = pixels[p + 1]) * rbs;
	            b_sum += (stack.b = pb = pixels[p + 2]) * rbs;
	            a_sum += (stack.a = pa = pixels[p + 3]) * rbs;
	            r_in_sum += pr;
	            g_in_sum += pg;
	            b_in_sum += pb;
	            a_in_sum += pa;
	            stack = stack.next;
	        }
	        stackIn = stackStart;
	        stackOut = stackEnd;
	        for (x = 0; x < width; x++) {
	            pixels[yi + 3] = pa = (a_sum * mul_sum) >> shg_sum;
	            if (pa !== 0) {
	                pa = 255 / pa;
	                pixels[yi] = ((r_sum * mul_sum) >> shg_sum) * pa;
	                pixels[yi + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;
	                pixels[yi + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;
	            }
	            else {
	                pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
	            }
	            r_sum -= r_out_sum;
	            g_sum -= g_out_sum;
	            b_sum -= b_out_sum;
	            a_sum -= a_out_sum;
	            r_out_sum -= stackIn.r;
	            g_out_sum -= stackIn.g;
	            b_out_sum -= stackIn.b;
	            a_out_sum -= stackIn.a;
	            p = (yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1)) << 2;
	            r_in_sum += stackIn.r = pixels[p];
	            g_in_sum += stackIn.g = pixels[p + 1];
	            b_in_sum += stackIn.b = pixels[p + 2];
	            a_in_sum += stackIn.a = pixels[p + 3];
	            r_sum += r_in_sum;
	            g_sum += g_in_sum;
	            b_sum += b_in_sum;
	            a_sum += a_in_sum;
	            stackIn = stackIn.next;
	            r_out_sum += pr = stackOut.r;
	            g_out_sum += pg = stackOut.g;
	            b_out_sum += pb = stackOut.b;
	            a_out_sum += pa = stackOut.a;
	            r_in_sum -= pr;
	            g_in_sum -= pg;
	            b_in_sum -= pb;
	            a_in_sum -= pa;
	            stackOut = stackOut.next;
	            yi += 4;
	        }
	        yw += width;
	    }
	    for (x = 0; x < width; x++) {
	        g_in_sum =
	            b_in_sum =
	                a_in_sum =
	                    r_in_sum =
	                        g_sum =
	                            b_sum =
	                                a_sum =
	                                    r_sum =
	                                        0;
	        yi = x << 2;
	        r_out_sum = radiusPlus1 * (pr = pixels[yi]);
	        g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
	        b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
	        a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
	        r_sum += sumFactor * pr;
	        g_sum += sumFactor * pg;
	        b_sum += sumFactor * pb;
	        a_sum += sumFactor * pa;
	        stack = stackStart;
	        for (i = 0; i < radiusPlus1; i++) {
	            stack.r = pr;
	            stack.g = pg;
	            stack.b = pb;
	            stack.a = pa;
	            stack = stack.next;
	        }
	        yp = width;
	        for (i = 1; i <= radius; i++) {
	            yi = (yp + x) << 2;
	            r_sum += (stack.r = pr = pixels[yi]) * (rbs = radiusPlus1 - i);
	            g_sum += (stack.g = pg = pixels[yi + 1]) * rbs;
	            b_sum += (stack.b = pb = pixels[yi + 2]) * rbs;
	            a_sum += (stack.a = pa = pixels[yi + 3]) * rbs;
	            r_in_sum += pr;
	            g_in_sum += pg;
	            b_in_sum += pb;
	            a_in_sum += pa;
	            stack = stack.next;
	            if (i < heightMinus1) {
	                yp += width;
	            }
	        }
	        yi = x;
	        stackIn = stackStart;
	        stackOut = stackEnd;
	        for (y = 0; y < height; y++) {
	            p = yi << 2;
	            pixels[p + 3] = pa = (a_sum * mul_sum) >> shg_sum;
	            if (pa > 0) {
	                pa = 255 / pa;
	                pixels[p] = ((r_sum * mul_sum) >> shg_sum) * pa;
	                pixels[p + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;
	                pixels[p + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;
	            }
	            else {
	                pixels[p] = pixels[p + 1] = pixels[p + 2] = 0;
	            }
	            r_sum -= r_out_sum;
	            g_sum -= g_out_sum;
	            b_sum -= b_out_sum;
	            a_sum -= a_out_sum;
	            r_out_sum -= stackIn.r;
	            g_out_sum -= stackIn.g;
	            b_out_sum -= stackIn.b;
	            a_out_sum -= stackIn.a;
	            p =
	                (x +
	                    ((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width) <<
	                    2;
	            r_sum += r_in_sum += stackIn.r = pixels[p];
	            g_sum += g_in_sum += stackIn.g = pixels[p + 1];
	            b_sum += b_in_sum += stackIn.b = pixels[p + 2];
	            a_sum += a_in_sum += stackIn.a = pixels[p + 3];
	            stackIn = stackIn.next;
	            r_out_sum += pr = stackOut.r;
	            g_out_sum += pg = stackOut.g;
	            b_out_sum += pb = stackOut.b;
	            a_out_sum += pa = stackOut.a;
	            r_in_sum -= pr;
	            g_in_sum -= pg;
	            b_in_sum -= pb;
	            a_in_sum -= pa;
	            stackOut = stackOut.next;
	            yi += width;
	        }
	    }
	}
	const Blur$1 = function Blur(imageData) {
	    const radius = Math.round(this.blurRadius());
	    if (radius > 0) {
	        filterGaussBlurRGBA(imageData, radius);
	    }
	};
	Blur.Blur = Blur$1;
	Factory_1.Factory.addGetterSetter(Node_1.Node, 'blurRadius', 0, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
	return Blur;
}

var Brighten = {};

var hasRequiredBrighten;

function requireBrighten () {
	if (hasRequiredBrighten) return Brighten;
	hasRequiredBrighten = 1;
	Object.defineProperty(Brighten, "__esModule", { value: true });
	Brighten.Brighten = void 0;
	const Factory_1 = requireFactory();
	const Node_1 = requireNode();
	const Validators_1 = requireValidators();
	const Brighten$1 = function (imageData) {
	    const brightness = this.brightness() * 255, data = imageData.data, len = data.length;
	    for (let i = 0; i < len; i += 4) {
	        data[i] += brightness;
	        data[i + 1] += brightness;
	        data[i + 2] += brightness;
	    }
	};
	Brighten.Brighten = Brighten$1;
	Factory_1.Factory.addGetterSetter(Node_1.Node, 'brightness', 0, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
	return Brighten;
}

var Contrast = {};

var hasRequiredContrast;

function requireContrast () {
	if (hasRequiredContrast) return Contrast;
	hasRequiredContrast = 1;
	Object.defineProperty(Contrast, "__esModule", { value: true });
	Contrast.Contrast = void 0;
	const Factory_1 = requireFactory();
	const Node_1 = requireNode();
	const Validators_1 = requireValidators();
	const Contrast$1 = function (imageData) {
	    const adjust = Math.pow((this.contrast() + 100) / 100, 2);
	    const data = imageData.data, nPixels = data.length;
	    let red = 150, green = 150, blue = 150;
	    for (let i = 0; i < nPixels; i += 4) {
	        red = data[i];
	        green = data[i + 1];
	        blue = data[i + 2];
	        red /= 255;
	        red -= 0.5;
	        red *= adjust;
	        red += 0.5;
	        red *= 255;
	        green /= 255;
	        green -= 0.5;
	        green *= adjust;
	        green += 0.5;
	        green *= 255;
	        blue /= 255;
	        blue -= 0.5;
	        blue *= adjust;
	        blue += 0.5;
	        blue *= 255;
	        red = red < 0 ? 0 : red > 255 ? 255 : red;
	        green = green < 0 ? 0 : green > 255 ? 255 : green;
	        blue = blue < 0 ? 0 : blue > 255 ? 255 : blue;
	        data[i] = red;
	        data[i + 1] = green;
	        data[i + 2] = blue;
	    }
	};
	Contrast.Contrast = Contrast$1;
	Factory_1.Factory.addGetterSetter(Node_1.Node, 'contrast', 0, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
	return Contrast;
}

var Emboss = {};

var hasRequiredEmboss;

function requireEmboss () {
	if (hasRequiredEmboss) return Emboss;
	hasRequiredEmboss = 1;
	Object.defineProperty(Emboss, "__esModule", { value: true });
	Emboss.Emboss = void 0;
	const Factory_1 = requireFactory();
	const Node_1 = requireNode();
	const Util_1 = requireUtil();
	const Validators_1 = requireValidators();
	const Emboss$1 = function (imageData) {
	    const strength = this.embossStrength() * 10, greyLevel = this.embossWhiteLevel() * 255, direction = this.embossDirection(), blend = this.embossBlend(), data = imageData.data, w = imageData.width, h = imageData.height, w4 = w * 4;
	    let dirY = 0, dirX = 0, y = h;
	    switch (direction) {
	        case 'top-left':
	            dirY = -1;
	            dirX = -1;
	            break;
	        case 'top':
	            dirY = -1;
	            dirX = 0;
	            break;
	        case 'top-right':
	            dirY = -1;
	            dirX = 1;
	            break;
	        case 'right':
	            dirY = 0;
	            dirX = 1;
	            break;
	        case 'bottom-right':
	            dirY = 1;
	            dirX = 1;
	            break;
	        case 'bottom':
	            dirY = 1;
	            dirX = 0;
	            break;
	        case 'bottom-left':
	            dirY = 1;
	            dirX = -1;
	            break;
	        case 'left':
	            dirY = 0;
	            dirX = -1;
	            break;
	        default:
	            Util_1.Util.error('Unknown emboss direction: ' + direction);
	    }
	    do {
	        const offsetY = (y - 1) * w4;
	        let otherY = dirY;
	        if (y + otherY < 1) {
	            otherY = 0;
	        }
	        if (y + otherY > h) {
	            otherY = 0;
	        }
	        const offsetYOther = (y - 1 + otherY) * w * 4;
	        let x = w;
	        do {
	            const offset = offsetY + (x - 1) * 4;
	            let otherX = dirX;
	            if (x + otherX < 1) {
	                otherX = 0;
	            }
	            if (x + otherX > w) {
	                otherX = 0;
	            }
	            const offsetOther = offsetYOther + (x - 1 + otherX) * 4;
	            const dR = data[offset] - data[offsetOther];
	            const dG = data[offset + 1] - data[offsetOther + 1];
	            const dB = data[offset + 2] - data[offsetOther + 2];
	            let dif = dR;
	            const absDif = dif > 0 ? dif : -dif;
	            const absG = dG > 0 ? dG : -dG;
	            const absB = dB > 0 ? dB : -dB;
	            if (absG > absDif) {
	                dif = dG;
	            }
	            if (absB > absDif) {
	                dif = dB;
	            }
	            dif *= strength;
	            if (blend) {
	                const r = data[offset] + dif;
	                const g = data[offset + 1] + dif;
	                const b = data[offset + 2] + dif;
	                data[offset] = r > 255 ? 255 : r < 0 ? 0 : r;
	                data[offset + 1] = g > 255 ? 255 : g < 0 ? 0 : g;
	                data[offset + 2] = b > 255 ? 255 : b < 0 ? 0 : b;
	            }
	            else {
	                let grey = greyLevel - dif;
	                if (grey < 0) {
	                    grey = 0;
	                }
	                else if (grey > 255) {
	                    grey = 255;
	                }
	                data[offset] = data[offset + 1] = data[offset + 2] = grey;
	            }
	        } while (--x);
	    } while (--y);
	};
	Emboss.Emboss = Emboss$1;
	Factory_1.Factory.addGetterSetter(Node_1.Node, 'embossStrength', 0.5, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
	Factory_1.Factory.addGetterSetter(Node_1.Node, 'embossWhiteLevel', 0.5, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
	Factory_1.Factory.addGetterSetter(Node_1.Node, 'embossDirection', 'top-left', undefined, Factory_1.Factory.afterSetFilter);
	Factory_1.Factory.addGetterSetter(Node_1.Node, 'embossBlend', false, undefined, Factory_1.Factory.afterSetFilter);
	return Emboss;
}

var Enhance = {};

var hasRequiredEnhance;

function requireEnhance () {
	if (hasRequiredEnhance) return Enhance;
	hasRequiredEnhance = 1;
	Object.defineProperty(Enhance, "__esModule", { value: true });
	Enhance.Enhance = void 0;
	const Factory_1 = requireFactory();
	const Node_1 = requireNode();
	const Validators_1 = requireValidators();
	function remap(fromValue, fromMin, fromMax, toMin, toMax) {
	    const fromRange = fromMax - fromMin, toRange = toMax - toMin;
	    if (fromRange === 0) {
	        return toMin + toRange / 2;
	    }
	    if (toRange === 0) {
	        return toMin;
	    }
	    let toValue = (fromValue - fromMin) / fromRange;
	    toValue = toRange * toValue + toMin;
	    return toValue;
	}
	const Enhance$1 = function (imageData) {
	    const data = imageData.data, nSubPixels = data.length;
	    let rMin = data[0], rMax = rMin, r, gMin = data[1], gMax = gMin, g, bMin = data[2], bMax = bMin, b;
	    const enhanceAmount = this.enhance();
	    if (enhanceAmount === 0) {
	        return;
	    }
	    for (let i = 0; i < nSubPixels; i += 4) {
	        r = data[i + 0];
	        if (r < rMin) {
	            rMin = r;
	        }
	        else if (r > rMax) {
	            rMax = r;
	        }
	        g = data[i + 1];
	        if (g < gMin) {
	            gMin = g;
	        }
	        else if (g > gMax) {
	            gMax = g;
	        }
	        b = data[i + 2];
	        if (b < bMin) {
	            bMin = b;
	        }
	        else if (b > bMax) {
	            bMax = b;
	        }
	    }
	    if (rMax === rMin) {
	        rMax = 255;
	        rMin = 0;
	    }
	    if (gMax === gMin) {
	        gMax = 255;
	        gMin = 0;
	    }
	    if (bMax === bMin) {
	        bMax = 255;
	        bMin = 0;
	    }
	    let rMid, rGoalMax, rGoalMin, gMid, gGoalMax, gGoalMin, bMid, bGoalMax, bGoalMin;
	    if (enhanceAmount > 0) {
	        rGoalMax = rMax + enhanceAmount * (255 - rMax);
	        rGoalMin = rMin - enhanceAmount * (rMin - 0);
	        gGoalMax = gMax + enhanceAmount * (255 - gMax);
	        gGoalMin = gMin - enhanceAmount * (gMin - 0);
	        bGoalMax = bMax + enhanceAmount * (255 - bMax);
	        bGoalMin = bMin - enhanceAmount * (bMin - 0);
	    }
	    else {
	        rMid = (rMax + rMin) * 0.5;
	        rGoalMax = rMax + enhanceAmount * (rMax - rMid);
	        rGoalMin = rMin + enhanceAmount * (rMin - rMid);
	        gMid = (gMax + gMin) * 0.5;
	        gGoalMax = gMax + enhanceAmount * (gMax - gMid);
	        gGoalMin = gMin + enhanceAmount * (gMin - gMid);
	        bMid = (bMax + bMin) * 0.5;
	        bGoalMax = bMax + enhanceAmount * (bMax - bMid);
	        bGoalMin = bMin + enhanceAmount * (bMin - bMid);
	    }
	    for (let i = 0; i < nSubPixels; i += 4) {
	        data[i + 0] = remap(data[i + 0], rMin, rMax, rGoalMin, rGoalMax);
	        data[i + 1] = remap(data[i + 1], gMin, gMax, gGoalMin, gGoalMax);
	        data[i + 2] = remap(data[i + 2], bMin, bMax, bGoalMin, bGoalMax);
	    }
	};
	Enhance.Enhance = Enhance$1;
	Factory_1.Factory.addGetterSetter(Node_1.Node, 'enhance', 0, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
	return Enhance;
}

var Grayscale = {};

var hasRequiredGrayscale;

function requireGrayscale () {
	if (hasRequiredGrayscale) return Grayscale;
	hasRequiredGrayscale = 1;
	Object.defineProperty(Grayscale, "__esModule", { value: true });
	Grayscale.Grayscale = void 0;
	const Grayscale$1 = function (imageData) {
	    const data = imageData.data, len = data.length;
	    for (let i = 0; i < len; i += 4) {
	        const brightness = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2];
	        data[i] = brightness;
	        data[i + 1] = brightness;
	        data[i + 2] = brightness;
	    }
	};
	Grayscale.Grayscale = Grayscale$1;
	return Grayscale;
}

var HSL = {};

var hasRequiredHSL;

function requireHSL () {
	if (hasRequiredHSL) return HSL;
	hasRequiredHSL = 1;
	Object.defineProperty(HSL, "__esModule", { value: true });
	HSL.HSL = void 0;
	const Factory_1 = requireFactory();
	const Node_1 = requireNode();
	const Validators_1 = requireValidators();
	Factory_1.Factory.addGetterSetter(Node_1.Node, 'hue', 0, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
	Factory_1.Factory.addGetterSetter(Node_1.Node, 'saturation', 0, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
	Factory_1.Factory.addGetterSetter(Node_1.Node, 'luminance', 0, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
	const HSL$1 = function (imageData) {
	    const data = imageData.data, nPixels = data.length, v = 1, s = Math.pow(2, this.saturation()), h = Math.abs(this.hue() + 360) % 360, l = this.luminance() * 127;
	    const vsu = v * s * Math.cos((h * Math.PI) / 180), vsw = v * s * Math.sin((h * Math.PI) / 180);
	    const rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw, rg = 0.587 * v - 0.587 * vsu + 0.33 * vsw, rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
	    const gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw, gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw, gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
	    const br = 0.299 * v - 0.3 * vsu + 1.25 * vsw, bg = 0.587 * v - 0.586 * vsu - 1.05 * vsw, bb = 0.114 * v + 0.886 * vsu - 0.2 * vsw;
	    let r, g, b, a;
	    for (let i = 0; i < nPixels; i += 4) {
	        r = data[i + 0];
	        g = data[i + 1];
	        b = data[i + 2];
	        a = data[i + 3];
	        data[i + 0] = rr * r + rg * g + rb * b + l;
	        data[i + 1] = gr * r + gg * g + gb * b + l;
	        data[i + 2] = br * r + bg * g + bb * b + l;
	        data[i + 3] = a;
	    }
	};
	HSL.HSL = HSL$1;
	return HSL;
}

var HSV = {};

var hasRequiredHSV;

function requireHSV () {
	if (hasRequiredHSV) return HSV;
	hasRequiredHSV = 1;
	Object.defineProperty(HSV, "__esModule", { value: true });
	HSV.HSV = void 0;
	const Factory_1 = requireFactory();
	const Node_1 = requireNode();
	const Validators_1 = requireValidators();
	const HSV$1 = function (imageData) {
	    const data = imageData.data, nPixels = data.length, v = Math.pow(2, this.value()), s = Math.pow(2, this.saturation()), h = Math.abs(this.hue() + 360) % 360;
	    const vsu = v * s * Math.cos((h * Math.PI) / 180), vsw = v * s * Math.sin((h * Math.PI) / 180);
	    const rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw, rg = 0.587 * v - 0.587 * vsu + 0.33 * vsw, rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
	    const gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw, gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw, gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
	    const br = 0.299 * v - 0.3 * vsu + 1.25 * vsw, bg = 0.587 * v - 0.586 * vsu - 1.05 * vsw, bb = 0.114 * v + 0.886 * vsu - 0.2 * vsw;
	    let r, g, b, a;
	    for (let i = 0; i < nPixels; i += 4) {
	        r = data[i + 0];
	        g = data[i + 1];
	        b = data[i + 2];
	        a = data[i + 3];
	        data[i + 0] = rr * r + rg * g + rb * b;
	        data[i + 1] = gr * r + gg * g + gb * b;
	        data[i + 2] = br * r + bg * g + bb * b;
	        data[i + 3] = a;
	    }
	};
	HSV.HSV = HSV$1;
	Factory_1.Factory.addGetterSetter(Node_1.Node, 'hue', 0, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
	Factory_1.Factory.addGetterSetter(Node_1.Node, 'saturation', 0, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
	Factory_1.Factory.addGetterSetter(Node_1.Node, 'value', 0, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
	return HSV;
}

var Invert = {};

var hasRequiredInvert;

function requireInvert () {
	if (hasRequiredInvert) return Invert;
	hasRequiredInvert = 1;
	Object.defineProperty(Invert, "__esModule", { value: true });
	Invert.Invert = void 0;
	const Invert$1 = function (imageData) {
	    const data = imageData.data, len = data.length;
	    for (let i = 0; i < len; i += 4) {
	        data[i] = 255 - data[i];
	        data[i + 1] = 255 - data[i + 1];
	        data[i + 2] = 255 - data[i + 2];
	    }
	};
	Invert.Invert = Invert$1;
	return Invert;
}

var Kaleidoscope = {};

var hasRequiredKaleidoscope;

function requireKaleidoscope () {
	if (hasRequiredKaleidoscope) return Kaleidoscope;
	hasRequiredKaleidoscope = 1;
	Object.defineProperty(Kaleidoscope, "__esModule", { value: true });
	Kaleidoscope.Kaleidoscope = void 0;
	const Factory_1 = requireFactory();
	const Node_1 = requireNode();
	const Util_1 = requireUtil();
	const Validators_1 = requireValidators();
	const ToPolar = function (src, dst, opt) {
	    const srcPixels = src.data, dstPixels = dst.data, xSize = src.width, ySize = src.height, xMid = opt.polarCenterX || xSize / 2, yMid = opt.polarCenterY || ySize / 2;
	    let rMax = Math.sqrt(xMid * xMid + yMid * yMid);
	    let x = xSize - xMid;
	    let y = ySize - yMid;
	    const rad = Math.sqrt(x * x + y * y);
	    rMax = rad > rMax ? rad : rMax;
	    const rSize = ySize, tSize = xSize;
	    const conversion = ((360 / tSize) * Math.PI) / 180;
	    for (let theta = 0; theta < tSize; theta += 1) {
	        const sin = Math.sin(theta * conversion);
	        const cos = Math.cos(theta * conversion);
	        for (let radius = 0; radius < rSize; radius += 1) {
	            x = Math.floor(xMid + ((rMax * radius) / rSize) * cos);
	            y = Math.floor(yMid + ((rMax * radius) / rSize) * sin);
	            let i = (y * xSize + x) * 4;
	            const r = srcPixels[i + 0];
	            const g = srcPixels[i + 1];
	            const b = srcPixels[i + 2];
	            const a = srcPixels[i + 3];
	            i = (theta + radius * xSize) * 4;
	            dstPixels[i + 0] = r;
	            dstPixels[i + 1] = g;
	            dstPixels[i + 2] = b;
	            dstPixels[i + 3] = a;
	        }
	    }
	};
	const FromPolar = function (src, dst, opt) {
	    const srcPixels = src.data, dstPixels = dst.data, xSize = src.width, ySize = src.height, xMid = opt.polarCenterX || xSize / 2, yMid = opt.polarCenterY || ySize / 2;
	    let rMax = Math.sqrt(xMid * xMid + yMid * yMid);
	    let x = xSize - xMid;
	    let y = ySize - yMid;
	    const rad = Math.sqrt(x * x + y * y);
	    rMax = rad > rMax ? rad : rMax;
	    const rSize = ySize, tSize = xSize, phaseShift = 0;
	    let x1, y1;
	    for (x = 0; x < xSize; x += 1) {
	        for (y = 0; y < ySize; y += 1) {
	            const dx = x - xMid;
	            const dy = y - yMid;
	            const radius = (Math.sqrt(dx * dx + dy * dy) * rSize) / rMax;
	            let theta = ((Math.atan2(dy, dx) * 180) / Math.PI + 360 + phaseShift) % 360;
	            theta = (theta * tSize) / 360;
	            x1 = Math.floor(theta);
	            y1 = Math.floor(radius);
	            let i = (y1 * xSize + x1) * 4;
	            const r = srcPixels[i + 0];
	            const g = srcPixels[i + 1];
	            const b = srcPixels[i + 2];
	            const a = srcPixels[i + 3];
	            i = (y * xSize + x) * 4;
	            dstPixels[i + 0] = r;
	            dstPixels[i + 1] = g;
	            dstPixels[i + 2] = b;
	            dstPixels[i + 3] = a;
	        }
	    }
	};
	const Kaleidoscope$1 = function (imageData) {
	    const xSize = imageData.width, ySize = imageData.height;
	    let x, y, xoff, i, r, g, b, a, srcPos, dstPos;
	    let power = Math.round(this.kaleidoscopePower());
	    const angle = Math.round(this.kaleidoscopeAngle());
	    const offset = Math.floor((xSize * (angle % 360)) / 360);
	    if (power < 1) {
	        return;
	    }
	    const tempCanvas = Util_1.Util.createCanvasElement();
	    tempCanvas.width = xSize;
	    tempCanvas.height = ySize;
	    const scratchData = tempCanvas
	        .getContext('2d')
	        .getImageData(0, 0, xSize, ySize);
	    Util_1.Util.releaseCanvas(tempCanvas);
	    ToPolar(imageData, scratchData, {
	        polarCenterX: xSize / 2,
	        polarCenterY: ySize / 2,
	    });
	    let minSectionSize = xSize / Math.pow(2, power);
	    while (minSectionSize <= 8) {
	        minSectionSize = minSectionSize * 2;
	        power -= 1;
	    }
	    minSectionSize = Math.ceil(minSectionSize);
	    let sectionSize = minSectionSize;
	    let xStart = 0, xEnd = sectionSize, xDelta = 1;
	    if (offset + minSectionSize > xSize) {
	        xStart = sectionSize;
	        xEnd = 0;
	        xDelta = -1;
	    }
	    for (y = 0; y < ySize; y += 1) {
	        for (x = xStart; x !== xEnd; x += xDelta) {
	            xoff = Math.round(x + offset) % xSize;
	            srcPos = (xSize * y + xoff) * 4;
	            r = scratchData.data[srcPos + 0];
	            g = scratchData.data[srcPos + 1];
	            b = scratchData.data[srcPos + 2];
	            a = scratchData.data[srcPos + 3];
	            dstPos = (xSize * y + x) * 4;
	            scratchData.data[dstPos + 0] = r;
	            scratchData.data[dstPos + 1] = g;
	            scratchData.data[dstPos + 2] = b;
	            scratchData.data[dstPos + 3] = a;
	        }
	    }
	    for (y = 0; y < ySize; y += 1) {
	        sectionSize = Math.floor(minSectionSize);
	        for (i = 0; i < power; i += 1) {
	            for (x = 0; x < sectionSize + 1; x += 1) {
	                srcPos = (xSize * y + x) * 4;
	                r = scratchData.data[srcPos + 0];
	                g = scratchData.data[srcPos + 1];
	                b = scratchData.data[srcPos + 2];
	                a = scratchData.data[srcPos + 3];
	                dstPos = (xSize * y + sectionSize * 2 - x - 1) * 4;
	                scratchData.data[dstPos + 0] = r;
	                scratchData.data[dstPos + 1] = g;
	                scratchData.data[dstPos + 2] = b;
	                scratchData.data[dstPos + 3] = a;
	            }
	            sectionSize *= 2;
	        }
	    }
	    FromPolar(scratchData, imageData, { });
	};
	Kaleidoscope.Kaleidoscope = Kaleidoscope$1;
	Factory_1.Factory.addGetterSetter(Node_1.Node, 'kaleidoscopePower', 2, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
	Factory_1.Factory.addGetterSetter(Node_1.Node, 'kaleidoscopeAngle', 0, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
	return Kaleidoscope;
}

var Mask = {};

var hasRequiredMask;

function requireMask () {
	if (hasRequiredMask) return Mask;
	hasRequiredMask = 1;
	Object.defineProperty(Mask, "__esModule", { value: true });
	Mask.Mask = void 0;
	const Factory_1 = requireFactory();
	const Node_1 = requireNode();
	const Validators_1 = requireValidators();
	function pixelAt(idata, x, y) {
	    let idx = (y * idata.width + x) * 4;
	    const d = [];
	    d.push(idata.data[idx++], idata.data[idx++], idata.data[idx++], idata.data[idx++]);
	    return d;
	}
	function rgbDistance(p1, p2) {
	    return Math.sqrt(Math.pow(p1[0] - p2[0], 2) +
	        Math.pow(p1[1] - p2[1], 2) +
	        Math.pow(p1[2] - p2[2], 2));
	}
	function rgbMean(pTab) {
	    const m = [0, 0, 0];
	    for (let i = 0; i < pTab.length; i++) {
	        m[0] += pTab[i][0];
	        m[1] += pTab[i][1];
	        m[2] += pTab[i][2];
	    }
	    m[0] /= pTab.length;
	    m[1] /= pTab.length;
	    m[2] /= pTab.length;
	    return m;
	}
	function backgroundMask(idata, threshold) {
	    const rgbv_no = pixelAt(idata, 0, 0);
	    const rgbv_ne = pixelAt(idata, idata.width - 1, 0);
	    const rgbv_so = pixelAt(idata, 0, idata.height - 1);
	    const rgbv_se = pixelAt(idata, idata.width - 1, idata.height - 1);
	    const thres = threshold || 10;
	    if (rgbDistance(rgbv_no, rgbv_ne) < thres &&
	        rgbDistance(rgbv_ne, rgbv_se) < thres &&
	        rgbDistance(rgbv_se, rgbv_so) < thres &&
	        rgbDistance(rgbv_so, rgbv_no) < thres) {
	        const mean = rgbMean([rgbv_ne, rgbv_no, rgbv_se, rgbv_so]);
	        const mask = [];
	        for (let i = 0; i < idata.width * idata.height; i++) {
	            const d = rgbDistance(mean, [
	                idata.data[i * 4],
	                idata.data[i * 4 + 1],
	                idata.data[i * 4 + 2],
	            ]);
	            mask[i] = d < thres ? 0 : 255;
	        }
	        return mask;
	    }
	}
	function applyMask(idata, mask) {
	    for (let i = 0; i < idata.width * idata.height; i++) {
	        idata.data[4 * i + 3] = mask[i];
	    }
	}
	function erodeMask(mask, sw, sh) {
	    const weights = [1, 1, 1, 1, 0, 1, 1, 1, 1];
	    const side = Math.round(Math.sqrt(weights.length));
	    const halfSide = Math.floor(side / 2);
	    const maskResult = [];
	    for (let y = 0; y < sh; y++) {
	        for (let x = 0; x < sw; x++) {
	            const so = y * sw + x;
	            let a = 0;
	            for (let cy = 0; cy < side; cy++) {
	                for (let cx = 0; cx < side; cx++) {
	                    const scy = y + cy - halfSide;
	                    const scx = x + cx - halfSide;
	                    if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
	                        const srcOff = scy * sw + scx;
	                        const wt = weights[cy * side + cx];
	                        a += mask[srcOff] * wt;
	                    }
	                }
	            }
	            maskResult[so] = a === 255 * 8 ? 255 : 0;
	        }
	    }
	    return maskResult;
	}
	function dilateMask(mask, sw, sh) {
	    const weights = [1, 1, 1, 1, 1, 1, 1, 1, 1];
	    const side = Math.round(Math.sqrt(weights.length));
	    const halfSide = Math.floor(side / 2);
	    const maskResult = [];
	    for (let y = 0; y < sh; y++) {
	        for (let x = 0; x < sw; x++) {
	            const so = y * sw + x;
	            let a = 0;
	            for (let cy = 0; cy < side; cy++) {
	                for (let cx = 0; cx < side; cx++) {
	                    const scy = y + cy - halfSide;
	                    const scx = x + cx - halfSide;
	                    if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
	                        const srcOff = scy * sw + scx;
	                        const wt = weights[cy * side + cx];
	                        a += mask[srcOff] * wt;
	                    }
	                }
	            }
	            maskResult[so] = a >= 255 * 4 ? 255 : 0;
	        }
	    }
	    return maskResult;
	}
	function smoothEdgeMask(mask, sw, sh) {
	    const weights = [1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9];
	    const side = Math.round(Math.sqrt(weights.length));
	    const halfSide = Math.floor(side / 2);
	    const maskResult = [];
	    for (let y = 0; y < sh; y++) {
	        for (let x = 0; x < sw; x++) {
	            const so = y * sw + x;
	            let a = 0;
	            for (let cy = 0; cy < side; cy++) {
	                for (let cx = 0; cx < side; cx++) {
	                    const scy = y + cy - halfSide;
	                    const scx = x + cx - halfSide;
	                    if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
	                        const srcOff = scy * sw + scx;
	                        const wt = weights[cy * side + cx];
	                        a += mask[srcOff] * wt;
	                    }
	                }
	            }
	            maskResult[so] = a;
	        }
	    }
	    return maskResult;
	}
	const Mask$1 = function (imageData) {
	    const threshold = this.threshold();
	    let mask = backgroundMask(imageData, threshold);
	    if (mask) {
	        mask = erodeMask(mask, imageData.width, imageData.height);
	        mask = dilateMask(mask, imageData.width, imageData.height);
	        mask = smoothEdgeMask(mask, imageData.width, imageData.height);
	        applyMask(imageData, mask);
	    }
	    return imageData;
	};
	Mask.Mask = Mask$1;
	Factory_1.Factory.addGetterSetter(Node_1.Node, 'threshold', 0, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
	return Mask;
}

var Noise = {};

var hasRequiredNoise;

function requireNoise () {
	if (hasRequiredNoise) return Noise;
	hasRequiredNoise = 1;
	Object.defineProperty(Noise, "__esModule", { value: true });
	Noise.Noise = void 0;
	const Factory_1 = requireFactory();
	const Node_1 = requireNode();
	const Validators_1 = requireValidators();
	const Noise$1 = function (imageData) {
	    const amount = this.noise() * 255, data = imageData.data, nPixels = data.length, half = amount / 2;
	    for (let i = 0; i < nPixels; i += 4) {
	        data[i + 0] += half - 2 * half * Math.random();
	        data[i + 1] += half - 2 * half * Math.random();
	        data[i + 2] += half - 2 * half * Math.random();
	    }
	};
	Noise.Noise = Noise$1;
	Factory_1.Factory.addGetterSetter(Node_1.Node, 'noise', 0.2, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
	return Noise;
}

var Pixelate = {};

var hasRequiredPixelate;

function requirePixelate () {
	if (hasRequiredPixelate) return Pixelate;
	hasRequiredPixelate = 1;
	Object.defineProperty(Pixelate, "__esModule", { value: true });
	Pixelate.Pixelate = void 0;
	const Factory_1 = requireFactory();
	const Util_1 = requireUtil();
	const Node_1 = requireNode();
	const Validators_1 = requireValidators();
	const Pixelate$1 = function (imageData) {
	    let pixelSize = Math.ceil(this.pixelSize()), width = imageData.width, height = imageData.height, x, y, i, red, green, blue, alpha, nBinsX = Math.ceil(width / pixelSize), nBinsY = Math.ceil(height / pixelSize), xBinStart, xBinEnd, yBinStart, yBinEnd, xBin, yBin, pixelsInBin, data = imageData.data;
	    if (pixelSize <= 0) {
	        Util_1.Util.error('pixelSize value can not be <= 0');
	        return;
	    }
	    for (xBin = 0; xBin < nBinsX; xBin += 1) {
	        for (yBin = 0; yBin < nBinsY; yBin += 1) {
	            red = 0;
	            green = 0;
	            blue = 0;
	            alpha = 0;
	            xBinStart = xBin * pixelSize;
	            xBinEnd = xBinStart + pixelSize;
	            yBinStart = yBin * pixelSize;
	            yBinEnd = yBinStart + pixelSize;
	            pixelsInBin = 0;
	            for (x = xBinStart; x < xBinEnd; x += 1) {
	                if (x >= width) {
	                    continue;
	                }
	                for (y = yBinStart; y < yBinEnd; y += 1) {
	                    if (y >= height) {
	                        continue;
	                    }
	                    i = (width * y + x) * 4;
	                    red += data[i + 0];
	                    green += data[i + 1];
	                    blue += data[i + 2];
	                    alpha += data[i + 3];
	                    pixelsInBin += 1;
	                }
	            }
	            red = red / pixelsInBin;
	            green = green / pixelsInBin;
	            blue = blue / pixelsInBin;
	            alpha = alpha / pixelsInBin;
	            for (x = xBinStart; x < xBinEnd; x += 1) {
	                if (x >= width) {
	                    continue;
	                }
	                for (y = yBinStart; y < yBinEnd; y += 1) {
	                    if (y >= height) {
	                        continue;
	                    }
	                    i = (width * y + x) * 4;
	                    data[i + 0] = red;
	                    data[i + 1] = green;
	                    data[i + 2] = blue;
	                    data[i + 3] = alpha;
	                }
	            }
	        }
	    }
	};
	Pixelate.Pixelate = Pixelate$1;
	Factory_1.Factory.addGetterSetter(Node_1.Node, 'pixelSize', 8, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
	return Pixelate;
}

var Posterize = {};

var hasRequiredPosterize;

function requirePosterize () {
	if (hasRequiredPosterize) return Posterize;
	hasRequiredPosterize = 1;
	Object.defineProperty(Posterize, "__esModule", { value: true });
	Posterize.Posterize = void 0;
	const Factory_1 = requireFactory();
	const Node_1 = requireNode();
	const Validators_1 = requireValidators();
	const Posterize$1 = function (imageData) {
	    const levels = Math.round(this.levels() * 254) + 1, data = imageData.data, len = data.length, scale = 255 / levels;
	    for (let i = 0; i < len; i += 1) {
	        data[i] = Math.floor(data[i] / scale) * scale;
	    }
	};
	Posterize.Posterize = Posterize$1;
	Factory_1.Factory.addGetterSetter(Node_1.Node, 'levels', 0.5, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
	return Posterize;
}

var RGB = {};

var hasRequiredRGB;

function requireRGB () {
	if (hasRequiredRGB) return RGB;
	hasRequiredRGB = 1;
	Object.defineProperty(RGB, "__esModule", { value: true });
	RGB.RGB = void 0;
	const Factory_1 = requireFactory();
	const Node_1 = requireNode();
	const Validators_1 = requireValidators();
	const RGB$1 = function (imageData) {
	    const data = imageData.data, nPixels = data.length, red = this.red(), green = this.green(), blue = this.blue();
	    for (let i = 0; i < nPixels; i += 4) {
	        const brightness = (0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2]) / 255;
	        data[i] = brightness * red;
	        data[i + 1] = brightness * green;
	        data[i + 2] = brightness * blue;
	        data[i + 3] = data[i + 3];
	    }
	};
	RGB.RGB = RGB$1;
	Factory_1.Factory.addGetterSetter(Node_1.Node, 'red', 0, function (val) {
	    this._filterUpToDate = false;
	    if (val > 255) {
	        return 255;
	    }
	    else if (val < 0) {
	        return 0;
	    }
	    else {
	        return Math.round(val);
	    }
	});
	Factory_1.Factory.addGetterSetter(Node_1.Node, 'green', 0, function (val) {
	    this._filterUpToDate = false;
	    if (val > 255) {
	        return 255;
	    }
	    else if (val < 0) {
	        return 0;
	    }
	    else {
	        return Math.round(val);
	    }
	});
	Factory_1.Factory.addGetterSetter(Node_1.Node, 'blue', 0, Validators_1.RGBComponent, Factory_1.Factory.afterSetFilter);
	return RGB;
}

var RGBA = {};

var hasRequiredRGBA;

function requireRGBA () {
	if (hasRequiredRGBA) return RGBA;
	hasRequiredRGBA = 1;
	Object.defineProperty(RGBA, "__esModule", { value: true });
	RGBA.RGBA = void 0;
	const Factory_1 = requireFactory();
	const Node_1 = requireNode();
	const Validators_1 = requireValidators();
	const RGBA$1 = function (imageData) {
	    const data = imageData.data, nPixels = data.length, red = this.red(), green = this.green(), blue = this.blue(), alpha = this.alpha();
	    for (let i = 0; i < nPixels; i += 4) {
	        const ia = 1 - alpha;
	        data[i] = red * alpha + data[i] * ia;
	        data[i + 1] = green * alpha + data[i + 1] * ia;
	        data[i + 2] = blue * alpha + data[i + 2] * ia;
	    }
	};
	RGBA.RGBA = RGBA$1;
	Factory_1.Factory.addGetterSetter(Node_1.Node, 'red', 0, function (val) {
	    this._filterUpToDate = false;
	    if (val > 255) {
	        return 255;
	    }
	    else if (val < 0) {
	        return 0;
	    }
	    else {
	        return Math.round(val);
	    }
	});
	Factory_1.Factory.addGetterSetter(Node_1.Node, 'green', 0, function (val) {
	    this._filterUpToDate = false;
	    if (val > 255) {
	        return 255;
	    }
	    else if (val < 0) {
	        return 0;
	    }
	    else {
	        return Math.round(val);
	    }
	});
	Factory_1.Factory.addGetterSetter(Node_1.Node, 'blue', 0, Validators_1.RGBComponent, Factory_1.Factory.afterSetFilter);
	Factory_1.Factory.addGetterSetter(Node_1.Node, 'alpha', 1, function (val) {
	    this._filterUpToDate = false;
	    if (val > 1) {
	        return 1;
	    }
	    else if (val < 0) {
	        return 0;
	    }
	    else {
	        return val;
	    }
	});
	return RGBA;
}

var Sepia = {};

var hasRequiredSepia;

function requireSepia () {
	if (hasRequiredSepia) return Sepia;
	hasRequiredSepia = 1;
	Object.defineProperty(Sepia, "__esModule", { value: true });
	Sepia.Sepia = void 0;
	const Sepia$1 = function (imageData) {
	    const data = imageData.data, nPixels = data.length;
	    for (let i = 0; i < nPixels; i += 4) {
	        const r = data[i + 0];
	        const g = data[i + 1];
	        const b = data[i + 2];
	        data[i + 0] = Math.min(255, r * 0.393 + g * 0.769 + b * 0.189);
	        data[i + 1] = Math.min(255, r * 0.349 + g * 0.686 + b * 0.168);
	        data[i + 2] = Math.min(255, r * 0.272 + g * 0.534 + b * 0.131);
	    }
	};
	Sepia.Sepia = Sepia$1;
	return Sepia;
}

var Solarize = {};

var hasRequiredSolarize;

function requireSolarize () {
	if (hasRequiredSolarize) return Solarize;
	hasRequiredSolarize = 1;
	Object.defineProperty(Solarize, "__esModule", { value: true });
	Solarize.Solarize = void 0;
	const Solarize$1 = function (imageData) {
	    const data = imageData.data, w = imageData.width, h = imageData.height, w4 = w * 4;
	    let y = h;
	    do {
	        const offsetY = (y - 1) * w4;
	        let x = w;
	        do {
	            const offset = offsetY + (x - 1) * 4;
	            let r = data[offset];
	            let g = data[offset + 1];
	            let b = data[offset + 2];
	            if (r > 127) {
	                r = 255 - r;
	            }
	            if (g > 127) {
	                g = 255 - g;
	            }
	            if (b > 127) {
	                b = 255 - b;
	            }
	            data[offset] = r;
	            data[offset + 1] = g;
	            data[offset + 2] = b;
	        } while (--x);
	    } while (--y);
	};
	Solarize.Solarize = Solarize$1;
	return Solarize;
}

var Threshold = {};

var hasRequiredThreshold;

function requireThreshold () {
	if (hasRequiredThreshold) return Threshold;
	hasRequiredThreshold = 1;
	Object.defineProperty(Threshold, "__esModule", { value: true });
	Threshold.Threshold = void 0;
	const Factory_1 = requireFactory();
	const Node_1 = requireNode();
	const Validators_1 = requireValidators();
	const Threshold$1 = function (imageData) {
	    const level = this.threshold() * 255, data = imageData.data, len = data.length;
	    for (let i = 0; i < len; i += 1) {
	        data[i] = data[i] < level ? 0 : 255;
	    }
	};
	Threshold.Threshold = Threshold$1;
	Factory_1.Factory.addGetterSetter(Node_1.Node, 'threshold', 0.5, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
	return Threshold;
}

var hasRequired_FullInternals;

function require_FullInternals () {
	if (hasRequired_FullInternals) return _FullInternals;
	hasRequired_FullInternals = 1;
	Object.defineProperty(_FullInternals, "__esModule", { value: true });
	_FullInternals.Konva = void 0;
	const _CoreInternals_1 = require_CoreInternals();
	const Arc_1 = requireArc();
	const Arrow_1 = requireArrow();
	const Circle_1 = requireCircle();
	const Ellipse_1 = requireEllipse();
	const Image_1 = requireImage();
	const Label_1 = requireLabel();
	const Line_1 = requireLine();
	const Path_1 = requirePath();
	const Rect_1 = requireRect();
	const RegularPolygon_1 = requireRegularPolygon();
	const Ring_1 = requireRing();
	const Sprite_1 = requireSprite();
	const Star_1 = requireStar();
	const Text_1 = requireText();
	const TextPath_1 = requireTextPath();
	const Transformer_1 = requireTransformer();
	const Wedge_1 = requireWedge();
	const Blur_1 = requireBlur();
	const Brighten_1 = requireBrighten();
	const Contrast_1 = requireContrast();
	const Emboss_1 = requireEmboss();
	const Enhance_1 = requireEnhance();
	const Grayscale_1 = requireGrayscale();
	const HSL_1 = requireHSL();
	const HSV_1 = requireHSV();
	const Invert_1 = requireInvert();
	const Kaleidoscope_1 = requireKaleidoscope();
	const Mask_1 = requireMask();
	const Noise_1 = requireNoise();
	const Pixelate_1 = requirePixelate();
	const Posterize_1 = requirePosterize();
	const RGB_1 = requireRGB();
	const RGBA_1 = requireRGBA();
	const Sepia_1 = requireSepia();
	const Solarize_1 = requireSolarize();
	const Threshold_1 = requireThreshold();
	_FullInternals.Konva = _CoreInternals_1.Konva.Util._assign(_CoreInternals_1.Konva, {
	    Arc: Arc_1.Arc,
	    Arrow: Arrow_1.Arrow,
	    Circle: Circle_1.Circle,
	    Ellipse: Ellipse_1.Ellipse,
	    Image: Image_1.Image,
	    Label: Label_1.Label,
	    Tag: Label_1.Tag,
	    Line: Line_1.Line,
	    Path: Path_1.Path,
	    Rect: Rect_1.Rect,
	    RegularPolygon: RegularPolygon_1.RegularPolygon,
	    Ring: Ring_1.Ring,
	    Sprite: Sprite_1.Sprite,
	    Star: Star_1.Star,
	    Text: Text_1.Text,
	    TextPath: TextPath_1.TextPath,
	    Transformer: Transformer_1.Transformer,
	    Wedge: Wedge_1.Wedge,
	    Filters: {
	        Blur: Blur_1.Blur,
	        Brighten: Brighten_1.Brighten,
	        Contrast: Contrast_1.Contrast,
	        Emboss: Emboss_1.Emboss,
	        Enhance: Enhance_1.Enhance,
	        Grayscale: Grayscale_1.Grayscale,
	        HSL: HSL_1.HSL,
	        HSV: HSV_1.HSV,
	        Invert: Invert_1.Invert,
	        Kaleidoscope: Kaleidoscope_1.Kaleidoscope,
	        Mask: Mask_1.Mask,
	        Noise: Noise_1.Noise,
	        Pixelate: Pixelate_1.Pixelate,
	        Posterize: Posterize_1.Posterize,
	        RGB: RGB_1.RGB,
	        RGBA: RGBA_1.RGBA,
	        Sepia: Sepia_1.Sepia,
	        Solarize: Solarize_1.Solarize,
	        Threshold: Threshold_1.Threshold,
	    },
	});
	return _FullInternals;
}

var lib = lib$1.exports;

var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib$1.exports;
	hasRequiredLib = 1;
	Object.defineProperty(lib, "__esModule", { value: true });
	const _FullInternals_1 = require_FullInternals();
	lib$1.exports = _FullInternals_1.Konva;
	return lib$1.exports;
}

requireLib();

var Core = {exports: {}};

var hasRequiredCore;

function requireCore () {
	if (hasRequiredCore) return Core.exports;
	hasRequiredCore = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Konva = void 0;
		var _CoreInternals_1 = require_CoreInternals();
		Object.defineProperty(exports, "Konva", { enumerable: true, get: function () { return _CoreInternals_1.Konva; } });
		const _CoreInternals_2 = require_CoreInternals();
		module.exports = _CoreInternals_2.Konva; 
	} (Core, Core.exports));
	return Core.exports;
}

var CoreExports = requireCore();
var Konva = /*@__PURE__*/getDefaultExportFromCjs(CoreExports);

var reactReconciler = {exports: {}};

var reactReconciler_production = {exports: {}};

var scheduler$1 = {exports: {}};

var scheduler_production$1 = {};

/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredScheduler_production$1;

function requireScheduler_production$1 () {
	if (hasRequiredScheduler_production$1) return scheduler_production$1;
	hasRequiredScheduler_production$1 = 1;
	(function (exports) {
		function push(heap, node) {
		  var index = heap.length;
		  heap.push(node);
		  a: for (; 0 < index; ) {
		    var parentIndex = (index - 1) >>> 1,
		      parent = heap[parentIndex];
		    if (0 < compare(parent, node))
		      (heap[parentIndex] = node), (heap[index] = parent), (index = parentIndex);
		    else break a;
		  }
		}
		function peek(heap) {
		  return 0 === heap.length ? null : heap[0];
		}
		function pop(heap) {
		  if (0 === heap.length) return null;
		  var first = heap[0],
		    last = heap.pop();
		  if (last !== first) {
		    heap[0] = last;
		    a: for (
		      var index = 0, length = heap.length, halfLength = length >>> 1;
		      index < halfLength;

		    ) {
		      var leftIndex = 2 * (index + 1) - 1,
		        left = heap[leftIndex],
		        rightIndex = leftIndex + 1,
		        right = heap[rightIndex];
		      if (0 > compare(left, last))
		        rightIndex < length && 0 > compare(right, left)
		          ? ((heap[index] = right),
		            (heap[rightIndex] = last),
		            (index = rightIndex))
		          : ((heap[index] = left),
		            (heap[leftIndex] = last),
		            (index = leftIndex));
		      else if (rightIndex < length && 0 > compare(right, last))
		        (heap[index] = right), (heap[rightIndex] = last), (index = rightIndex);
		      else break a;
		    }
		  }
		  return first;
		}
		function compare(a, b) {
		  var diff = a.sortIndex - b.sortIndex;
		  return 0 !== diff ? diff : a.id - b.id;
		}
		exports.unstable_now = void 0;
		if ("object" === typeof performance && "function" === typeof performance.now) {
		  var localPerformance = performance;
		  exports.unstable_now = function () {
		    return localPerformance.now();
		  };
		} else {
		  var localDate = Date,
		    initialTime = localDate.now();
		  exports.unstable_now = function () {
		    return localDate.now() - initialTime;
		  };
		}
		var taskQueue = [],
		  timerQueue = [],
		  taskIdCounter = 1,
		  currentTask = null,
		  currentPriorityLevel = 3,
		  isPerformingWork = false,
		  isHostCallbackScheduled = false,
		  isHostTimeoutScheduled = false,
		  localSetTimeout = "function" === typeof setTimeout ? setTimeout : null,
		  localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null,
		  localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
		function advanceTimers(currentTime) {
		  for (var timer = peek(timerQueue); null !== timer; ) {
		    if (null === timer.callback) pop(timerQueue);
		    else if (timer.startTime <= currentTime)
		      pop(timerQueue),
		        (timer.sortIndex = timer.expirationTime),
		        push(taskQueue, timer);
		    else break;
		    timer = peek(timerQueue);
		  }
		}
		function handleTimeout(currentTime) {
		  isHostTimeoutScheduled = false;
		  advanceTimers(currentTime);
		  if (!isHostCallbackScheduled)
		    if (null !== peek(taskQueue))
		      (isHostCallbackScheduled = true), requestHostCallback();
		    else {
		      var firstTimer = peek(timerQueue);
		      null !== firstTimer &&
		        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
		    }
		}
		var isMessageLoopRunning = false,
		  taskTimeoutID = -1,
		  frameInterval = 5,
		  startTime = -1;
		function shouldYieldToHost() {
		  return exports.unstable_now() - startTime < frameInterval ? false : true;
		}
		function performWorkUntilDeadline() {
		  if (isMessageLoopRunning) {
		    var currentTime = exports.unstable_now();
		    startTime = currentTime;
		    var hasMoreWork = true;
		    try {
		      a: {
		        isHostCallbackScheduled = !1;
		        isHostTimeoutScheduled &&
		          ((isHostTimeoutScheduled = !1),
		          localClearTimeout(taskTimeoutID),
		          (taskTimeoutID = -1));
		        isPerformingWork = !0;
		        var previousPriorityLevel = currentPriorityLevel;
		        try {
		          b: {
		            advanceTimers(currentTime);
		            for (
		              currentTask = peek(taskQueue);
		              null !== currentTask &&
		              !(
		                currentTask.expirationTime > currentTime && shouldYieldToHost()
		              );

		            ) {
		              var callback = currentTask.callback;
		              if ("function" === typeof callback) {
		                currentTask.callback = null;
		                currentPriorityLevel = currentTask.priorityLevel;
		                var continuationCallback = callback(
		                  currentTask.expirationTime <= currentTime
		                );
		                currentTime = exports.unstable_now();
		                if ("function" === typeof continuationCallback) {
		                  currentTask.callback = continuationCallback;
		                  advanceTimers(currentTime);
		                  hasMoreWork = !0;
		                  break b;
		                }
		                currentTask === peek(taskQueue) && pop(taskQueue);
		                advanceTimers(currentTime);
		              } else pop(taskQueue);
		              currentTask = peek(taskQueue);
		            }
		            if (null !== currentTask) hasMoreWork = !0;
		            else {
		              var firstTimer = peek(timerQueue);
		              null !== firstTimer &&
		                requestHostTimeout(
		                  handleTimeout,
		                  firstTimer.startTime - currentTime
		                );
		              hasMoreWork = !1;
		            }
		          }
		          break a;
		        } finally {
		          (currentTask = null),
		            (currentPriorityLevel = previousPriorityLevel),
		            (isPerformingWork = !1);
		        }
		        hasMoreWork = void 0;
		      }
		    } finally {
		      hasMoreWork
		        ? schedulePerformWorkUntilDeadline()
		        : (isMessageLoopRunning = false);
		    }
		  }
		}
		var schedulePerformWorkUntilDeadline;
		if ("function" === typeof localSetImmediate)
		  schedulePerformWorkUntilDeadline = function () {
		    localSetImmediate(performWorkUntilDeadline);
		  };
		else if ("undefined" !== typeof MessageChannel) {
		  var channel = new MessageChannel(),
		    port = channel.port2;
		  channel.port1.onmessage = performWorkUntilDeadline;
		  schedulePerformWorkUntilDeadline = function () {
		    port.postMessage(null);
		  };
		} else
		  schedulePerformWorkUntilDeadline = function () {
		    localSetTimeout(performWorkUntilDeadline, 0);
		  };
		function requestHostCallback() {
		  isMessageLoopRunning ||
		    ((isMessageLoopRunning = true), schedulePerformWorkUntilDeadline());
		}
		function requestHostTimeout(callback, ms) {
		  taskTimeoutID = localSetTimeout(function () {
		    callback(exports.unstable_now());
		  }, ms);
		}
		exports.unstable_IdlePriority = 5;
		exports.unstable_ImmediatePriority = 1;
		exports.unstable_LowPriority = 4;
		exports.unstable_NormalPriority = 3;
		exports.unstable_Profiling = null;
		exports.unstable_UserBlockingPriority = 2;
		exports.unstable_cancelCallback = function (task) {
		  task.callback = null;
		};
		exports.unstable_continueExecution = function () {
		  isHostCallbackScheduled ||
		    isPerformingWork ||
		    ((isHostCallbackScheduled = true), requestHostCallback());
		};
		exports.unstable_forceFrameRate = function (fps) {
		  0 > fps || 125 < fps
		    ? console.error(
		        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
		      )
		    : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);
		};
		exports.unstable_getCurrentPriorityLevel = function () {
		  return currentPriorityLevel;
		};
		exports.unstable_getFirstCallbackNode = function () {
		  return peek(taskQueue);
		};
		exports.unstable_next = function (eventHandler) {
		  switch (currentPriorityLevel) {
		    case 1:
		    case 2:
		    case 3:
		      var priorityLevel = 3;
		      break;
		    default:
		      priorityLevel = currentPriorityLevel;
		  }
		  var previousPriorityLevel = currentPriorityLevel;
		  currentPriorityLevel = priorityLevel;
		  try {
		    return eventHandler();
		  } finally {
		    currentPriorityLevel = previousPriorityLevel;
		  }
		};
		exports.unstable_pauseExecution = function () {};
		exports.unstable_requestPaint = function () {};
		exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {
		  switch (priorityLevel) {
		    case 1:
		    case 2:
		    case 3:
		    case 4:
		    case 5:
		      break;
		    default:
		      priorityLevel = 3;
		  }
		  var previousPriorityLevel = currentPriorityLevel;
		  currentPriorityLevel = priorityLevel;
		  try {
		    return eventHandler();
		  } finally {
		    currentPriorityLevel = previousPriorityLevel;
		  }
		};
		exports.unstable_scheduleCallback = function (
		  priorityLevel,
		  callback,
		  options
		) {
		  var currentTime = exports.unstable_now();
		  "object" === typeof options && null !== options
		    ? ((options = options.delay),
		      (options =
		        "number" === typeof options && 0 < options
		          ? currentTime + options
		          : currentTime))
		    : (options = currentTime);
		  switch (priorityLevel) {
		    case 1:
		      var timeout = -1;
		      break;
		    case 2:
		      timeout = 250;
		      break;
		    case 5:
		      timeout = 1073741823;
		      break;
		    case 4:
		      timeout = 1e4;
		      break;
		    default:
		      timeout = 5e3;
		  }
		  timeout = options + timeout;
		  priorityLevel = {
		    id: taskIdCounter++,
		    callback: callback,
		    priorityLevel: priorityLevel,
		    startTime: options,
		    expirationTime: timeout,
		    sortIndex: -1
		  };
		  options > currentTime
		    ? ((priorityLevel.sortIndex = options),
		      push(timerQueue, priorityLevel),
		      null === peek(taskQueue) &&
		        priorityLevel === peek(timerQueue) &&
		        (isHostTimeoutScheduled
		          ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))
		          : (isHostTimeoutScheduled = true),
		        requestHostTimeout(handleTimeout, options - currentTime)))
		    : ((priorityLevel.sortIndex = timeout),
		      push(taskQueue, priorityLevel),
		      isHostCallbackScheduled ||
		        isPerformingWork ||
		        ((isHostCallbackScheduled = true), requestHostCallback()));
		  return priorityLevel;
		};
		exports.unstable_shouldYield = shouldYieldToHost;
		exports.unstable_wrapCallback = function (callback) {
		  var parentPriorityLevel = currentPriorityLevel;
		  return function () {
		    var previousPriorityLevel = currentPriorityLevel;
		    currentPriorityLevel = parentPriorityLevel;
		    try {
		      return callback.apply(this, arguments);
		    } finally {
		      currentPriorityLevel = previousPriorityLevel;
		    }
		  };
		}; 
	} (scheduler_production$1));
	return scheduler_production$1;
}

var scheduler_development$1 = {};

/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredScheduler_development$1;

function requireScheduler_development$1 () {
	if (hasRequiredScheduler_development$1) return scheduler_development$1;
	hasRequiredScheduler_development$1 = 1;
	(function (exports) {
		"production" !== process.env.NODE_ENV &&
		  (function () {
		    function performWorkUntilDeadline() {
		      if (isMessageLoopRunning) {
		        var currentTime = exports.unstable_now();
		        startTime = currentTime;
		        var hasMoreWork = true;
		        try {
		          a: {
		            isHostCallbackScheduled = !1;
		            isHostTimeoutScheduled &&
		              ((isHostTimeoutScheduled = !1),
		              localClearTimeout(taskTimeoutID),
		              (taskTimeoutID = -1));
		            isPerformingWork = !0;
		            var previousPriorityLevel = currentPriorityLevel;
		            try {
		              b: {
		                advanceTimers(currentTime);
		                for (
		                  currentTask = peek(taskQueue);
		                  null !== currentTask &&
		                  !(
		                    currentTask.expirationTime > currentTime &&
		                    shouldYieldToHost()
		                  );

		                ) {
		                  var callback = currentTask.callback;
		                  if ("function" === typeof callback) {
		                    currentTask.callback = null;
		                    currentPriorityLevel = currentTask.priorityLevel;
		                    var continuationCallback = callback(
		                      currentTask.expirationTime <= currentTime
		                    );
		                    currentTime = exports.unstable_now();
		                    if ("function" === typeof continuationCallback) {
		                      currentTask.callback = continuationCallback;
		                      advanceTimers(currentTime);
		                      hasMoreWork = !0;
		                      break b;
		                    }
		                    currentTask === peek(taskQueue) && pop(taskQueue);
		                    advanceTimers(currentTime);
		                  } else pop(taskQueue);
		                  currentTask = peek(taskQueue);
		                }
		                if (null !== currentTask) hasMoreWork = !0;
		                else {
		                  var firstTimer = peek(timerQueue);
		                  null !== firstTimer &&
		                    requestHostTimeout(
		                      handleTimeout,
		                      firstTimer.startTime - currentTime
		                    );
		                  hasMoreWork = !1;
		                }
		              }
		              break a;
		            } finally {
		              (currentTask = null),
		                (currentPriorityLevel = previousPriorityLevel),
		                (isPerformingWork = !1);
		            }
		            hasMoreWork = void 0;
		          }
		        } finally {
		          hasMoreWork
		            ? schedulePerformWorkUntilDeadline()
		            : (isMessageLoopRunning = false);
		        }
		      }
		    }
		    function push(heap, node) {
		      var index = heap.length;
		      heap.push(node);
		      a: for (; 0 < index; ) {
		        var parentIndex = (index - 1) >>> 1,
		          parent = heap[parentIndex];
		        if (0 < compare(parent, node))
		          (heap[parentIndex] = node),
		            (heap[index] = parent),
		            (index = parentIndex);
		        else break a;
		      }
		    }
		    function peek(heap) {
		      return 0 === heap.length ? null : heap[0];
		    }
		    function pop(heap) {
		      if (0 === heap.length) return null;
		      var first = heap[0],
		        last = heap.pop();
		      if (last !== first) {
		        heap[0] = last;
		        a: for (
		          var index = 0, length = heap.length, halfLength = length >>> 1;
		          index < halfLength;

		        ) {
		          var leftIndex = 2 * (index + 1) - 1,
		            left = heap[leftIndex],
		            rightIndex = leftIndex + 1,
		            right = heap[rightIndex];
		          if (0 > compare(left, last))
		            rightIndex < length && 0 > compare(right, left)
		              ? ((heap[index] = right),
		                (heap[rightIndex] = last),
		                (index = rightIndex))
		              : ((heap[index] = left),
		                (heap[leftIndex] = last),
		                (index = leftIndex));
		          else if (rightIndex < length && 0 > compare(right, last))
		            (heap[index] = right),
		              (heap[rightIndex] = last),
		              (index = rightIndex);
		          else break a;
		        }
		      }
		      return first;
		    }
		    function compare(a, b) {
		      var diff = a.sortIndex - b.sortIndex;
		      return 0 !== diff ? diff : a.id - b.id;
		    }
		    function advanceTimers(currentTime) {
		      for (var timer = peek(timerQueue); null !== timer; ) {
		        if (null === timer.callback) pop(timerQueue);
		        else if (timer.startTime <= currentTime)
		          pop(timerQueue),
		            (timer.sortIndex = timer.expirationTime),
		            push(taskQueue, timer);
		        else break;
		        timer = peek(timerQueue);
		      }
		    }
		    function handleTimeout(currentTime) {
		      isHostTimeoutScheduled = false;
		      advanceTimers(currentTime);
		      if (!isHostCallbackScheduled)
		        if (null !== peek(taskQueue))
		          (isHostCallbackScheduled = true), requestHostCallback();
		        else {
		          var firstTimer = peek(timerQueue);
		          null !== firstTimer &&
		            requestHostTimeout(
		              handleTimeout,
		              firstTimer.startTime - currentTime
		            );
		        }
		    }
		    function shouldYieldToHost() {
		      return exports.unstable_now() - startTime < frameInterval ? false : true;
		    }
		    function requestHostCallback() {
		      isMessageLoopRunning ||
		        ((isMessageLoopRunning = true), schedulePerformWorkUntilDeadline());
		    }
		    function requestHostTimeout(callback, ms) {
		      taskTimeoutID = localSetTimeout(function () {
		        callback(exports.unstable_now());
		      }, ms);
		    }
		    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
		      "function" ===
		        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&
		      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
		    exports.unstable_now = void 0;
		    if (
		      "object" === typeof performance &&
		      "function" === typeof performance.now
		    ) {
		      var localPerformance = performance;
		      exports.unstable_now = function () {
		        return localPerformance.now();
		      };
		    } else {
		      var localDate = Date,
		        initialTime = localDate.now();
		      exports.unstable_now = function () {
		        return localDate.now() - initialTime;
		      };
		    }
		    var taskQueue = [],
		      timerQueue = [],
		      taskIdCounter = 1,
		      currentTask = null,
		      currentPriorityLevel = 3,
		      isPerformingWork = false,
		      isHostCallbackScheduled = false,
		      isHostTimeoutScheduled = false,
		      localSetTimeout = "function" === typeof setTimeout ? setTimeout : null,
		      localClearTimeout =
		        "function" === typeof clearTimeout ? clearTimeout : null,
		      localSetImmediate =
		        "undefined" !== typeof setImmediate ? setImmediate : null,
		      isMessageLoopRunning = false,
		      taskTimeoutID = -1,
		      frameInterval = 5,
		      startTime = -1;
		    if ("function" === typeof localSetImmediate)
		      var schedulePerformWorkUntilDeadline = function () {
		        localSetImmediate(performWorkUntilDeadline);
		      };
		    else if ("undefined" !== typeof MessageChannel) {
		      var channel = new MessageChannel(),
		        port = channel.port2;
		      channel.port1.onmessage = performWorkUntilDeadline;
		      schedulePerformWorkUntilDeadline = function () {
		        port.postMessage(null);
		      };
		    } else
		      schedulePerformWorkUntilDeadline = function () {
		        localSetTimeout(performWorkUntilDeadline, 0);
		      };
		    exports.unstable_IdlePriority = 5;
		    exports.unstable_ImmediatePriority = 1;
		    exports.unstable_LowPriority = 4;
		    exports.unstable_NormalPriority = 3;
		    exports.unstable_Profiling = null;
		    exports.unstable_UserBlockingPriority = 2;
		    exports.unstable_cancelCallback = function (task) {
		      task.callback = null;
		    };
		    exports.unstable_continueExecution = function () {
		      isHostCallbackScheduled ||
		        isPerformingWork ||
		        ((isHostCallbackScheduled = true), requestHostCallback());
		    };
		    exports.unstable_forceFrameRate = function (fps) {
		      0 > fps || 125 < fps
		        ? console.error(
		            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
		          )
		        : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);
		    };
		    exports.unstable_getCurrentPriorityLevel = function () {
		      return currentPriorityLevel;
		    };
		    exports.unstable_getFirstCallbackNode = function () {
		      return peek(taskQueue);
		    };
		    exports.unstable_next = function (eventHandler) {
		      switch (currentPriorityLevel) {
		        case 1:
		        case 2:
		        case 3:
		          var priorityLevel = 3;
		          break;
		        default:
		          priorityLevel = currentPriorityLevel;
		      }
		      var previousPriorityLevel = currentPriorityLevel;
		      currentPriorityLevel = priorityLevel;
		      try {
		        return eventHandler();
		      } finally {
		        currentPriorityLevel = previousPriorityLevel;
		      }
		    };
		    exports.unstable_pauseExecution = function () {};
		    exports.unstable_requestPaint = function () {};
		    exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {
		      switch (priorityLevel) {
		        case 1:
		        case 2:
		        case 3:
		        case 4:
		        case 5:
		          break;
		        default:
		          priorityLevel = 3;
		      }
		      var previousPriorityLevel = currentPriorityLevel;
		      currentPriorityLevel = priorityLevel;
		      try {
		        return eventHandler();
		      } finally {
		        currentPriorityLevel = previousPriorityLevel;
		      }
		    };
		    exports.unstable_scheduleCallback = function (
		      priorityLevel,
		      callback,
		      options
		    ) {
		      var currentTime = exports.unstable_now();
		      "object" === typeof options && null !== options
		        ? ((options = options.delay),
		          (options =
		            "number" === typeof options && 0 < options
		              ? currentTime + options
		              : currentTime))
		        : (options = currentTime);
		      switch (priorityLevel) {
		        case 1:
		          var timeout = -1;
		          break;
		        case 2:
		          timeout = 250;
		          break;
		        case 5:
		          timeout = 1073741823;
		          break;
		        case 4:
		          timeout = 1e4;
		          break;
		        default:
		          timeout = 5e3;
		      }
		      timeout = options + timeout;
		      priorityLevel = {
		        id: taskIdCounter++,
		        callback: callback,
		        priorityLevel: priorityLevel,
		        startTime: options,
		        expirationTime: timeout,
		        sortIndex: -1
		      };
		      options > currentTime
		        ? ((priorityLevel.sortIndex = options),
		          push(timerQueue, priorityLevel),
		          null === peek(taskQueue) &&
		            priorityLevel === peek(timerQueue) &&
		            (isHostTimeoutScheduled
		              ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))
		              : (isHostTimeoutScheduled = true),
		            requestHostTimeout(handleTimeout, options - currentTime)))
		        : ((priorityLevel.sortIndex = timeout),
		          push(taskQueue, priorityLevel),
		          isHostCallbackScheduled ||
		            isPerformingWork ||
		            ((isHostCallbackScheduled = true), requestHostCallback()));
		      return priorityLevel;
		    };
		    exports.unstable_shouldYield = shouldYieldToHost;
		    exports.unstable_wrapCallback = function (callback) {
		      var parentPriorityLevel = currentPriorityLevel;
		      return function () {
		        var previousPriorityLevel = currentPriorityLevel;
		        currentPriorityLevel = parentPriorityLevel;
		        try {
		          return callback.apply(this, arguments);
		        } finally {
		          currentPriorityLevel = previousPriorityLevel;
		        }
		      };
		    };
		    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
		      "function" ===
		        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&
		      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
		  })(); 
	} (scheduler_development$1));
	return scheduler_development$1;
}

var hasRequiredScheduler$1;

function requireScheduler$1 () {
	if (hasRequiredScheduler$1) return scheduler$1.exports;
	hasRequiredScheduler$1 = 1;

	if (process.env.NODE_ENV === 'production') {
	  scheduler$1.exports = requireScheduler_production$1();
	} else {
	  scheduler$1.exports = requireScheduler_development$1();
	}
	return scheduler$1.exports;
}

/**
 * @license React
 * react-reconciler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactReconciler_production;

function requireReactReconciler_production () {
	if (hasRequiredReactReconciler_production) return reactReconciler_production.exports;
	hasRequiredReactReconciler_production = 1;
	(function (module) {
		module.exports = function ($$$config) {
		  function createFiber(tag, pendingProps, key, mode) {
		    return new FiberNode(tag, pendingProps, key, mode);
		  }
		  function noop() {}
		  function formatProdErrorMessage(code) {
		    var url = "https://react.dev/errors/" + code;
		    if (1 < arguments.length) {
		      url += "?args[]=" + encodeURIComponent(arguments[1]);
		      for (var i = 2; i < arguments.length; i++)
		        url += "&args[]=" + encodeURIComponent(arguments[i]);
		    }
		    return (
		      "Minified React error #" +
		      code +
		      "; visit " +
		      url +
		      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
		    );
		  }
		  function getIteratorFn(maybeIterable) {
		    if (null === maybeIterable || "object" !== typeof maybeIterable)
		      return null;
		    maybeIterable =
		      (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
		      maybeIterable["@@iterator"];
		    return "function" === typeof maybeIterable ? maybeIterable : null;
		  }
		  function getComponentNameFromType(type) {
		    if (null == type) return null;
		    if ("function" === typeof type)
		      return type.$$typeof === REACT_CLIENT_REFERENCE
		        ? null
		        : type.displayName || type.name || null;
		    if ("string" === typeof type) return type;
		    switch (type) {
		      case REACT_FRAGMENT_TYPE:
		        return "Fragment";
		      case REACT_PORTAL_TYPE:
		        return "Portal";
		      case REACT_PROFILER_TYPE:
		        return "Profiler";
		      case REACT_STRICT_MODE_TYPE:
		        return "StrictMode";
		      case REACT_SUSPENSE_TYPE:
		        return "Suspense";
		      case REACT_SUSPENSE_LIST_TYPE:
		        return "SuspenseList";
		    }
		    if ("object" === typeof type)
		      switch (type.$$typeof) {
		        case REACT_CONTEXT_TYPE:
		          return (type.displayName || "Context") + ".Provider";
		        case REACT_CONSUMER_TYPE:
		          return (type._context.displayName || "Context") + ".Consumer";
		        case REACT_FORWARD_REF_TYPE:
		          var innerType = type.render;
		          type = type.displayName;
		          type ||
		            ((type = innerType.displayName || innerType.name || ""),
		            (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
		          return type;
		        case REACT_MEMO_TYPE:
		          return (
		            (innerType = type.displayName || null),
		            null !== innerType
		              ? innerType
		              : getComponentNameFromType(type.type) || "Memo"
		          );
		        case REACT_LAZY_TYPE:
		          innerType = type._payload;
		          type = type._init;
		          try {
		            return getComponentNameFromType(type(innerType));
		          } catch (x) {}
		      }
		    return null;
		  }
		  function describeBuiltInComponentFrame(name) {
		    if (void 0 === prefix)
		      try {
		        throw Error();
		      } catch (x) {
		        var match = x.stack.trim().match(/\n( *(at )?)/);
		        prefix = (match && match[1]) || "";
		        suffix =
		          -1 < x.stack.indexOf("\n    at")
		            ? " (<anonymous>)"
		            : -1 < x.stack.indexOf("@")
		              ? "@unknown:0:0"
		              : "";
		      }
		    return "\n" + prefix + name + suffix;
		  }
		  function describeNativeComponentFrame(fn, construct) {
		    if (!fn || reentry) return "";
		    reentry = true;
		    var previousPrepareStackTrace = Error.prepareStackTrace;
		    Error.prepareStackTrace = void 0;
		    try {
		      var RunInRootFrame = {
		        DetermineComponentFrameRoot: function () {
		          try {
		            if (construct) {
		              var Fake = function () {
		                throw Error();
		              };
		              Object.defineProperty(Fake.prototype, "props", {
		                set: function () {
		                  throw Error();
		                }
		              });
		              if ("object" === typeof Reflect && Reflect.construct) {
		                try {
		                  Reflect.construct(Fake, []);
		                } catch (x) {
		                  var control = x;
		                }
		                Reflect.construct(fn, [], Fake);
		              } else {
		                try {
		                  Fake.call();
		                } catch (x$0) {
		                  control = x$0;
		                }
		                fn.call(Fake.prototype);
		              }
		            } else {
		              try {
		                throw Error();
		              } catch (x$1) {
		                control = x$1;
		              }
		              (Fake = fn()) &&
		                "function" === typeof Fake.catch &&
		                Fake.catch(function () {});
		            }
		          } catch (sample) {
		            if (sample && control && "string" === typeof sample.stack)
		              return [sample.stack, control.stack];
		          }
		          return [null, null];
		        }
		      };
		      RunInRootFrame.DetermineComponentFrameRoot.displayName =
		        "DetermineComponentFrameRoot";
		      var namePropDescriptor = Object.getOwnPropertyDescriptor(
		        RunInRootFrame.DetermineComponentFrameRoot,
		        "name"
		      );
		      namePropDescriptor &&
		        namePropDescriptor.configurable &&
		        Object.defineProperty(
		          RunInRootFrame.DetermineComponentFrameRoot,
		          "name",
		          { value: "DetermineComponentFrameRoot" }
		        );
		      var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),
		        sampleStack = _RunInRootFrame$Deter[0],
		        controlStack = _RunInRootFrame$Deter[1];
		      if (sampleStack && controlStack) {
		        var sampleLines = sampleStack.split("\n"),
		          controlLines = controlStack.split("\n");
		        for (
		          namePropDescriptor = RunInRootFrame = 0;
		          RunInRootFrame < sampleLines.length &&
		          !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot");

		        )
		          RunInRootFrame++;
		        for (
		          ;
		          namePropDescriptor < controlLines.length &&
		          !controlLines[namePropDescriptor].includes(
		            "DetermineComponentFrameRoot"
		          );

		        )
		          namePropDescriptor++;
		        if (
		          RunInRootFrame === sampleLines.length ||
		          namePropDescriptor === controlLines.length
		        )
		          for (
		            RunInRootFrame = sampleLines.length - 1,
		              namePropDescriptor = controlLines.length - 1;
		            1 <= RunInRootFrame &&
		            0 <= namePropDescriptor &&
		            sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor];

		          )
		            namePropDescriptor--;
		        for (
		          ;
		          1 <= RunInRootFrame && 0 <= namePropDescriptor;
		          RunInRootFrame--, namePropDescriptor--
		        )
		          if (
		            sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]
		          ) {
		            if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
		              do
		                if (
		                  (RunInRootFrame--,
		                  namePropDescriptor--,
		                  0 > namePropDescriptor ||
		                    sampleLines[RunInRootFrame] !==
		                      controlLines[namePropDescriptor])
		                ) {
		                  var frame =
		                    "\n" +
		                    sampleLines[RunInRootFrame].replace(" at new ", " at ");
		                  fn.displayName &&
		                    frame.includes("<anonymous>") &&
		                    (frame = frame.replace("<anonymous>", fn.displayName));
		                  return frame;
		                }
		              while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
		            }
		            break;
		          }
		      }
		    } finally {
		      (reentry = false), (Error.prepareStackTrace = previousPrepareStackTrace);
		    }
		    return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "")
		      ? describeBuiltInComponentFrame(previousPrepareStackTrace)
		      : "";
		  }
		  function describeFiber(fiber) {
		    switch (fiber.tag) {
		      case 26:
		      case 27:
		      case 5:
		        return describeBuiltInComponentFrame(fiber.type);
		      case 16:
		        return describeBuiltInComponentFrame("Lazy");
		      case 13:
		        return describeBuiltInComponentFrame("Suspense");
		      case 19:
		        return describeBuiltInComponentFrame("SuspenseList");
		      case 0:
		      case 15:
		        return (fiber = describeNativeComponentFrame(fiber.type, false)), fiber;
		      case 11:
		        return (
		          (fiber = describeNativeComponentFrame(fiber.type.render, false)), fiber
		        );
		      case 1:
		        return (fiber = describeNativeComponentFrame(fiber.type, true)), fiber;
		      default:
		        return "";
		    }
		  }
		  function getStackByFiberInDevAndProd(workInProgress) {
		    try {
		      var info = "";
		      do
		        (info += describeFiber(workInProgress)),
		          (workInProgress = workInProgress.return);
		      while (workInProgress);
		      return info;
		    } catch (x) {
		      return "\nError generating stack: " + x.message + "\n" + x.stack;
		    }
		  }
		  function getNearestMountedFiber(fiber) {
		    var node = fiber,
		      nearestMounted = fiber;
		    if (fiber.alternate) for (; node.return; ) node = node.return;
		    else {
		      fiber = node;
		      do
		        (node = fiber),
		          0 !== (node.flags & 4098) && (nearestMounted = node.return),
		          (fiber = node.return);
		      while (fiber);
		    }
		    return 3 === node.tag ? nearestMounted : null;
		  }
		  function assertIsMounted(fiber) {
		    if (getNearestMountedFiber(fiber) !== fiber)
		      throw Error(formatProdErrorMessage(188));
		  }
		  function findCurrentFiberUsingSlowPath(fiber) {
		    var alternate = fiber.alternate;
		    if (!alternate) {
		      alternate = getNearestMountedFiber(fiber);
		      if (null === alternate) throw Error(formatProdErrorMessage(188));
		      return alternate !== fiber ? null : fiber;
		    }
		    for (var a = fiber, b = alternate; ; ) {
		      var parentA = a.return;
		      if (null === parentA) break;
		      var parentB = parentA.alternate;
		      if (null === parentB) {
		        b = parentA.return;
		        if (null !== b) {
		          a = b;
		          continue;
		        }
		        break;
		      }
		      if (parentA.child === parentB.child) {
		        for (parentB = parentA.child; parentB; ) {
		          if (parentB === a) return assertIsMounted(parentA), fiber;
		          if (parentB === b) return assertIsMounted(parentA), alternate;
		          parentB = parentB.sibling;
		        }
		        throw Error(formatProdErrorMessage(188));
		      }
		      if (a.return !== b.return) (a = parentA), (b = parentB);
		      else {
		        for (var didFindChild = false, child$2 = parentA.child; child$2; ) {
		          if (child$2 === a) {
		            didFindChild = true;
		            a = parentA;
		            b = parentB;
		            break;
		          }
		          if (child$2 === b) {
		            didFindChild = true;
		            b = parentA;
		            a = parentB;
		            break;
		          }
		          child$2 = child$2.sibling;
		        }
		        if (!didFindChild) {
		          for (child$2 = parentB.child; child$2; ) {
		            if (child$2 === a) {
		              didFindChild = true;
		              a = parentB;
		              b = parentA;
		              break;
		            }
		            if (child$2 === b) {
		              didFindChild = true;
		              b = parentB;
		              a = parentA;
		              break;
		            }
		            child$2 = child$2.sibling;
		          }
		          if (!didFindChild) throw Error(formatProdErrorMessage(189));
		        }
		      }
		      if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
		    }
		    if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
		    return a.stateNode.current === a ? fiber : alternate;
		  }
		  function findCurrentHostFiberImpl(node) {
		    var tag = node.tag;
		    if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
		    for (node = node.child; null !== node; ) {
		      tag = findCurrentHostFiberImpl(node);
		      if (null !== tag) return tag;
		      node = node.sibling;
		    }
		    return null;
		  }
		  function findCurrentHostFiberWithNoPortalsImpl(node) {
		    var tag = node.tag;
		    if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
		    for (node = node.child; null !== node; ) {
		      if (
		        4 !== node.tag &&
		        ((tag = findCurrentHostFiberWithNoPortalsImpl(node)), null !== tag)
		      )
		        return tag;
		      node = node.sibling;
		    }
		    return null;
		  }
		  function createCursor(defaultValue) {
		    return { current: defaultValue };
		  }
		  function pop(cursor) {
		    0 > index$jscomp$0 ||
		      ((cursor.current = valueStack[index$jscomp$0]),
		      (valueStack[index$jscomp$0] = null),
		      index$jscomp$0--);
		  }
		  function push(cursor, value) {
		    index$jscomp$0++;
		    valueStack[index$jscomp$0] = cursor.current;
		    cursor.current = value;
		  }
		  function clz32Fallback(x) {
		    x >>>= 0;
		    return 0 === x ? 32 : (31 - ((log$1(x) / LN2) | 0)) | 0;
		  }
		  function getHighestPriorityLanes(lanes) {
		    var pendingSyncLanes = lanes & 42;
		    if (0 !== pendingSyncLanes) return pendingSyncLanes;
		    switch (lanes & -lanes) {
		      case 1:
		        return 1;
		      case 2:
		        return 2;
		      case 4:
		        return 4;
		      case 8:
		        return 8;
		      case 16:
		        return 16;
		      case 32:
		        return 32;
		      case 64:
		        return 64;
		      case 128:
		      case 256:
		      case 512:
		      case 1024:
		      case 2048:
		      case 4096:
		      case 8192:
		      case 16384:
		      case 32768:
		      case 65536:
		      case 131072:
		      case 262144:
		      case 524288:
		      case 1048576:
		      case 2097152:
		        return lanes & 4194176;
		      case 4194304:
		      case 8388608:
		      case 16777216:
		      case 33554432:
		        return lanes & 62914560;
		      case 67108864:
		        return 67108864;
		      case 134217728:
		        return 134217728;
		      case 268435456:
		        return 268435456;
		      case 536870912:
		        return 536870912;
		      case 1073741824:
		        return 0;
		      default:
		        return lanes;
		    }
		  }
		  function getNextLanes(root, wipLanes) {
		    var pendingLanes = root.pendingLanes;
		    if (0 === pendingLanes) return 0;
		    var nextLanes = 0,
		      suspendedLanes = root.suspendedLanes,
		      pingedLanes = root.pingedLanes,
		      warmLanes = root.warmLanes;
		    root = 0 !== root.finishedLanes;
		    var nonIdlePendingLanes = pendingLanes & 134217727;
		    0 !== nonIdlePendingLanes
		      ? ((pendingLanes = nonIdlePendingLanes & ~suspendedLanes),
		        0 !== pendingLanes
		          ? (nextLanes = getHighestPriorityLanes(pendingLanes))
		          : ((pingedLanes &= nonIdlePendingLanes),
		            0 !== pingedLanes
		              ? (nextLanes = getHighestPriorityLanes(pingedLanes))
		              : root ||
		                ((warmLanes = nonIdlePendingLanes & ~warmLanes),
		                0 !== warmLanes &&
		                  (nextLanes = getHighestPriorityLanes(warmLanes)))))
		      : ((nonIdlePendingLanes = pendingLanes & ~suspendedLanes),
		        0 !== nonIdlePendingLanes
		          ? (nextLanes = getHighestPriorityLanes(nonIdlePendingLanes))
		          : 0 !== pingedLanes
		            ? (nextLanes = getHighestPriorityLanes(pingedLanes))
		            : root ||
		              ((warmLanes = pendingLanes & ~warmLanes),
		              0 !== warmLanes &&
		                (nextLanes = getHighestPriorityLanes(warmLanes))));
		    return 0 === nextLanes
		      ? 0
		      : 0 !== wipLanes &&
		          wipLanes !== nextLanes &&
		          0 === (wipLanes & suspendedLanes) &&
		          ((suspendedLanes = nextLanes & -nextLanes),
		          (warmLanes = wipLanes & -wipLanes),
		          suspendedLanes >= warmLanes ||
		            (32 === suspendedLanes && 0 !== (warmLanes & 4194176)))
		        ? wipLanes
		        : nextLanes;
		  }
		  function checkIfRootIsPrerendering(root, renderLanes) {
		    return (
		      0 ===
		      (root.pendingLanes &
		        ~(root.suspendedLanes & ~root.pingedLanes) &
		        renderLanes)
		    );
		  }
		  function computeExpirationTime(lane, currentTime) {
		    switch (lane) {
		      case 1:
		      case 2:
		      case 4:
		      case 8:
		        return currentTime + 250;
		      case 16:
		      case 32:
		      case 64:
		      case 128:
		      case 256:
		      case 512:
		      case 1024:
		      case 2048:
		      case 4096:
		      case 8192:
		      case 16384:
		      case 32768:
		      case 65536:
		      case 131072:
		      case 262144:
		      case 524288:
		      case 1048576:
		      case 2097152:
		        return currentTime + 5e3;
		      case 4194304:
		      case 8388608:
		      case 16777216:
		      case 33554432:
		        return -1;
		      case 67108864:
		      case 134217728:
		      case 268435456:
		      case 536870912:
		      case 1073741824:
		        return -1;
		      default:
		        return -1;
		    }
		  }
		  function claimNextTransitionLane() {
		    var lane = nextTransitionLane;
		    nextTransitionLane <<= 1;
		    0 === (nextTransitionLane & 4194176) && (nextTransitionLane = 128);
		    return lane;
		  }
		  function claimNextRetryLane() {
		    var lane = nextRetryLane;
		    nextRetryLane <<= 1;
		    0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
		    return lane;
		  }
		  function createLaneMap(initial) {
		    for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
		    return laneMap;
		  }
		  function markRootUpdated$1(root, updateLane) {
		    root.pendingLanes |= updateLane;
		    268435456 !== updateLane &&
		      ((root.suspendedLanes = 0), (root.pingedLanes = 0), (root.warmLanes = 0));
		  }
		  function markRootFinished(
		    root,
		    finishedLanes,
		    remainingLanes,
		    spawnedLane,
		    updatedLanes,
		    suspendedRetryLanes
		  ) {
		    var previouslyPendingLanes = root.pendingLanes;
		    root.pendingLanes = remainingLanes;
		    root.suspendedLanes = 0;
		    root.pingedLanes = 0;
		    root.warmLanes = 0;
		    root.expiredLanes &= remainingLanes;
		    root.entangledLanes &= remainingLanes;
		    root.errorRecoveryDisabledLanes &= remainingLanes;
		    root.shellSuspendCounter = 0;
		    var entanglements = root.entanglements,
		      expirationTimes = root.expirationTimes,
		      hiddenUpdates = root.hiddenUpdates;
		    for (
		      remainingLanes = previouslyPendingLanes & ~remainingLanes;
		      0 < remainingLanes;

		    ) {
		      var index$7 = 31 - clz32(remainingLanes),
		        lane = 1 << index$7;
		      entanglements[index$7] = 0;
		      expirationTimes[index$7] = -1;
		      var hiddenUpdatesForLane = hiddenUpdates[index$7];
		      if (null !== hiddenUpdatesForLane)
		        for (
		          hiddenUpdates[index$7] = null, index$7 = 0;
		          index$7 < hiddenUpdatesForLane.length;
		          index$7++
		        ) {
		          var update = hiddenUpdatesForLane[index$7];
		          null !== update && (update.lane &= -536870913);
		        }
		      remainingLanes &= ~lane;
		    }
		    0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
		    0 !== suspendedRetryLanes &&
		      0 === updatedLanes &&
		      0 !== root.tag &&
		      (root.suspendedLanes |=
		        suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
		  }
		  function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
		    root.pendingLanes |= spawnedLane;
		    root.suspendedLanes &= ~spawnedLane;
		    var spawnedLaneIndex = 31 - clz32(spawnedLane);
		    root.entangledLanes |= spawnedLane;
		    root.entanglements[spawnedLaneIndex] =
		      root.entanglements[spawnedLaneIndex] |
		      1073741824 |
		      (entangledLanes & 4194218);
		  }
		  function markRootEntangled(root, entangledLanes) {
		    var rootEntangledLanes = (root.entangledLanes |= entangledLanes);
		    for (root = root.entanglements; rootEntangledLanes; ) {
		      var index$8 = 31 - clz32(rootEntangledLanes),
		        lane = 1 << index$8;
		      (lane & entangledLanes) | (root[index$8] & entangledLanes) &&
		        (root[index$8] |= entangledLanes);
		      rootEntangledLanes &= ~lane;
		    }
		  }
		  function lanesToEventPriority(lanes) {
		    lanes &= -lanes;
		    return 2 < lanes
		      ? 8 < lanes
		        ? 0 !== (lanes & 134217727)
		          ? 32
		          : 268435456
		        : 8
		      : 2;
		  }
		  function onCommitRoot(root) {
		    if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
		      try {
		        injectedHook.onCommitFiberRoot(
		          rendererID,
		          root,
		          void 0,
		          128 === (root.current.flags & 128)
		        );
		      } catch (err) {}
		  }
		  function setIsStrictModeForDevtools(newIsStrictMode) {
		    "function" === typeof log && unstable_setDisableYieldValue(newIsStrictMode);
		    if (injectedHook && "function" === typeof injectedHook.setStrictMode)
		      try {
		        injectedHook.setStrictMode(rendererID, newIsStrictMode);
		      } catch (err) {}
		  }
		  function is(x, y) {
		    return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
		  }
		  function createCapturedValueAtFiber(value, source) {
		    if ("object" === typeof value && null !== value) {
		      var existing = CapturedStacks.get(value);
		      if (void 0 !== existing) return existing;
		      source = {
		        value: value,
		        source: source,
		        stack: getStackByFiberInDevAndProd(source)
		      };
		      CapturedStacks.set(value, source);
		      return source;
		    }
		    return {
		      value: value,
		      source: source,
		      stack: getStackByFiberInDevAndProd(source)
		    };
		  }
		  function pushTreeFork(workInProgress, totalChildren) {
		    forkStack[forkStackIndex++] = treeForkCount;
		    forkStack[forkStackIndex++] = treeForkProvider;
		    treeForkProvider = workInProgress;
		    treeForkCount = totalChildren;
		  }
		  function pushTreeId(workInProgress, totalChildren, index) {
		    idStack[idStackIndex++] = treeContextId;
		    idStack[idStackIndex++] = treeContextOverflow;
		    idStack[idStackIndex++] = treeContextProvider;
		    treeContextProvider = workInProgress;
		    var baseIdWithLeadingBit = treeContextId;
		    workInProgress = treeContextOverflow;
		    var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
		    baseIdWithLeadingBit &= ~(1 << baseLength);
		    index += 1;
		    var length = 32 - clz32(totalChildren) + baseLength;
		    if (30 < length) {
		      var numberOfOverflowBits = baseLength - (baseLength % 5);
		      length = (
		        baseIdWithLeadingBit &
		        ((1 << numberOfOverflowBits) - 1)
		      ).toString(32);
		      baseIdWithLeadingBit >>= numberOfOverflowBits;
		      baseLength -= numberOfOverflowBits;
		      treeContextId =
		        (1 << (32 - clz32(totalChildren) + baseLength)) |
		        (index << baseLength) |
		        baseIdWithLeadingBit;
		      treeContextOverflow = length + workInProgress;
		    } else
		      (treeContextId =
		        (1 << length) | (index << baseLength) | baseIdWithLeadingBit),
		        (treeContextOverflow = workInProgress);
		  }
		  function pushMaterializedTreeId(workInProgress) {
		    null !== workInProgress.return &&
		      (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));
		  }
		  function popTreeContext(workInProgress) {
		    for (; workInProgress === treeForkProvider; )
		      (treeForkProvider = forkStack[--forkStackIndex]),
		        (forkStack[forkStackIndex] = null),
		        (treeForkCount = forkStack[--forkStackIndex]),
		        (forkStack[forkStackIndex] = null);
		    for (; workInProgress === treeContextProvider; )
		      (treeContextProvider = idStack[--idStackIndex]),
		        (idStack[idStackIndex] = null),
		        (treeContextOverflow = idStack[--idStackIndex]),
		        (idStack[idStackIndex] = null),
		        (treeContextId = idStack[--idStackIndex]),
		        (idStack[idStackIndex] = null);
		  }
		  function pushHostContainer(fiber, nextRootInstance) {
		    push(rootInstanceStackCursor, nextRootInstance);
		    push(contextFiberStackCursor, fiber);
		    push(contextStackCursor, null);
		    fiber = getRootHostContext(nextRootInstance);
		    pop(contextStackCursor);
		    push(contextStackCursor, fiber);
		  }
		  function popHostContainer() {
		    pop(contextStackCursor);
		    pop(contextFiberStackCursor);
		    pop(rootInstanceStackCursor);
		  }
		  function pushHostContext(fiber) {
		    null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
		    var context = contextStackCursor.current,
		      nextContext = getChildHostContext(context, fiber.type);
		    context !== nextContext &&
		      (push(contextFiberStackCursor, fiber),
		      push(contextStackCursor, nextContext));
		  }
		  function popHostContext(fiber) {
		    contextFiberStackCursor.current === fiber &&
		      (pop(contextStackCursor), pop(contextFiberStackCursor));
		    hostTransitionProviderCursor.current === fiber &&
		      (pop(hostTransitionProviderCursor),
		      isPrimaryRenderer
		        ? (HostTransitionContext._currentValue = NotPendingTransition)
		        : (HostTransitionContext._currentValue2 = NotPendingTransition));
		  }
		  function throwOnHydrationMismatch(fiber) {
		    var error = Error(formatProdErrorMessage(418, ""));
		    queueHydrationError(createCapturedValueAtFiber(error, fiber));
		    throw HydrationMismatchException;
		  }
		  function prepareToHydrateHostInstance(fiber, hostContext) {
		    if (!supportsHydration) throw Error(formatProdErrorMessage(175));
		    hydrateInstance(
		      fiber.stateNode,
		      fiber.type,
		      fiber.memoizedProps,
		      hostContext,
		      fiber
		    ) || throwOnHydrationMismatch(fiber);
		  }
		  function popToNextHostParent(fiber) {
		    for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
		      switch (hydrationParentFiber.tag) {
		        case 3:
		        case 27:
		          rootOrSingletonContext = true;
		          return;
		        case 5:
		        case 13:
		          rootOrSingletonContext = false;
		          return;
		        default:
		          hydrationParentFiber = hydrationParentFiber.return;
		      }
		  }
		  function popHydrationState(fiber) {
		    if (!supportsHydration || fiber !== hydrationParentFiber) return false;
		    if (!isHydrating) return popToNextHostParent(fiber), (isHydrating = true), false;
		    var shouldClear = false;
		    supportsSingletons
		      ? 3 !== fiber.tag &&
		        27 !== fiber.tag &&
		        (5 !== fiber.tag ||
		          (shouldDeleteUnhydratedTailInstances(fiber.type) &&
		            !shouldSetTextContent(fiber.type, fiber.memoizedProps))) &&
		        (shouldClear = true)
		      : 3 !== fiber.tag &&
		        (5 !== fiber.tag ||
		          (shouldDeleteUnhydratedTailInstances(fiber.type) &&
		            !shouldSetTextContent(fiber.type, fiber.memoizedProps))) &&
		        (shouldClear = true);
		    shouldClear && nextHydratableInstance && throwOnHydrationMismatch(fiber);
		    popToNextHostParent(fiber);
		    if (13 === fiber.tag) {
		      if (!supportsHydration) throw Error(formatProdErrorMessage(316));
		      fiber = fiber.memoizedState;
		      fiber = null !== fiber ? fiber.dehydrated : null;
		      if (!fiber) throw Error(formatProdErrorMessage(317));
		      nextHydratableInstance =
		        getNextHydratableInstanceAfterSuspenseInstance(fiber);
		    } else
		      nextHydratableInstance = hydrationParentFiber
		        ? getNextHydratableSibling(fiber.stateNode)
		        : null;
		    return true;
		  }
		  function resetHydrationState() {
		    supportsHydration &&
		      ((nextHydratableInstance = hydrationParentFiber = null),
		      (isHydrating = false));
		  }
		  function queueHydrationError(error) {
		    null === hydrationErrors
		      ? (hydrationErrors = [error])
		      : hydrationErrors.push(error);
		  }
		  function finishQueueingConcurrentUpdates() {
		    for (
		      var endIndex = concurrentQueuesIndex,
		        i = (concurrentlyUpdatedLanes = concurrentQueuesIndex = 0);
		      i < endIndex;

		    ) {
		      var fiber = concurrentQueues[i];
		      concurrentQueues[i++] = null;
		      var queue = concurrentQueues[i];
		      concurrentQueues[i++] = null;
		      var update = concurrentQueues[i];
		      concurrentQueues[i++] = null;
		      var lane = concurrentQueues[i];
		      concurrentQueues[i++] = null;
		      if (null !== queue && null !== update) {
		        var pending = queue.pending;
		        null === pending
		          ? (update.next = update)
		          : ((update.next = pending.next), (pending.next = update));
		        queue.pending = update;
		      }
		      0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
		    }
		  }
		  function enqueueUpdate$1(fiber, queue, update, lane) {
		    concurrentQueues[concurrentQueuesIndex++] = fiber;
		    concurrentQueues[concurrentQueuesIndex++] = queue;
		    concurrentQueues[concurrentQueuesIndex++] = update;
		    concurrentQueues[concurrentQueuesIndex++] = lane;
		    concurrentlyUpdatedLanes |= lane;
		    fiber.lanes |= lane;
		    fiber = fiber.alternate;
		    null !== fiber && (fiber.lanes |= lane);
		  }
		  function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
		    enqueueUpdate$1(fiber, queue, update, lane);
		    return getRootForUpdatedFiber(fiber);
		  }
		  function enqueueConcurrentRenderForLane(fiber, lane) {
		    enqueueUpdate$1(fiber, null, null, lane);
		    return getRootForUpdatedFiber(fiber);
		  }
		  function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
		    sourceFiber.lanes |= lane;
		    var alternate = sourceFiber.alternate;
		    null !== alternate && (alternate.lanes |= lane);
		    for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
		      (parent.childLanes |= lane),
		        (alternate = parent.alternate),
		        null !== alternate && (alternate.childLanes |= lane),
		        22 === parent.tag &&
		          ((sourceFiber = parent.stateNode),
		          null === sourceFiber ||
		            sourceFiber._visibility & 1 ||
		            (isHidden = true)),
		        (sourceFiber = parent),
		        (parent = parent.return);
		    isHidden &&
		      null !== update &&
		      3 === sourceFiber.tag &&
		      ((parent = sourceFiber.stateNode),
		      (isHidden = 31 - clz32(lane)),
		      (parent = parent.hiddenUpdates),
		      (sourceFiber = parent[isHidden]),
		      null === sourceFiber
		        ? (parent[isHidden] = [update])
		        : sourceFiber.push(update),
		      (update.lane = lane | 536870912));
		  }
		  function getRootForUpdatedFiber(sourceFiber) {
		    if (50 < nestedUpdateCount)
		      throw (
		        ((nestedUpdateCount = 0),
		        (rootWithNestedUpdates = null),
		        Error(formatProdErrorMessage(185)))
		      );
		    for (var parent = sourceFiber.return; null !== parent; )
		      (sourceFiber = parent), (parent = sourceFiber.return);
		    return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
		  }
		  function ensureRootIsScheduled(root) {
		    root !== lastScheduledRoot &&
		      null === root.next &&
		      (null === lastScheduledRoot
		        ? (firstScheduledRoot = lastScheduledRoot = root)
		        : (lastScheduledRoot = lastScheduledRoot.next = root));
		    mightHavePendingSyncWork = true;
		    didScheduleMicrotask ||
		      ((didScheduleMicrotask = true),
		      scheduleImmediateTask(processRootScheduleInMicrotask));
		  }
		  function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
		    if (!isFlushingWork && mightHavePendingSyncWork) {
		      isFlushingWork = true;
		      do {
		        var didPerformSomeWork = false;
		        for (var root = firstScheduledRoot; null !== root; ) {
		          if (0 !== syncTransitionLanes) {
		              var pendingLanes = root.pendingLanes;
		              if (0 === pendingLanes) var JSCompiler_inline_result = 0;
		              else {
		                var suspendedLanes = root.suspendedLanes,
		                  pingedLanes = root.pingedLanes;
		                JSCompiler_inline_result =
		                  (1 << (31 - clz32(42 | syncTransitionLanes) + 1)) - 1;
		                JSCompiler_inline_result &=
		                  pendingLanes & ~(suspendedLanes & ~pingedLanes);
		                JSCompiler_inline_result =
		                  JSCompiler_inline_result & 201326677
		                    ? (JSCompiler_inline_result & 201326677) | 1
		                    : JSCompiler_inline_result
		                      ? JSCompiler_inline_result | 2
		                      : 0;
		              }
		              0 !== JSCompiler_inline_result &&
		                ((didPerformSomeWork = true),
		                performSyncWorkOnRoot(root, JSCompiler_inline_result));
		            } else
		              (JSCompiler_inline_result = workInProgressRootRenderLanes),
		                (JSCompiler_inline_result = getNextLanes(
		                  root,
		                  root === workInProgressRoot ? JSCompiler_inline_result : 0
		                )),
		                0 === (JSCompiler_inline_result & 3) ||
		                  checkIfRootIsPrerendering(root, JSCompiler_inline_result) ||
		                  ((didPerformSomeWork = true),
		                  performSyncWorkOnRoot(root, JSCompiler_inline_result));
		          root = root.next;
		        }
		      } while (didPerformSomeWork);
		      isFlushingWork = false;
		    }
		  }
		  function processRootScheduleInMicrotask() {
		    mightHavePendingSyncWork = didScheduleMicrotask = false;
		    var syncTransitionLanes = 0;
		    0 !== currentEventTransitionLane &&
		      (shouldAttemptEagerTransition() &&
		        (syncTransitionLanes = currentEventTransitionLane),
		      (currentEventTransitionLane = 0));
		    for (
		      var currentTime = now(), prev = null, root = firstScheduledRoot;
		      null !== root;

		    ) {
		      var next = root.next,
		        nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
		      if (0 === nextLanes)
		        (root.next = null),
		          null === prev ? (firstScheduledRoot = next) : (prev.next = next),
		          null === next && (lastScheduledRoot = prev);
		      else if (
		        ((prev = root), 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
		      )
		        mightHavePendingSyncWork = true;
		      root = next;
		    }
		    flushSyncWorkAcrossRoots_impl(syncTransitionLanes);
		  }
		  function scheduleTaskForRootDuringMicrotask(root, currentTime) {
		    for (
		      var suspendedLanes = root.suspendedLanes,
		        pingedLanes = root.pingedLanes,
		        expirationTimes = root.expirationTimes,
		        lanes = root.pendingLanes & -62914561;
		      0 < lanes;

		    ) {
		      var index$5 = 31 - clz32(lanes),
		        lane = 1 << index$5,
		        expirationTime = expirationTimes[index$5];
		      if (-1 === expirationTime) {
		        if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
		          expirationTimes[index$5] = computeExpirationTime(lane, currentTime);
		      } else expirationTime <= currentTime && (root.expiredLanes |= lane);
		      lanes &= ~lane;
		    }
		    currentTime = workInProgressRoot;
		    suspendedLanes = workInProgressRootRenderLanes;
		    suspendedLanes = getNextLanes(
		      root,
		      root === currentTime ? suspendedLanes : 0
		    );
		    pingedLanes = root.callbackNode;
		    if (
		      0 === suspendedLanes ||
		      (root === currentTime && 2 === workInProgressSuspendedReason) ||
		      null !== root.cancelPendingCommit
		    )
		      return (
		        null !== pingedLanes &&
		          null !== pingedLanes &&
		          cancelCallback$1(pingedLanes),
		        (root.callbackNode = null),
		        (root.callbackPriority = 0)
		      );
		    if (
		      0 === (suspendedLanes & 3) ||
		      checkIfRootIsPrerendering(root, suspendedLanes)
		    ) {
		      currentTime = suspendedLanes & -suspendedLanes;
		      if (currentTime === root.callbackPriority) return currentTime;
		      null !== pingedLanes && cancelCallback$1(pingedLanes);
		      switch (lanesToEventPriority(suspendedLanes)) {
		        case 2:
		        case 8:
		          suspendedLanes = UserBlockingPriority;
		          break;
		        case 32:
		          suspendedLanes = NormalPriority$1;
		          break;
		        case 268435456:
		          suspendedLanes = IdlePriority;
		          break;
		        default:
		          suspendedLanes = NormalPriority$1;
		      }
		      pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
		      suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
		      root.callbackPriority = currentTime;
		      root.callbackNode = suspendedLanes;
		      return currentTime;
		    }
		    null !== pingedLanes &&
		      null !== pingedLanes &&
		      cancelCallback$1(pingedLanes);
		    root.callbackPriority = 2;
		    root.callbackNode = null;
		    return 2;
		  }
		  function performWorkOnRootViaSchedulerTask(root, didTimeout) {
		    var originalCallbackNode = root.callbackNode;
		    if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode)
		      return null;
		    var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
		    workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
		      root,
		      root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0
		    );
		    if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
		    performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);
		    scheduleTaskForRootDuringMicrotask(root, now());
		    return null != root.callbackNode &&
		      root.callbackNode === originalCallbackNode
		      ? performWorkOnRootViaSchedulerTask.bind(null, root)
		      : null;
		  }
		  function performSyncWorkOnRoot(root, lanes) {
		    if (flushPassiveEffects()) return null;
		    performWorkOnRoot(root, lanes, true);
		  }
		  function scheduleImmediateTask(cb) {
		    supportsMicrotasks
		      ? scheduleMicrotask(function () {
		          0 !== (executionContext & 6)
		            ? scheduleCallback$3(ImmediatePriority, cb)
		            : cb();
		        })
		      : scheduleCallback$3(ImmediatePriority, cb);
		  }
		  function requestTransitionLane() {
		    0 === currentEventTransitionLane &&
		      (currentEventTransitionLane = claimNextTransitionLane());
		    return currentEventTransitionLane;
		  }
		  function entangleAsyncAction(transition, thenable) {
		    if (null === currentEntangledListeners) {
		      var entangledListeners = (currentEntangledListeners = []);
		      currentEntangledPendingCount = 0;
		      currentEntangledLane = requestTransitionLane();
		      currentEntangledActionThenable = {
		        status: "pending",
		        value: void 0,
		        then: function (resolve) {
		          entangledListeners.push(resolve);
		        }
		      };
		    }
		    currentEntangledPendingCount++;
		    thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
		    return thenable;
		  }
		  function pingEngtangledActionScope() {
		    if (
		      0 === --currentEntangledPendingCount &&
		      null !== currentEntangledListeners
		    ) {
		      null !== currentEntangledActionThenable &&
		        (currentEntangledActionThenable.status = "fulfilled");
		      var listeners = currentEntangledListeners;
		      currentEntangledListeners = null;
		      currentEntangledLane = 0;
		      currentEntangledActionThenable = null;
		      for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
		    }
		  }
		  function chainThenableValue(thenable, result) {
		    var listeners = [],
		      thenableWithOverride = {
		        status: "pending",
		        value: null,
		        reason: null,
		        then: function (resolve) {
		          listeners.push(resolve);
		        }
		      };
		    thenable.then(
		      function () {
		        thenableWithOverride.status = "fulfilled";
		        thenableWithOverride.value = result;
		        for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
		      },
		      function (error) {
		        thenableWithOverride.status = "rejected";
		        thenableWithOverride.reason = error;
		        for (error = 0; error < listeners.length; error++)
		          (0, listeners[error])(void 0);
		      }
		    );
		    return thenableWithOverride;
		  }
		  function initializeUpdateQueue(fiber) {
		    fiber.updateQueue = {
		      baseState: fiber.memoizedState,
		      firstBaseUpdate: null,
		      lastBaseUpdate: null,
		      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
		      callbacks: null
		    };
		  }
		  function cloneUpdateQueue(current, workInProgress) {
		    current = current.updateQueue;
		    workInProgress.updateQueue === current &&
		      (workInProgress.updateQueue = {
		        baseState: current.baseState,
		        firstBaseUpdate: current.firstBaseUpdate,
		        lastBaseUpdate: current.lastBaseUpdate,
		        shared: current.shared,
		        callbacks: null
		      });
		  }
		  function createUpdate(lane) {
		    return { lane: lane, tag: 0, payload: null, callback: null, next: null };
		  }
		  function enqueueUpdate(fiber, update, lane) {
		    var updateQueue = fiber.updateQueue;
		    if (null === updateQueue) return null;
		    updateQueue = updateQueue.shared;
		    if (0 !== (executionContext & 2)) {
		      var pending = updateQueue.pending;
		      null === pending
		        ? (update.next = update)
		        : ((update.next = pending.next), (pending.next = update));
		      updateQueue.pending = update;
		      update = getRootForUpdatedFiber(fiber);
		      markUpdateLaneFromFiberToRoot(fiber, null, lane);
		      return update;
		    }
		    enqueueUpdate$1(fiber, updateQueue, update, lane);
		    return getRootForUpdatedFiber(fiber);
		  }
		  function entangleTransitions(root, fiber, lane) {
		    fiber = fiber.updateQueue;
		    if (null !== fiber && ((fiber = fiber.shared), 0 !== (lane & 4194176))) {
		      var queueLanes = fiber.lanes;
		      queueLanes &= root.pendingLanes;
		      lane |= queueLanes;
		      fiber.lanes = lane;
		      markRootEntangled(root, lane);
		    }
		  }
		  function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
		    var queue = workInProgress.updateQueue,
		      current = workInProgress.alternate;
		    if (
		      null !== current &&
		      ((current = current.updateQueue), queue === current)
		    ) {
		      var newFirst = null,
		        newLast = null;
		      queue = queue.firstBaseUpdate;
		      if (null !== queue) {
		        do {
		          var clone = {
		            lane: queue.lane,
		            tag: queue.tag,
		            payload: queue.payload,
		            callback: null,
		            next: null
		          };
		          null === newLast
		            ? (newFirst = newLast = clone)
		            : (newLast = newLast.next = clone);
		          queue = queue.next;
		        } while (null !== queue);
		        null === newLast
		          ? (newFirst = newLast = capturedUpdate)
		          : (newLast = newLast.next = capturedUpdate);
		      } else newFirst = newLast = capturedUpdate;
		      queue = {
		        baseState: current.baseState,
		        firstBaseUpdate: newFirst,
		        lastBaseUpdate: newLast,
		        shared: current.shared,
		        callbacks: current.callbacks
		      };
		      workInProgress.updateQueue = queue;
		      return;
		    }
		    workInProgress = queue.lastBaseUpdate;
		    null === workInProgress
		      ? (queue.firstBaseUpdate = capturedUpdate)
		      : (workInProgress.next = capturedUpdate);
		    queue.lastBaseUpdate = capturedUpdate;
		  }
		  function suspendIfUpdateReadFromEntangledAsyncAction() {
		    if (didReadFromEntangledAsyncAction) {
		      var entangledActionThenable = currentEntangledActionThenable;
		      if (null !== entangledActionThenable) throw entangledActionThenable;
		    }
		  }
		  function processUpdateQueue(
		    workInProgress$jscomp$0,
		    props,
		    instance$jscomp$0,
		    renderLanes
		  ) {
		    didReadFromEntangledAsyncAction = false;
		    var queue = workInProgress$jscomp$0.updateQueue;
		    hasForceUpdate = false;
		    var firstBaseUpdate = queue.firstBaseUpdate,
		      lastBaseUpdate = queue.lastBaseUpdate,
		      pendingQueue = queue.shared.pending;
		    if (null !== pendingQueue) {
		      queue.shared.pending = null;
		      var lastPendingUpdate = pendingQueue,
		        firstPendingUpdate = lastPendingUpdate.next;
		      lastPendingUpdate.next = null;
		      null === lastBaseUpdate
		        ? (firstBaseUpdate = firstPendingUpdate)
		        : (lastBaseUpdate.next = firstPendingUpdate);
		      lastBaseUpdate = lastPendingUpdate;
		      var current = workInProgress$jscomp$0.alternate;
		      null !== current &&
		        ((current = current.updateQueue),
		        (pendingQueue = current.lastBaseUpdate),
		        pendingQueue !== lastBaseUpdate &&
		          (null === pendingQueue
		            ? (current.firstBaseUpdate = firstPendingUpdate)
		            : (pendingQueue.next = firstPendingUpdate),
		          (current.lastBaseUpdate = lastPendingUpdate)));
		    }
		    if (null !== firstBaseUpdate) {
		      var newState = queue.baseState;
		      lastBaseUpdate = 0;
		      current = firstPendingUpdate = lastPendingUpdate = null;
		      pendingQueue = firstBaseUpdate;
		      do {
		        var updateLane = pendingQueue.lane & -536870913,
		          isHiddenUpdate = updateLane !== pendingQueue.lane;
		        if (
		          isHiddenUpdate
		            ? (workInProgressRootRenderLanes & updateLane) === updateLane
		            : (renderLanes & updateLane) === updateLane
		        ) {
		          0 !== updateLane &&
		            updateLane === currentEntangledLane &&
		            (didReadFromEntangledAsyncAction = true);
		          null !== current &&
		            (current = current.next =
		              {
		                lane: 0,
		                tag: pendingQueue.tag,
		                payload: pendingQueue.payload,
		                callback: null,
		                next: null
		              });
		          a: {
		            var workInProgress = workInProgress$jscomp$0,
		              update = pendingQueue;
		            updateLane = props;
		            var instance = instance$jscomp$0;
		            switch (update.tag) {
		              case 1:
		                workInProgress = update.payload;
		                if ("function" === typeof workInProgress) {
		                  newState = workInProgress.call(
		                    instance,
		                    newState,
		                    updateLane
		                  );
		                  break a;
		                }
		                newState = workInProgress;
		                break a;
		              case 3:
		                workInProgress.flags = (workInProgress.flags & -65537) | 128;
		              case 0:
		                workInProgress = update.payload;
		                updateLane =
		                  "function" === typeof workInProgress
		                    ? workInProgress.call(instance, newState, updateLane)
		                    : workInProgress;
		                if (null === updateLane || void 0 === updateLane) break a;
		                newState = assign({}, newState, updateLane);
		                break a;
		              case 2:
		                hasForceUpdate = true;
		            }
		          }
		          updateLane = pendingQueue.callback;
		          null !== updateLane &&
		            ((workInProgress$jscomp$0.flags |= 64),
		            isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192),
		            (isHiddenUpdate = queue.callbacks),
		            null === isHiddenUpdate
		              ? (queue.callbacks = [updateLane])
		              : isHiddenUpdate.push(updateLane));
		        } else
		          (isHiddenUpdate = {
		            lane: updateLane,
		            tag: pendingQueue.tag,
		            payload: pendingQueue.payload,
		            callback: pendingQueue.callback,
		            next: null
		          }),
		            null === current
		              ? ((firstPendingUpdate = current = isHiddenUpdate),
		                (lastPendingUpdate = newState))
		              : (current = current.next = isHiddenUpdate),
		            (lastBaseUpdate |= updateLane);
		        pendingQueue = pendingQueue.next;
		        if (null === pendingQueue)
		          if (((pendingQueue = queue.shared.pending), null === pendingQueue))
		            break;
		          else
		            (isHiddenUpdate = pendingQueue),
		              (pendingQueue = isHiddenUpdate.next),
		              (isHiddenUpdate.next = null),
		              (queue.lastBaseUpdate = isHiddenUpdate),
		              (queue.shared.pending = null);
		      } while (1);
		      null === current && (lastPendingUpdate = newState);
		      queue.baseState = lastPendingUpdate;
		      queue.firstBaseUpdate = firstPendingUpdate;
		      queue.lastBaseUpdate = current;
		      null === firstBaseUpdate && (queue.shared.lanes = 0);
		      workInProgressRootSkippedLanes |= lastBaseUpdate;
		      workInProgress$jscomp$0.lanes = lastBaseUpdate;
		      workInProgress$jscomp$0.memoizedState = newState;
		    }
		  }
		  function callCallback(callback, context) {
		    if ("function" !== typeof callback)
		      throw Error(formatProdErrorMessage(191, callback));
		    callback.call(context);
		  }
		  function commitCallbacks(updateQueue, context) {
		    var callbacks = updateQueue.callbacks;
		    if (null !== callbacks)
		      for (
		        updateQueue.callbacks = null, updateQueue = 0;
		        updateQueue < callbacks.length;
		        updateQueue++
		      )
		        callCallback(callbacks[updateQueue], context);
		  }
		  function shallowEqual(objA, objB) {
		    if (objectIs(objA, objB)) return true;
		    if (
		      "object" !== typeof objA ||
		      null === objA ||
		      "object" !== typeof objB ||
		      null === objB
		    )
		      return false;
		    var keysA = Object.keys(objA),
		      keysB = Object.keys(objB);
		    if (keysA.length !== keysB.length) return false;
		    for (keysB = 0; keysB < keysA.length; keysB++) {
		      var currentKey = keysA[keysB];
		      if (
		        !hasOwnProperty.call(objB, currentKey) ||
		        !objectIs(objA[currentKey], objB[currentKey])
		      )
		        return false;
		    }
		    return true;
		  }
		  function isThenableResolved(thenable) {
		    thenable = thenable.status;
		    return "fulfilled" === thenable || "rejected" === thenable;
		  }
		  function noop$1() {}
		  function trackUsedThenable(thenableState, thenable, index) {
		    index = thenableState[index];
		    void 0 === index
		      ? thenableState.push(thenable)
		      : index !== thenable &&
		        (thenable.then(noop$1, noop$1), (thenable = index));
		    switch (thenable.status) {
		      case "fulfilled":
		        return thenable.value;
		      case "rejected":
		        thenableState = thenable.reason;
		        if (thenableState === SuspenseException)
		          throw Error(formatProdErrorMessage(483));
		        throw thenableState;
		      default:
		        if ("string" === typeof thenable.status) thenable.then(noop$1, noop$1);
		        else {
		          thenableState = workInProgressRoot;
		          if (null !== thenableState && 100 < thenableState.shellSuspendCounter)
		            throw Error(formatProdErrorMessage(482));
		          thenableState = thenable;
		          thenableState.status = "pending";
		          thenableState.then(
		            function (fulfilledValue) {
		              if ("pending" === thenable.status) {
		                var fulfilledThenable = thenable;
		                fulfilledThenable.status = "fulfilled";
		                fulfilledThenable.value = fulfilledValue;
		              }
		            },
		            function (error) {
		              if ("pending" === thenable.status) {
		                var rejectedThenable = thenable;
		                rejectedThenable.status = "rejected";
		                rejectedThenable.reason = error;
		              }
		            }
		          );
		        }
		        switch (thenable.status) {
		          case "fulfilled":
		            return thenable.value;
		          case "rejected":
		            thenableState = thenable.reason;
		            if (thenableState === SuspenseException)
		              throw Error(formatProdErrorMessage(483));
		            throw thenableState;
		        }
		        suspendedThenable = thenable;
		        throw SuspenseException;
		    }
		  }
		  function getSuspendedThenable() {
		    if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
		    var thenable = suspendedThenable;
		    suspendedThenable = null;
		    return thenable;
		  }
		  function unwrapThenable(thenable) {
		    var index = thenableIndexCounter$1;
		    thenableIndexCounter$1 += 1;
		    null === thenableState$1 && (thenableState$1 = []);
		    return trackUsedThenable(thenableState$1, thenable, index);
		  }
		  function coerceRef(workInProgress, element) {
		    element = element.props.ref;
		    workInProgress.ref = void 0 !== element ? element : null;
		  }
		  function throwOnInvalidObjectType(returnFiber, newChild) {
		    if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
		      throw Error(formatProdErrorMessage(525));
		    returnFiber = Object.prototype.toString.call(newChild);
		    throw Error(
		      formatProdErrorMessage(
		        31,
		        "[object Object]" === returnFiber
		          ? "object with keys {" + Object.keys(newChild).join(", ") + "}"
		          : returnFiber
		      )
		    );
		  }
		  function resolveLazy(lazyType) {
		    var init = lazyType._init;
		    return init(lazyType._payload);
		  }
		  function createChildReconciler(shouldTrackSideEffects) {
		    function deleteChild(returnFiber, childToDelete) {
		      if (shouldTrackSideEffects) {
		        var deletions = returnFiber.deletions;
		        null === deletions
		          ? ((returnFiber.deletions = [childToDelete]),
		            (returnFiber.flags |= 16))
		          : deletions.push(childToDelete);
		      }
		    }
		    function deleteRemainingChildren(returnFiber, currentFirstChild) {
		      if (!shouldTrackSideEffects) return null;
		      for (; null !== currentFirstChild; )
		        deleteChild(returnFiber, currentFirstChild),
		          (currentFirstChild = currentFirstChild.sibling);
		      return null;
		    }
		    function mapRemainingChildren(currentFirstChild) {
		      for (var existingChildren = new Map(); null !== currentFirstChild; )
		        null !== currentFirstChild.key
		          ? existingChildren.set(currentFirstChild.key, currentFirstChild)
		          : existingChildren.set(currentFirstChild.index, currentFirstChild),
		          (currentFirstChild = currentFirstChild.sibling);
		      return existingChildren;
		    }
		    function useFiber(fiber, pendingProps) {
		      fiber = createWorkInProgress(fiber, pendingProps);
		      fiber.index = 0;
		      fiber.sibling = null;
		      return fiber;
		    }
		    function placeChild(newFiber, lastPlacedIndex, newIndex) {
		      newFiber.index = newIndex;
		      if (!shouldTrackSideEffects)
		        return (newFiber.flags |= 1048576), lastPlacedIndex;
		      newIndex = newFiber.alternate;
		      if (null !== newIndex)
		        return (
		          (newIndex = newIndex.index),
		          newIndex < lastPlacedIndex
		            ? ((newFiber.flags |= 33554434), lastPlacedIndex)
		            : newIndex
		        );
		      newFiber.flags |= 33554434;
		      return lastPlacedIndex;
		    }
		    function placeSingleChild(newFiber) {
		      shouldTrackSideEffects &&
		        null === newFiber.alternate &&
		        (newFiber.flags |= 33554434);
		      return newFiber;
		    }
		    function updateTextNode(returnFiber, current, textContent, lanes) {
		      if (null === current || 6 !== current.tag)
		        return (
		          (current = createFiberFromText(textContent, returnFiber.mode, lanes)),
		          (current.return = returnFiber),
		          current
		        );
		      current = useFiber(current, textContent);
		      current.return = returnFiber;
		      return current;
		    }
		    function updateElement(returnFiber, current, element, lanes) {
		      var elementType = element.type;
		      if (elementType === REACT_FRAGMENT_TYPE)
		        return updateFragment(
		          returnFiber,
		          current,
		          element.props.children,
		          lanes,
		          element.key
		        );
		      if (
		        null !== current &&
		        (current.elementType === elementType ||
		          ("object" === typeof elementType &&
		            null !== elementType &&
		            elementType.$$typeof === REACT_LAZY_TYPE &&
		            resolveLazy(elementType) === current.type))
		      )
		        return (
		          (current = useFiber(current, element.props)),
		          coerceRef(current, element),
		          (current.return = returnFiber),
		          current
		        );
		      current = createFiberFromTypeAndProps(
		        element.type,
		        element.key,
		        element.props,
		        null,
		        returnFiber.mode,
		        lanes
		      );
		      coerceRef(current, element);
		      current.return = returnFiber;
		      return current;
		    }
		    function updatePortal(returnFiber, current, portal, lanes) {
		      if (
		        null === current ||
		        4 !== current.tag ||
		        current.stateNode.containerInfo !== portal.containerInfo ||
		        current.stateNode.implementation !== portal.implementation
		      )
		        return (
		          (current = createFiberFromPortal(portal, returnFiber.mode, lanes)),
		          (current.return = returnFiber),
		          current
		        );
		      current = useFiber(current, portal.children || []);
		      current.return = returnFiber;
		      return current;
		    }
		    function updateFragment(returnFiber, current, fragment, lanes, key) {
		      if (null === current || 7 !== current.tag)
		        return (
		          (current = createFiberFromFragment(
		            fragment,
		            returnFiber.mode,
		            lanes,
		            key
		          )),
		          (current.return = returnFiber),
		          current
		        );
		      current = useFiber(current, fragment);
		      current.return = returnFiber;
		      return current;
		    }
		    function createChild(returnFiber, newChild, lanes) {
		      if (
		        ("string" === typeof newChild && "" !== newChild) ||
		        "number" === typeof newChild ||
		        "bigint" === typeof newChild
		      )
		        return (
		          (newChild = createFiberFromText(
		            "" + newChild,
		            returnFiber.mode,
		            lanes
		          )),
		          (newChild.return = returnFiber),
		          newChild
		        );
		      if ("object" === typeof newChild && null !== newChild) {
		        switch (newChild.$$typeof) {
		          case REACT_ELEMENT_TYPE:
		            return (
		              (lanes = createFiberFromTypeAndProps(
		                newChild.type,
		                newChild.key,
		                newChild.props,
		                null,
		                returnFiber.mode,
		                lanes
		              )),
		              coerceRef(lanes, newChild),
		              (lanes.return = returnFiber),
		              lanes
		            );
		          case REACT_PORTAL_TYPE:
		            return (
		              (newChild = createFiberFromPortal(
		                newChild,
		                returnFiber.mode,
		                lanes
		              )),
		              (newChild.return = returnFiber),
		              newChild
		            );
		          case REACT_LAZY_TYPE:
		            var init = newChild._init;
		            newChild = init(newChild._payload);
		            return createChild(returnFiber, newChild, lanes);
		        }
		        if (isArrayImpl(newChild) || getIteratorFn(newChild))
		          return (
		            (newChild = createFiberFromFragment(
		              newChild,
		              returnFiber.mode,
		              lanes,
		              null
		            )),
		            (newChild.return = returnFiber),
		            newChild
		          );
		        if ("function" === typeof newChild.then)
		          return createChild(returnFiber, unwrapThenable(newChild), lanes);
		        if (newChild.$$typeof === REACT_CONTEXT_TYPE)
		          return createChild(
		            returnFiber,
		            readContextDuringReconciliation(returnFiber, newChild),
		            lanes
		          );
		        throwOnInvalidObjectType(returnFiber, newChild);
		      }
		      return null;
		    }
		    function updateSlot(returnFiber, oldFiber, newChild, lanes) {
		      var key = null !== oldFiber ? oldFiber.key : null;
		      if (
		        ("string" === typeof newChild && "" !== newChild) ||
		        "number" === typeof newChild ||
		        "bigint" === typeof newChild
		      )
		        return null !== key
		          ? null
		          : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
		      if ("object" === typeof newChild && null !== newChild) {
		        switch (newChild.$$typeof) {
		          case REACT_ELEMENT_TYPE:
		            return newChild.key === key
		              ? updateElement(returnFiber, oldFiber, newChild, lanes)
		              : null;
		          case REACT_PORTAL_TYPE:
		            return newChild.key === key
		              ? updatePortal(returnFiber, oldFiber, newChild, lanes)
		              : null;
		          case REACT_LAZY_TYPE:
		            return (
		              (key = newChild._init),
		              (newChild = key(newChild._payload)),
		              updateSlot(returnFiber, oldFiber, newChild, lanes)
		            );
		        }
		        if (isArrayImpl(newChild) || getIteratorFn(newChild))
		          return null !== key
		            ? null
		            : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
		        if ("function" === typeof newChild.then)
		          return updateSlot(
		            returnFiber,
		            oldFiber,
		            unwrapThenable(newChild),
		            lanes
		          );
		        if (newChild.$$typeof === REACT_CONTEXT_TYPE)
		          return updateSlot(
		            returnFiber,
		            oldFiber,
		            readContextDuringReconciliation(returnFiber, newChild),
		            lanes
		          );
		        throwOnInvalidObjectType(returnFiber, newChild);
		      }
		      return null;
		    }
		    function updateFromMap(
		      existingChildren,
		      returnFiber,
		      newIdx,
		      newChild,
		      lanes
		    ) {
		      if (
		        ("string" === typeof newChild && "" !== newChild) ||
		        "number" === typeof newChild ||
		        "bigint" === typeof newChild
		      )
		        return (
		          (existingChildren = existingChildren.get(newIdx) || null),
		          updateTextNode(returnFiber, existingChildren, "" + newChild, lanes)
		        );
		      if ("object" === typeof newChild && null !== newChild) {
		        switch (newChild.$$typeof) {
		          case REACT_ELEMENT_TYPE:
		            return (
		              (existingChildren =
		                existingChildren.get(
		                  null === newChild.key ? newIdx : newChild.key
		                ) || null),
		              updateElement(returnFiber, existingChildren, newChild, lanes)
		            );
		          case REACT_PORTAL_TYPE:
		            return (
		              (existingChildren =
		                existingChildren.get(
		                  null === newChild.key ? newIdx : newChild.key
		                ) || null),
		              updatePortal(returnFiber, existingChildren, newChild, lanes)
		            );
		          case REACT_LAZY_TYPE:
		            var init = newChild._init;
		            newChild = init(newChild._payload);
		            return updateFromMap(
		              existingChildren,
		              returnFiber,
		              newIdx,
		              newChild,
		              lanes
		            );
		        }
		        if (isArrayImpl(newChild) || getIteratorFn(newChild))
		          return (
		            (existingChildren = existingChildren.get(newIdx) || null),
		            updateFragment(returnFiber, existingChildren, newChild, lanes, null)
		          );
		        if ("function" === typeof newChild.then)
		          return updateFromMap(
		            existingChildren,
		            returnFiber,
		            newIdx,
		            unwrapThenable(newChild),
		            lanes
		          );
		        if (newChild.$$typeof === REACT_CONTEXT_TYPE)
		          return updateFromMap(
		            existingChildren,
		            returnFiber,
		            newIdx,
		            readContextDuringReconciliation(returnFiber, newChild),
		            lanes
		          );
		        throwOnInvalidObjectType(returnFiber, newChild);
		      }
		      return null;
		    }
		    function reconcileChildrenArray(
		      returnFiber,
		      currentFirstChild,
		      newChildren,
		      lanes
		    ) {
		      for (
		        var resultingFirstChild = null,
		          previousNewFiber = null,
		          oldFiber = currentFirstChild,
		          newIdx = (currentFirstChild = 0),
		          nextOldFiber = null;
		        null !== oldFiber && newIdx < newChildren.length;
		        newIdx++
		      ) {
		        oldFiber.index > newIdx
		          ? ((nextOldFiber = oldFiber), (oldFiber = null))
		          : (nextOldFiber = oldFiber.sibling);
		        var newFiber = updateSlot(
		          returnFiber,
		          oldFiber,
		          newChildren[newIdx],
		          lanes
		        );
		        if (null === newFiber) {
		          null === oldFiber && (oldFiber = nextOldFiber);
		          break;
		        }
		        shouldTrackSideEffects &&
		          oldFiber &&
		          null === newFiber.alternate &&
		          deleteChild(returnFiber, oldFiber);
		        currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
		        null === previousNewFiber
		          ? (resultingFirstChild = newFiber)
		          : (previousNewFiber.sibling = newFiber);
		        previousNewFiber = newFiber;
		        oldFiber = nextOldFiber;
		      }
		      if (newIdx === newChildren.length)
		        return (
		          deleteRemainingChildren(returnFiber, oldFiber),
		          isHydrating && pushTreeFork(returnFiber, newIdx),
		          resultingFirstChild
		        );
		      if (null === oldFiber) {
		        for (; newIdx < newChildren.length; newIdx++)
		          (oldFiber = createChild(returnFiber, newChildren[newIdx], lanes)),
		            null !== oldFiber &&
		              ((currentFirstChild = placeChild(
		                oldFiber,
		                currentFirstChild,
		                newIdx
		              )),
		              null === previousNewFiber
		                ? (resultingFirstChild = oldFiber)
		                : (previousNewFiber.sibling = oldFiber),
		              (previousNewFiber = oldFiber));
		        isHydrating && pushTreeFork(returnFiber, newIdx);
		        return resultingFirstChild;
		      }
		      for (
		        oldFiber = mapRemainingChildren(oldFiber);
		        newIdx < newChildren.length;
		        newIdx++
		      )
		        (nextOldFiber = updateFromMap(
		          oldFiber,
		          returnFiber,
		          newIdx,
		          newChildren[newIdx],
		          lanes
		        )),
		          null !== nextOldFiber &&
		            (shouldTrackSideEffects &&
		              null !== nextOldFiber.alternate &&
		              oldFiber.delete(
		                null === nextOldFiber.key ? newIdx : nextOldFiber.key
		              ),
		            (currentFirstChild = placeChild(
		              nextOldFiber,
		              currentFirstChild,
		              newIdx
		            )),
		            null === previousNewFiber
		              ? (resultingFirstChild = nextOldFiber)
		              : (previousNewFiber.sibling = nextOldFiber),
		            (previousNewFiber = nextOldFiber));
		      shouldTrackSideEffects &&
		        oldFiber.forEach(function (child) {
		          return deleteChild(returnFiber, child);
		        });
		      isHydrating && pushTreeFork(returnFiber, newIdx);
		      return resultingFirstChild;
		    }
		    function reconcileChildrenIterator(
		      returnFiber,
		      currentFirstChild,
		      newChildren,
		      lanes
		    ) {
		      if (null == newChildren) throw Error(formatProdErrorMessage(151));
		      for (
		        var resultingFirstChild = null,
		          previousNewFiber = null,
		          oldFiber = currentFirstChild,
		          newIdx = (currentFirstChild = 0),
		          nextOldFiber = null,
		          step = newChildren.next();
		        null !== oldFiber && !step.done;
		        newIdx++, step = newChildren.next()
		      ) {
		        oldFiber.index > newIdx
		          ? ((nextOldFiber = oldFiber), (oldFiber = null))
		          : (nextOldFiber = oldFiber.sibling);
		        var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
		        if (null === newFiber) {
		          null === oldFiber && (oldFiber = nextOldFiber);
		          break;
		        }
		        shouldTrackSideEffects &&
		          oldFiber &&
		          null === newFiber.alternate &&
		          deleteChild(returnFiber, oldFiber);
		        currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
		        null === previousNewFiber
		          ? (resultingFirstChild = newFiber)
		          : (previousNewFiber.sibling = newFiber);
		        previousNewFiber = newFiber;
		        oldFiber = nextOldFiber;
		      }
		      if (step.done)
		        return (
		          deleteRemainingChildren(returnFiber, oldFiber),
		          isHydrating && pushTreeFork(returnFiber, newIdx),
		          resultingFirstChild
		        );
		      if (null === oldFiber) {
		        for (; !step.done; newIdx++, step = newChildren.next())
		          (step = createChild(returnFiber, step.value, lanes)),
		            null !== step &&
		              ((currentFirstChild = placeChild(
		                step,
		                currentFirstChild,
		                newIdx
		              )),
		              null === previousNewFiber
		                ? (resultingFirstChild = step)
		                : (previousNewFiber.sibling = step),
		              (previousNewFiber = step));
		        isHydrating && pushTreeFork(returnFiber, newIdx);
		        return resultingFirstChild;
		      }
		      for (
		        oldFiber = mapRemainingChildren(oldFiber);
		        !step.done;
		        newIdx++, step = newChildren.next()
		      )
		        (step = updateFromMap(
		          oldFiber,
		          returnFiber,
		          newIdx,
		          step.value,
		          lanes
		        )),
		          null !== step &&
		            (shouldTrackSideEffects &&
		              null !== step.alternate &&
		              oldFiber.delete(null === step.key ? newIdx : step.key),
		            (currentFirstChild = placeChild(step, currentFirstChild, newIdx)),
		            null === previousNewFiber
		              ? (resultingFirstChild = step)
		              : (previousNewFiber.sibling = step),
		            (previousNewFiber = step));
		      shouldTrackSideEffects &&
		        oldFiber.forEach(function (child) {
		          return deleteChild(returnFiber, child);
		        });
		      isHydrating && pushTreeFork(returnFiber, newIdx);
		      return resultingFirstChild;
		    }
		    function reconcileChildFibersImpl(
		      returnFiber,
		      currentFirstChild,
		      newChild,
		      lanes
		    ) {
		      "object" === typeof newChild &&
		        null !== newChild &&
		        newChild.type === REACT_FRAGMENT_TYPE &&
		        null === newChild.key &&
		        (newChild = newChild.props.children);
		      if ("object" === typeof newChild && null !== newChild) {
		        switch (newChild.$$typeof) {
		          case REACT_ELEMENT_TYPE:
		            a: {
		              for (var key = newChild.key; null !== currentFirstChild; ) {
		                if (currentFirstChild.key === key) {
		                  key = newChild.type;
		                  if (key === REACT_FRAGMENT_TYPE) {
		                    if (7 === currentFirstChild.tag) {
		                      deleteRemainingChildren(
		                        returnFiber,
		                        currentFirstChild.sibling
		                      );
		                      lanes = useFiber(
		                        currentFirstChild,
		                        newChild.props.children
		                      );
		                      lanes.return = returnFiber;
		                      returnFiber = lanes;
		                      break a;
		                    }
		                  } else if (
		                    currentFirstChild.elementType === key ||
		                    ("object" === typeof key &&
		                      null !== key &&
		                      key.$$typeof === REACT_LAZY_TYPE &&
		                      resolveLazy(key) === currentFirstChild.type)
		                  ) {
		                    deleteRemainingChildren(
		                      returnFiber,
		                      currentFirstChild.sibling
		                    );
		                    lanes = useFiber(currentFirstChild, newChild.props);
		                    coerceRef(lanes, newChild);
		                    lanes.return = returnFiber;
		                    returnFiber = lanes;
		                    break a;
		                  }
		                  deleteRemainingChildren(returnFiber, currentFirstChild);
		                  break;
		                } else deleteChild(returnFiber, currentFirstChild);
		                currentFirstChild = currentFirstChild.sibling;
		              }
		              newChild.type === REACT_FRAGMENT_TYPE
		                ? ((lanes = createFiberFromFragment(
		                    newChild.props.children,
		                    returnFiber.mode,
		                    lanes,
		                    newChild.key
		                  )),
		                  (lanes.return = returnFiber),
		                  (returnFiber = lanes))
		                : ((lanes = createFiberFromTypeAndProps(
		                    newChild.type,
		                    newChild.key,
		                    newChild.props,
		                    null,
		                    returnFiber.mode,
		                    lanes
		                  )),
		                  coerceRef(lanes, newChild),
		                  (lanes.return = returnFiber),
		                  (returnFiber = lanes));
		            }
		            return placeSingleChild(returnFiber);
		          case REACT_PORTAL_TYPE:
		            a: {
		              for (key = newChild.key; null !== currentFirstChild; ) {
		                if (currentFirstChild.key === key)
		                  if (
		                    4 === currentFirstChild.tag &&
		                    currentFirstChild.stateNode.containerInfo ===
		                      newChild.containerInfo &&
		                    currentFirstChild.stateNode.implementation ===
		                      newChild.implementation
		                  ) {
		                    deleteRemainingChildren(
		                      returnFiber,
		                      currentFirstChild.sibling
		                    );
		                    lanes = useFiber(
		                      currentFirstChild,
		                      newChild.children || []
		                    );
		                    lanes.return = returnFiber;
		                    returnFiber = lanes;
		                    break a;
		                  } else {
		                    deleteRemainingChildren(returnFiber, currentFirstChild);
		                    break;
		                  }
		                else deleteChild(returnFiber, currentFirstChild);
		                currentFirstChild = currentFirstChild.sibling;
		              }
		              lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
		              lanes.return = returnFiber;
		              returnFiber = lanes;
		            }
		            return placeSingleChild(returnFiber);
		          case REACT_LAZY_TYPE:
		            return (
		              (key = newChild._init),
		              (newChild = key(newChild._payload)),
		              reconcileChildFibersImpl(
		                returnFiber,
		                currentFirstChild,
		                newChild,
		                lanes
		              )
		            );
		        }
		        if (isArrayImpl(newChild))
		          return reconcileChildrenArray(
		            returnFiber,
		            currentFirstChild,
		            newChild,
		            lanes
		          );
		        if (getIteratorFn(newChild)) {
		          key = getIteratorFn(newChild);
		          if ("function" !== typeof key)
		            throw Error(formatProdErrorMessage(150));
		          newChild = key.call(newChild);
		          return reconcileChildrenIterator(
		            returnFiber,
		            currentFirstChild,
		            newChild,
		            lanes
		          );
		        }
		        if ("function" === typeof newChild.then)
		          return reconcileChildFibersImpl(
		            returnFiber,
		            currentFirstChild,
		            unwrapThenable(newChild),
		            lanes
		          );
		        if (newChild.$$typeof === REACT_CONTEXT_TYPE)
		          return reconcileChildFibersImpl(
		            returnFiber,
		            currentFirstChild,
		            readContextDuringReconciliation(returnFiber, newChild),
		            lanes
		          );
		        throwOnInvalidObjectType(returnFiber, newChild);
		      }
		      return ("string" === typeof newChild && "" !== newChild) ||
		        "number" === typeof newChild ||
		        "bigint" === typeof newChild
		        ? ((newChild = "" + newChild),
		          null !== currentFirstChild && 6 === currentFirstChild.tag
		            ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling),
		              (lanes = useFiber(currentFirstChild, newChild)),
		              (lanes.return = returnFiber),
		              (returnFiber = lanes))
		            : (deleteRemainingChildren(returnFiber, currentFirstChild),
		              (lanes = createFiberFromText(newChild, returnFiber.mode, lanes)),
		              (lanes.return = returnFiber),
		              (returnFiber = lanes)),
		          placeSingleChild(returnFiber))
		        : deleteRemainingChildren(returnFiber, currentFirstChild);
		    }
		    return function (returnFiber, currentFirstChild, newChild, lanes) {
		      try {
		        thenableIndexCounter$1 = 0;
		        var firstChildFiber = reconcileChildFibersImpl(
		          returnFiber,
		          currentFirstChild,
		          newChild,
		          lanes
		        );
		        thenableState$1 = null;
		        return firstChildFiber;
		      } catch (x) {
		        if (x === SuspenseException) throw x;
		        var fiber = createFiber(29, x, null, returnFiber.mode);
		        fiber.lanes = lanes;
		        fiber.return = returnFiber;
		        return fiber;
		      } finally {
		      }
		    };
		  }
		  function pushHiddenContext(fiber, context) {
		    fiber = entangledRenderLanes;
		    push(prevEntangledRenderLanesCursor, fiber);
		    push(currentTreeHiddenStackCursor, context);
		    entangledRenderLanes = fiber | context.baseLanes;
		  }
		  function reuseHiddenContextOnStack() {
		    push(prevEntangledRenderLanesCursor, entangledRenderLanes);
		    push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
		  }
		  function popHiddenContext() {
		    entangledRenderLanes = prevEntangledRenderLanesCursor.current;
		    pop(currentTreeHiddenStackCursor);
		    pop(prevEntangledRenderLanesCursor);
		  }
		  function pushPrimaryTreeSuspenseHandler(handler) {
		    var current = handler.alternate;
		    push(suspenseStackCursor, suspenseStackCursor.current & 1);
		    push(suspenseHandlerStackCursor, handler);
		    null === shellBoundary &&
		      (null === current || null !== currentTreeHiddenStackCursor.current
		        ? (shellBoundary = handler)
		        : null !== current.memoizedState && (shellBoundary = handler));
		  }
		  function pushOffscreenSuspenseHandler(fiber) {
		    if (22 === fiber.tag) {
		      if (
		        (push(suspenseStackCursor, suspenseStackCursor.current),
		        push(suspenseHandlerStackCursor, fiber),
		        null === shellBoundary)
		      ) {
		        var current = fiber.alternate;
		        null !== current &&
		          null !== current.memoizedState &&
		          (shellBoundary = fiber);
		      }
		    } else reuseSuspenseHandlerOnStack();
		  }
		  function reuseSuspenseHandlerOnStack() {
		    push(suspenseStackCursor, suspenseStackCursor.current);
		    push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
		  }
		  function popSuspenseHandler(fiber) {
		    pop(suspenseHandlerStackCursor);
		    shellBoundary === fiber && (shellBoundary = null);
		    pop(suspenseStackCursor);
		  }
		  function findFirstSuspended(row) {
		    for (var node = row; null !== node; ) {
		      if (13 === node.tag) {
		        var state = node.memoizedState;
		        if (
		          null !== state &&
		          ((state = state.dehydrated),
		          null === state ||
		            isSuspenseInstancePending(state) ||
		            isSuspenseInstanceFallback(state))
		        )
		          return node;
		      } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
		        if (0 !== (node.flags & 128)) return node;
		      } else if (null !== node.child) {
		        node.child.return = node;
		        node = node.child;
		        continue;
		      }
		      if (node === row) break;
		      for (; null === node.sibling; ) {
		        if (null === node.return || node.return === row) return null;
		        node = node.return;
		      }
		      node.sibling.return = node.return;
		      node = node.sibling;
		    }
		    return null;
		  }
		  function throwInvalidHookError() {
		    throw Error(formatProdErrorMessage(321));
		  }
		  function areHookInputsEqual(nextDeps, prevDeps) {
		    if (null === prevDeps) return false;
		    for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
		      if (!objectIs(nextDeps[i], prevDeps[i])) return false;
		    return true;
		  }
		  function renderWithHooks(
		    current,
		    workInProgress,
		    Component,
		    props,
		    secondArg,
		    nextRenderLanes
		  ) {
		    renderLanes = nextRenderLanes;
		    currentlyRenderingFiber$1 = workInProgress;
		    workInProgress.memoizedState = null;
		    workInProgress.updateQueue = null;
		    workInProgress.lanes = 0;
		    ReactSharedInternals.H =
		      null === current || null === current.memoizedState
		        ? HooksDispatcherOnMount
		        : HooksDispatcherOnUpdate;
		    shouldDoubleInvokeUserFnsInHooksDEV = false;
		    nextRenderLanes = Component(props, secondArg);
		    shouldDoubleInvokeUserFnsInHooksDEV = false;
		    didScheduleRenderPhaseUpdateDuringThisPass &&
		      (nextRenderLanes = renderWithHooksAgain(
		        workInProgress,
		        Component,
		        props,
		        secondArg
		      ));
		    finishRenderingHooks(current);
		    return nextRenderLanes;
		  }
		  function finishRenderingHooks(current) {
		    ReactSharedInternals.H = ContextOnlyDispatcher;
		    var didRenderTooFewHooks =
		      null !== currentHook && null !== currentHook.next;
		    renderLanes = 0;
		    workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;
		    didScheduleRenderPhaseUpdate = false;
		    thenableIndexCounter = 0;
		    thenableState = null;
		    if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
		    null === current ||
		      didReceiveUpdate ||
		      ((current = current.dependencies),
		      null !== current &&
		        checkIfContextChanged(current) &&
		        (didReceiveUpdate = true));
		  }
		  function renderWithHooksAgain(workInProgress, Component, props, secondArg) {
		    currentlyRenderingFiber$1 = workInProgress;
		    var numberOfReRenders = 0;
		    do {
		      didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
		      thenableIndexCounter = 0;
		      didScheduleRenderPhaseUpdateDuringThisPass = false;
		      if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
		      numberOfReRenders += 1;
		      workInProgressHook = currentHook = null;
		      if (null != workInProgress.updateQueue) {
		        var children = workInProgress.updateQueue;
		        children.lastEffect = null;
		        children.events = null;
		        children.stores = null;
		        null != children.memoCache && (children.memoCache.index = 0);
		      }
		      ReactSharedInternals.H = HooksDispatcherOnRerender;
		      children = Component(props, secondArg);
		    } while (didScheduleRenderPhaseUpdateDuringThisPass);
		    return children;
		  }
		  function TransitionAwareHostComponent() {
		    var dispatcher = ReactSharedInternals.H,
		      maybeThenable = dispatcher.useState()[0];
		    maybeThenable =
		      "function" === typeof maybeThenable.then
		        ? useThenable(maybeThenable)
		        : maybeThenable;
		    dispatcher = dispatcher.useState()[0];
		    (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher &&
		      (currentlyRenderingFiber$1.flags |= 1024);
		    return maybeThenable;
		  }
		  function checkDidRenderIdHook() {
		    var didRenderIdHook = 0 !== localIdCounter;
		    localIdCounter = 0;
		    return didRenderIdHook;
		  }
		  function bailoutHooks(current, workInProgress, lanes) {
		    workInProgress.updateQueue = current.updateQueue;
		    workInProgress.flags &= -2053;
		    current.lanes &= ~lanes;
		  }
		  function resetHooksOnUnwind(workInProgress) {
		    if (didScheduleRenderPhaseUpdate) {
		      for (
		        workInProgress = workInProgress.memoizedState;
		        null !== workInProgress;

		      ) {
		        var queue = workInProgress.queue;
		        null !== queue && (queue.pending = null);
		        workInProgress = workInProgress.next;
		      }
		      didScheduleRenderPhaseUpdate = false;
		    }
		    renderLanes = 0;
		    workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;
		    didScheduleRenderPhaseUpdateDuringThisPass = false;
		    thenableIndexCounter = localIdCounter = 0;
		    thenableState = null;
		  }
		  function mountWorkInProgressHook() {
		    var hook = {
		      memoizedState: null,
		      baseState: null,
		      baseQueue: null,
		      queue: null,
		      next: null
		    };
		    null === workInProgressHook
		      ? (currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook)
		      : (workInProgressHook = workInProgressHook.next = hook);
		    return workInProgressHook;
		  }
		  function updateWorkInProgressHook() {
		    if (null === currentHook) {
		      var nextCurrentHook = currentlyRenderingFiber$1.alternate;
		      nextCurrentHook =
		        null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
		    } else nextCurrentHook = currentHook.next;
		    var nextWorkInProgressHook =
		      null === workInProgressHook
		        ? currentlyRenderingFiber$1.memoizedState
		        : workInProgressHook.next;
		    if (null !== nextWorkInProgressHook)
		      (workInProgressHook = nextWorkInProgressHook),
		        (currentHook = nextCurrentHook);
		    else {
		      if (null === nextCurrentHook) {
		        if (null === currentlyRenderingFiber$1.alternate)
		          throw Error(formatProdErrorMessage(467));
		        throw Error(formatProdErrorMessage(310));
		      }
		      currentHook = nextCurrentHook;
		      nextCurrentHook = {
		        memoizedState: currentHook.memoizedState,
		        baseState: currentHook.baseState,
		        baseQueue: currentHook.baseQueue,
		        queue: currentHook.queue,
		        next: null
		      };
		      null === workInProgressHook
		        ? (currentlyRenderingFiber$1.memoizedState = workInProgressHook =
		            nextCurrentHook)
		        : (workInProgressHook = workInProgressHook.next = nextCurrentHook);
		    }
		    return workInProgressHook;
		  }
		  function useThenable(thenable) {
		    var index = thenableIndexCounter;
		    thenableIndexCounter += 1;
		    null === thenableState && (thenableState = []);
		    thenable = trackUsedThenable(thenableState, thenable, index);
		    index = currentlyRenderingFiber$1;
		    null ===
		      (null === workInProgressHook
		        ? index.memoizedState
		        : workInProgressHook.next) &&
		      ((index = index.alternate),
		      (ReactSharedInternals.H =
		        null === index || null === index.memoizedState
		          ? HooksDispatcherOnMount
		          : HooksDispatcherOnUpdate));
		    return thenable;
		  }
		  function use(usable) {
		    if (null !== usable && "object" === typeof usable) {
		      if ("function" === typeof usable.then) return useThenable(usable);
		      if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
		    }
		    throw Error(formatProdErrorMessage(438, String(usable)));
		  }
		  function useMemoCache(size) {
		    var memoCache = null,
		      updateQueue = currentlyRenderingFiber$1.updateQueue;
		    null !== updateQueue && (memoCache = updateQueue.memoCache);
		    if (null == memoCache) {
		      var current = currentlyRenderingFiber$1.alternate;
		      null !== current &&
		        ((current = current.updateQueue),
		        null !== current &&
		          ((current = current.memoCache),
		          null != current &&
		            (memoCache = {
		              data: current.data.map(function (array) {
		                return array.slice();
		              }),
		              index: 0
		            })));
		    }
		    null == memoCache && (memoCache = { data: [], index: 0 });
		    null === updateQueue &&
		      ((updateQueue = createFunctionComponentUpdateQueue()),
		      (currentlyRenderingFiber$1.updateQueue = updateQueue));
		    updateQueue.memoCache = memoCache;
		    updateQueue = memoCache.data[memoCache.index];
		    if (void 0 === updateQueue)
		      for (
		        updateQueue = memoCache.data[memoCache.index] = Array(size),
		          current = 0;
		        current < size;
		        current++
		      )
		        updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
		    memoCache.index++;
		    return updateQueue;
		  }
		  function basicStateReducer(state, action) {
		    return "function" === typeof action ? action(state) : action;
		  }
		  function updateReducer(reducer) {
		    var hook = updateWorkInProgressHook();
		    return updateReducerImpl(hook, currentHook, reducer);
		  }
		  function updateReducerImpl(hook, current, reducer) {
		    var queue = hook.queue;
		    if (null === queue) throw Error(formatProdErrorMessage(311));
		    queue.lastRenderedReducer = reducer;
		    var baseQueue = hook.baseQueue,
		      pendingQueue = queue.pending;
		    if (null !== pendingQueue) {
		      if (null !== baseQueue) {
		        var baseFirst = baseQueue.next;
		        baseQueue.next = pendingQueue.next;
		        pendingQueue.next = baseFirst;
		      }
		      current.baseQueue = baseQueue = pendingQueue;
		      queue.pending = null;
		    }
		    pendingQueue = hook.baseState;
		    if (null === baseQueue) hook.memoizedState = pendingQueue;
		    else {
		      current = baseQueue.next;
		      var newBaseQueueFirst = (baseFirst = null),
		        newBaseQueueLast = null,
		        update = current,
		        didReadFromEntangledAsyncAction$48 = false;
		      do {
		        var updateLane = update.lane & -536870913;
		        if (
		          updateLane !== update.lane
		            ? (workInProgressRootRenderLanes & updateLane) === updateLane
		            : (renderLanes & updateLane) === updateLane
		        ) {
		          var revertLane = update.revertLane;
		          if (0 === revertLane)
		            null !== newBaseQueueLast &&
		              (newBaseQueueLast = newBaseQueueLast.next =
		                {
		                  lane: 0,
		                  revertLane: 0,
		                  action: update.action,
		                  hasEagerState: update.hasEagerState,
		                  eagerState: update.eagerState,
		                  next: null
		                }),
		              updateLane === currentEntangledLane &&
		                (didReadFromEntangledAsyncAction$48 = true);
		          else if ((renderLanes & revertLane) === revertLane) {
		            update = update.next;
		            revertLane === currentEntangledLane &&
		              (didReadFromEntangledAsyncAction$48 = true);
		            continue;
		          } else
		            (updateLane = {
		              lane: 0,
		              revertLane: update.revertLane,
		              action: update.action,
		              hasEagerState: update.hasEagerState,
		              eagerState: update.eagerState,
		              next: null
		            }),
		              null === newBaseQueueLast
		                ? ((newBaseQueueFirst = newBaseQueueLast = updateLane),
		                  (baseFirst = pendingQueue))
		                : (newBaseQueueLast = newBaseQueueLast.next = updateLane),
		              (currentlyRenderingFiber$1.lanes |= revertLane),
		              (workInProgressRootSkippedLanes |= revertLane);
		          updateLane = update.action;
		          shouldDoubleInvokeUserFnsInHooksDEV &&
		            reducer(pendingQueue, updateLane);
		          pendingQueue = update.hasEagerState
		            ? update.eagerState
		            : reducer(pendingQueue, updateLane);
		        } else
		          (revertLane = {
		            lane: updateLane,
		            revertLane: update.revertLane,
		            action: update.action,
		            hasEagerState: update.hasEagerState,
		            eagerState: update.eagerState,
		            next: null
		          }),
		            null === newBaseQueueLast
		              ? ((newBaseQueueFirst = newBaseQueueLast = revertLane),
		                (baseFirst = pendingQueue))
		              : (newBaseQueueLast = newBaseQueueLast.next = revertLane),
		            (currentlyRenderingFiber$1.lanes |= updateLane),
		            (workInProgressRootSkippedLanes |= updateLane);
		        update = update.next;
		      } while (null !== update && update !== current);
		      null === newBaseQueueLast
		        ? (baseFirst = pendingQueue)
		        : (newBaseQueueLast.next = newBaseQueueFirst);
		      if (
		        !objectIs(pendingQueue, hook.memoizedState) &&
		        ((didReceiveUpdate = true),
		        didReadFromEntangledAsyncAction$48 &&
		          ((reducer = currentEntangledActionThenable), null !== reducer))
		      )
		        throw reducer;
		      hook.memoizedState = pendingQueue;
		      hook.baseState = baseFirst;
		      hook.baseQueue = newBaseQueueLast;
		      queue.lastRenderedState = pendingQueue;
		    }
		    null === baseQueue && (queue.lanes = 0);
		    return [hook.memoizedState, queue.dispatch];
		  }
		  function rerenderReducer(reducer) {
		    var hook = updateWorkInProgressHook(),
		      queue = hook.queue;
		    if (null === queue) throw Error(formatProdErrorMessage(311));
		    queue.lastRenderedReducer = reducer;
		    var dispatch = queue.dispatch,
		      lastRenderPhaseUpdate = queue.pending,
		      newState = hook.memoizedState;
		    if (null !== lastRenderPhaseUpdate) {
		      queue.pending = null;
		      var update = (lastRenderPhaseUpdate = lastRenderPhaseUpdate.next);
		      do (newState = reducer(newState, update.action)), (update = update.next);
		      while (update !== lastRenderPhaseUpdate);
		      objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
		      hook.memoizedState = newState;
		      null === hook.baseQueue && (hook.baseState = newState);
		      queue.lastRenderedState = newState;
		    }
		    return [newState, dispatch];
		  }
		  function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
		    var fiber = currentlyRenderingFiber$1,
		      hook = updateWorkInProgressHook(),
		      isHydrating$jscomp$0 = isHydrating;
		    if (isHydrating$jscomp$0) {
		      if (void 0 === getServerSnapshot)
		        throw Error(formatProdErrorMessage(407));
		      getServerSnapshot = getServerSnapshot();
		    } else getServerSnapshot = getSnapshot();
		    var snapshotChanged = !objectIs(
		      (currentHook || hook).memoizedState,
		      getServerSnapshot
		    );
		    snapshotChanged &&
		      ((hook.memoizedState = getServerSnapshot), (didReceiveUpdate = true));
		    hook = hook.queue;
		    updateEffect(subscribeToStore.bind(null, fiber, hook, subscribe), [
		      subscribe
		    ]);
		    if (
		      hook.getSnapshot !== getSnapshot ||
		      snapshotChanged ||
		      (null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1)
		    ) {
		      fiber.flags |= 2048;
		      pushEffect(
		        9,
		        updateStoreInstance.bind(
		          null,
		          fiber,
		          hook,
		          getServerSnapshot,
		          getSnapshot
		        ),
		        { destroy: void 0 },
		        null
		      );
		      if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
		      isHydrating$jscomp$0 ||
		        0 !== (renderLanes & 60) ||
		        pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
		    }
		    return getServerSnapshot;
		  }
		  function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
		    fiber.flags |= 16384;
		    fiber = { getSnapshot: getSnapshot, value: renderedSnapshot };
		    getSnapshot = currentlyRenderingFiber$1.updateQueue;
		    null === getSnapshot
		      ? ((getSnapshot = createFunctionComponentUpdateQueue()),
		        (currentlyRenderingFiber$1.updateQueue = getSnapshot),
		        (getSnapshot.stores = [fiber]))
		      : ((renderedSnapshot = getSnapshot.stores),
		        null === renderedSnapshot
		          ? (getSnapshot.stores = [fiber])
		          : renderedSnapshot.push(fiber));
		  }
		  function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
		    inst.value = nextSnapshot;
		    inst.getSnapshot = getSnapshot;
		    checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
		  }
		  function subscribeToStore(fiber, inst, subscribe) {
		    return subscribe(function () {
		      checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
		    });
		  }
		  function checkIfSnapshotChanged(inst) {
		    var latestGetSnapshot = inst.getSnapshot;
		    inst = inst.value;
		    try {
		      var nextValue = latestGetSnapshot();
		      return !objectIs(inst, nextValue);
		    } catch (error) {
		      return true;
		    }
		  }
		  function forceStoreRerender(fiber) {
		    var root = enqueueConcurrentRenderForLane(fiber, 2);
		    null !== root && scheduleUpdateOnFiber(root, fiber, 2);
		  }
		  function mountStateImpl(initialState) {
		    var hook = mountWorkInProgressHook();
		    if ("function" === typeof initialState) {
		      var initialStateInitializer = initialState;
		      initialState = initialStateInitializer();
		      if (shouldDoubleInvokeUserFnsInHooksDEV) {
		        setIsStrictModeForDevtools(true);
		        try {
		          initialStateInitializer();
		        } finally {
		          setIsStrictModeForDevtools(false);
		        }
		      }
		    }
		    hook.memoizedState = hook.baseState = initialState;
		    hook.queue = {
		      pending: null,
		      lanes: 0,
		      dispatch: null,
		      lastRenderedReducer: basicStateReducer,
		      lastRenderedState: initialState
		    };
		    return hook;
		  }
		  function updateOptimisticImpl(hook, current, passthrough, reducer) {
		    hook.baseState = passthrough;
		    return updateReducerImpl(
		      hook,
		      currentHook,
		      "function" === typeof reducer ? reducer : basicStateReducer
		    );
		  }
		  function dispatchActionState(
		    fiber,
		    actionQueue,
		    setPendingState,
		    setState,
		    payload
		  ) {
		    if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
		    fiber = actionQueue.action;
		    if (null !== fiber) {
		      var actionNode = {
		        payload: payload,
		        action: fiber,
		        next: null,
		        isTransition: true,
		        status: "pending",
		        value: null,
		        reason: null,
		        listeners: [],
		        then: function (listener) {
		          actionNode.listeners.push(listener);
		        }
		      };
		      null !== ReactSharedInternals.T
		        ? setPendingState(true)
		        : (actionNode.isTransition = false);
		      setState(actionNode);
		      setPendingState = actionQueue.pending;
		      null === setPendingState
		        ? ((actionNode.next = actionQueue.pending = actionNode),
		          runActionStateAction(actionQueue, actionNode))
		        : ((actionNode.next = setPendingState.next),
		          (actionQueue.pending = setPendingState.next = actionNode));
		    }
		  }
		  function runActionStateAction(actionQueue, node) {
		    var action = node.action,
		      payload = node.payload,
		      prevState = actionQueue.state;
		    if (node.isTransition) {
		      var prevTransition = ReactSharedInternals.T,
		        currentTransition = {};
		      ReactSharedInternals.T = currentTransition;
		      try {
		        var returnValue = action(prevState, payload),
		          onStartTransitionFinish = ReactSharedInternals.S;
		        null !== onStartTransitionFinish &&
		          onStartTransitionFinish(currentTransition, returnValue);
		        handleActionReturnValue(actionQueue, node, returnValue);
		      } catch (error) {
		        onActionError(actionQueue, node, error);
		      } finally {
		        ReactSharedInternals.T = prevTransition;
		      }
		    } else
		      try {
		        (prevTransition = action(prevState, payload)),
		          handleActionReturnValue(actionQueue, node, prevTransition);
		      } catch (error$52) {
		        onActionError(actionQueue, node, error$52);
		      }
		  }
		  function handleActionReturnValue(actionQueue, node, returnValue) {
		    null !== returnValue &&
		    "object" === typeof returnValue &&
		    "function" === typeof returnValue.then
		      ? returnValue.then(
		          function (nextState) {
		            onActionSuccess(actionQueue, node, nextState);
		          },
		          function (error) {
		            return onActionError(actionQueue, node, error);
		          }
		        )
		      : onActionSuccess(actionQueue, node, returnValue);
		  }
		  function onActionSuccess(actionQueue, actionNode, nextState) {
		    actionNode.status = "fulfilled";
		    actionNode.value = nextState;
		    notifyActionListeners(actionNode);
		    actionQueue.state = nextState;
		    actionNode = actionQueue.pending;
		    null !== actionNode &&
		      ((nextState = actionNode.next),
		      nextState === actionNode
		        ? (actionQueue.pending = null)
		        : ((nextState = nextState.next),
		          (actionNode.next = nextState),
		          runActionStateAction(actionQueue, nextState)));
		  }
		  function onActionError(actionQueue, actionNode, error) {
		    var last = actionQueue.pending;
		    actionQueue.pending = null;
		    if (null !== last) {
		      last = last.next;
		      do
		        (actionNode.status = "rejected"),
		          (actionNode.reason = error),
		          notifyActionListeners(actionNode),
		          (actionNode = actionNode.next);
		      while (actionNode !== last);
		    }
		    actionQueue.action = null;
		  }
		  function notifyActionListeners(actionNode) {
		    actionNode = actionNode.listeners;
		    for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
		  }
		  function actionStateReducer(oldState, newState) {
		    return newState;
		  }
		  function mountActionState(action, initialStateProp) {
		    if (isHydrating) {
		      var ssrFormState = workInProgressRoot.formState;
		      if (null !== ssrFormState) {
		        a: {
		          var JSCompiler_inline_result = currentlyRenderingFiber$1;
		          if (isHydrating) {
		            if (nextHydratableInstance) {
		              var markerInstance = canHydrateFormStateMarker(
		                nextHydratableInstance,
		                rootOrSingletonContext
		              );
		              if (markerInstance) {
		                nextHydratableInstance =
		                  getNextHydratableSibling(markerInstance);
		                JSCompiler_inline_result =
		                  isFormStateMarkerMatching(markerInstance);
		                break a;
		              }
		            }
		            throwOnHydrationMismatch(JSCompiler_inline_result);
		          }
		          JSCompiler_inline_result = false;
		        }
		        JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
		      }
		    }
		    ssrFormState = mountWorkInProgressHook();
		    ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
		    JSCompiler_inline_result = {
		      pending: null,
		      lanes: 0,
		      dispatch: null,
		      lastRenderedReducer: actionStateReducer,
		      lastRenderedState: initialStateProp
		    };
		    ssrFormState.queue = JSCompiler_inline_result;
		    ssrFormState = dispatchSetState.bind(
		      null,
		      currentlyRenderingFiber$1,
		      JSCompiler_inline_result
		    );
		    JSCompiler_inline_result.dispatch = ssrFormState;
		    JSCompiler_inline_result = mountStateImpl(false);
		    var setPendingState = dispatchOptimisticSetState.bind(
		      null,
		      currentlyRenderingFiber$1,
		      false,
		      JSCompiler_inline_result.queue
		    );
		    JSCompiler_inline_result = mountWorkInProgressHook();
		    markerInstance = {
		      state: initialStateProp,
		      dispatch: null,
		      action: action,
		      pending: null
		    };
		    JSCompiler_inline_result.queue = markerInstance;
		    ssrFormState = dispatchActionState.bind(
		      null,
		      currentlyRenderingFiber$1,
		      markerInstance,
		      setPendingState,
		      ssrFormState
		    );
		    markerInstance.dispatch = ssrFormState;
		    JSCompiler_inline_result.memoizedState = action;
		    return [initialStateProp, ssrFormState, false];
		  }
		  function updateActionState(action) {
		    var stateHook = updateWorkInProgressHook();
		    return updateActionStateImpl(stateHook, currentHook, action);
		  }
		  function updateActionStateImpl(stateHook, currentStateHook, action) {
		    currentStateHook = updateReducerImpl(
		      stateHook,
		      currentStateHook,
		      actionStateReducer
		    )[0];
		    stateHook = updateReducer(basicStateReducer)[0];
		    currentStateHook =
		      "object" === typeof currentStateHook &&
		      null !== currentStateHook &&
		      "function" === typeof currentStateHook.then
		        ? useThenable(currentStateHook)
		        : currentStateHook;
		    var actionQueueHook = updateWorkInProgressHook(),
		      actionQueue = actionQueueHook.queue,
		      dispatch = actionQueue.dispatch;
		    action !== actionQueueHook.memoizedState &&
		      ((currentlyRenderingFiber$1.flags |= 2048),
		      pushEffect(
		        9,
		        actionStateActionEffect.bind(null, actionQueue, action),
		        { destroy: void 0 },
		        null
		      ));
		    return [currentStateHook, dispatch, stateHook];
		  }
		  function actionStateActionEffect(actionQueue, action) {
		    actionQueue.action = action;
		  }
		  function rerenderActionState(action) {
		    var stateHook = updateWorkInProgressHook(),
		      currentStateHook = currentHook;
		    if (null !== currentStateHook)
		      return updateActionStateImpl(stateHook, currentStateHook, action);
		    updateWorkInProgressHook();
		    stateHook = stateHook.memoizedState;
		    currentStateHook = updateWorkInProgressHook();
		    var dispatch = currentStateHook.queue.dispatch;
		    currentStateHook.memoizedState = action;
		    return [stateHook, dispatch, false];
		  }
		  function pushEffect(tag, create, inst, deps) {
		    tag = { tag: tag, create: create, inst: inst, deps: deps, next: null };
		    create = currentlyRenderingFiber$1.updateQueue;
		    null === create &&
		      ((create = createFunctionComponentUpdateQueue()),
		      (currentlyRenderingFiber$1.updateQueue = create));
		    inst = create.lastEffect;
		    null === inst
		      ? (create.lastEffect = tag.next = tag)
		      : ((deps = inst.next),
		        (inst.next = tag),
		        (tag.next = deps),
		        (create.lastEffect = tag));
		    return tag;
		  }
		  function updateRef() {
		    return updateWorkInProgressHook().memoizedState;
		  }
		  function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
		    var hook = mountWorkInProgressHook();
		    currentlyRenderingFiber$1.flags |= fiberFlags;
		    hook.memoizedState = pushEffect(
		      1 | hookFlags,
		      create,
		      { destroy: void 0 },
		      void 0 === deps ? null : deps
		    );
		  }
		  function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
		    var hook = updateWorkInProgressHook();
		    deps = void 0 === deps ? null : deps;
		    var inst = hook.memoizedState.inst;
		    null !== currentHook &&
		    null !== deps &&
		    areHookInputsEqual(deps, currentHook.memoizedState.deps)
		      ? (hook.memoizedState = pushEffect(hookFlags, create, inst, deps))
		      : ((currentlyRenderingFiber$1.flags |= fiberFlags),
		        (hook.memoizedState = pushEffect(1 | hookFlags, create, inst, deps)));
		  }
		  function mountEffect(create, deps) {
		    mountEffectImpl(8390656, 8, create, deps);
		  }
		  function updateEffect(create, deps) {
		    updateEffectImpl(2048, 8, create, deps);
		  }
		  function updateInsertionEffect(create, deps) {
		    return updateEffectImpl(4, 2, create, deps);
		  }
		  function updateLayoutEffect(create, deps) {
		    return updateEffectImpl(4, 4, create, deps);
		  }
		  function imperativeHandleEffect(create, ref) {
		    if ("function" === typeof ref) {
		      create = create();
		      var refCleanup = ref(create);
		      return function () {
		        "function" === typeof refCleanup ? refCleanup() : ref(null);
		      };
		    }
		    if (null !== ref && void 0 !== ref)
		      return (
		        (create = create()),
		        (ref.current = create),
		        function () {
		          ref.current = null;
		        }
		      );
		  }
		  function updateImperativeHandle(ref, create, deps) {
		    deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
		    updateEffectImpl(
		      4,
		      4,
		      imperativeHandleEffect.bind(null, create, ref),
		      deps
		    );
		  }
		  function mountDebugValue() {}
		  function updateCallback(callback, deps) {
		    var hook = updateWorkInProgressHook();
		    deps = void 0 === deps ? null : deps;
		    var prevState = hook.memoizedState;
		    if (null !== deps && areHookInputsEqual(deps, prevState[1]))
		      return prevState[0];
		    hook.memoizedState = [callback, deps];
		    return callback;
		  }
		  function updateMemo(nextCreate, deps) {
		    var hook = updateWorkInProgressHook();
		    deps = void 0 === deps ? null : deps;
		    var prevState = hook.memoizedState;
		    if (null !== deps && areHookInputsEqual(deps, prevState[1]))
		      return prevState[0];
		    prevState = nextCreate();
		    if (shouldDoubleInvokeUserFnsInHooksDEV) {
		      setIsStrictModeForDevtools(true);
		      try {
		        nextCreate();
		      } finally {
		        setIsStrictModeForDevtools(false);
		      }
		    }
		    hook.memoizedState = [prevState, deps];
		    return prevState;
		  }
		  function mountDeferredValueImpl(hook, value, initialValue) {
		    if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
		      return (hook.memoizedState = value);
		    hook.memoizedState = initialValue;
		    hook = requestDeferredLane();
		    currentlyRenderingFiber$1.lanes |= hook;
		    workInProgressRootSkippedLanes |= hook;
		    return initialValue;
		  }
		  function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
		    if (objectIs(value, prevValue)) return value;
		    if (null !== currentTreeHiddenStackCursor.current)
		      return (
		        (hook = mountDeferredValueImpl(hook, value, initialValue)),
		        objectIs(hook, prevValue) || (didReceiveUpdate = true),
		        hook
		      );
		    if (0 === (renderLanes & 42))
		      return (didReceiveUpdate = true), (hook.memoizedState = value);
		    hook = requestDeferredLane();
		    currentlyRenderingFiber$1.lanes |= hook;
		    workInProgressRootSkippedLanes |= hook;
		    return prevValue;
		  }
		  function startTransition(
		    fiber,
		    queue,
		    pendingState,
		    finishedState,
		    callback
		  ) {
		    var previousPriority = getCurrentUpdatePriority();
		    setCurrentUpdatePriority(
		      0 !== previousPriority && 8 > previousPriority ? previousPriority : 8
		    );
		    var prevTransition = ReactSharedInternals.T,
		      currentTransition = {};
		    ReactSharedInternals.T = currentTransition;
		    dispatchOptimisticSetState(fiber, false, queue, pendingState);
		    try {
		      var returnValue = callback(),
		        onStartTransitionFinish = ReactSharedInternals.S;
		      null !== onStartTransitionFinish &&
		        onStartTransitionFinish(currentTransition, returnValue);
		      if (
		        null !== returnValue &&
		        "object" === typeof returnValue &&
		        "function" === typeof returnValue.then
		      ) {
		        var thenableForFinishedState = chainThenableValue(
		          returnValue,
		          finishedState
		        );
		        dispatchSetStateInternal(
		          fiber,
		          queue,
		          thenableForFinishedState,
		          requestUpdateLane(fiber)
		        );
		      } else
		        dispatchSetStateInternal(
		          fiber,
		          queue,
		          finishedState,
		          requestUpdateLane(fiber)
		        );
		    } catch (error) {
		      dispatchSetStateInternal(
		        fiber,
		        queue,
		        { then: function () {}, status: "rejected", reason: error },
		        requestUpdateLane()
		      );
		    } finally {
		      setCurrentUpdatePriority(previousPriority),
		        (ReactSharedInternals.T = prevTransition);
		    }
		  }
		  function ensureFormComponentIsStateful(formFiber) {
		    var existingStateHook = formFiber.memoizedState;
		    if (null !== existingStateHook) return existingStateHook;
		    existingStateHook = {
		      memoizedState: NotPendingTransition,
		      baseState: NotPendingTransition,
		      baseQueue: null,
		      queue: {
		        pending: null,
		        lanes: 0,
		        dispatch: null,
		        lastRenderedReducer: basicStateReducer,
		        lastRenderedState: NotPendingTransition
		      },
		      next: null
		    };
		    var initialResetState = {};
		    existingStateHook.next = {
		      memoizedState: initialResetState,
		      baseState: initialResetState,
		      baseQueue: null,
		      queue: {
		        pending: null,
		        lanes: 0,
		        dispatch: null,
		        lastRenderedReducer: basicStateReducer,
		        lastRenderedState: initialResetState
		      },
		      next: null
		    };
		    formFiber.memoizedState = existingStateHook;
		    formFiber = formFiber.alternate;
		    null !== formFiber && (formFiber.memoizedState = existingStateHook);
		    return existingStateHook;
		  }
		  function useHostTransitionStatus() {
		    return readContext(HostTransitionContext);
		  }
		  function updateId() {
		    return updateWorkInProgressHook().memoizedState;
		  }
		  function updateRefresh() {
		    return updateWorkInProgressHook().memoizedState;
		  }
		  function refreshCache(fiber) {
		    for (var provider = fiber.return; null !== provider; ) {
		      switch (provider.tag) {
		        case 24:
		        case 3:
		          var lane = requestUpdateLane();
		          fiber = createUpdate(lane);
		          var root = enqueueUpdate(provider, fiber, lane);
		          null !== root &&
		            (scheduleUpdateOnFiber(root, provider, lane),
		            entangleTransitions(root, provider, lane));
		          provider = { cache: createCache() };
		          fiber.payload = provider;
		          return;
		      }
		      provider = provider.return;
		    }
		  }
		  function dispatchReducerAction(fiber, queue, action) {
		    var lane = requestUpdateLane();
		    action = {
		      lane: lane,
		      revertLane: 0,
		      action: action,
		      hasEagerState: false,
		      eagerState: null,
		      next: null
		    };
		    isRenderPhaseUpdate(fiber)
		      ? enqueueRenderPhaseUpdate(queue, action)
		      : ((action = enqueueConcurrentHookUpdate(fiber, queue, action, lane)),
		        null !== action &&
		          (scheduleUpdateOnFiber(action, fiber, lane),
		          entangleTransitionUpdate(action, queue, lane)));
		  }
		  function dispatchSetState(fiber, queue, action) {
		    var lane = requestUpdateLane();
		    dispatchSetStateInternal(fiber, queue, action, lane);
		  }
		  function dispatchSetStateInternal(fiber, queue, action, lane) {
		    var update = {
		      lane: lane,
		      revertLane: 0,
		      action: action,
		      hasEagerState: false,
		      eagerState: null,
		      next: null
		    };
		    if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
		    else {
		      var alternate = fiber.alternate;
		      if (
		        0 === fiber.lanes &&
		        (null === alternate || 0 === alternate.lanes) &&
		        ((alternate = queue.lastRenderedReducer), null !== alternate)
		      )
		        try {
		          var currentState = queue.lastRenderedState,
		            eagerState = alternate(currentState, action);
		          update.hasEagerState = !0;
		          update.eagerState = eagerState;
		          if (objectIs(eagerState, currentState))
		            return (
		              enqueueUpdate$1(fiber, queue, update, 0),
		              null === workInProgressRoot && finishQueueingConcurrentUpdates(),
		              !1
		            );
		        } catch (error) {
		        } finally {
		        }
		      action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
		      if (null !== action)
		        return (
		          scheduleUpdateOnFiber(action, fiber, lane),
		          entangleTransitionUpdate(action, queue, lane),
		          true
		        );
		    }
		    return false;
		  }
		  function dispatchOptimisticSetState(
		    fiber,
		    throwIfDuringRender,
		    queue,
		    action
		  ) {
		    action = {
		      lane: 2,
		      revertLane: requestTransitionLane(),
		      action: action,
		      hasEagerState: false,
		      eagerState: null,
		      next: null
		    };
		    if (isRenderPhaseUpdate(fiber)) {
		      if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
		    } else
		      (throwIfDuringRender = enqueueConcurrentHookUpdate(
		        fiber,
		        queue,
		        action,
		        2
		      )),
		        null !== throwIfDuringRender &&
		          scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
		  }
		  function isRenderPhaseUpdate(fiber) {
		    var alternate = fiber.alternate;
		    return (
		      fiber === currentlyRenderingFiber$1 ||
		      (null !== alternate && alternate === currentlyRenderingFiber$1)
		    );
		  }
		  function enqueueRenderPhaseUpdate(queue, update) {
		    didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate =
		      true;
		    var pending = queue.pending;
		    null === pending
		      ? (update.next = update)
		      : ((update.next = pending.next), (pending.next = update));
		    queue.pending = update;
		  }
		  function entangleTransitionUpdate(root, queue, lane) {
		    if (0 !== (lane & 4194176)) {
		      var queueLanes = queue.lanes;
		      queueLanes &= root.pendingLanes;
		      lane |= queueLanes;
		      queue.lanes = lane;
		      markRootEntangled(root, lane);
		    }
		  }
		  function applyDerivedStateFromProps(
		    workInProgress,
		    ctor,
		    getDerivedStateFromProps,
		    nextProps
		  ) {
		    ctor = workInProgress.memoizedState;
		    getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
		    getDerivedStateFromProps =
		      null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps
		        ? ctor
		        : assign({}, ctor, getDerivedStateFromProps);
		    workInProgress.memoizedState = getDerivedStateFromProps;
		    0 === workInProgress.lanes &&
		      (workInProgress.updateQueue.baseState = getDerivedStateFromProps);
		  }
		  function checkShouldComponentUpdate(
		    workInProgress,
		    ctor,
		    oldProps,
		    newProps,
		    oldState,
		    newState,
		    nextContext
		  ) {
		    workInProgress = workInProgress.stateNode;
		    return "function" === typeof workInProgress.shouldComponentUpdate
		      ? workInProgress.shouldComponentUpdate(newProps, newState, nextContext)
		      : ctor.prototype && ctor.prototype.isPureReactComponent
		        ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
		        : true;
		  }
		  function callComponentWillReceiveProps(
		    workInProgress,
		    instance,
		    newProps,
		    nextContext
		  ) {
		    workInProgress = instance.state;
		    "function" === typeof instance.componentWillReceiveProps &&
		      instance.componentWillReceiveProps(newProps, nextContext);
		    "function" === typeof instance.UNSAFE_componentWillReceiveProps &&
		      instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
		    instance.state !== workInProgress &&
		      classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
		  }
		  function resolveClassComponentProps(Component, baseProps) {
		    var newProps = baseProps;
		    if ("ref" in baseProps) {
		      newProps = {};
		      for (var propName in baseProps)
		        "ref" !== propName && (newProps[propName] = baseProps[propName]);
		    }
		    if ((Component = Component.defaultProps)) {
		      newProps === baseProps && (newProps = assign({}, newProps));
		      for (var propName$54 in Component)
		        void 0 === newProps[propName$54] &&
		          (newProps[propName$54] = Component[propName$54]);
		    }
		    return newProps;
		  }
		  function logUncaughtError(root, errorInfo) {
		    try {
		      var onUncaughtError = root.onUncaughtError;
		      onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
		    } catch (e) {
		      setTimeout(function () {
		        throw e;
		      });
		    }
		  }
		  function logCaughtError(root, boundary, errorInfo) {
		    try {
		      var onCaughtError = root.onCaughtError;
		      onCaughtError(errorInfo.value, {
		        componentStack: errorInfo.stack,
		        errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
		      });
		    } catch (e) {
		      setTimeout(function () {
		        throw e;
		      });
		    }
		  }
		  function createRootErrorUpdate(root, errorInfo, lane) {
		    lane = createUpdate(lane);
		    lane.tag = 3;
		    lane.payload = { element: null };
		    lane.callback = function () {
		      logUncaughtError(root, errorInfo);
		    };
		    return lane;
		  }
		  function createClassErrorUpdate(lane) {
		    lane = createUpdate(lane);
		    lane.tag = 3;
		    return lane;
		  }
		  function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
		    var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
		    if ("function" === typeof getDerivedStateFromError) {
		      var error = errorInfo.value;
		      update.payload = function () {
		        return getDerivedStateFromError(error);
		      };
		      update.callback = function () {
		        logCaughtError(root, fiber, errorInfo);
		      };
		    }
		    var inst = fiber.stateNode;
		    null !== inst &&
		      "function" === typeof inst.componentDidCatch &&
		      (update.callback = function () {
		        logCaughtError(root, fiber, errorInfo);
		        "function" !== typeof getDerivedStateFromError &&
		          (null === legacyErrorBoundariesThatAlreadyFailed
		            ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))
		            : legacyErrorBoundariesThatAlreadyFailed.add(this));
		        var stack = errorInfo.stack;
		        this.componentDidCatch(errorInfo.value, {
		          componentStack: null !== stack ? stack : ""
		        });
		      });
		  }
		  function throwException(
		    root,
		    returnFiber,
		    sourceFiber,
		    value,
		    rootRenderLanes
		  ) {
		    sourceFiber.flags |= 32768;
		    if (
		      null !== value &&
		      "object" === typeof value &&
		      "function" === typeof value.then
		    ) {
		      returnFiber = sourceFiber.alternate;
		      null !== returnFiber &&
		        propagateParentContextChanges(
		          returnFiber,
		          sourceFiber,
		          rootRenderLanes,
		          true
		        );
		      sourceFiber = suspenseHandlerStackCursor.current;
		      if (null !== sourceFiber) {
		        switch (sourceFiber.tag) {
		          case 13:
		            return (
		              null === shellBoundary
		                ? renderDidSuspendDelayIfPossible()
		                : null === sourceFiber.alternate &&
		                  0 === workInProgressRootExitStatus &&
		                  (workInProgressRootExitStatus = 3),
		              (sourceFiber.flags &= -257),
		              (sourceFiber.flags |= 65536),
		              (sourceFiber.lanes = rootRenderLanes),
		              value === noopSuspenseyCommitThenable
		                ? (sourceFiber.flags |= 16384)
		                : ((returnFiber = sourceFiber.updateQueue),
		                  null === returnFiber
		                    ? (sourceFiber.updateQueue = new Set([value]))
		                    : returnFiber.add(value),
		                  attachPingListener(root, value, rootRenderLanes)),
		              false
		            );
		          case 22:
		            return (
		              (sourceFiber.flags |= 65536),
		              value === noopSuspenseyCommitThenable
		                ? (sourceFiber.flags |= 16384)
		                : ((returnFiber = sourceFiber.updateQueue),
		                  null === returnFiber
		                    ? ((returnFiber = {
		                        transitions: null,
		                        markerInstances: null,
		                        retryQueue: new Set([value])
		                      }),
		                      (sourceFiber.updateQueue = returnFiber))
		                    : ((sourceFiber = returnFiber.retryQueue),
		                      null === sourceFiber
		                        ? (returnFiber.retryQueue = new Set([value]))
		                        : sourceFiber.add(value)),
		                  attachPingListener(root, value, rootRenderLanes)),
		              false
		            );
		        }
		        throw Error(formatProdErrorMessage(435, sourceFiber.tag));
		      }
		      attachPingListener(root, value, rootRenderLanes);
		      renderDidSuspendDelayIfPossible();
		      return false;
		    }
		    if (isHydrating)
		      return (
		        (returnFiber = suspenseHandlerStackCursor.current),
		        null !== returnFiber
		          ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256),
		            (returnFiber.flags |= 65536),
		            (returnFiber.lanes = rootRenderLanes),
		            value !== HydrationMismatchException &&
		              ((root = Error(formatProdErrorMessage(422), { cause: value })),
		              queueHydrationError(
		                createCapturedValueAtFiber(root, sourceFiber)
		              )))
		          : (value !== HydrationMismatchException &&
		              ((returnFiber = Error(formatProdErrorMessage(423), {
		                cause: value
		              })),
		              queueHydrationError(
		                createCapturedValueAtFiber(returnFiber, sourceFiber)
		              )),
		            (root = root.current.alternate),
		            (root.flags |= 65536),
		            (rootRenderLanes &= -rootRenderLanes),
		            (root.lanes |= rootRenderLanes),
		            (value = createCapturedValueAtFiber(value, sourceFiber)),
		            (rootRenderLanes = createRootErrorUpdate(
		              root.stateNode,
		              value,
		              rootRenderLanes
		            )),
		            enqueueCapturedUpdate(root, rootRenderLanes),
		            4 !== workInProgressRootExitStatus &&
		              (workInProgressRootExitStatus = 2)),
		        false
		      );
		    var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
		    wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
		    null === workInProgressRootConcurrentErrors
		      ? (workInProgressRootConcurrentErrors = [wrapperError])
		      : workInProgressRootConcurrentErrors.push(wrapperError);
		    4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
		    if (null === returnFiber) return true;
		    value = createCapturedValueAtFiber(value, sourceFiber);
		    sourceFiber = returnFiber;
		    do {
		      switch (sourceFiber.tag) {
		        case 3:
		          return (
		            (sourceFiber.flags |= 65536),
		            (root = rootRenderLanes & -rootRenderLanes),
		            (sourceFiber.lanes |= root),
		            (root = createRootErrorUpdate(sourceFiber.stateNode, value, root)),
		            enqueueCapturedUpdate(sourceFiber, root),
		            false
		          );
		        case 1:
		          if (
		            ((returnFiber = sourceFiber.type),
		            (wrapperError = sourceFiber.stateNode),
		            0 === (sourceFiber.flags & 128) &&
		              ("function" === typeof returnFiber.getDerivedStateFromError ||
		                (null !== wrapperError &&
		                  "function" === typeof wrapperError.componentDidCatch &&
		                  (null === legacyErrorBoundariesThatAlreadyFailed ||
		                    !legacyErrorBoundariesThatAlreadyFailed.has(
		                      wrapperError
		                    )))))
		          )
		            return (
		              (sourceFiber.flags |= 65536),
		              (rootRenderLanes &= -rootRenderLanes),
		              (sourceFiber.lanes |= rootRenderLanes),
		              (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),
		              initializeClassErrorUpdate(
		                rootRenderLanes,
		                root,
		                sourceFiber,
		                value
		              ),
		              enqueueCapturedUpdate(sourceFiber, rootRenderLanes),
		              false
		            );
		      }
		      sourceFiber = sourceFiber.return;
		    } while (null !== sourceFiber);
		    return false;
		  }
		  function reconcileChildren(
		    current,
		    workInProgress,
		    nextChildren,
		    renderLanes
		  ) {
		    workInProgress.child =
		      null === current
		        ? mountChildFibers(workInProgress, null, nextChildren, renderLanes)
		        : reconcileChildFibers(
		            workInProgress,
		            current.child,
		            nextChildren,
		            renderLanes
		          );
		  }
		  function updateForwardRef(
		    current,
		    workInProgress,
		    Component,
		    nextProps,
		    renderLanes
		  ) {
		    Component = Component.render;
		    var ref = workInProgress.ref;
		    if ("ref" in nextProps) {
		      var propsWithoutRef = {};
		      for (var key in nextProps)
		        "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
		    } else propsWithoutRef = nextProps;
		    prepareToReadContext(workInProgress);
		    nextProps = renderWithHooks(
		      current,
		      workInProgress,
		      Component,
		      propsWithoutRef,
		      ref,
		      renderLanes
		    );
		    key = checkDidRenderIdHook();
		    if (null !== current && !didReceiveUpdate)
		      return (
		        bailoutHooks(current, workInProgress, renderLanes),
		        bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
		      );
		    isHydrating && key && pushMaterializedTreeId(workInProgress);
		    workInProgress.flags |= 1;
		    reconcileChildren(current, workInProgress, nextProps, renderLanes);
		    return workInProgress.child;
		  }
		  function updateMemoComponent(
		    current,
		    workInProgress,
		    Component,
		    nextProps,
		    renderLanes
		  ) {
		    if (null === current) {
		      var type = Component.type;
		      if (
		        "function" === typeof type &&
		        !shouldConstruct(type) &&
		        void 0 === type.defaultProps &&
		        null === Component.compare
		      )
		        return (
		          (workInProgress.tag = 15),
		          (workInProgress.type = type),
		          updateSimpleMemoComponent(
		            current,
		            workInProgress,
		            type,
		            nextProps,
		            renderLanes
		          )
		        );
		      current = createFiberFromTypeAndProps(
		        Component.type,
		        null,
		        nextProps,
		        workInProgress,
		        workInProgress.mode,
		        renderLanes
		      );
		      current.ref = workInProgress.ref;
		      current.return = workInProgress;
		      return (workInProgress.child = current);
		    }
		    type = current.child;
		    if (!checkScheduledUpdateOrContext(current, renderLanes)) {
		      var prevProps = type.memoizedProps;
		      Component = Component.compare;
		      Component = null !== Component ? Component : shallowEqual;
		      if (Component(prevProps, nextProps) && current.ref === workInProgress.ref)
		        return bailoutOnAlreadyFinishedWork(
		          current,
		          workInProgress,
		          renderLanes
		        );
		    }
		    workInProgress.flags |= 1;
		    current = createWorkInProgress(type, nextProps);
		    current.ref = workInProgress.ref;
		    current.return = workInProgress;
		    return (workInProgress.child = current);
		  }
		  function updateSimpleMemoComponent(
		    current,
		    workInProgress,
		    Component,
		    nextProps,
		    renderLanes
		  ) {
		    if (null !== current) {
		      var prevProps = current.memoizedProps;
		      if (
		        shallowEqual(prevProps, nextProps) &&
		        current.ref === workInProgress.ref
		      )
		        if (
		          ((didReceiveUpdate = false),
		          (workInProgress.pendingProps = nextProps = prevProps),
		          checkScheduledUpdateOrContext(current, renderLanes))
		        )
		          0 !== (current.flags & 131072) && (didReceiveUpdate = true);
		        else
		          return (
		            (workInProgress.lanes = current.lanes),
		            bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
		          );
		    }
		    return updateFunctionComponent(
		      current,
		      workInProgress,
		      Component,
		      nextProps,
		      renderLanes
		    );
		  }
		  function updateOffscreenComponent(current, workInProgress, renderLanes) {
		    var nextProps = workInProgress.pendingProps,
		      nextChildren = nextProps.children,
		      nextIsDetached = 0 !== (workInProgress.stateNode._pendingVisibility & 2),
		      prevState = null !== current ? current.memoizedState : null;
		    markRef(current, workInProgress);
		    if ("hidden" === nextProps.mode || nextIsDetached) {
		      if (0 !== (workInProgress.flags & 128)) {
		        nextProps =
		          null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;
		        if (null !== current) {
		          nextChildren = workInProgress.child = current.child;
		          for (nextIsDetached = 0; null !== nextChildren; )
		            (nextIsDetached =
		              nextIsDetached | nextChildren.lanes | nextChildren.childLanes),
		              (nextChildren = nextChildren.sibling);
		          workInProgress.childLanes = nextIsDetached & ~nextProps;
		        } else (workInProgress.childLanes = 0), (workInProgress.child = null);
		        return deferHiddenOffscreenComponent(
		          current,
		          workInProgress,
		          nextProps,
		          renderLanes
		        );
		      }
		      if (0 !== (renderLanes & 536870912))
		        (workInProgress.memoizedState = { baseLanes: 0, cachePool: null }),
		          null !== current &&
		            pushTransition(
		              workInProgress,
		              null !== prevState ? prevState.cachePool : null
		            ),
		          null !== prevState
		            ? pushHiddenContext(workInProgress, prevState)
		            : reuseHiddenContextOnStack(),
		          pushOffscreenSuspenseHandler(workInProgress);
		      else
		        return (
		          (workInProgress.lanes = workInProgress.childLanes = 536870912),
		          deferHiddenOffscreenComponent(
		            current,
		            workInProgress,
		            null !== prevState
		              ? prevState.baseLanes | renderLanes
		              : renderLanes,
		            renderLanes
		          )
		        );
		    } else
		      null !== prevState
		        ? (pushTransition(workInProgress, prevState.cachePool),
		          pushHiddenContext(workInProgress, prevState),
		          reuseSuspenseHandlerOnStack(),
		          (workInProgress.memoizedState = null))
		        : (null !== current && pushTransition(workInProgress, null),
		          reuseHiddenContextOnStack(),
		          reuseSuspenseHandlerOnStack());
		    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
		    return workInProgress.child;
		  }
		  function deferHiddenOffscreenComponent(
		    current,
		    workInProgress,
		    nextBaseLanes,
		    renderLanes
		  ) {
		    var JSCompiler_inline_result = peekCacheFromPool();
		    JSCompiler_inline_result =
		      null === JSCompiler_inline_result
		        ? null
		        : {
		            parent: isPrimaryRenderer
		              ? CacheContext._currentValue
		              : CacheContext._currentValue2,
		            pool: JSCompiler_inline_result
		          };
		    workInProgress.memoizedState = {
		      baseLanes: nextBaseLanes,
		      cachePool: JSCompiler_inline_result
		    };
		    null !== current && pushTransition(workInProgress, null);
		    reuseHiddenContextOnStack();
		    pushOffscreenSuspenseHandler(workInProgress);
		    null !== current &&
		      propagateParentContextChanges(current, workInProgress, renderLanes, true);
		    return null;
		  }
		  function markRef(current, workInProgress) {
		    var ref = workInProgress.ref;
		    if (null === ref)
		      null !== current &&
		        null !== current.ref &&
		        (workInProgress.flags |= 2097664);
		    else {
		      if ("function" !== typeof ref && "object" !== typeof ref)
		        throw Error(formatProdErrorMessage(284));
		      if (null === current || current.ref !== ref)
		        workInProgress.flags |= 2097664;
		    }
		  }
		  function updateFunctionComponent(
		    current,
		    workInProgress,
		    Component,
		    nextProps,
		    renderLanes
		  ) {
		    prepareToReadContext(workInProgress);
		    Component = renderWithHooks(
		      current,
		      workInProgress,
		      Component,
		      nextProps,
		      void 0,
		      renderLanes
		    );
		    nextProps = checkDidRenderIdHook();
		    if (null !== current && !didReceiveUpdate)
		      return (
		        bailoutHooks(current, workInProgress, renderLanes),
		        bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
		      );
		    isHydrating && nextProps && pushMaterializedTreeId(workInProgress);
		    workInProgress.flags |= 1;
		    reconcileChildren(current, workInProgress, Component, renderLanes);
		    return workInProgress.child;
		  }
		  function replayFunctionComponent(
		    current,
		    workInProgress,
		    nextProps,
		    Component,
		    secondArg,
		    renderLanes
		  ) {
		    prepareToReadContext(workInProgress);
		    workInProgress.updateQueue = null;
		    nextProps = renderWithHooksAgain(
		      workInProgress,
		      Component,
		      nextProps,
		      secondArg
		    );
		    finishRenderingHooks(current);
		    Component = checkDidRenderIdHook();
		    if (null !== current && !didReceiveUpdate)
		      return (
		        bailoutHooks(current, workInProgress, renderLanes),
		        bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
		      );
		    isHydrating && Component && pushMaterializedTreeId(workInProgress);
		    workInProgress.flags |= 1;
		    reconcileChildren(current, workInProgress, nextProps, renderLanes);
		    return workInProgress.child;
		  }
		  function updateClassComponent(
		    current,
		    workInProgress,
		    Component,
		    nextProps,
		    renderLanes
		  ) {
		    prepareToReadContext(workInProgress);
		    if (null === workInProgress.stateNode) {
		      var context = emptyContextObject,
		        contextType = Component.contextType;
		      "object" === typeof contextType &&
		        null !== contextType &&
		        (context = readContext(contextType));
		      context = new Component(nextProps, context);
		      workInProgress.memoizedState =
		        null !== context.state && void 0 !== context.state
		          ? context.state
		          : null;
		      context.updater = classComponentUpdater;
		      workInProgress.stateNode = context;
		      context._reactInternals = workInProgress;
		      context = workInProgress.stateNode;
		      context.props = nextProps;
		      context.state = workInProgress.memoizedState;
		      context.refs = {};
		      initializeUpdateQueue(workInProgress);
		      contextType = Component.contextType;
		      context.context =
		        "object" === typeof contextType && null !== contextType
		          ? readContext(contextType)
		          : emptyContextObject;
		      context.state = workInProgress.memoizedState;
		      contextType = Component.getDerivedStateFromProps;
		      "function" === typeof contextType &&
		        (applyDerivedStateFromProps(
		          workInProgress,
		          Component,
		          contextType,
		          nextProps
		        ),
		        (context.state = workInProgress.memoizedState));
		      "function" === typeof Component.getDerivedStateFromProps ||
		        "function" === typeof context.getSnapshotBeforeUpdate ||
		        ("function" !== typeof context.UNSAFE_componentWillMount &&
		          "function" !== typeof context.componentWillMount) ||
		        ((contextType = context.state),
		        "function" === typeof context.componentWillMount &&
		          context.componentWillMount(),
		        "function" === typeof context.UNSAFE_componentWillMount &&
		          context.UNSAFE_componentWillMount(),
		        contextType !== context.state &&
		          classComponentUpdater.enqueueReplaceState(
		            context,
		            context.state,
		            null
		          ),
		        processUpdateQueue(workInProgress, nextProps, context, renderLanes),
		        suspendIfUpdateReadFromEntangledAsyncAction(),
		        (context.state = workInProgress.memoizedState));
		      "function" === typeof context.componentDidMount &&
		        (workInProgress.flags |= 4194308);
		      nextProps = true;
		    } else if (null === current) {
		      context = workInProgress.stateNode;
		      var unresolvedOldProps = workInProgress.memoizedProps,
		        oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
		      context.props = oldProps;
		      var oldContext = context.context,
		        contextType$jscomp$0 = Component.contextType;
		      contextType = emptyContextObject;
		      "object" === typeof contextType$jscomp$0 &&
		        null !== contextType$jscomp$0 &&
		        (contextType = readContext(contextType$jscomp$0));
		      var getDerivedStateFromProps = Component.getDerivedStateFromProps;
		      contextType$jscomp$0 =
		        "function" === typeof getDerivedStateFromProps ||
		        "function" === typeof context.getSnapshotBeforeUpdate;
		      unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;
		      contextType$jscomp$0 ||
		        ("function" !== typeof context.UNSAFE_componentWillReceiveProps &&
		          "function" !== typeof context.componentWillReceiveProps) ||
		        ((unresolvedOldProps || oldContext !== contextType) &&
		          callComponentWillReceiveProps(
		            workInProgress,
		            context,
		            nextProps,
		            contextType
		          ));
		      hasForceUpdate = false;
		      var oldState = workInProgress.memoizedState;
		      context.state = oldState;
		      processUpdateQueue(workInProgress, nextProps, context, renderLanes);
		      suspendIfUpdateReadFromEntangledAsyncAction();
		      oldContext = workInProgress.memoizedState;
		      unresolvedOldProps || oldState !== oldContext || hasForceUpdate
		        ? ("function" === typeof getDerivedStateFromProps &&
		            (applyDerivedStateFromProps(
		              workInProgress,
		              Component,
		              getDerivedStateFromProps,
		              nextProps
		            ),
		            (oldContext = workInProgress.memoizedState)),
		          (oldProps =
		            hasForceUpdate ||
		            checkShouldComponentUpdate(
		              workInProgress,
		              Component,
		              oldProps,
		              nextProps,
		              oldState,
		              oldContext,
		              contextType
		            ))
		            ? (contextType$jscomp$0 ||
		                ("function" !== typeof context.UNSAFE_componentWillMount &&
		                  "function" !== typeof context.componentWillMount) ||
		                ("function" === typeof context.componentWillMount &&
		                  context.componentWillMount(),
		                "function" === typeof context.UNSAFE_componentWillMount &&
		                  context.UNSAFE_componentWillMount()),
		              "function" === typeof context.componentDidMount &&
		                (workInProgress.flags |= 4194308))
		            : ("function" === typeof context.componentDidMount &&
		                (workInProgress.flags |= 4194308),
		              (workInProgress.memoizedProps = nextProps),
		              (workInProgress.memoizedState = oldContext)),
		          (context.props = nextProps),
		          (context.state = oldContext),
		          (context.context = contextType),
		          (nextProps = oldProps))
		        : ("function" === typeof context.componentDidMount &&
		            (workInProgress.flags |= 4194308),
		          (nextProps = false));
		    } else {
		      context = workInProgress.stateNode;
		      cloneUpdateQueue(current, workInProgress);
		      contextType = workInProgress.memoizedProps;
		      contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
		      context.props = contextType$jscomp$0;
		      getDerivedStateFromProps = workInProgress.pendingProps;
		      oldState = context.context;
		      oldContext = Component.contextType;
		      oldProps = emptyContextObject;
		      "object" === typeof oldContext &&
		        null !== oldContext &&
		        (oldProps = readContext(oldContext));
		      unresolvedOldProps = Component.getDerivedStateFromProps;
		      (oldContext =
		        "function" === typeof unresolvedOldProps ||
		        "function" === typeof context.getSnapshotBeforeUpdate) ||
		        ("function" !== typeof context.UNSAFE_componentWillReceiveProps &&
		          "function" !== typeof context.componentWillReceiveProps) ||
		        ((contextType !== getDerivedStateFromProps || oldState !== oldProps) &&
		          callComponentWillReceiveProps(
		            workInProgress,
		            context,
		            nextProps,
		            oldProps
		          ));
		      hasForceUpdate = false;
		      oldState = workInProgress.memoizedState;
		      context.state = oldState;
		      processUpdateQueue(workInProgress, nextProps, context, renderLanes);
		      suspendIfUpdateReadFromEntangledAsyncAction();
		      var newState = workInProgress.memoizedState;
		      contextType !== getDerivedStateFromProps ||
		      oldState !== newState ||
		      hasForceUpdate ||
		      (null !== current &&
		        null !== current.dependencies &&
		        checkIfContextChanged(current.dependencies))
		        ? ("function" === typeof unresolvedOldProps &&
		            (applyDerivedStateFromProps(
		              workInProgress,
		              Component,
		              unresolvedOldProps,
		              nextProps
		            ),
		            (newState = workInProgress.memoizedState)),
		          (contextType$jscomp$0 =
		            hasForceUpdate ||
		            checkShouldComponentUpdate(
		              workInProgress,
		              Component,
		              contextType$jscomp$0,
		              nextProps,
		              oldState,
		              newState,
		              oldProps
		            ) ||
		            (null !== current &&
		              null !== current.dependencies &&
		              checkIfContextChanged(current.dependencies)))
		            ? (oldContext ||
		                ("function" !== typeof context.UNSAFE_componentWillUpdate &&
		                  "function" !== typeof context.componentWillUpdate) ||
		                ("function" === typeof context.componentWillUpdate &&
		                  context.componentWillUpdate(nextProps, newState, oldProps),
		                "function" === typeof context.UNSAFE_componentWillUpdate &&
		                  context.UNSAFE_componentWillUpdate(
		                    nextProps,
		                    newState,
		                    oldProps
		                  )),
		              "function" === typeof context.componentDidUpdate &&
		                (workInProgress.flags |= 4),
		              "function" === typeof context.getSnapshotBeforeUpdate &&
		                (workInProgress.flags |= 1024))
		            : ("function" !== typeof context.componentDidUpdate ||
		                (contextType === current.memoizedProps &&
		                  oldState === current.memoizedState) ||
		                (workInProgress.flags |= 4),
		              "function" !== typeof context.getSnapshotBeforeUpdate ||
		                (contextType === current.memoizedProps &&
		                  oldState === current.memoizedState) ||
		                (workInProgress.flags |= 1024),
		              (workInProgress.memoizedProps = nextProps),
		              (workInProgress.memoizedState = newState)),
		          (context.props = nextProps),
		          (context.state = newState),
		          (context.context = oldProps),
		          (nextProps = contextType$jscomp$0))
		        : ("function" !== typeof context.componentDidUpdate ||
		            (contextType === current.memoizedProps &&
		              oldState === current.memoizedState) ||
		            (workInProgress.flags |= 4),
		          "function" !== typeof context.getSnapshotBeforeUpdate ||
		            (contextType === current.memoizedProps &&
		              oldState === current.memoizedState) ||
		            (workInProgress.flags |= 1024),
		          (nextProps = false));
		    }
		    context = nextProps;
		    markRef(current, workInProgress);
		    nextProps = 0 !== (workInProgress.flags & 128);
		    context || nextProps
		      ? ((context = workInProgress.stateNode),
		        (Component =
		          nextProps && "function" !== typeof Component.getDerivedStateFromError
		            ? null
		            : context.render()),
		        (workInProgress.flags |= 1),
		        null !== current && nextProps
		          ? ((workInProgress.child = reconcileChildFibers(
		              workInProgress,
		              current.child,
		              null,
		              renderLanes
		            )),
		            (workInProgress.child = reconcileChildFibers(
		              workInProgress,
		              null,
		              Component,
		              renderLanes
		            )))
		          : reconcileChildren(current, workInProgress, Component, renderLanes),
		        (workInProgress.memoizedState = context.state),
		        (current = workInProgress.child))
		      : (current = bailoutOnAlreadyFinishedWork(
		          current,
		          workInProgress,
		          renderLanes
		        ));
		    return current;
		  }
		  function mountHostRootWithoutHydrating(
		    current,
		    workInProgress,
		    nextChildren,
		    renderLanes
		  ) {
		    resetHydrationState();
		    workInProgress.flags |= 256;
		    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
		    return workInProgress.child;
		  }
		  function mountSuspenseOffscreenState(renderLanes) {
		    return { baseLanes: renderLanes, cachePool: getSuspendedCache() };
		  }
		  function getRemainingWorkInPrimaryTree(
		    current,
		    primaryTreeDidDefer,
		    renderLanes
		  ) {
		    current = null !== current ? current.childLanes & ~renderLanes : 0;
		    primaryTreeDidDefer && (current |= workInProgressDeferredLane);
		    return current;
		  }
		  function updateSuspenseComponent(current, workInProgress, renderLanes) {
		    var nextProps = workInProgress.pendingProps,
		      showFallback = false,
		      didSuspend = 0 !== (workInProgress.flags & 128),
		      JSCompiler_temp;
		    (JSCompiler_temp = didSuspend) ||
		      (JSCompiler_temp =
		        null !== current && null === current.memoizedState
		          ? false
		          : 0 !== (suspenseStackCursor.current & 2));
		    JSCompiler_temp && ((showFallback = true), (workInProgress.flags &= -129));
		    JSCompiler_temp = 0 !== (workInProgress.flags & 32);
		    workInProgress.flags &= -33;
		    if (null === current) {
		      if (isHydrating) {
		        showFallback
		          ? pushPrimaryTreeSuspenseHandler(workInProgress)
		          : reuseSuspenseHandlerOnStack();
		        if (isHydrating) {
		          var nextInstance = nextHydratableInstance,
		            JSCompiler_temp$jscomp$0;
		          if ((JSCompiler_temp$jscomp$0 = nextInstance))
		            (nextInstance = canHydrateSuspenseInstance(
		              nextInstance,
		              rootOrSingletonContext
		            )),
		              null !== nextInstance
		                ? ((workInProgress.memoizedState = {
		                    dehydrated: nextInstance,
		                    treeContext:
		                      null !== treeContextProvider
		                        ? { id: treeContextId, overflow: treeContextOverflow }
		                        : null,
		                    retryLane: 536870912
		                  }),
		                  (JSCompiler_temp$jscomp$0 = createFiber(18, null, null, 0)),
		                  (JSCompiler_temp$jscomp$0.stateNode = nextInstance),
		                  (JSCompiler_temp$jscomp$0.return = workInProgress),
		                  (workInProgress.child = JSCompiler_temp$jscomp$0),
		                  (hydrationParentFiber = workInProgress),
		                  (nextHydratableInstance = null),
		                  (JSCompiler_temp$jscomp$0 = true))
		                : (JSCompiler_temp$jscomp$0 = false);
		          JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress);
		        }
		        nextInstance = workInProgress.memoizedState;
		        if (
		          null !== nextInstance &&
		          ((nextInstance = nextInstance.dehydrated), null !== nextInstance)
		        )
		          return (
		            isSuspenseInstanceFallback(nextInstance)
		              ? (workInProgress.lanes = 16)
		              : (workInProgress.lanes = 536870912),
		            null
		          );
		        popSuspenseHandler(workInProgress);
		      }
		      nextInstance = nextProps.children;
		      nextProps = nextProps.fallback;
		      if (showFallback)
		        return (
		          reuseSuspenseHandlerOnStack(),
		          (showFallback = workInProgress.mode),
		          (nextInstance = mountWorkInProgressOffscreenFiber(
		            { mode: "hidden", children: nextInstance },
		            showFallback
		          )),
		          (nextProps = createFiberFromFragment(
		            nextProps,
		            showFallback,
		            renderLanes,
		            null
		          )),
		          (nextInstance.return = workInProgress),
		          (nextProps.return = workInProgress),
		          (nextInstance.sibling = nextProps),
		          (workInProgress.child = nextInstance),
		          (showFallback = workInProgress.child),
		          (showFallback.memoizedState =
		            mountSuspenseOffscreenState(renderLanes)),
		          (showFallback.childLanes = getRemainingWorkInPrimaryTree(
		            current,
		            JSCompiler_temp,
		            renderLanes
		          )),
		          (workInProgress.memoizedState = SUSPENDED_MARKER),
		          nextProps
		        );
		      pushPrimaryTreeSuspenseHandler(workInProgress);
		      return mountSuspensePrimaryChildren(workInProgress, nextInstance);
		    }
		    JSCompiler_temp$jscomp$0 = current.memoizedState;
		    if (
		      null !== JSCompiler_temp$jscomp$0 &&
		      ((nextInstance = JSCompiler_temp$jscomp$0.dehydrated),
		      null !== nextInstance)
		    ) {
		      if (didSuspend)
		        workInProgress.flags & 256
		          ? (pushPrimaryTreeSuspenseHandler(workInProgress),
		            (workInProgress.flags &= -257),
		            (workInProgress = retrySuspenseComponentWithoutHydrating(
		              current,
		              workInProgress,
		              renderLanes
		            )))
		          : null !== workInProgress.memoizedState
		            ? (reuseSuspenseHandlerOnStack(),
		              (workInProgress.child = current.child),
		              (workInProgress.flags |= 128),
		              (workInProgress = null))
		            : (reuseSuspenseHandlerOnStack(),
		              (showFallback = nextProps.fallback),
		              (nextInstance = workInProgress.mode),
		              (nextProps = mountWorkInProgressOffscreenFiber(
		                { mode: "visible", children: nextProps.children },
		                nextInstance
		              )),
		              (showFallback = createFiberFromFragment(
		                showFallback,
		                nextInstance,
		                renderLanes,
		                null
		              )),
		              (showFallback.flags |= 2),
		              (nextProps.return = workInProgress),
		              (showFallback.return = workInProgress),
		              (nextProps.sibling = showFallback),
		              (workInProgress.child = nextProps),
		              reconcileChildFibers(
		                workInProgress,
		                current.child,
		                null,
		                renderLanes
		              ),
		              (nextProps = workInProgress.child),
		              (nextProps.memoizedState =
		                mountSuspenseOffscreenState(renderLanes)),
		              (nextProps.childLanes = getRemainingWorkInPrimaryTree(
		                current,
		                JSCompiler_temp,
		                renderLanes
		              )),
		              (workInProgress.memoizedState = SUSPENDED_MARKER),
		              (workInProgress = showFallback));
		      else if (
		        (pushPrimaryTreeSuspenseHandler(workInProgress),
		        isSuspenseInstanceFallback(nextInstance))
		      )
		        (JSCompiler_temp =
		          getSuspenseInstanceFallbackErrorDetails(nextInstance).digest),
		          (nextProps = Error(formatProdErrorMessage(419))),
		          (nextProps.stack = ""),
		          (nextProps.digest = JSCompiler_temp),
		          queueHydrationError({ value: nextProps, source: null, stack: null }),
		          (workInProgress = retrySuspenseComponentWithoutHydrating(
		            current,
		            workInProgress,
		            renderLanes
		          ));
		      else if (
		        (didReceiveUpdate ||
		          propagateParentContextChanges(
		            current,
		            workInProgress,
		            renderLanes,
		            false
		          ),
		        (JSCompiler_temp = 0 !== (renderLanes & current.childLanes)),
		        didReceiveUpdate || JSCompiler_temp)
		      ) {
		        JSCompiler_temp = workInProgressRoot;
		        if (null !== JSCompiler_temp) {
		          nextProps = renderLanes & -renderLanes;
		          if (0 !== (nextProps & 42)) nextProps = 1;
		          else
		            switch (nextProps) {
		              case 2:
		                nextProps = 1;
		                break;
		              case 8:
		                nextProps = 4;
		                break;
		              case 32:
		                nextProps = 16;
		                break;
		              case 128:
		              case 256:
		              case 512:
		              case 1024:
		              case 2048:
		              case 4096:
		              case 8192:
		              case 16384:
		              case 32768:
		              case 65536:
		              case 131072:
		              case 262144:
		              case 524288:
		              case 1048576:
		              case 2097152:
		              case 4194304:
		              case 8388608:
		              case 16777216:
		              case 33554432:
		                nextProps = 64;
		                break;
		              case 268435456:
		                nextProps = 134217728;
		                break;
		              default:
		                nextProps = 0;
		            }
		          nextProps =
		            0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes))
		              ? 0
		              : nextProps;
		          if (
		            0 !== nextProps &&
		            nextProps !== JSCompiler_temp$jscomp$0.retryLane
		          )
		            throw (
		              ((JSCompiler_temp$jscomp$0.retryLane = nextProps),
		              enqueueConcurrentRenderForLane(current, nextProps),
		              scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps),
		              SelectiveHydrationException)
		            );
		        }
		        isSuspenseInstancePending(nextInstance) ||
		          renderDidSuspendDelayIfPossible();
		        workInProgress = retrySuspenseComponentWithoutHydrating(
		          current,
		          workInProgress,
		          renderLanes
		        );
		      } else
		        isSuspenseInstancePending(nextInstance)
		          ? ((workInProgress.flags |= 128),
		            (workInProgress.child = current.child),
		            (workInProgress = retryDehydratedSuspenseBoundary.bind(
		              null,
		              current
		            )),
		            registerSuspenseInstanceRetry(nextInstance, workInProgress),
		            (workInProgress = null))
		          : ((current = JSCompiler_temp$jscomp$0.treeContext),
		            supportsHydration &&
		              ((nextHydratableInstance =
		                getFirstHydratableChildWithinSuspenseInstance(nextInstance)),
		              (hydrationParentFiber = workInProgress),
		              (isHydrating = true),
		              (hydrationErrors = null),
		              (rootOrSingletonContext = false),
		              null !== current &&
		                ((idStack[idStackIndex++] = treeContextId),
		                (idStack[idStackIndex++] = treeContextOverflow),
		                (idStack[idStackIndex++] = treeContextProvider),
		                (treeContextId = current.id),
		                (treeContextOverflow = current.overflow),
		                (treeContextProvider = workInProgress))),
		            (workInProgress = mountSuspensePrimaryChildren(
		              workInProgress,
		              nextProps.children
		            )),
		            (workInProgress.flags |= 4096));
		      return workInProgress;
		    }
		    if (showFallback)
		      return (
		        reuseSuspenseHandlerOnStack(),
		        (showFallback = nextProps.fallback),
		        (nextInstance = workInProgress.mode),
		        (JSCompiler_temp$jscomp$0 = current.child),
		        (didSuspend = JSCompiler_temp$jscomp$0.sibling),
		        (nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {
		          mode: "hidden",
		          children: nextProps.children
		        })),
		        (nextProps.subtreeFlags =
		          JSCompiler_temp$jscomp$0.subtreeFlags & 31457280),
		        null !== didSuspend
		          ? (showFallback = createWorkInProgress(didSuspend, showFallback))
		          : ((showFallback = createFiberFromFragment(
		              showFallback,
		              nextInstance,
		              renderLanes,
		              null
		            )),
		            (showFallback.flags |= 2)),
		        (showFallback.return = workInProgress),
		        (nextProps.return = workInProgress),
		        (nextProps.sibling = showFallback),
		        (workInProgress.child = nextProps),
		        (nextProps = showFallback),
		        (showFallback = workInProgress.child),
		        (nextInstance = current.child.memoizedState),
		        null === nextInstance
		          ? (nextInstance = mountSuspenseOffscreenState(renderLanes))
		          : ((JSCompiler_temp$jscomp$0 = nextInstance.cachePool),
		            null !== JSCompiler_temp$jscomp$0
		              ? ((didSuspend = isPrimaryRenderer
		                  ? CacheContext._currentValue
		                  : CacheContext._currentValue2),
		                (JSCompiler_temp$jscomp$0 =
		                  JSCompiler_temp$jscomp$0.parent !== didSuspend
		                    ? { parent: didSuspend, pool: didSuspend }
		                    : JSCompiler_temp$jscomp$0))
		              : (JSCompiler_temp$jscomp$0 = getSuspendedCache()),
		            (nextInstance = {
		              baseLanes: nextInstance.baseLanes | renderLanes,
		              cachePool: JSCompiler_temp$jscomp$0
		            })),
		        (showFallback.memoizedState = nextInstance),
		        (showFallback.childLanes = getRemainingWorkInPrimaryTree(
		          current,
		          JSCompiler_temp,
		          renderLanes
		        )),
		        (workInProgress.memoizedState = SUSPENDED_MARKER),
		        nextProps
		      );
		    pushPrimaryTreeSuspenseHandler(workInProgress);
		    renderLanes = current.child;
		    current = renderLanes.sibling;
		    renderLanes = createWorkInProgress(renderLanes, {
		      mode: "visible",
		      children: nextProps.children
		    });
		    renderLanes.return = workInProgress;
		    renderLanes.sibling = null;
		    null !== current &&
		      ((JSCompiler_temp = workInProgress.deletions),
		      null === JSCompiler_temp
		        ? ((workInProgress.deletions = [current]), (workInProgress.flags |= 16))
		        : JSCompiler_temp.push(current));
		    workInProgress.child = renderLanes;
		    workInProgress.memoizedState = null;
		    return renderLanes;
		  }
		  function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
		    primaryChildren = mountWorkInProgressOffscreenFiber(
		      { mode: "visible", children: primaryChildren },
		      workInProgress.mode
		    );
		    primaryChildren.return = workInProgress;
		    return (workInProgress.child = primaryChildren);
		  }
		  function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
		    return createFiberFromOffscreen(offscreenProps, mode, 0, null);
		  }
		  function retrySuspenseComponentWithoutHydrating(
		    current,
		    workInProgress,
		    renderLanes
		  ) {
		    reconcileChildFibers(workInProgress, current.child, null, renderLanes);
		    current = mountSuspensePrimaryChildren(
		      workInProgress,
		      workInProgress.pendingProps.children
		    );
		    current.flags |= 2;
		    workInProgress.memoizedState = null;
		    return current;
		  }
		  function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {
		    fiber.lanes |= renderLanes;
		    var alternate = fiber.alternate;
		    null !== alternate && (alternate.lanes |= renderLanes);
		    scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);
		  }
		  function initSuspenseListRenderState(
		    workInProgress,
		    isBackwards,
		    tail,
		    lastContentRow,
		    tailMode
		  ) {
		    var renderState = workInProgress.memoizedState;
		    null === renderState
		      ? (workInProgress.memoizedState = {
		          isBackwards: isBackwards,
		          rendering: null,
		          renderingStartTime: 0,
		          last: lastContentRow,
		          tail: tail,
		          tailMode: tailMode
		        })
		      : ((renderState.isBackwards = isBackwards),
		        (renderState.rendering = null),
		        (renderState.renderingStartTime = 0),
		        (renderState.last = lastContentRow),
		        (renderState.tail = tail),
		        (renderState.tailMode = tailMode));
		  }
		  function updateSuspenseListComponent(current, workInProgress, renderLanes) {
		    var nextProps = workInProgress.pendingProps,
		      revealOrder = nextProps.revealOrder,
		      tailMode = nextProps.tail;
		    reconcileChildren(current, workInProgress, nextProps.children, renderLanes);
		    nextProps = suspenseStackCursor.current;
		    if (0 !== (nextProps & 2))
		      (nextProps = (nextProps & 1) | 2), (workInProgress.flags |= 128);
		    else {
		      if (null !== current && 0 !== (current.flags & 128))
		        a: for (current = workInProgress.child; null !== current; ) {
		          if (13 === current.tag)
		            null !== current.memoizedState &&
		              scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
		          else if (19 === current.tag)
		            scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
		          else if (null !== current.child) {
		            current.child.return = current;
		            current = current.child;
		            continue;
		          }
		          if (current === workInProgress) break a;
		          for (; null === current.sibling; ) {
		            if (null === current.return || current.return === workInProgress)
		              break a;
		            current = current.return;
		          }
		          current.sibling.return = current.return;
		          current = current.sibling;
		        }
		      nextProps &= 1;
		    }
		    push(suspenseStackCursor, nextProps);
		    switch (revealOrder) {
		      case "forwards":
		        renderLanes = workInProgress.child;
		        for (revealOrder = null; null !== renderLanes; )
		          (current = renderLanes.alternate),
		            null !== current &&
		              null === findFirstSuspended(current) &&
		              (revealOrder = renderLanes),
		            (renderLanes = renderLanes.sibling);
		        renderLanes = revealOrder;
		        null === renderLanes
		          ? ((revealOrder = workInProgress.child),
		            (workInProgress.child = null))
		          : ((revealOrder = renderLanes.sibling), (renderLanes.sibling = null));
		        initSuspenseListRenderState(
		          workInProgress,
		          false,
		          revealOrder,
		          renderLanes,
		          tailMode
		        );
		        break;
		      case "backwards":
		        renderLanes = null;
		        revealOrder = workInProgress.child;
		        for (workInProgress.child = null; null !== revealOrder; ) {
		          current = revealOrder.alternate;
		          if (null !== current && null === findFirstSuspended(current)) {
		            workInProgress.child = revealOrder;
		            break;
		          }
		          current = revealOrder.sibling;
		          revealOrder.sibling = renderLanes;
		          renderLanes = revealOrder;
		          revealOrder = current;
		        }
		        initSuspenseListRenderState(
		          workInProgress,
		          true,
		          renderLanes,
		          null,
		          tailMode
		        );
		        break;
		      case "together":
		        initSuspenseListRenderState(workInProgress, false, null, null, void 0);
		        break;
		      default:
		        workInProgress.memoizedState = null;
		    }
		    return workInProgress.child;
		  }
		  function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
		    null !== current && (workInProgress.dependencies = current.dependencies);
		    workInProgressRootSkippedLanes |= workInProgress.lanes;
		    if (0 === (renderLanes & workInProgress.childLanes))
		      if (null !== current) {
		        if (
		          (propagateParentContextChanges(
		            current,
		            workInProgress,
		            renderLanes,
		            false
		          ),
		          0 === (renderLanes & workInProgress.childLanes))
		        )
		          return null;
		      } else return null;
		    if (null !== current && workInProgress.child !== current.child)
		      throw Error(formatProdErrorMessage(153));
		    if (null !== workInProgress.child) {
		      current = workInProgress.child;
		      renderLanes = createWorkInProgress(current, current.pendingProps);
		      workInProgress.child = renderLanes;
		      for (renderLanes.return = workInProgress; null !== current.sibling; )
		        (current = current.sibling),
		          (renderLanes = renderLanes.sibling =
		            createWorkInProgress(current, current.pendingProps)),
		          (renderLanes.return = workInProgress);
		      renderLanes.sibling = null;
		    }
		    return workInProgress.child;
		  }
		  function checkScheduledUpdateOrContext(current, renderLanes) {
		    if (0 !== (current.lanes & renderLanes)) return true;
		    current = current.dependencies;
		    return null !== current && checkIfContextChanged(current) ? true : false;
		  }
		  function attemptEarlyBailoutIfNoScheduledUpdate(
		    current,
		    workInProgress,
		    renderLanes
		  ) {
		    switch (workInProgress.tag) {
		      case 3:
		        pushHostContainer(
		          workInProgress,
		          workInProgress.stateNode.containerInfo
		        );
		        pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
		        resetHydrationState();
		        break;
		      case 27:
		      case 5:
		        pushHostContext(workInProgress);
		        break;
		      case 4:
		        pushHostContainer(
		          workInProgress,
		          workInProgress.stateNode.containerInfo
		        );
		        break;
		      case 10:
		        pushProvider(
		          workInProgress,
		          workInProgress.type,
		          workInProgress.memoizedProps.value
		        );
		        break;
		      case 13:
		        var state = workInProgress.memoizedState;
		        if (null !== state) {
		          if (null !== state.dehydrated)
		            return (
		              pushPrimaryTreeSuspenseHandler(workInProgress),
		              (workInProgress.flags |= 128),
		              null
		            );
		          if (0 !== (renderLanes & workInProgress.child.childLanes))
		            return updateSuspenseComponent(
		              current,
		              workInProgress,
		              renderLanes
		            );
		          pushPrimaryTreeSuspenseHandler(workInProgress);
		          current = bailoutOnAlreadyFinishedWork(
		            current,
		            workInProgress,
		            renderLanes
		          );
		          return null !== current ? current.sibling : null;
		        }
		        pushPrimaryTreeSuspenseHandler(workInProgress);
		        break;
		      case 19:
		        var didSuspendBefore = 0 !== (current.flags & 128);
		        state = 0 !== (renderLanes & workInProgress.childLanes);
		        state ||
		          (propagateParentContextChanges(
		            current,
		            workInProgress,
		            renderLanes,
		            false
		          ),
		          (state = 0 !== (renderLanes & workInProgress.childLanes)));
		        if (didSuspendBefore) {
		          if (state)
		            return updateSuspenseListComponent(
		              current,
		              workInProgress,
		              renderLanes
		            );
		          workInProgress.flags |= 128;
		        }
		        didSuspendBefore = workInProgress.memoizedState;
		        null !== didSuspendBefore &&
		          ((didSuspendBefore.rendering = null),
		          (didSuspendBefore.tail = null),
		          (didSuspendBefore.lastEffect = null));
		        push(suspenseStackCursor, suspenseStackCursor.current);
		        if (state) break;
		        else return null;
		      case 22:
		      case 23:
		        return (
		          (workInProgress.lanes = 0),
		          updateOffscreenComponent(current, workInProgress, renderLanes)
		        );
		      case 24:
		        pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
		    }
		    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
		  }
		  function beginWork(current, workInProgress, renderLanes) {
		    if (null !== current)
		      if (current.memoizedProps !== workInProgress.pendingProps)
		        didReceiveUpdate = true;
		      else {
		        if (
		          !checkScheduledUpdateOrContext(current, renderLanes) &&
		          0 === (workInProgress.flags & 128)
		        )
		          return (
		            (didReceiveUpdate = false),
		            attemptEarlyBailoutIfNoScheduledUpdate(
		              current,
		              workInProgress,
		              renderLanes
		            )
		          );
		        didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
		      }
		    else
		      (didReceiveUpdate = false),
		        isHydrating &&
		          0 !== (workInProgress.flags & 1048576) &&
		          pushTreeId(workInProgress, treeForkCount, workInProgress.index);
		    workInProgress.lanes = 0;
		    switch (workInProgress.tag) {
		      case 16:
		        a: {
		          current = workInProgress.pendingProps;
		          var lazyComponent = workInProgress.elementType,
		            init = lazyComponent._init;
		          lazyComponent = init(lazyComponent._payload);
		          workInProgress.type = lazyComponent;
		          if ("function" === typeof lazyComponent)
		            shouldConstruct(lazyComponent)
		              ? ((current = resolveClassComponentProps(lazyComponent, current)),
		                (workInProgress.tag = 1),
		                (workInProgress = updateClassComponent(
		                  null,
		                  workInProgress,
		                  lazyComponent,
		                  current,
		                  renderLanes
		                )))
		              : ((workInProgress.tag = 0),
		                (workInProgress = updateFunctionComponent(
		                  null,
		                  workInProgress,
		                  lazyComponent,
		                  current,
		                  renderLanes
		                )));
		          else {
		            if (void 0 !== lazyComponent && null !== lazyComponent)
		              if (
		                ((init = lazyComponent.$$typeof),
		                init === REACT_FORWARD_REF_TYPE)
		              ) {
		                workInProgress.tag = 11;
		                workInProgress = updateForwardRef(
		                  null,
		                  workInProgress,
		                  lazyComponent,
		                  current,
		                  renderLanes
		                );
		                break a;
		              } else if (init === REACT_MEMO_TYPE) {
		                workInProgress.tag = 14;
		                workInProgress = updateMemoComponent(
		                  null,
		                  workInProgress,
		                  lazyComponent,
		                  current,
		                  renderLanes
		                );
		                break a;
		              }
		            workInProgress =
		              getComponentNameFromType(lazyComponent) || lazyComponent;
		            throw Error(formatProdErrorMessage(306, workInProgress, ""));
		          }
		        }
		        return workInProgress;
		      case 0:
		        return updateFunctionComponent(
		          current,
		          workInProgress,
		          workInProgress.type,
		          workInProgress.pendingProps,
		          renderLanes
		        );
		      case 1:
		        return (
		          (lazyComponent = workInProgress.type),
		          (init = resolveClassComponentProps(
		            lazyComponent,
		            workInProgress.pendingProps
		          )),
		          updateClassComponent(
		            current,
		            workInProgress,
		            lazyComponent,
		            init,
		            renderLanes
		          )
		        );
		      case 3:
		        a: {
		          pushHostContainer(
		            workInProgress,
		            workInProgress.stateNode.containerInfo
		          );
		          if (null === current) throw Error(formatProdErrorMessage(387));
		          var nextProps = workInProgress.pendingProps;
		          init = workInProgress.memoizedState;
		          lazyComponent = init.element;
		          cloneUpdateQueue(current, workInProgress);
		          processUpdateQueue(workInProgress, nextProps, null, renderLanes);
		          var nextState = workInProgress.memoizedState;
		          nextProps = nextState.cache;
		          pushProvider(workInProgress, CacheContext, nextProps);
		          nextProps !== init.cache &&
		            propagateContextChanges(
		              workInProgress,
		              [CacheContext],
		              renderLanes,
		              true
		            );
		          suspendIfUpdateReadFromEntangledAsyncAction();
		          nextProps = nextState.element;
		          if (supportsHydration && init.isDehydrated)
		            if (
		              ((init = {
		                element: nextProps,
		                isDehydrated: false,
		                cache: nextState.cache
		              }),
		              (workInProgress.updateQueue.baseState = init),
		              (workInProgress.memoizedState = init),
		              workInProgress.flags & 256)
		            ) {
		              workInProgress = mountHostRootWithoutHydrating(
		                current,
		                workInProgress,
		                nextProps,
		                renderLanes
		              );
		              break a;
		            } else if (nextProps !== lazyComponent) {
		              lazyComponent = createCapturedValueAtFiber(
		                Error(formatProdErrorMessage(424)),
		                workInProgress
		              );
		              queueHydrationError(lazyComponent);
		              workInProgress = mountHostRootWithoutHydrating(
		                current,
		                workInProgress,
		                nextProps,
		                renderLanes
		              );
		              break a;
		            } else
		              for (
		                supportsHydration &&
		                  ((nextHydratableInstance =
		                    getFirstHydratableChildWithinContainer(
		                      workInProgress.stateNode.containerInfo
		                    )),
		                  (hydrationParentFiber = workInProgress),
		                  (isHydrating = true),
		                  (hydrationErrors = null),
		                  (rootOrSingletonContext = true)),
		                  renderLanes = mountChildFibers(
		                    workInProgress,
		                    null,
		                    nextProps,
		                    renderLanes
		                  ),
		                  workInProgress.child = renderLanes;
		                renderLanes;

		              )
		                (renderLanes.flags = (renderLanes.flags & -3) | 4096),
		                  (renderLanes = renderLanes.sibling);
		          else {
		            resetHydrationState();
		            if (nextProps === lazyComponent) {
		              workInProgress = bailoutOnAlreadyFinishedWork(
		                current,
		                workInProgress,
		                renderLanes
		              );
		              break a;
		            }
		            reconcileChildren(current, workInProgress, nextProps, renderLanes);
		          }
		          workInProgress = workInProgress.child;
		        }
		        return workInProgress;
		      case 26:
		        if (supportsResources)
		          return (
		            markRef(current, workInProgress),
		            null === current
		              ? (renderLanes = getResource(
		                  workInProgress.type,
		                  null,
		                  workInProgress.pendingProps,
		                  null
		                ))
		                ? (workInProgress.memoizedState = renderLanes)
		                : isHydrating ||
		                  (workInProgress.stateNode = createHoistableInstance(
		                    workInProgress.type,
		                    workInProgress.pendingProps,
		                    rootInstanceStackCursor.current,
		                    workInProgress
		                  ))
		              : (workInProgress.memoizedState = getResource(
		                  workInProgress.type,
		                  current.memoizedProps,
		                  workInProgress.pendingProps,
		                  current.memoizedState
		                )),
		            null
		          );
		      case 27:
		        if (supportsSingletons)
		          return (
		            pushHostContext(workInProgress),
		            null === current &&
		              supportsSingletons &&
		              isHydrating &&
		              ((lazyComponent = workInProgress.stateNode =
		                resolveSingletonInstance(
		                  workInProgress.type,
		                  workInProgress.pendingProps,
		                  rootInstanceStackCursor.current,
		                  contextStackCursor.current,
		                  false
		                )),
		              (hydrationParentFiber = workInProgress),
		              (rootOrSingletonContext = true),
		              (nextHydratableInstance =
		                getFirstHydratableChild(lazyComponent))),
		            (lazyComponent = workInProgress.pendingProps.children),
		            null !== current || isHydrating
		              ? reconcileChildren(
		                  current,
		                  workInProgress,
		                  lazyComponent,
		                  renderLanes
		                )
		              : (workInProgress.child = reconcileChildFibers(
		                  workInProgress,
		                  null,
		                  lazyComponent,
		                  renderLanes
		                )),
		            markRef(current, workInProgress),
		            workInProgress.child
		          );
		      case 5:
		        if (null === current && isHydrating) {
		          validateHydratableInstance(
		            workInProgress.type,
		            workInProgress.pendingProps,
		            contextStackCursor.current
		          );
		          if ((init = lazyComponent = nextHydratableInstance))
		            (lazyComponent = canHydrateInstance(
		              lazyComponent,
		              workInProgress.type,
		              workInProgress.pendingProps,
		              rootOrSingletonContext
		            )),
		              null !== lazyComponent
		                ? ((workInProgress.stateNode = lazyComponent),
		                  (hydrationParentFiber = workInProgress),
		                  (nextHydratableInstance =
		                    getFirstHydratableChild(lazyComponent)),
		                  (rootOrSingletonContext = false),
		                  (init = true))
		                : (init = false);
		          init || throwOnHydrationMismatch(workInProgress);
		        }
		        pushHostContext(workInProgress);
		        init = workInProgress.type;
		        nextProps = workInProgress.pendingProps;
		        nextState = null !== current ? current.memoizedProps : null;
		        lazyComponent = nextProps.children;
		        shouldSetTextContent(init, nextProps)
		          ? (lazyComponent = null)
		          : null !== nextState &&
		            shouldSetTextContent(init, nextState) &&
		            (workInProgress.flags |= 32);
		        null !== workInProgress.memoizedState &&
		          ((init = renderWithHooks(
		            current,
		            workInProgress,
		            TransitionAwareHostComponent,
		            null,
		            null,
		            renderLanes
		          )),
		          isPrimaryRenderer
		            ? (HostTransitionContext._currentValue = init)
		            : (HostTransitionContext._currentValue2 = init));
		        markRef(current, workInProgress);
		        reconcileChildren(current, workInProgress, lazyComponent, renderLanes);
		        return workInProgress.child;
		      case 6:
		        if (null === current && isHydrating) {
		          validateHydratableTextInstance(
		            workInProgress.pendingProps,
		            contextStackCursor.current
		          );
		          if ((current = renderLanes = nextHydratableInstance))
		            (renderLanes = canHydrateTextInstance(
		              renderLanes,
		              workInProgress.pendingProps,
		              rootOrSingletonContext
		            )),
		              null !== renderLanes
		                ? ((workInProgress.stateNode = renderLanes),
		                  (hydrationParentFiber = workInProgress),
		                  (nextHydratableInstance = null),
		                  (current = true))
		                : (current = false);
		          current || throwOnHydrationMismatch(workInProgress);
		        }
		        return null;
		      case 13:
		        return updateSuspenseComponent(current, workInProgress, renderLanes);
		      case 4:
		        return (
		          pushHostContainer(
		            workInProgress,
		            workInProgress.stateNode.containerInfo
		          ),
		          (lazyComponent = workInProgress.pendingProps),
		          null === current
		            ? (workInProgress.child = reconcileChildFibers(
		                workInProgress,
		                null,
		                lazyComponent,
		                renderLanes
		              ))
		            : reconcileChildren(
		                current,
		                workInProgress,
		                lazyComponent,
		                renderLanes
		              ),
		          workInProgress.child
		        );
		      case 11:
		        return updateForwardRef(
		          current,
		          workInProgress,
		          workInProgress.type,
		          workInProgress.pendingProps,
		          renderLanes
		        );
		      case 7:
		        return (
		          reconcileChildren(
		            current,
		            workInProgress,
		            workInProgress.pendingProps,
		            renderLanes
		          ),
		          workInProgress.child
		        );
		      case 8:
		        return (
		          reconcileChildren(
		            current,
		            workInProgress,
		            workInProgress.pendingProps.children,
		            renderLanes
		          ),
		          workInProgress.child
		        );
		      case 12:
		        return (
		          reconcileChildren(
		            current,
		            workInProgress,
		            workInProgress.pendingProps.children,
		            renderLanes
		          ),
		          workInProgress.child
		        );
		      case 10:
		        return (
		          (lazyComponent = workInProgress.pendingProps),
		          pushProvider(
		            workInProgress,
		            workInProgress.type,
		            lazyComponent.value
		          ),
		          reconcileChildren(
		            current,
		            workInProgress,
		            lazyComponent.children,
		            renderLanes
		          ),
		          workInProgress.child
		        );
		      case 9:
		        return (
		          (init = workInProgress.type._context),
		          (lazyComponent = workInProgress.pendingProps.children),
		          prepareToReadContext(workInProgress),
		          (init = readContext(init)),
		          (lazyComponent = lazyComponent(init)),
		          (workInProgress.flags |= 1),
		          reconcileChildren(
		            current,
		            workInProgress,
		            lazyComponent,
		            renderLanes
		          ),
		          workInProgress.child
		        );
		      case 14:
		        return updateMemoComponent(
		          current,
		          workInProgress,
		          workInProgress.type,
		          workInProgress.pendingProps,
		          renderLanes
		        );
		      case 15:
		        return updateSimpleMemoComponent(
		          current,
		          workInProgress,
		          workInProgress.type,
		          workInProgress.pendingProps,
		          renderLanes
		        );
		      case 19:
		        return updateSuspenseListComponent(
		          current,
		          workInProgress,
		          renderLanes
		        );
		      case 22:
		        return updateOffscreenComponent(current, workInProgress, renderLanes);
		      case 24:
		        return (
		          prepareToReadContext(workInProgress),
		          (lazyComponent = readContext(CacheContext)),
		          null === current
		            ? ((init = peekCacheFromPool()),
		              null === init &&
		                ((init = workInProgressRoot),
		                (nextProps = createCache()),
		                (init.pooledCache = nextProps),
		                nextProps.refCount++,
		                null !== nextProps && (init.pooledCacheLanes |= renderLanes),
		                (init = nextProps)),
		              (workInProgress.memoizedState = {
		                parent: lazyComponent,
		                cache: init
		              }),
		              initializeUpdateQueue(workInProgress),
		              pushProvider(workInProgress, CacheContext, init))
		            : (0 !== (current.lanes & renderLanes) &&
		                (cloneUpdateQueue(current, workInProgress),
		                processUpdateQueue(workInProgress, null, null, renderLanes),
		                suspendIfUpdateReadFromEntangledAsyncAction()),
		              (init = current.memoizedState),
		              (nextProps = workInProgress.memoizedState),
		              init.parent !== lazyComponent
		                ? ((init = { parent: lazyComponent, cache: lazyComponent }),
		                  (workInProgress.memoizedState = init),
		                  0 === workInProgress.lanes &&
		                    (workInProgress.memoizedState =
		                      workInProgress.updateQueue.baseState =
		                        init),
		                  pushProvider(workInProgress, CacheContext, lazyComponent))
		                : ((lazyComponent = nextProps.cache),
		                  pushProvider(workInProgress, CacheContext, lazyComponent),
		                  lazyComponent !== init.cache &&
		                    propagateContextChanges(
		                      workInProgress,
		                      [CacheContext],
		                      renderLanes,
		                      true
		                    ))),
		          reconcileChildren(
		            current,
		            workInProgress,
		            workInProgress.pendingProps.children,
		            renderLanes
		          ),
		          workInProgress.child
		        );
		      case 29:
		        throw workInProgress.pendingProps;
		    }
		    throw Error(formatProdErrorMessage(156, workInProgress.tag));
		  }
		  function pushProvider(providerFiber, context, nextValue) {
		    isPrimaryRenderer
		      ? (push(valueCursor, context._currentValue),
		        (context._currentValue = nextValue))
		      : (push(valueCursor, context._currentValue2),
		        (context._currentValue2 = nextValue));
		  }
		  function popProvider(context) {
		    var currentValue = valueCursor.current;
		    isPrimaryRenderer
		      ? (context._currentValue = currentValue)
		      : (context._currentValue2 = currentValue);
		    pop(valueCursor);
		  }
		  function scheduleContextWorkOnParentPath(
		    parent,
		    renderLanes,
		    propagationRoot
		  ) {
		    for (; null !== parent; ) {
		      var alternate = parent.alternate;
		      (parent.childLanes & renderLanes) !== renderLanes
		        ? ((parent.childLanes |= renderLanes),
		          null !== alternate && (alternate.childLanes |= renderLanes))
		        : null !== alternate &&
		          (alternate.childLanes & renderLanes) !== renderLanes &&
		          (alternate.childLanes |= renderLanes);
		      if (parent === propagationRoot) break;
		      parent = parent.return;
		    }
		  }
		  function propagateContextChanges(
		    workInProgress,
		    contexts,
		    renderLanes,
		    forcePropagateEntireTree
		  ) {
		    var fiber = workInProgress.child;
		    null !== fiber && (fiber.return = workInProgress);
		    for (; null !== fiber; ) {
		      var list = fiber.dependencies;
		      if (null !== list) {
		        var nextFiber = fiber.child;
		        list = list.firstContext;
		        a: for (; null !== list; ) {
		          var dependency = list;
		          list = fiber;
		          for (var i = 0; i < contexts.length; i++)
		            if (dependency.context === contexts[i]) {
		              list.lanes |= renderLanes;
		              dependency = list.alternate;
		              null !== dependency && (dependency.lanes |= renderLanes);
		              scheduleContextWorkOnParentPath(
		                list.return,
		                renderLanes,
		                workInProgress
		              );
		              forcePropagateEntireTree || (nextFiber = null);
		              break a;
		            }
		          list = dependency.next;
		        }
		      } else if (18 === fiber.tag) {
		        nextFiber = fiber.return;
		        if (null === nextFiber) throw Error(formatProdErrorMessage(341));
		        nextFiber.lanes |= renderLanes;
		        list = nextFiber.alternate;
		        null !== list && (list.lanes |= renderLanes);
		        scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);
		        nextFiber = null;
		      } else nextFiber = fiber.child;
		      if (null !== nextFiber) nextFiber.return = fiber;
		      else
		        for (nextFiber = fiber; null !== nextFiber; ) {
		          if (nextFiber === workInProgress) {
		            nextFiber = null;
		            break;
		          }
		          fiber = nextFiber.sibling;
		          if (null !== fiber) {
		            fiber.return = nextFiber.return;
		            nextFiber = fiber;
		            break;
		          }
		          nextFiber = nextFiber.return;
		        }
		      fiber = nextFiber;
		    }
		  }
		  function propagateParentContextChanges(
		    current,
		    workInProgress,
		    renderLanes,
		    forcePropagateEntireTree
		  ) {
		    current = null;
		    for (
		      var parent = workInProgress, isInsidePropagationBailout = false;
		      null !== parent;

		    ) {
		      if (!isInsidePropagationBailout)
		        if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
		        else if (0 !== (parent.flags & 262144)) break;
		      if (10 === parent.tag) {
		        var currentParent = parent.alternate;
		        if (null === currentParent) throw Error(formatProdErrorMessage(387));
		        currentParent = currentParent.memoizedProps;
		        if (null !== currentParent) {
		          var context = parent.type;
		          objectIs(parent.pendingProps.value, currentParent.value) ||
		            (null !== current ? current.push(context) : (current = [context]));
		        }
		      } else if (parent === hostTransitionProviderCursor.current) {
		        currentParent = parent.alternate;
		        if (null === currentParent) throw Error(formatProdErrorMessage(387));
		        currentParent.memoizedState.memoizedState !==
		          parent.memoizedState.memoizedState &&
		          (null !== current
		            ? current.push(HostTransitionContext)
		            : (current = [HostTransitionContext]));
		      }
		      parent = parent.return;
		    }
		    null !== current &&
		      propagateContextChanges(
		        workInProgress,
		        current,
		        renderLanes,
		        forcePropagateEntireTree
		      );
		    workInProgress.flags |= 262144;
		  }
		  function checkIfContextChanged(currentDependencies) {
		    for (
		      currentDependencies = currentDependencies.firstContext;
		      null !== currentDependencies;

		    ) {
		      var context = currentDependencies.context;
		      if (
		        !objectIs(
		          isPrimaryRenderer ? context._currentValue : context._currentValue2,
		          currentDependencies.memoizedValue
		        )
		      )
		        return true;
		      currentDependencies = currentDependencies.next;
		    }
		    return false;
		  }
		  function prepareToReadContext(workInProgress) {
		    currentlyRenderingFiber = workInProgress;
		    lastContextDependency = null;
		    workInProgress = workInProgress.dependencies;
		    null !== workInProgress && (workInProgress.firstContext = null);
		  }
		  function readContext(context) {
		    return readContextForConsumer(currentlyRenderingFiber, context);
		  }
		  function readContextDuringReconciliation(consumer, context) {
		    null === currentlyRenderingFiber && prepareToReadContext(consumer);
		    return readContextForConsumer(consumer, context);
		  }
		  function readContextForConsumer(consumer, context) {
		    var value = isPrimaryRenderer
		      ? context._currentValue
		      : context._currentValue2;
		    context = { context: context, memoizedValue: value, next: null };
		    if (null === lastContextDependency) {
		      if (null === consumer) throw Error(formatProdErrorMessage(308));
		      lastContextDependency = context;
		      consumer.dependencies = { lanes: 0, firstContext: context };
		      consumer.flags |= 524288;
		    } else lastContextDependency = lastContextDependency.next = context;
		    return value;
		  }
		  function createCache() {
		    return {
		      controller: new AbortControllerLocal(),
		      data: new Map(),
		      refCount: 0
		    };
		  }
		  function releaseCache(cache) {
		    cache.refCount--;
		    0 === cache.refCount &&
		      scheduleCallback$1(NormalPriority, function () {
		        cache.controller.abort();
		      });
		  }
		  function peekCacheFromPool() {
		    var cacheResumedFromPreviousRender = resumedCache.current;
		    return null !== cacheResumedFromPreviousRender
		      ? cacheResumedFromPreviousRender
		      : workInProgressRoot.pooledCache;
		  }
		  function pushTransition(offscreenWorkInProgress, prevCachePool) {
		    null === prevCachePool
		      ? push(resumedCache, resumedCache.current)
		      : push(resumedCache, prevCachePool.pool);
		  }
		  function getSuspendedCache() {
		    var cacheFromPool = peekCacheFromPool();
		    return null === cacheFromPool
		      ? null
		      : {
		          parent: isPrimaryRenderer
		            ? CacheContext._currentValue
		            : CacheContext._currentValue2,
		          pool: cacheFromPool
		        };
		  }
		  function markUpdate(workInProgress) {
		    workInProgress.flags |= 4;
		  }
		  function doesRequireClone(current, completedWork) {
		    if (null !== current && current.child === completedWork.child) return false;
		    if (0 !== (completedWork.flags & 16)) return true;
		    for (current = completedWork.child; null !== current; ) {
		      if (0 !== (current.flags & 13878) || 0 !== (current.subtreeFlags & 13878))
		        return true;
		      current = current.sibling;
		    }
		    return false;
		  }
		  function appendAllChildren(
		    parent,
		    workInProgress,
		    needsVisibilityToggle,
		    isHidden
		  ) {
		    if (supportsMutation)
		      for (
		        needsVisibilityToggle = workInProgress.child;
		        null !== needsVisibilityToggle;

		      ) {
		        if (5 === needsVisibilityToggle.tag || 6 === needsVisibilityToggle.tag)
		          appendInitialChild(parent, needsVisibilityToggle.stateNode);
		        else if (
		          !(
		            4 === needsVisibilityToggle.tag ||
		            (supportsSingletons && 27 === needsVisibilityToggle.tag)
		          ) &&
		          null !== needsVisibilityToggle.child
		        ) {
		          needsVisibilityToggle.child.return = needsVisibilityToggle;
		          needsVisibilityToggle = needsVisibilityToggle.child;
		          continue;
		        }
		        if (needsVisibilityToggle === workInProgress) break;
		        for (; null === needsVisibilityToggle.sibling; ) {
		          if (
		            null === needsVisibilityToggle.return ||
		            needsVisibilityToggle.return === workInProgress
		          )
		            return;
		          needsVisibilityToggle = needsVisibilityToggle.return;
		        }
		        needsVisibilityToggle.sibling.return = needsVisibilityToggle.return;
		        needsVisibilityToggle = needsVisibilityToggle.sibling;
		      }
		    else if (supportsPersistence)
		      for (var node$91 = workInProgress.child; null !== node$91; ) {
		        if (5 === node$91.tag) {
		          var instance = node$91.stateNode;
		          needsVisibilityToggle &&
		            isHidden &&
		            (instance = cloneHiddenInstance(
		              instance,
		              node$91.type,
		              node$91.memoizedProps
		            ));
		          appendInitialChild(parent, instance);
		        } else if (6 === node$91.tag)
		          (instance = node$91.stateNode),
		            needsVisibilityToggle &&
		              isHidden &&
		              (instance = cloneHiddenTextInstance(
		                instance,
		                node$91.memoizedProps
		              )),
		            appendInitialChild(parent, instance);
		        else if (4 !== node$91.tag)
		          if (22 === node$91.tag && null !== node$91.memoizedState)
		            (instance = node$91.child),
		              null !== instance && (instance.return = node$91),
		              appendAllChildren(parent, node$91, true, true);
		          else if (null !== node$91.child) {
		            node$91.child.return = node$91;
		            node$91 = node$91.child;
		            continue;
		          }
		        if (node$91 === workInProgress) break;
		        for (; null === node$91.sibling; ) {
		          if (null === node$91.return || node$91.return === workInProgress)
		            return;
		          node$91 = node$91.return;
		        }
		        node$91.sibling.return = node$91.return;
		        node$91 = node$91.sibling;
		      }
		  }
		  function appendAllChildrenToContainer(
		    containerChildSet,
		    workInProgress,
		    needsVisibilityToggle,
		    isHidden
		  ) {
		    if (supportsPersistence)
		      for (var node = workInProgress.child; null !== node; ) {
		        if (5 === node.tag) {
		          var instance = node.stateNode;
		          needsVisibilityToggle &&
		            isHidden &&
		            (instance = cloneHiddenInstance(
		              instance,
		              node.type,
		              node.memoizedProps
		            ));
		          appendChildToContainerChildSet(containerChildSet, instance);
		        } else if (6 === node.tag)
		          (instance = node.stateNode),
		            needsVisibilityToggle &&
		              isHidden &&
		              (instance = cloneHiddenTextInstance(
		                instance,
		                node.memoizedProps
		              )),
		            appendChildToContainerChildSet(containerChildSet, instance);
		        else if (4 !== node.tag)
		          if (22 === node.tag && null !== node.memoizedState)
		            (instance = node.child),
		              null !== instance && (instance.return = node),
		              appendAllChildrenToContainer(
		                containerChildSet,
		                node,
		                !(
		                  null !== node.memoizedProps &&
		                  "manual" === node.memoizedProps.mode
		                ),
		                true
		              );
		          else if (null !== node.child) {
		            node.child.return = node;
		            node = node.child;
		            continue;
		          }
		        if (node === workInProgress) break;
		        for (; null === node.sibling; ) {
		          if (null === node.return || node.return === workInProgress) return;
		          node = node.return;
		        }
		        node.sibling.return = node.return;
		        node = node.sibling;
		      }
		  }
		  function updateHostContainer(current, workInProgress) {
		    if (supportsPersistence && doesRequireClone(current, workInProgress)) {
		      current = workInProgress.stateNode;
		      var container = current.containerInfo,
		        newChildSet = createContainerChildSet();
		      appendAllChildrenToContainer(newChildSet, workInProgress, false, false);
		      current.pendingChildren = newChildSet;
		      markUpdate(workInProgress);
		      finalizeContainerChildren(container, newChildSet);
		    }
		  }
		  function updateHostComponent(current, workInProgress, type, newProps) {
		    if (supportsMutation)
		      current.memoizedProps !== newProps && markUpdate(workInProgress);
		    else if (supportsPersistence) {
		      var currentInstance = current.stateNode,
		        oldProps$94 = current.memoizedProps;
		      if (
		        (current = doesRequireClone(current, workInProgress)) ||
		        oldProps$94 !== newProps
		      ) {
		        var currentHostContext = contextStackCursor.current;
		        oldProps$94 = cloneInstance(
		          currentInstance,
		          type,
		          oldProps$94,
		          newProps,
		          !current,
		          null
		        );
		        oldProps$94 === currentInstance
		          ? (workInProgress.stateNode = currentInstance)
		          : (finalizeInitialChildren(
		              oldProps$94,
		              type,
		              newProps,
		              currentHostContext
		            ) && markUpdate(workInProgress),
		            (workInProgress.stateNode = oldProps$94),
		            current
		              ? appendAllChildren(oldProps$94, workInProgress, false, false)
		              : markUpdate(workInProgress));
		      } else workInProgress.stateNode = currentInstance;
		    }
		  }
		  function preloadInstanceAndSuspendIfNeeded(workInProgress, type, props) {
		    if (maySuspendCommit(type, props)) {
		      if (((workInProgress.flags |= 16777216), !preloadInstance(type, props)))
		        if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;
		        else
		          throw (
		            ((suspendedThenable = noopSuspenseyCommitThenable),
		            SuspenseyCommitException)
		          );
		    } else workInProgress.flags &= -16777217;
		  }
		  function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {
		    if (mayResourceSuspendCommit(resource)) {
		      if (((workInProgress.flags |= 16777216), !preloadResource(resource)))
		        if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;
		        else
		          throw (
		            ((suspendedThenable = noopSuspenseyCommitThenable),
		            SuspenseyCommitException)
		          );
		    } else workInProgress.flags &= -16777217;
		  }
		  function scheduleRetryEffect(workInProgress, retryQueue) {
		    null !== retryQueue && (workInProgress.flags |= 4);
		    workInProgress.flags & 16384 &&
		      ((retryQueue =
		        22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),
		      (workInProgress.lanes |= retryQueue),
		      (workInProgressSuspendedRetryLanes |= retryQueue));
		  }
		  function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
		    if (!isHydrating)
		      switch (renderState.tailMode) {
		        case "hidden":
		          hasRenderedATailFallback = renderState.tail;
		          for (var lastTailNode = null; null !== hasRenderedATailFallback; )
		            null !== hasRenderedATailFallback.alternate &&
		              (lastTailNode = hasRenderedATailFallback),
		              (hasRenderedATailFallback = hasRenderedATailFallback.sibling);
		          null === lastTailNode
		            ? (renderState.tail = null)
		            : (lastTailNode.sibling = null);
		          break;
		        case "collapsed":
		          lastTailNode = renderState.tail;
		          for (var lastTailNode$96 = null; null !== lastTailNode; )
		            null !== lastTailNode.alternate && (lastTailNode$96 = lastTailNode),
		              (lastTailNode = lastTailNode.sibling);
		          null === lastTailNode$96
		            ? hasRenderedATailFallback || null === renderState.tail
		              ? (renderState.tail = null)
		              : (renderState.tail.sibling = null)
		            : (lastTailNode$96.sibling = null);
		      }
		  }
		  function bubbleProperties(completedWork) {
		    var didBailout =
		        null !== completedWork.alternate &&
		        completedWork.alternate.child === completedWork.child,
		      newChildLanes = 0,
		      subtreeFlags = 0;
		    if (didBailout)
		      for (var child$97 = completedWork.child; null !== child$97; )
		        (newChildLanes |= child$97.lanes | child$97.childLanes),
		          (subtreeFlags |= child$97.subtreeFlags & 31457280),
		          (subtreeFlags |= child$97.flags & 31457280),
		          (child$97.return = completedWork),
		          (child$97 = child$97.sibling);
		    else
		      for (child$97 = completedWork.child; null !== child$97; )
		        (newChildLanes |= child$97.lanes | child$97.childLanes),
		          (subtreeFlags |= child$97.subtreeFlags),
		          (subtreeFlags |= child$97.flags),
		          (child$97.return = completedWork),
		          (child$97 = child$97.sibling);
		    completedWork.subtreeFlags |= subtreeFlags;
		    completedWork.childLanes = newChildLanes;
		    return didBailout;
		  }
		  function completeWork(current, workInProgress, renderLanes) {
		    var newProps = workInProgress.pendingProps;
		    popTreeContext(workInProgress);
		    switch (workInProgress.tag) {
		      case 16:
		      case 15:
		      case 0:
		      case 11:
		      case 7:
		      case 8:
		      case 12:
		      case 9:
		      case 14:
		        return bubbleProperties(workInProgress), null;
		      case 1:
		        return bubbleProperties(workInProgress), null;
		      case 3:
		        renderLanes = workInProgress.stateNode;
		        newProps = null;
		        null !== current && (newProps = current.memoizedState.cache);
		        workInProgress.memoizedState.cache !== newProps &&
		          (workInProgress.flags |= 2048);
		        popProvider(CacheContext);
		        popHostContainer();
		        renderLanes.pendingContext &&
		          ((renderLanes.context = renderLanes.pendingContext),
		          (renderLanes.pendingContext = null));
		        if (null === current || null === current.child)
		          popHydrationState(workInProgress)
		            ? markUpdate(workInProgress)
		            : null === current ||
		              (current.memoizedState.isDehydrated &&
		                0 === (workInProgress.flags & 256)) ||
		              ((workInProgress.flags |= 1024),
		              null !== hydrationErrors &&
		                (queueRecoverableErrors(hydrationErrors),
		                (hydrationErrors = null)));
		        updateHostContainer(current, workInProgress);
		        bubbleProperties(workInProgress);
		        return null;
		      case 26:
		        if (supportsResources) {
		          renderLanes = workInProgress.type;
		          var nextResource = workInProgress.memoizedState;
		          null === current
		            ? (markUpdate(workInProgress),
		              null !== nextResource
		                ? (bubbleProperties(workInProgress),
		                  preloadResourceAndSuspendIfNeeded(
		                    workInProgress,
		                    nextResource
		                  ))
		                : (bubbleProperties(workInProgress),
		                  preloadInstanceAndSuspendIfNeeded(
		                    workInProgress,
		                    renderLanes,
		                    newProps
		                  )))
		            : nextResource
		              ? nextResource !== current.memoizedState
		                ? (markUpdate(workInProgress),
		                  bubbleProperties(workInProgress),
		                  preloadResourceAndSuspendIfNeeded(
		                    workInProgress,
		                    nextResource
		                  ))
		                : (bubbleProperties(workInProgress),
		                  (workInProgress.flags &= -16777217))
		              : (supportsMutation
		                  ? current.memoizedProps !== newProps &&
		                    markUpdate(workInProgress)
		                  : updateHostComponent(
		                      current,
		                      workInProgress,
		                      renderLanes,
		                      newProps
		                    ),
		                bubbleProperties(workInProgress),
		                preloadInstanceAndSuspendIfNeeded(
		                  workInProgress,
		                  renderLanes,
		                  newProps
		                ));
		          return null;
		        }
		      case 27:
		        if (supportsSingletons) {
		          popHostContext(workInProgress);
		          renderLanes = rootInstanceStackCursor.current;
		          nextResource = workInProgress.type;
		          if (null !== current && null != workInProgress.stateNode)
		            supportsMutation
		              ? current.memoizedProps !== newProps && markUpdate(workInProgress)
		              : updateHostComponent(
		                  current,
		                  workInProgress,
		                  nextResource,
		                  newProps
		                );
		          else {
		            if (!newProps) {
		              if (null === workInProgress.stateNode)
		                throw Error(formatProdErrorMessage(166));
		              bubbleProperties(workInProgress);
		              return null;
		            }
		            current = contextStackCursor.current;
		            popHydrationState(workInProgress)
		              ? prepareToHydrateHostInstance(workInProgress, current)
		              : ((current = resolveSingletonInstance(
		                  nextResource,
		                  newProps,
		                  renderLanes,
		                  current,
		                  true
		                )),
		                (workInProgress.stateNode = current),
		                markUpdate(workInProgress));
		          }
		          bubbleProperties(workInProgress);
		          return null;
		        }
		      case 5:
		        popHostContext(workInProgress);
		        renderLanes = workInProgress.type;
		        if (null !== current && null != workInProgress.stateNode)
		          updateHostComponent(current, workInProgress, renderLanes, newProps);
		        else {
		          if (!newProps) {
		            if (null === workInProgress.stateNode)
		              throw Error(formatProdErrorMessage(166));
		            bubbleProperties(workInProgress);
		            return null;
		          }
		          current = contextStackCursor.current;
		          popHydrationState(workInProgress)
		            ? prepareToHydrateHostInstance(workInProgress, current)
		            : ((nextResource = createInstance(
		                renderLanes,
		                newProps,
		                rootInstanceStackCursor.current,
		                current,
		                workInProgress
		              )),
		              appendAllChildren(nextResource, workInProgress, false, false),
		              (workInProgress.stateNode = nextResource),
		              finalizeInitialChildren(
		                nextResource,
		                renderLanes,
		                newProps,
		                current
		              ) && markUpdate(workInProgress));
		        }
		        bubbleProperties(workInProgress);
		        preloadInstanceAndSuspendIfNeeded(
		          workInProgress,
		          workInProgress.type,
		          workInProgress.pendingProps
		        );
		        return null;
		      case 6:
		        if (current && null != workInProgress.stateNode)
		          (renderLanes = current.memoizedProps),
		            supportsMutation
		              ? renderLanes !== newProps && markUpdate(workInProgress)
		              : supportsPersistence &&
		                (renderLanes !== newProps
		                  ? ((workInProgress.stateNode = createTextInstance(
		                      newProps,
		                      rootInstanceStackCursor.current,
		                      contextStackCursor.current,
		                      workInProgress
		                    )),
		                    markUpdate(workInProgress))
		                  : (workInProgress.stateNode = current.stateNode));
		        else {
		          if ("string" !== typeof newProps && null === workInProgress.stateNode)
		            throw Error(formatProdErrorMessage(166));
		          current = rootInstanceStackCursor.current;
		          renderLanes = contextStackCursor.current;
		          if (popHydrationState(workInProgress)) {
		            if (!supportsHydration) throw Error(formatProdErrorMessage(176));
		            current = workInProgress.stateNode;
		            renderLanes = workInProgress.memoizedProps;
		            newProps = null;
		            nextResource = hydrationParentFiber;
		            if (null !== nextResource)
		              switch (nextResource.tag) {
		                case 27:
		                case 5:
		                  newProps = nextResource.memoizedProps;
		              }
		            hydrateTextInstance(
		              current,
		              renderLanes,
		              workInProgress,
		              newProps
		            ) || throwOnHydrationMismatch(workInProgress);
		          } else
		            workInProgress.stateNode = createTextInstance(
		              newProps,
		              current,
		              renderLanes,
		              workInProgress
		            );
		        }
		        bubbleProperties(workInProgress);
		        return null;
		      case 13:
		        newProps = workInProgress.memoizedState;
		        if (
		          null === current ||
		          (null !== current.memoizedState &&
		            null !== current.memoizedState.dehydrated)
		        ) {
		          nextResource = popHydrationState(workInProgress);
		          if (null !== newProps && null !== newProps.dehydrated) {
		            if (null === current) {
		              if (!nextResource) throw Error(formatProdErrorMessage(318));
		              if (!supportsHydration) throw Error(formatProdErrorMessage(344));
		              nextResource = workInProgress.memoizedState;
		              nextResource =
		                null !== nextResource ? nextResource.dehydrated : null;
		              if (!nextResource) throw Error(formatProdErrorMessage(317));
		              hydrateSuspenseInstance(nextResource, workInProgress);
		            } else
		              resetHydrationState(),
		                0 === (workInProgress.flags & 128) &&
		                  (workInProgress.memoizedState = null),
		                (workInProgress.flags |= 4);
		            bubbleProperties(workInProgress);
		            nextResource = false;
		          } else
		            null !== hydrationErrors &&
		              (queueRecoverableErrors(hydrationErrors),
		              (hydrationErrors = null)),
		              (nextResource = true);
		          if (!nextResource) {
		            if (workInProgress.flags & 256)
		              return popSuspenseHandler(workInProgress), workInProgress;
		            popSuspenseHandler(workInProgress);
		            return null;
		          }
		        }
		        popSuspenseHandler(workInProgress);
		        if (0 !== (workInProgress.flags & 128))
		          return (workInProgress.lanes = renderLanes), workInProgress;
		        renderLanes = null !== newProps;
		        current = null !== current && null !== current.memoizedState;
		        if (renderLanes) {
		          newProps = workInProgress.child;
		          nextResource = null;
		          null !== newProps.alternate &&
		            null !== newProps.alternate.memoizedState &&
		            null !== newProps.alternate.memoizedState.cachePool &&
		            (nextResource = newProps.alternate.memoizedState.cachePool.pool);
		          var cache$110 = null;
		          null !== newProps.memoizedState &&
		            null !== newProps.memoizedState.cachePool &&
		            (cache$110 = newProps.memoizedState.cachePool.pool);
		          cache$110 !== nextResource && (newProps.flags |= 2048);
		        }
		        renderLanes !== current &&
		          renderLanes &&
		          (workInProgress.child.flags |= 8192);
		        scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
		        bubbleProperties(workInProgress);
		        return null;
		      case 4:
		        return (
		          popHostContainer(),
		          updateHostContainer(current, workInProgress),
		          null === current &&
		            preparePortalMount(workInProgress.stateNode.containerInfo),
		          bubbleProperties(workInProgress),
		          null
		        );
		      case 10:
		        return (
		          popProvider(workInProgress.type),
		          bubbleProperties(workInProgress),
		          null
		        );
		      case 19:
		        pop(suspenseStackCursor);
		        nextResource = workInProgress.memoizedState;
		        if (null === nextResource)
		          return bubbleProperties(workInProgress), null;
		        newProps = 0 !== (workInProgress.flags & 128);
		        cache$110 = nextResource.rendering;
		        if (null === cache$110)
		          if (newProps) cutOffTailIfNeeded(nextResource, false);
		          else {
		            if (
		              0 !== workInProgressRootExitStatus ||
		              (null !== current && 0 !== (current.flags & 128))
		            )
		              for (current = workInProgress.child; null !== current; ) {
		                cache$110 = findFirstSuspended(current);
		                if (null !== cache$110) {
		                  workInProgress.flags |= 128;
		                  cutOffTailIfNeeded(nextResource, false);
		                  current = cache$110.updateQueue;
		                  workInProgress.updateQueue = current;
		                  scheduleRetryEffect(workInProgress, current);
		                  workInProgress.subtreeFlags = 0;
		                  current = renderLanes;
		                  for (
		                    renderLanes = workInProgress.child;
		                    null !== renderLanes;

		                  )
		                    resetWorkInProgress(renderLanes, current),
		                      (renderLanes = renderLanes.sibling);
		                  push(
		                    suspenseStackCursor,
		                    (suspenseStackCursor.current & 1) | 2
		                  );
		                  return workInProgress.child;
		                }
		                current = current.sibling;
		              }
		            null !== nextResource.tail &&
		              now() > workInProgressRootRenderTargetTime &&
		              ((workInProgress.flags |= 128),
		              (newProps = true),
		              cutOffTailIfNeeded(nextResource, false),
		              (workInProgress.lanes = 4194304));
		          }
		        else {
		          if (!newProps)
		            if (((current = findFirstSuspended(cache$110)), null !== current)) {
		              if (
		                ((workInProgress.flags |= 128),
		                (newProps = true),
		                (current = current.updateQueue),
		                (workInProgress.updateQueue = current),
		                scheduleRetryEffect(workInProgress, current),
		                cutOffTailIfNeeded(nextResource, true),
		                null === nextResource.tail &&
		                  "hidden" === nextResource.tailMode &&
		                  !cache$110.alternate &&
		                  !isHydrating)
		              )
		                return bubbleProperties(workInProgress), null;
		            } else
		              2 * now() - nextResource.renderingStartTime >
		                workInProgressRootRenderTargetTime &&
		                536870912 !== renderLanes &&
		                ((workInProgress.flags |= 128),
		                (newProps = true),
		                cutOffTailIfNeeded(nextResource, false),
		                (workInProgress.lanes = 4194304));
		          nextResource.isBackwards
		            ? ((cache$110.sibling = workInProgress.child),
		              (workInProgress.child = cache$110))
		            : ((current = nextResource.last),
		              null !== current
		                ? (current.sibling = cache$110)
		                : (workInProgress.child = cache$110),
		              (nextResource.last = cache$110));
		        }
		        if (null !== nextResource.tail)
		          return (
		            (workInProgress = nextResource.tail),
		            (nextResource.rendering = workInProgress),
		            (nextResource.tail = workInProgress.sibling),
		            (nextResource.renderingStartTime = now()),
		            (workInProgress.sibling = null),
		            (current = suspenseStackCursor.current),
		            push(
		              suspenseStackCursor,
		              newProps ? (current & 1) | 2 : current & 1
		            ),
		            workInProgress
		          );
		        bubbleProperties(workInProgress);
		        return null;
		      case 22:
		      case 23:
		        return (
		          popSuspenseHandler(workInProgress),
		          popHiddenContext(),
		          (newProps = null !== workInProgress.memoizedState),
		          null !== current
		            ? (null !== current.memoizedState) !== newProps &&
		              (workInProgress.flags |= 8192)
		            : newProps && (workInProgress.flags |= 8192),
		          newProps
		            ? 0 !== (renderLanes & 536870912) &&
		              0 === (workInProgress.flags & 128) &&
		              (bubbleProperties(workInProgress),
		              workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192))
		            : bubbleProperties(workInProgress),
		          (renderLanes = workInProgress.updateQueue),
		          null !== renderLanes &&
		            scheduleRetryEffect(workInProgress, renderLanes.retryQueue),
		          (renderLanes = null),
		          null !== current &&
		            null !== current.memoizedState &&
		            null !== current.memoizedState.cachePool &&
		            (renderLanes = current.memoizedState.cachePool.pool),
		          (newProps = null),
		          null !== workInProgress.memoizedState &&
		            null !== workInProgress.memoizedState.cachePool &&
		            (newProps = workInProgress.memoizedState.cachePool.pool),
		          newProps !== renderLanes && (workInProgress.flags |= 2048),
		          null !== current && pop(resumedCache),
		          null
		        );
		      case 24:
		        return (
		          (renderLanes = null),
		          null !== current && (renderLanes = current.memoizedState.cache),
		          workInProgress.memoizedState.cache !== renderLanes &&
		            (workInProgress.flags |= 2048),
		          popProvider(CacheContext),
		          bubbleProperties(workInProgress),
		          null
		        );
		      case 25:
		        return null;
		    }
		    throw Error(formatProdErrorMessage(156, workInProgress.tag));
		  }
		  function unwindWork(current, workInProgress) {
		    popTreeContext(workInProgress);
		    switch (workInProgress.tag) {
		      case 1:
		        return (
		          (current = workInProgress.flags),
		          current & 65536
		            ? ((workInProgress.flags = (current & -65537) | 128),
		              workInProgress)
		            : null
		        );
		      case 3:
		        return (
		          popProvider(CacheContext),
		          popHostContainer(),
		          (current = workInProgress.flags),
		          0 !== (current & 65536) && 0 === (current & 128)
		            ? ((workInProgress.flags = (current & -65537) | 128),
		              workInProgress)
		            : null
		        );
		      case 26:
		      case 27:
		      case 5:
		        return popHostContext(workInProgress), null;
		      case 13:
		        popSuspenseHandler(workInProgress);
		        current = workInProgress.memoizedState;
		        if (null !== current && null !== current.dehydrated) {
		          if (null === workInProgress.alternate)
		            throw Error(formatProdErrorMessage(340));
		          resetHydrationState();
		        }
		        current = workInProgress.flags;
		        return current & 65536
		          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
		          : null;
		      case 19:
		        return pop(suspenseStackCursor), null;
		      case 4:
		        return popHostContainer(), null;
		      case 10:
		        return popProvider(workInProgress.type), null;
		      case 22:
		      case 23:
		        return (
		          popSuspenseHandler(workInProgress),
		          popHiddenContext(),
		          null !== current && pop(resumedCache),
		          (current = workInProgress.flags),
		          current & 65536
		            ? ((workInProgress.flags = (current & -65537) | 128),
		              workInProgress)
		            : null
		        );
		      case 24:
		        return popProvider(CacheContext), null;
		      case 25:
		        return null;
		      default:
		        return null;
		    }
		  }
		  function unwindInterruptedWork(current, interruptedWork) {
		    popTreeContext(interruptedWork);
		    switch (interruptedWork.tag) {
		      case 3:
		        popProvider(CacheContext);
		        popHostContainer();
		        break;
		      case 26:
		      case 27:
		      case 5:
		        popHostContext(interruptedWork);
		        break;
		      case 4:
		        popHostContainer();
		        break;
		      case 13:
		        popSuspenseHandler(interruptedWork);
		        break;
		      case 19:
		        pop(suspenseStackCursor);
		        break;
		      case 10:
		        popProvider(interruptedWork.type);
		        break;
		      case 22:
		      case 23:
		        popSuspenseHandler(interruptedWork);
		        popHiddenContext();
		        null !== current && pop(resumedCache);
		        break;
		      case 24:
		        popProvider(CacheContext);
		    }
		  }
		  function commitHookEffectListMount(flags, finishedWork) {
		    try {
		      var updateQueue = finishedWork.updateQueue,
		        lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
		      if (null !== lastEffect) {
		        var firstEffect = lastEffect.next;
		        updateQueue = firstEffect;
		        do {
		          if ((updateQueue.tag & flags) === flags) {
		            lastEffect = void 0;
		            var create = updateQueue.create,
		              inst = updateQueue.inst;
		            lastEffect = create();
		            inst.destroy = lastEffect;
		          }
		          updateQueue = updateQueue.next;
		        } while (updateQueue !== firstEffect);
		      }
		    } catch (error) {
		      captureCommitPhaseError(finishedWork, finishedWork.return, error);
		    }
		  }
		  function commitHookEffectListUnmount(
		    flags,
		    finishedWork,
		    nearestMountedAncestor$jscomp$0
		  ) {
		    try {
		      var updateQueue = finishedWork.updateQueue,
		        lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
		      if (null !== lastEffect) {
		        var firstEffect = lastEffect.next;
		        updateQueue = firstEffect;
		        do {
		          if ((updateQueue.tag & flags) === flags) {
		            var inst = updateQueue.inst,
		              destroy = inst.destroy;
		            if (void 0 !== destroy) {
		              inst.destroy = void 0;
		              lastEffect = finishedWork;
		              var nearestMountedAncestor = nearestMountedAncestor$jscomp$0;
		              try {
		                destroy();
		              } catch (error) {
		                captureCommitPhaseError(
		                  lastEffect,
		                  nearestMountedAncestor,
		                  error
		                );
		              }
		            }
		          }
		          updateQueue = updateQueue.next;
		        } while (updateQueue !== firstEffect);
		      }
		    } catch (error) {
		      captureCommitPhaseError(finishedWork, finishedWork.return, error);
		    }
		  }
		  function commitClassCallbacks(finishedWork) {
		    var updateQueue = finishedWork.updateQueue;
		    if (null !== updateQueue) {
		      var instance = finishedWork.stateNode;
		      try {
		        commitCallbacks(updateQueue, instance);
		      } catch (error) {
		        captureCommitPhaseError(finishedWork, finishedWork.return, error);
		      }
		    }
		  }
		  function safelyCallComponentWillUnmount(
		    current,
		    nearestMountedAncestor,
		    instance
		  ) {
		    instance.props = resolveClassComponentProps(
		      current.type,
		      current.memoizedProps
		    );
		    instance.state = current.memoizedState;
		    try {
		      instance.componentWillUnmount();
		    } catch (error) {
		      captureCommitPhaseError(current, nearestMountedAncestor, error);
		    }
		  }
		  function safelyAttachRef(current, nearestMountedAncestor) {
		    try {
		      var ref = current.ref;
		      if (null !== ref) {
		        var instance = current.stateNode;
		        switch (current.tag) {
		          case 26:
		          case 27:
		          case 5:
		            var instanceToUse = getPublicInstance(instance);
		            break;
		          default:
		            instanceToUse = instance;
		        }
		        "function" === typeof ref
		          ? (current.refCleanup = ref(instanceToUse))
		          : (ref.current = instanceToUse);
		      }
		    } catch (error) {
		      captureCommitPhaseError(current, nearestMountedAncestor, error);
		    }
		  }
		  function safelyDetachRef(current, nearestMountedAncestor) {
		    var ref = current.ref,
		      refCleanup = current.refCleanup;
		    if (null !== ref)
		      if ("function" === typeof refCleanup)
		        try {
		          refCleanup();
		        } catch (error) {
		          captureCommitPhaseError(current, nearestMountedAncestor, error);
		        } finally {
		          (current.refCleanup = null),
		            (current = current.alternate),
		            null != current && (current.refCleanup = null);
		        }
		      else if ("function" === typeof ref)
		        try {
		          ref(null);
		        } catch (error$126) {
		          captureCommitPhaseError(current, nearestMountedAncestor, error$126);
		        }
		      else ref.current = null;
		  }
		  function commitHostMount(finishedWork) {
		    var type = finishedWork.type,
		      props = finishedWork.memoizedProps,
		      instance = finishedWork.stateNode;
		    try {
		      commitMount(instance, type, props, finishedWork);
		    } catch (error) {
		      captureCommitPhaseError(finishedWork, finishedWork.return, error);
		    }
		  }
		  function commitHostUpdate(finishedWork, newProps, oldProps) {
		    try {
		      commitUpdate(
		        finishedWork.stateNode,
		        finishedWork.type,
		        oldProps,
		        newProps,
		        finishedWork
		      );
		    } catch (error) {
		      captureCommitPhaseError(finishedWork, finishedWork.return, error);
		    }
		  }
		  function isHostParent(fiber) {
		    return (
		      5 === fiber.tag ||
		      3 === fiber.tag ||
		      (supportsResources ? 26 === fiber.tag : false) ||
		      (supportsSingletons ? 27 === fiber.tag : false) ||
		      4 === fiber.tag
		    );
		  }
		  function getHostSibling(fiber) {
		    a: for (;;) {
		      for (; null === fiber.sibling; ) {
		        if (null === fiber.return || isHostParent(fiber.return)) return null;
		        fiber = fiber.return;
		      }
		      fiber.sibling.return = fiber.return;
		      for (
		        fiber = fiber.sibling;
		        5 !== fiber.tag &&
		        6 !== fiber.tag &&
		        (supportsSingletons ? 27 !== fiber.tag : 1) &&
		        18 !== fiber.tag;

		      ) {
		        if (fiber.flags & 2) continue a;
		        if (null === fiber.child || 4 === fiber.tag) continue a;
		        else (fiber.child.return = fiber), (fiber = fiber.child);
		      }
		      if (!(fiber.flags & 2)) return fiber.stateNode;
		    }
		  }
		  function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
		    var tag = node.tag;
		    if (5 === tag || 6 === tag)
		      (node = node.stateNode),
		        before
		          ? insertInContainerBefore(parent, node, before)
		          : appendChildToContainer(parent, node);
		    else if (
		      !(4 === tag || (supportsSingletons && 27 === tag)) &&
		      ((node = node.child), null !== node)
		    )
		      for (
		        insertOrAppendPlacementNodeIntoContainer(node, before, parent),
		          node = node.sibling;
		        null !== node;

		      )
		        insertOrAppendPlacementNodeIntoContainer(node, before, parent),
		          (node = node.sibling);
		  }
		  function insertOrAppendPlacementNode(node, before, parent) {
		    var tag = node.tag;
		    if (5 === tag || 6 === tag)
		      (node = node.stateNode),
		        before ? insertBefore(parent, node, before) : appendChild(parent, node);
		    else if (
		      !(4 === tag || (supportsSingletons && 27 === tag)) &&
		      ((node = node.child), null !== node)
		    )
		      for (
		        insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
		        null !== node;

		      )
		        insertOrAppendPlacementNode(node, before, parent),
		          (node = node.sibling);
		  }
		  function commitHostPortalContainerChildren(
		    portal,
		    finishedWork,
		    pendingChildren
		  ) {
		    portal = portal.containerInfo;
		    try {
		      replaceContainerChildren(portal, pendingChildren);
		    } catch (error) {
		      captureCommitPhaseError(finishedWork, finishedWork.return, error);
		    }
		  }
		  function commitBeforeMutationEffects(root, firstChild) {
		    prepareForCommit(root.containerInfo);
		    for (nextEffect = firstChild; null !== nextEffect; )
		      if (
		        ((root = nextEffect),
		        (firstChild = root.child),
		        0 !== (root.subtreeFlags & 1028) && null !== firstChild)
		      )
		        (firstChild.return = root), (nextEffect = firstChild);
		      else
		        for (; null !== nextEffect; ) {
		          root = nextEffect;
		          var current = root.alternate;
		          firstChild = root.flags;
		          switch (root.tag) {
		            case 0:
		              break;
		            case 11:
		            case 15:
		              break;
		            case 1:
		              if (0 !== (firstChild & 1024) && null !== current) {
		                firstChild = void 0;
		                var finishedWork = root,
		                  prevProps = current.memoizedProps;
		                current = current.memoizedState;
		                var instance = finishedWork.stateNode;
		                try {
		                  var resolvedPrevProps = resolveClassComponentProps(
		                    finishedWork.type,
		                    prevProps,
		                    finishedWork.elementType === finishedWork.type
		                  );
		                  firstChild = instance.getSnapshotBeforeUpdate(
		                    resolvedPrevProps,
		                    current
		                  );
		                  instance.__reactInternalSnapshotBeforeUpdate = firstChild;
		                } catch (error) {
		                  captureCommitPhaseError(
		                    finishedWork,
		                    finishedWork.return,
		                    error
		                  );
		                }
		              }
		              break;
		            case 3:
		              0 !== (firstChild & 1024) &&
		                supportsMutation &&
		                clearContainer(root.stateNode.containerInfo);
		              break;
		            case 5:
		            case 26:
		            case 27:
		            case 6:
		            case 4:
		            case 17:
		              break;
		            default:
		              if (0 !== (firstChild & 1024))
		                throw Error(formatProdErrorMessage(163));
		          }
		          firstChild = root.sibling;
		          if (null !== firstChild) {
		            firstChild.return = root.return;
		            nextEffect = firstChild;
		            break;
		          }
		          nextEffect = root.return;
		        }
		    resolvedPrevProps = shouldFireAfterActiveInstanceBlur;
		    shouldFireAfterActiveInstanceBlur = false;
		    return resolvedPrevProps;
		  }
		  function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
		    var flags = finishedWork.flags;
		    switch (finishedWork.tag) {
		      case 0:
		      case 11:
		      case 15:
		        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		        flags & 4 && commitHookEffectListMount(5, finishedWork);
		        break;
		      case 1:
		        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		        if (flags & 4)
		          if (((finishedRoot = finishedWork.stateNode), null === current))
		            try {
		              finishedRoot.componentDidMount();
		            } catch (error) {
		              captureCommitPhaseError(finishedWork, finishedWork.return, error);
		            }
		          else {
		            var prevProps = resolveClassComponentProps(
		              finishedWork.type,
		              current.memoizedProps
		            );
		            current = current.memoizedState;
		            try {
		              finishedRoot.componentDidUpdate(
		                prevProps,
		                current,
		                finishedRoot.__reactInternalSnapshotBeforeUpdate
		              );
		            } catch (error$125) {
		              captureCommitPhaseError(
		                finishedWork,
		                finishedWork.return,
		                error$125
		              );
		            }
		          }
		        flags & 64 && commitClassCallbacks(finishedWork);
		        flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
		        break;
		      case 3:
		        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		        if (
		          flags & 64 &&
		          ((flags = finishedWork.updateQueue), null !== flags)
		        ) {
		          finishedRoot = null;
		          if (null !== finishedWork.child)
		            switch (finishedWork.child.tag) {
		              case 27:
		              case 5:
		                finishedRoot = getPublicInstance(finishedWork.child.stateNode);
		                break;
		              case 1:
		                finishedRoot = finishedWork.child.stateNode;
		            }
		          try {
		            commitCallbacks(flags, finishedRoot);
		          } catch (error) {
		            captureCommitPhaseError(finishedWork, finishedWork.return, error);
		          }
		        }
		        break;
		      case 26:
		        if (supportsResources) {
		          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
		          break;
		        }
		      case 27:
		      case 5:
		        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		        null === current && flags & 4 && commitHostMount(finishedWork);
		        flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
		        break;
		      case 12:
		        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		        break;
		      case 13:
		        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		        flags & 4 &&
		          commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
		        break;
		      case 22:
		        prevProps =
		          null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
		        if (!prevProps) {
		          current =
		            (null !== current && null !== current.memoizedState) ||
		            offscreenSubtreeWasHidden;
		          var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
		            prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
		          offscreenSubtreeIsHidden = prevProps;
		          (offscreenSubtreeWasHidden = current) &&
		          !prevOffscreenSubtreeWasHidden
		            ? recursivelyTraverseReappearLayoutEffects(
		                finishedRoot,
		                finishedWork,
		                0 !== (finishedWork.subtreeFlags & 8772)
		              )
		            : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
		          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
		        }
		        flags & 512 &&
		          ("manual" === finishedWork.memoizedProps.mode
		            ? safelyAttachRef(finishedWork, finishedWork.return)
		            : safelyDetachRef(finishedWork, finishedWork.return));
		        break;
		      default:
		        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		    }
		  }
		  function detachFiberAfterEffects(fiber) {
		    var alternate = fiber.alternate;
		    null !== alternate &&
		      ((fiber.alternate = null), detachFiberAfterEffects(alternate));
		    fiber.child = null;
		    fiber.deletions = null;
		    fiber.sibling = null;
		    5 === fiber.tag &&
		      ((alternate = fiber.stateNode),
		      null !== alternate && detachDeletedInstance(alternate));
		    fiber.stateNode = null;
		    fiber.return = null;
		    fiber.dependencies = null;
		    fiber.memoizedProps = null;
		    fiber.memoizedState = null;
		    fiber.pendingProps = null;
		    fiber.stateNode = null;
		    fiber.updateQueue = null;
		  }
		  function recursivelyTraverseDeletionEffects(
		    finishedRoot,
		    nearestMountedAncestor,
		    parent
		  ) {
		    for (parent = parent.child; null !== parent; )
		      commitDeletionEffectsOnFiber(
		        finishedRoot,
		        nearestMountedAncestor,
		        parent
		      ),
		        (parent = parent.sibling);
		  }
		  function commitDeletionEffectsOnFiber(
		    finishedRoot,
		    nearestMountedAncestor,
		    deletedFiber
		  ) {
		    if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
		      try {
		        injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
		      } catch (err) {}
		    switch (deletedFiber.tag) {
		      case 26:
		        if (supportsResources) {
		          offscreenSubtreeWasHidden ||
		            safelyDetachRef(deletedFiber, nearestMountedAncestor);
		          recursivelyTraverseDeletionEffects(
		            finishedRoot,
		            nearestMountedAncestor,
		            deletedFiber
		          );
		          deletedFiber.memoizedState
		            ? releaseResource(deletedFiber.memoizedState)
		            : deletedFiber.stateNode &&
		              unmountHoistable(deletedFiber.stateNode);
		          break;
		        }
		      case 27:
		        if (supportsSingletons) {
		          offscreenSubtreeWasHidden ||
		            safelyDetachRef(deletedFiber, nearestMountedAncestor);
		          var prevHostParent = hostParent,
		            prevHostParentIsContainer = hostParentIsContainer;
		          hostParent = deletedFiber.stateNode;
		          recursivelyTraverseDeletionEffects(
		            finishedRoot,
		            nearestMountedAncestor,
		            deletedFiber
		          );
		          releaseSingletonInstance(deletedFiber.stateNode);
		          hostParent = prevHostParent;
		          hostParentIsContainer = prevHostParentIsContainer;
		          break;
		        }
		      case 5:
		        offscreenSubtreeWasHidden ||
		          safelyDetachRef(deletedFiber, nearestMountedAncestor);
		      case 6:
		        if (supportsMutation) {
		          if (
		            ((prevHostParent = hostParent),
		            (prevHostParentIsContainer = hostParentIsContainer),
		            (hostParent = null),
		            recursivelyTraverseDeletionEffects(
		              finishedRoot,
		              nearestMountedAncestor,
		              deletedFiber
		            ),
		            (hostParent = prevHostParent),
		            (hostParentIsContainer = prevHostParentIsContainer),
		            null !== hostParent)
		          )
		            if (hostParentIsContainer)
		              try {
		                removeChildFromContainer(hostParent, deletedFiber.stateNode);
		              } catch (error) {
		                captureCommitPhaseError(
		                  deletedFiber,
		                  nearestMountedAncestor,
		                  error
		                );
		              }
		            else
		              try {
		                removeChild(hostParent, deletedFiber.stateNode);
		              } catch (error) {
		                captureCommitPhaseError(
		                  deletedFiber,
		                  nearestMountedAncestor,
		                  error
		                );
		              }
		        } else
		          recursivelyTraverseDeletionEffects(
		            finishedRoot,
		            nearestMountedAncestor,
		            deletedFiber
		          );
		        break;
		      case 18:
		        supportsMutation &&
		          null !== hostParent &&
		          (hostParentIsContainer
		            ? clearSuspenseBoundaryFromContainer(
		                hostParent,
		                deletedFiber.stateNode
		              )
		            : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
		        break;
		      case 4:
		        supportsMutation
		          ? ((prevHostParent = hostParent),
		            (prevHostParentIsContainer = hostParentIsContainer),
		            (hostParent = deletedFiber.stateNode.containerInfo),
		            (hostParentIsContainer = true),
		            recursivelyTraverseDeletionEffects(
		              finishedRoot,
		              nearestMountedAncestor,
		              deletedFiber
		            ),
		            (hostParent = prevHostParent),
		            (hostParentIsContainer = prevHostParentIsContainer))
		          : (supportsPersistence &&
		              commitHostPortalContainerChildren(
		                deletedFiber.stateNode,
		                deletedFiber,
		                createContainerChildSet()
		              ),
		            recursivelyTraverseDeletionEffects(
		              finishedRoot,
		              nearestMountedAncestor,
		              deletedFiber
		            ));
		        break;
		      case 0:
		      case 11:
		      case 14:
		      case 15:
		        offscreenSubtreeWasHidden ||
		          commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
		        offscreenSubtreeWasHidden ||
		          commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
		        recursivelyTraverseDeletionEffects(
		          finishedRoot,
		          nearestMountedAncestor,
		          deletedFiber
		        );
		        break;
		      case 1:
		        offscreenSubtreeWasHidden ||
		          (safelyDetachRef(deletedFiber, nearestMountedAncestor),
		          (prevHostParent = deletedFiber.stateNode),
		          "function" === typeof prevHostParent.componentWillUnmount &&
		            safelyCallComponentWillUnmount(
		              deletedFiber,
		              nearestMountedAncestor,
		              prevHostParent
		            ));
		        recursivelyTraverseDeletionEffects(
		          finishedRoot,
		          nearestMountedAncestor,
		          deletedFiber
		        );
		        break;
		      case 21:
		        recursivelyTraverseDeletionEffects(
		          finishedRoot,
		          nearestMountedAncestor,
		          deletedFiber
		        );
		        break;
		      case 22:
		        offscreenSubtreeWasHidden ||
		          safelyDetachRef(deletedFiber, nearestMountedAncestor);
		        offscreenSubtreeWasHidden =
		          (prevHostParent = offscreenSubtreeWasHidden) ||
		          null !== deletedFiber.memoizedState;
		        recursivelyTraverseDeletionEffects(
		          finishedRoot,
		          nearestMountedAncestor,
		          deletedFiber
		        );
		        offscreenSubtreeWasHidden = prevHostParent;
		        break;
		      default:
		        recursivelyTraverseDeletionEffects(
		          finishedRoot,
		          nearestMountedAncestor,
		          deletedFiber
		        );
		    }
		  }
		  function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
		    if (
		      supportsHydration &&
		      null === finishedWork.memoizedState &&
		      ((finishedRoot = finishedWork.alternate),
		      null !== finishedRoot &&
		        ((finishedRoot = finishedRoot.memoizedState),
		        null !== finishedRoot &&
		          ((finishedRoot = finishedRoot.dehydrated), null !== finishedRoot)))
		    )
		      try {
		        commitHydratedSuspenseInstance(finishedRoot);
		      } catch (error) {
		        captureCommitPhaseError(finishedWork, finishedWork.return, error);
		      }
		  }
		  function getRetryCache(finishedWork) {
		    switch (finishedWork.tag) {
		      case 13:
		      case 19:
		        var retryCache = finishedWork.stateNode;
		        null === retryCache &&
		          (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
		        return retryCache;
		      case 22:
		        return (
		          (finishedWork = finishedWork.stateNode),
		          (retryCache = finishedWork._retryCache),
		          null === retryCache &&
		            (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),
		          retryCache
		        );
		      default:
		        throw Error(formatProdErrorMessage(435, finishedWork.tag));
		    }
		  }
		  function attachSuspenseRetryListeners(finishedWork, wakeables) {
		    var retryCache = getRetryCache(finishedWork);
		    wakeables.forEach(function (wakeable) {
		      var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
		      retryCache.has(wakeable) ||
		        (retryCache.add(wakeable), wakeable.then(retry, retry));
		    });
		  }
		  function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
		    var deletions = parentFiber.deletions;
		    if (null !== deletions)
		      for (var i = 0; i < deletions.length; i++) {
		        var childToDelete = deletions[i],
		          root = root$jscomp$0,
		          returnFiber = parentFiber;
		        if (supportsMutation) {
		          var parent = returnFiber;
		          a: for (; null !== parent; ) {
		            switch (parent.tag) {
		              case 27:
		              case 5:
		                hostParent = parent.stateNode;
		                hostParentIsContainer = false;
		                break a;
		              case 3:
		                hostParent = parent.stateNode.containerInfo;
		                hostParentIsContainer = true;
		                break a;
		              case 4:
		                hostParent = parent.stateNode.containerInfo;
		                hostParentIsContainer = true;
		                break a;
		            }
		            parent = parent.return;
		          }
		          if (null === hostParent) throw Error(formatProdErrorMessage(160));
		          commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);
		          hostParent = null;
		          hostParentIsContainer = false;
		        } else commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);
		        root = childToDelete.alternate;
		        null !== root && (root.return = null);
		        childToDelete.return = null;
		      }
		    if (parentFiber.subtreeFlags & 13878)
		      for (parentFiber = parentFiber.child; null !== parentFiber; )
		        commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),
		          (parentFiber = parentFiber.sibling);
		  }
		  function commitMutationEffectsOnFiber(finishedWork, root) {
		    var current = finishedWork.alternate,
		      flags = finishedWork.flags;
		    switch (finishedWork.tag) {
		      case 0:
		      case 11:
		      case 14:
		      case 15:
		        recursivelyTraverseMutationEffects(root, finishedWork);
		        commitReconciliationEffects(finishedWork);
		        flags & 4 &&
		          (commitHookEffectListUnmount(3, finishedWork, finishedWork.return),
		          commitHookEffectListMount(3, finishedWork),
		          commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
		        break;
		      case 1:
		        recursivelyTraverseMutationEffects(root, finishedWork);
		        commitReconciliationEffects(finishedWork);
		        flags & 512 &&
		          (offscreenSubtreeWasHidden ||
		            null === current ||
		            safelyDetachRef(current, current.return));
		        flags & 64 &&
		          offscreenSubtreeIsHidden &&
		          ((finishedWork = finishedWork.updateQueue),
		          null !== finishedWork &&
		            ((flags = finishedWork.callbacks),
		            null !== flags &&
		              ((current = finishedWork.shared.hiddenCallbacks),
		              (finishedWork.shared.hiddenCallbacks =
		                null === current ? flags : current.concat(flags)))));
		        break;
		      case 26:
		        if (supportsResources) {
		          var hoistableRoot = currentHoistableRoot;
		          recursivelyTraverseMutationEffects(root, finishedWork);
		          commitReconciliationEffects(finishedWork);
		          flags & 512 &&
		            (offscreenSubtreeWasHidden ||
		              null === current ||
		              safelyDetachRef(current, current.return));
		          flags & 4 &&
		            ((flags = null !== current ? current.memoizedState : null),
		            (root = finishedWork.memoizedState),
		            null === current
		              ? null === root
		                ? null === finishedWork.stateNode
		                  ? (finishedWork.stateNode = hydrateHoistable(
		                      hoistableRoot,
		                      finishedWork.type,
		                      finishedWork.memoizedProps,
		                      finishedWork
		                    ))
		                  : mountHoistable(
		                      hoistableRoot,
		                      finishedWork.type,
		                      finishedWork.stateNode
		                    )
		                : (finishedWork.stateNode = acquireResource(
		                    hoistableRoot,
		                    root,
		                    finishedWork.memoizedProps
		                  ))
		              : flags !== root
		                ? (null === flags
		                    ? null !== current.stateNode &&
		                      unmountHoistable(current.stateNode)
		                    : releaseResource(flags),
		                  null === root
		                    ? mountHoistable(
		                        hoistableRoot,
		                        finishedWork.type,
		                        finishedWork.stateNode
		                      )
		                    : acquireResource(
		                        hoistableRoot,
		                        root,
		                        finishedWork.memoizedProps
		                      ))
		                : null === root &&
		                  null !== finishedWork.stateNode &&
		                  commitHostUpdate(
		                    finishedWork,
		                    finishedWork.memoizedProps,
		                    current.memoizedProps
		                  ));
		          break;
		        }
		      case 27:
		        if (
		          supportsSingletons &&
		          flags & 4 &&
		          null === finishedWork.alternate
		        ) {
		          hoistableRoot = finishedWork.stateNode;
		          var props = finishedWork.memoizedProps;
		          try {
		            clearSingleton(hoistableRoot),
		              acquireSingletonInstance(
		                finishedWork.type,
		                props,
		                hoistableRoot,
		                finishedWork
		              );
		          } catch (error) {
		            captureCommitPhaseError(finishedWork, finishedWork.return, error);
		          }
		        }
		      case 5:
		        recursivelyTraverseMutationEffects(root, finishedWork);
		        commitReconciliationEffects(finishedWork);
		        flags & 512 &&
		          (offscreenSubtreeWasHidden ||
		            null === current ||
		            safelyDetachRef(current, current.return));
		        if (supportsMutation) {
		          if (finishedWork.flags & 32) {
		            root = finishedWork.stateNode;
		            try {
		              resetTextContent(root);
		            } catch (error) {
		              captureCommitPhaseError(finishedWork, finishedWork.return, error);
		            }
		          }
		          flags & 4 &&
		            null != finishedWork.stateNode &&
		            ((root = finishedWork.memoizedProps),
		            commitHostUpdate(
		              finishedWork,
		              root,
		              null !== current ? current.memoizedProps : root
		            ));
		          flags & 1024 && (needsFormReset = true);
		        }
		        break;
		      case 6:
		        recursivelyTraverseMutationEffects(root, finishedWork);
		        commitReconciliationEffects(finishedWork);
		        if (flags & 4 && supportsMutation) {
		          if (null === finishedWork.stateNode)
		            throw Error(formatProdErrorMessage(162));
		          flags = finishedWork.memoizedProps;
		          current = null !== current ? current.memoizedProps : flags;
		          root = finishedWork.stateNode;
		          try {
		            commitTextUpdate(root, current, flags);
		          } catch (error) {
		            captureCommitPhaseError(finishedWork, finishedWork.return, error);
		          }
		        }
		        break;
		      case 3:
		        supportsResources
		          ? (prepareToCommitHoistables(),
		            (hoistableRoot = currentHoistableRoot),
		            (currentHoistableRoot = getHoistableRoot(root.containerInfo)),
		            recursivelyTraverseMutationEffects(root, finishedWork),
		            (currentHoistableRoot = hoistableRoot))
		          : recursivelyTraverseMutationEffects(root, finishedWork);
		        commitReconciliationEffects(finishedWork);
		        if (flags & 4) {
		          if (
		            supportsMutation &&
		            supportsHydration &&
		            null !== current &&
		            current.memoizedState.isDehydrated
		          )
		            try {
		              commitHydratedContainer(root.containerInfo);
		            } catch (error) {
		              captureCommitPhaseError(finishedWork, finishedWork.return, error);
		            }
		          if (supportsPersistence) {
		            flags = root.containerInfo;
		            current = root.pendingChildren;
		            try {
		              replaceContainerChildren(flags, current);
		            } catch (error) {
		              captureCommitPhaseError(finishedWork, finishedWork.return, error);
		            }
		          }
		        }
		        needsFormReset &&
		          ((needsFormReset = false), recursivelyResetForms(finishedWork));
		        break;
		      case 4:
		        supportsResources
		          ? ((current = currentHoistableRoot),
		            (currentHoistableRoot = getHoistableRoot(
		              finishedWork.stateNode.containerInfo
		            )),
		            recursivelyTraverseMutationEffects(root, finishedWork),
		            commitReconciliationEffects(finishedWork),
		            (currentHoistableRoot = current))
		          : (recursivelyTraverseMutationEffects(root, finishedWork),
		            commitReconciliationEffects(finishedWork));
		        flags & 4 &&
		          supportsPersistence &&
		          commitHostPortalContainerChildren(
		            finishedWork.stateNode,
		            finishedWork,
		            finishedWork.stateNode.pendingChildren
		          );
		        break;
		      case 12:
		        recursivelyTraverseMutationEffects(root, finishedWork);
		        commitReconciliationEffects(finishedWork);
		        break;
		      case 13:
		        recursivelyTraverseMutationEffects(root, finishedWork);
		        commitReconciliationEffects(finishedWork);
		        finishedWork.child.flags & 8192 &&
		          (null !== finishedWork.memoizedState) !==
		            (null !== current && null !== current.memoizedState) &&
		          (globalMostRecentFallbackTime = now());
		        flags & 4 &&
		          ((flags = finishedWork.updateQueue),
		          null !== flags &&
		            ((finishedWork.updateQueue = null),
		            attachSuspenseRetryListeners(finishedWork, flags)));
		        break;
		      case 22:
		        flags & 512 &&
		          (offscreenSubtreeWasHidden ||
		            null === current ||
		            safelyDetachRef(current, current.return));
		        hoistableRoot = null !== finishedWork.memoizedState;
		        var wasHidden = null !== current && null !== current.memoizedState,
		          prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
		          prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
		        offscreenSubtreeIsHidden =
		          prevOffscreenSubtreeIsHidden || hoistableRoot;
		        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
		        recursivelyTraverseMutationEffects(root, finishedWork);
		        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
		        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
		        commitReconciliationEffects(finishedWork);
		        root = finishedWork.stateNode;
		        root._current = finishedWork;
		        root._visibility &= -3;
		        root._visibility |= root._pendingVisibility & 2;
		        if (
		          flags & 8192 &&
		          ((root._visibility = hoistableRoot
		            ? root._visibility & -2
		            : root._visibility | 1),
		          hoistableRoot &&
		            ((root = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden),
		            null === current ||
		              wasHidden ||
		              root ||
		              recursivelyTraverseDisappearLayoutEffects(finishedWork)),
		          supportsMutation &&
		            (null === finishedWork.memoizedProps ||
		              "manual" !== finishedWork.memoizedProps.mode))
		        )
		          a: if (((current = null), supportsMutation))
		            for (root = finishedWork; ; ) {
		              if (
		                5 === root.tag ||
		                (supportsResources && 26 === root.tag) ||
		                (supportsSingletons && 27 === root.tag)
		              ) {
		                if (null === current) {
		                  wasHidden = current = root;
		                  try {
		                    (props = wasHidden.stateNode),
		                      hoistableRoot
		                        ? hideInstance(props)
		                        : unhideInstance(
		                            wasHidden.stateNode,
		                            wasHidden.memoizedProps
		                          );
		                  } catch (error) {
		                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
		                  }
		                }
		              } else if (6 === root.tag) {
		                if (null === current) {
		                  wasHidden = root;
		                  try {
		                    var instance = wasHidden.stateNode;
		                    hoistableRoot
		                      ? hideTextInstance(instance)
		                      : unhideTextInstance(instance, wasHidden.memoizedProps);
		                  } catch (error) {
		                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
		                  }
		                }
		              } else if (
		                ((22 !== root.tag && 23 !== root.tag) ||
		                  null === root.memoizedState ||
		                  root === finishedWork) &&
		                null !== root.child
		              ) {
		                root.child.return = root;
		                root = root.child;
		                continue;
		              }
		              if (root === finishedWork) break a;
		              for (; null === root.sibling; ) {
		                if (null === root.return || root.return === finishedWork)
		                  break a;
		                current === root && (current = null);
		                root = root.return;
		              }
		              current === root && (current = null);
		              root.sibling.return = root.return;
		              root = root.sibling;
		            }
		        flags & 4 &&
		          ((flags = finishedWork.updateQueue),
		          null !== flags &&
		            ((current = flags.retryQueue),
		            null !== current &&
		              ((flags.retryQueue = null),
		              attachSuspenseRetryListeners(finishedWork, current))));
		        break;
		      case 19:
		        recursivelyTraverseMutationEffects(root, finishedWork);
		        commitReconciliationEffects(finishedWork);
		        flags & 4 &&
		          ((flags = finishedWork.updateQueue),
		          null !== flags &&
		            ((finishedWork.updateQueue = null),
		            attachSuspenseRetryListeners(finishedWork, flags)));
		        break;
		      case 21:
		        break;
		      default:
		        recursivelyTraverseMutationEffects(root, finishedWork),
		          commitReconciliationEffects(finishedWork);
		    }
		  }
		  function commitReconciliationEffects(finishedWork) {
		    var flags = finishedWork.flags;
		    if (flags & 2) {
		      try {
		        if (
		          supportsMutation &&
		          (!supportsSingletons || 27 !== finishedWork.tag)
		        ) {
		          a: {
		            for (var parent = finishedWork.return; null !== parent; ) {
		              if (isHostParent(parent)) {
		                var JSCompiler_inline_result = parent;
		                break a;
		              }
		              parent = parent.return;
		            }
		            throw Error(formatProdErrorMessage(160));
		          }
		          switch (JSCompiler_inline_result.tag) {
		            case 27:
		              if (supportsSingletons) {
		                var parent$jscomp$0 = JSCompiler_inline_result.stateNode,
		                  before = getHostSibling(finishedWork);
		                insertOrAppendPlacementNode(
		                  finishedWork,
		                  before,
		                  parent$jscomp$0
		                );
		                break;
		              }
		            case 5:
		              var parent$127 = JSCompiler_inline_result.stateNode;
		              JSCompiler_inline_result.flags & 32 &&
		                (resetTextContent(parent$127),
		                (JSCompiler_inline_result.flags &= -33));
		              var before$128 = getHostSibling(finishedWork);
		              insertOrAppendPlacementNode(finishedWork, before$128, parent$127);
		              break;
		            case 3:
		            case 4:
		              var parent$129 = JSCompiler_inline_result.stateNode.containerInfo,
		                before$130 = getHostSibling(finishedWork);
		              insertOrAppendPlacementNodeIntoContainer(
		                finishedWork,
		                before$130,
		                parent$129
		              );
		              break;
		            default:
		              throw Error(formatProdErrorMessage(161));
		          }
		        }
		      } catch (error) {
		        captureCommitPhaseError(finishedWork, finishedWork.return, error);
		      }
		      finishedWork.flags &= -3;
		    }
		    flags & 4096 && (finishedWork.flags &= -4097);
		  }
		  function recursivelyResetForms(parentFiber) {
		    if (parentFiber.subtreeFlags & 1024)
		      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
		        var fiber = parentFiber;
		        recursivelyResetForms(fiber);
		        5 === fiber.tag &&
		          fiber.flags & 1024 &&
		          resetFormInstance(fiber.stateNode);
		        parentFiber = parentFiber.sibling;
		      }
		  }
		  function recursivelyTraverseLayoutEffects(root, parentFiber) {
		    if (parentFiber.subtreeFlags & 8772)
		      for (parentFiber = parentFiber.child; null !== parentFiber; )
		        commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),
		          (parentFiber = parentFiber.sibling);
		  }
		  function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
		    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
		      var finishedWork = parentFiber;
		      switch (finishedWork.tag) {
		        case 0:
		        case 11:
		        case 14:
		        case 15:
		          commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
		          recursivelyTraverseDisappearLayoutEffects(finishedWork);
		          break;
		        case 1:
		          safelyDetachRef(finishedWork, finishedWork.return);
		          var instance = finishedWork.stateNode;
		          "function" === typeof instance.componentWillUnmount &&
		            safelyCallComponentWillUnmount(
		              finishedWork,
		              finishedWork.return,
		              instance
		            );
		          recursivelyTraverseDisappearLayoutEffects(finishedWork);
		          break;
		        case 26:
		        case 27:
		        case 5:
		          safelyDetachRef(finishedWork, finishedWork.return);
		          recursivelyTraverseDisappearLayoutEffects(finishedWork);
		          break;
		        case 22:
		          safelyDetachRef(finishedWork, finishedWork.return);
		          null === finishedWork.memoizedState &&
		            recursivelyTraverseDisappearLayoutEffects(finishedWork);
		          break;
		        default:
		          recursivelyTraverseDisappearLayoutEffects(finishedWork);
		      }
		      parentFiber = parentFiber.sibling;
		    }
		  }
		  function recursivelyTraverseReappearLayoutEffects(
		    finishedRoot$jscomp$0,
		    parentFiber,
		    includeWorkInProgressEffects
		  ) {
		    includeWorkInProgressEffects =
		      includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
		    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
		      var current = parentFiber.alternate,
		        finishedRoot = finishedRoot$jscomp$0,
		        finishedWork = parentFiber,
		        flags = finishedWork.flags;
		      switch (finishedWork.tag) {
		        case 0:
		        case 11:
		        case 15:
		          recursivelyTraverseReappearLayoutEffects(
		            finishedRoot,
		            finishedWork,
		            includeWorkInProgressEffects
		          );
		          commitHookEffectListMount(4, finishedWork);
		          break;
		        case 1:
		          recursivelyTraverseReappearLayoutEffects(
		            finishedRoot,
		            finishedWork,
		            includeWorkInProgressEffects
		          );
		          current = finishedWork;
		          finishedRoot = current.stateNode;
		          if ("function" === typeof finishedRoot.componentDidMount)
		            try {
		              finishedRoot.componentDidMount();
		            } catch (error) {
		              captureCommitPhaseError(current, current.return, error);
		            }
		          current = finishedWork;
		          finishedRoot = current.updateQueue;
		          if (null !== finishedRoot) {
		            var instance = current.stateNode;
		            try {
		              var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
		              if (null !== hiddenCallbacks)
		                for (
		                  finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0;
		                  finishedRoot < hiddenCallbacks.length;
		                  finishedRoot++
		                )
		                  callCallback(hiddenCallbacks[finishedRoot], instance);
		            } catch (error) {
		              captureCommitPhaseError(current, current.return, error);
		            }
		          }
		          includeWorkInProgressEffects &&
		            flags & 64 &&
		            commitClassCallbacks(finishedWork);
		          safelyAttachRef(finishedWork, finishedWork.return);
		          break;
		        case 26:
		        case 27:
		        case 5:
		          recursivelyTraverseReappearLayoutEffects(
		            finishedRoot,
		            finishedWork,
		            includeWorkInProgressEffects
		          );
		          includeWorkInProgressEffects &&
		            null === current &&
		            flags & 4 &&
		            commitHostMount(finishedWork);
		          safelyAttachRef(finishedWork, finishedWork.return);
		          break;
		        case 12:
		          recursivelyTraverseReappearLayoutEffects(
		            finishedRoot,
		            finishedWork,
		            includeWorkInProgressEffects
		          );
		          break;
		        case 13:
		          recursivelyTraverseReappearLayoutEffects(
		            finishedRoot,
		            finishedWork,
		            includeWorkInProgressEffects
		          );
		          includeWorkInProgressEffects &&
		            flags & 4 &&
		            commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
		          break;
		        case 22:
		          null === finishedWork.memoizedState &&
		            recursivelyTraverseReappearLayoutEffects(
		              finishedRoot,
		              finishedWork,
		              includeWorkInProgressEffects
		            );
		          safelyAttachRef(finishedWork, finishedWork.return);
		          break;
		        default:
		          recursivelyTraverseReappearLayoutEffects(
		            finishedRoot,
		            finishedWork,
		            includeWorkInProgressEffects
		          );
		      }
		      parentFiber = parentFiber.sibling;
		    }
		  }
		  function commitOffscreenPassiveMountEffects(current, finishedWork) {
		    var previousCache = null;
		    null !== current &&
		      null !== current.memoizedState &&
		      null !== current.memoizedState.cachePool &&
		      (previousCache = current.memoizedState.cachePool.pool);
		    current = null;
		    null !== finishedWork.memoizedState &&
		      null !== finishedWork.memoizedState.cachePool &&
		      (current = finishedWork.memoizedState.cachePool.pool);
		    current !== previousCache &&
		      (null != current && current.refCount++,
		      null != previousCache && releaseCache(previousCache));
		  }
		  function commitCachePassiveMountEffect(current, finishedWork) {
		    current = null;
		    null !== finishedWork.alternate &&
		      (current = finishedWork.alternate.memoizedState.cache);
		    finishedWork = finishedWork.memoizedState.cache;
		    finishedWork !== current &&
		      (finishedWork.refCount++, null != current && releaseCache(current));
		  }
		  function recursivelyTraversePassiveMountEffects(
		    root,
		    parentFiber,
		    committedLanes,
		    committedTransitions
		  ) {
		    if (parentFiber.subtreeFlags & 10256)
		      for (parentFiber = parentFiber.child; null !== parentFiber; )
		        commitPassiveMountOnFiber(
		          root,
		          parentFiber,
		          committedLanes,
		          committedTransitions
		        ),
		          (parentFiber = parentFiber.sibling);
		  }
		  function commitPassiveMountOnFiber(
		    finishedRoot,
		    finishedWork,
		    committedLanes,
		    committedTransitions
		  ) {
		    var flags = finishedWork.flags;
		    switch (finishedWork.tag) {
		      case 0:
		      case 11:
		      case 15:
		        recursivelyTraversePassiveMountEffects(
		          finishedRoot,
		          finishedWork,
		          committedLanes,
		          committedTransitions
		        );
		        flags & 2048 && commitHookEffectListMount(9, finishedWork);
		        break;
		      case 3:
		        recursivelyTraversePassiveMountEffects(
		          finishedRoot,
		          finishedWork,
		          committedLanes,
		          committedTransitions
		        );
		        flags & 2048 &&
		          ((finishedRoot = null),
		          null !== finishedWork.alternate &&
		            (finishedRoot = finishedWork.alternate.memoizedState.cache),
		          (finishedWork = finishedWork.memoizedState.cache),
		          finishedWork !== finishedRoot &&
		            (finishedWork.refCount++,
		            null != finishedRoot && releaseCache(finishedRoot)));
		        break;
		      case 12:
		        if (flags & 2048) {
		          recursivelyTraversePassiveMountEffects(
		            finishedRoot,
		            finishedWork,
		            committedLanes,
		            committedTransitions
		          );
		          finishedRoot = finishedWork.stateNode;
		          try {
		            var _finishedWork$memoize2 = finishedWork.memoizedProps,
		              id = _finishedWork$memoize2.id,
		              onPostCommit = _finishedWork$memoize2.onPostCommit;
		            "function" === typeof onPostCommit &&
		              onPostCommit(
		                id,
		                null === finishedWork.alternate ? "mount" : "update",
		                finishedRoot.passiveEffectDuration,
		                -0
		              );
		          } catch (error) {
		            captureCommitPhaseError(finishedWork, finishedWork.return, error);
		          }
		        } else
		          recursivelyTraversePassiveMountEffects(
		            finishedRoot,
		            finishedWork,
		            committedLanes,
		            committedTransitions
		          );
		        break;
		      case 23:
		        break;
		      case 22:
		        _finishedWork$memoize2 = finishedWork.stateNode;
		        null !== finishedWork.memoizedState
		          ? _finishedWork$memoize2._visibility & 4
		            ? recursivelyTraversePassiveMountEffects(
		                finishedRoot,
		                finishedWork,
		                committedLanes,
		                committedTransitions
		              )
		            : recursivelyTraverseAtomicPassiveEffects(
		                finishedRoot,
		                finishedWork
		              )
		          : _finishedWork$memoize2._visibility & 4
		            ? recursivelyTraversePassiveMountEffects(
		                finishedRoot,
		                finishedWork,
		                committedLanes,
		                committedTransitions
		              )
		            : ((_finishedWork$memoize2._visibility |= 4),
		              recursivelyTraverseReconnectPassiveEffects(
		                finishedRoot,
		                finishedWork,
		                committedLanes,
		                committedTransitions,
		                0 !== (finishedWork.subtreeFlags & 10256)
		              ));
		        flags & 2048 &&
		          commitOffscreenPassiveMountEffects(
		            finishedWork.alternate,
		            finishedWork
		          );
		        break;
		      case 24:
		        recursivelyTraversePassiveMountEffects(
		          finishedRoot,
		          finishedWork,
		          committedLanes,
		          committedTransitions
		        );
		        flags & 2048 &&
		          commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
		        break;
		      default:
		        recursivelyTraversePassiveMountEffects(
		          finishedRoot,
		          finishedWork,
		          committedLanes,
		          committedTransitions
		        );
		    }
		  }
		  function recursivelyTraverseReconnectPassiveEffects(
		    finishedRoot$jscomp$0,
		    parentFiber,
		    committedLanes$jscomp$0,
		    committedTransitions$jscomp$0,
		    includeWorkInProgressEffects
		  ) {
		    includeWorkInProgressEffects =
		      includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
		    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
		      var finishedRoot = finishedRoot$jscomp$0,
		        finishedWork = parentFiber,
		        committedLanes = committedLanes$jscomp$0,
		        committedTransitions = committedTransitions$jscomp$0,
		        flags = finishedWork.flags;
		      switch (finishedWork.tag) {
		        case 0:
		        case 11:
		        case 15:
		          recursivelyTraverseReconnectPassiveEffects(
		            finishedRoot,
		            finishedWork,
		            committedLanes,
		            committedTransitions,
		            includeWorkInProgressEffects
		          );
		          commitHookEffectListMount(8, finishedWork);
		          break;
		        case 23:
		          break;
		        case 22:
		          var instance = finishedWork.stateNode;
		          null !== finishedWork.memoizedState
		            ? instance._visibility & 4
		              ? recursivelyTraverseReconnectPassiveEffects(
		                  finishedRoot,
		                  finishedWork,
		                  committedLanes,
		                  committedTransitions,
		                  includeWorkInProgressEffects
		                )
		              : recursivelyTraverseAtomicPassiveEffects(
		                  finishedRoot,
		                  finishedWork
		                )
		            : ((instance._visibility |= 4),
		              recursivelyTraverseReconnectPassiveEffects(
		                finishedRoot,
		                finishedWork,
		                committedLanes,
		                committedTransitions,
		                includeWorkInProgressEffects
		              ));
		          includeWorkInProgressEffects &&
		            flags & 2048 &&
		            commitOffscreenPassiveMountEffects(
		              finishedWork.alternate,
		              finishedWork
		            );
		          break;
		        case 24:
		          recursivelyTraverseReconnectPassiveEffects(
		            finishedRoot,
		            finishedWork,
		            committedLanes,
		            committedTransitions,
		            includeWorkInProgressEffects
		          );
		          includeWorkInProgressEffects &&
		            flags & 2048 &&
		            commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
		          break;
		        default:
		          recursivelyTraverseReconnectPassiveEffects(
		            finishedRoot,
		            finishedWork,
		            committedLanes,
		            committedTransitions,
		            includeWorkInProgressEffects
		          );
		      }
		      parentFiber = parentFiber.sibling;
		    }
		  }
		  function recursivelyTraverseAtomicPassiveEffects(
		    finishedRoot$jscomp$0,
		    parentFiber
		  ) {
		    if (parentFiber.subtreeFlags & 10256)
		      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
		        var finishedRoot = finishedRoot$jscomp$0,
		          finishedWork = parentFiber,
		          flags = finishedWork.flags;
		        switch (finishedWork.tag) {
		          case 22:
		            recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
		            flags & 2048 &&
		              commitOffscreenPassiveMountEffects(
		                finishedWork.alternate,
		                finishedWork
		              );
		            break;
		          case 24:
		            recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
		            flags & 2048 &&
		              commitCachePassiveMountEffect(
		                finishedWork.alternate,
		                finishedWork
		              );
		            break;
		          default:
		            recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
		        }
		        parentFiber = parentFiber.sibling;
		      }
		  }
		  function recursivelyAccumulateSuspenseyCommit(parentFiber) {
		    if (parentFiber.subtreeFlags & suspenseyCommitFlag)
		      for (parentFiber = parentFiber.child; null !== parentFiber; )
		        accumulateSuspenseyCommitOnFiber(parentFiber),
		          (parentFiber = parentFiber.sibling);
		  }
		  function accumulateSuspenseyCommitOnFiber(fiber) {
		    switch (fiber.tag) {
		      case 26:
		        recursivelyAccumulateSuspenseyCommit(fiber);
		        fiber.flags & suspenseyCommitFlag &&
		          (null !== fiber.memoizedState
		            ? suspendResource(
		                currentHoistableRoot,
		                fiber.memoizedState,
		                fiber.memoizedProps
		              )
		            : suspendInstance(fiber.type, fiber.memoizedProps));
		        break;
		      case 5:
		        recursivelyAccumulateSuspenseyCommit(fiber);
		        fiber.flags & suspenseyCommitFlag &&
		          suspendInstance(fiber.type, fiber.memoizedProps);
		        break;
		      case 3:
		      case 4:
		        if (supportsResources) {
		          var previousHoistableRoot = currentHoistableRoot;
		          currentHoistableRoot = getHoistableRoot(
		            fiber.stateNode.containerInfo
		          );
		          recursivelyAccumulateSuspenseyCommit(fiber);
		          currentHoistableRoot = previousHoistableRoot;
		        } else recursivelyAccumulateSuspenseyCommit(fiber);
		        break;
		      case 22:
		        null === fiber.memoizedState &&
		          ((previousHoistableRoot = fiber.alternate),
		          null !== previousHoistableRoot &&
		          null !== previousHoistableRoot.memoizedState
		            ? ((previousHoistableRoot = suspenseyCommitFlag),
		              (suspenseyCommitFlag = 16777216),
		              recursivelyAccumulateSuspenseyCommit(fiber),
		              (suspenseyCommitFlag = previousHoistableRoot))
		            : recursivelyAccumulateSuspenseyCommit(fiber));
		        break;
		      default:
		        recursivelyAccumulateSuspenseyCommit(fiber);
		    }
		  }
		  function detachAlternateSiblings(parentFiber) {
		    var previousFiber = parentFiber.alternate;
		    if (
		      null !== previousFiber &&
		      ((parentFiber = previousFiber.child), null !== parentFiber)
		    ) {
		      previousFiber.child = null;
		      do
		        (previousFiber = parentFiber.sibling),
		          (parentFiber.sibling = null),
		          (parentFiber = previousFiber);
		      while (null !== parentFiber);
		    }
		  }
		  function recursivelyTraversePassiveUnmountEffects(parentFiber) {
		    var deletions = parentFiber.deletions;
		    if (0 !== (parentFiber.flags & 16)) {
		      if (null !== deletions)
		        for (var i = 0; i < deletions.length; i++) {
		          var childToDelete = deletions[i];
		          nextEffect = childToDelete;
		          commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
		            childToDelete,
		            parentFiber
		          );
		        }
		      detachAlternateSiblings(parentFiber);
		    }
		    if (parentFiber.subtreeFlags & 10256)
		      for (parentFiber = parentFiber.child; null !== parentFiber; )
		        commitPassiveUnmountOnFiber(parentFiber),
		          (parentFiber = parentFiber.sibling);
		  }
		  function commitPassiveUnmountOnFiber(finishedWork) {
		    switch (finishedWork.tag) {
		      case 0:
		      case 11:
		      case 15:
		        recursivelyTraversePassiveUnmountEffects(finishedWork);
		        finishedWork.flags & 2048 &&
		          commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
		        break;
		      case 3:
		        recursivelyTraversePassiveUnmountEffects(finishedWork);
		        break;
		      case 12:
		        recursivelyTraversePassiveUnmountEffects(finishedWork);
		        break;
		      case 22:
		        var instance = finishedWork.stateNode;
		        null !== finishedWork.memoizedState &&
		        instance._visibility & 4 &&
		        (null === finishedWork.return || 13 !== finishedWork.return.tag)
		          ? ((instance._visibility &= -5),
		            recursivelyTraverseDisconnectPassiveEffects(finishedWork))
		          : recursivelyTraversePassiveUnmountEffects(finishedWork);
		        break;
		      default:
		        recursivelyTraversePassiveUnmountEffects(finishedWork);
		    }
		  }
		  function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
		    var deletions = parentFiber.deletions;
		    if (0 !== (parentFiber.flags & 16)) {
		      if (null !== deletions)
		        for (var i = 0; i < deletions.length; i++) {
		          var childToDelete = deletions[i];
		          nextEffect = childToDelete;
		          commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
		            childToDelete,
		            parentFiber
		          );
		        }
		      detachAlternateSiblings(parentFiber);
		    }
		    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
		      deletions = parentFiber;
		      switch (deletions.tag) {
		        case 0:
		        case 11:
		        case 15:
		          commitHookEffectListUnmount(8, deletions, deletions.return);
		          recursivelyTraverseDisconnectPassiveEffects(deletions);
		          break;
		        case 22:
		          i = deletions.stateNode;
		          i._visibility & 4 &&
		            ((i._visibility &= -5),
		            recursivelyTraverseDisconnectPassiveEffects(deletions));
		          break;
		        default:
		          recursivelyTraverseDisconnectPassiveEffects(deletions);
		      }
		      parentFiber = parentFiber.sibling;
		    }
		  }
		  function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
		    deletedSubtreeRoot,
		    nearestMountedAncestor
		  ) {
		    for (; null !== nextEffect; ) {
		      var fiber = nextEffect;
		      switch (fiber.tag) {
		        case 0:
		        case 11:
		        case 15:
		          commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
		          break;
		        case 23:
		        case 22:
		          if (
		            null !== fiber.memoizedState &&
		            null !== fiber.memoizedState.cachePool
		          ) {
		            var cache = fiber.memoizedState.cachePool.pool;
		            null != cache && cache.refCount++;
		          }
		          break;
		        case 24:
		          releaseCache(fiber.memoizedState.cache);
		      }
		      cache = fiber.child;
		      if (null !== cache) (cache.return = fiber), (nextEffect = cache);
		      else
		        a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
		          cache = nextEffect;
		          var sibling = cache.sibling,
		            returnFiber = cache.return;
		          detachFiberAfterEffects(cache);
		          if (cache === fiber) {
		            nextEffect = null;
		            break a;
		          }
		          if (null !== sibling) {
		            sibling.return = returnFiber;
		            nextEffect = sibling;
		            break a;
		          }
		          nextEffect = returnFiber;
		        }
		    }
		  }
		  function findFiberRootForHostRoot(hostRoot) {
		    var maybeFiber = getInstanceFromNode(hostRoot);
		    if (null != maybeFiber) {
		      if ("string" !== typeof maybeFiber.memoizedProps["data-testname"])
		        throw Error(formatProdErrorMessage(364));
		      return maybeFiber;
		    }
		    hostRoot = findFiberRoot(hostRoot);
		    if (null === hostRoot) throw Error(formatProdErrorMessage(362));
		    return hostRoot.stateNode.current;
		  }
		  function matchSelector(fiber$jscomp$0, selector) {
		    var tag = fiber$jscomp$0.tag;
		    switch (selector.$$typeof) {
		      case COMPONENT_TYPE:
		        if (fiber$jscomp$0.type === selector.value) return true;
		        break;
		      case HAS_PSEUDO_CLASS_TYPE:
		        a: {
		          selector = selector.value;
		          fiber$jscomp$0 = [fiber$jscomp$0, 0];
		          for (tag = 0; tag < fiber$jscomp$0.length; ) {
		            var fiber = fiber$jscomp$0[tag++],
		              tag$jscomp$0 = fiber.tag,
		              selectorIndex = fiber$jscomp$0[tag++],
		              selector$jscomp$0 = selector[selectorIndex];
		            if (
		              (5 !== tag$jscomp$0 &&
		                26 !== tag$jscomp$0 &&
		                27 !== tag$jscomp$0) ||
		              !isHiddenSubtree(fiber)
		            ) {
		              for (
		                ;
		                null != selector$jscomp$0 &&
		                matchSelector(fiber, selector$jscomp$0);

		              )
		                selectorIndex++, (selector$jscomp$0 = selector[selectorIndex]);
		              if (selectorIndex === selector.length) {
		                selector = true;
		                break a;
		              } else
		                for (fiber = fiber.child; null !== fiber; )
		                  fiber$jscomp$0.push(fiber, selectorIndex),
		                    (fiber = fiber.sibling);
		            }
		          }
		          selector = false;
		        }
		        return selector;
		      case ROLE_TYPE:
		        if (
		          (5 === tag || 26 === tag || 27 === tag) &&
		          matchAccessibilityRole(fiber$jscomp$0.stateNode, selector.value)
		        )
		          return true;
		        break;
		      case TEXT_TYPE:
		        if (5 === tag || 6 === tag || 26 === tag || 27 === tag)
		          if (
		            ((fiber$jscomp$0 = getTextContent(fiber$jscomp$0)),
		            null !== fiber$jscomp$0 &&
		              0 <= fiber$jscomp$0.indexOf(selector.value))
		          )
		            return true;
		        break;
		      case TEST_NAME_TYPE:
		        if (5 === tag || 26 === tag || 27 === tag)
		          if (
		            ((fiber$jscomp$0 = fiber$jscomp$0.memoizedProps["data-testname"]),
		            "string" === typeof fiber$jscomp$0 &&
		              fiber$jscomp$0.toLowerCase() === selector.value.toLowerCase())
		          )
		            return true;
		        break;
		      default:
		        throw Error(formatProdErrorMessage(365));
		    }
		    return false;
		  }
		  function selectorToString(selector) {
		    switch (selector.$$typeof) {
		      case COMPONENT_TYPE:
		        return (
		          "<" + (getComponentNameFromType(selector.value) || "Unknown") + ">"
		        );
		      case HAS_PSEUDO_CLASS_TYPE:
		        return ":has(" + (selectorToString(selector) || "") + ")";
		      case ROLE_TYPE:
		        return '[role="' + selector.value + '"]';
		      case TEXT_TYPE:
		        return '"' + selector.value + '"';
		      case TEST_NAME_TYPE:
		        return '[data-testname="' + selector.value + '"]';
		      default:
		        throw Error(formatProdErrorMessage(365));
		    }
		  }
		  function findPaths(root, selectors) {
		    var matchingFibers = [];
		    root = [root, 0];
		    for (var index = 0; index < root.length; ) {
		      var fiber = root[index++],
		        tag = fiber.tag,
		        selectorIndex = root[index++],
		        selector = selectors[selectorIndex];
		      if ((5 !== tag && 26 !== tag && 27 !== tag) || !isHiddenSubtree(fiber)) {
		        for (; null != selector && matchSelector(fiber, selector); )
		          selectorIndex++, (selector = selectors[selectorIndex]);
		        if (selectorIndex === selectors.length) matchingFibers.push(fiber);
		        else
		          for (fiber = fiber.child; null !== fiber; )
		            root.push(fiber, selectorIndex), (fiber = fiber.sibling);
		      }
		    }
		    return matchingFibers;
		  }
		  function findAllNodes(hostRoot, selectors) {
		    if (!supportsTestSelectors) throw Error(formatProdErrorMessage(363));
		    hostRoot = findFiberRootForHostRoot(hostRoot);
		    hostRoot = findPaths(hostRoot, selectors);
		    selectors = [];
		    hostRoot = Array.from(hostRoot);
		    for (var index = 0; index < hostRoot.length; ) {
		      var node = hostRoot[index++],
		        tag = node.tag;
		      if (5 === tag || 26 === tag || 27 === tag)
		        isHiddenSubtree(node) || selectors.push(node.stateNode);
		      else
		        for (node = node.child; null !== node; )
		          hostRoot.push(node), (node = node.sibling);
		    }
		    return selectors;
		  }
		  function requestUpdateLane() {
		    if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)
		      return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
		    if (null !== ReactSharedInternals.T) {
		      var actionScopeLane = currentEntangledLane;
		      return 0 !== actionScopeLane ? actionScopeLane : requestTransitionLane();
		    }
		    return resolveUpdatePriority();
		  }
		  function requestDeferredLane() {
		    0 === workInProgressDeferredLane &&
		      (workInProgressDeferredLane =
		        0 === (workInProgressRootRenderLanes & 536870912) || isHydrating
		          ? claimNextTransitionLane()
		          : 536870912);
		    var suspenseHandler = suspenseHandlerStackCursor.current;
		    null !== suspenseHandler && (suspenseHandler.flags |= 32);
		    return workInProgressDeferredLane;
		  }
		  function scheduleUpdateOnFiber(root, fiber, lane) {
		    if (
		      (root === workInProgressRoot && 2 === workInProgressSuspendedReason) ||
		      null !== root.cancelPendingCommit
		    )
		      prepareFreshStack(root, 0),
		        markRootSuspended(
		          root,
		          workInProgressRootRenderLanes,
		          workInProgressDeferredLane,
		          false
		        );
		    markRootUpdated$1(root, lane);
		    if (0 === (executionContext & 2) || root !== workInProgressRoot)
		      root === workInProgressRoot &&
		        (0 === (executionContext & 2) &&
		          (workInProgressRootInterleavedUpdatedLanes |= lane),
		        4 === workInProgressRootExitStatus &&
		          markRootSuspended(
		            root,
		            workInProgressRootRenderLanes,
		            workInProgressDeferredLane,
		            false
		          )),
		        ensureRootIsScheduled(root);
		  }
		  function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
		    if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
		    var shouldTimeSlice =
		        (!forceSync &&
		          0 === (lanes & 60) &&
		          0 === (lanes & root$jscomp$0.expiredLanes)) ||
		        checkIfRootIsPrerendering(root$jscomp$0, lanes),
		      exitStatus = shouldTimeSlice
		        ? renderRootConcurrent(root$jscomp$0, lanes)
		        : renderRootSync(root$jscomp$0, lanes, true),
		      renderWasConcurrent = shouldTimeSlice;
		    do {
		      if (0 === exitStatus) {
		        workInProgressRootIsPrerendering &&
		          !shouldTimeSlice &&
		          markRootSuspended(root$jscomp$0, lanes, 0, false);
		        break;
		      } else if (6 === exitStatus)
		        markRootSuspended(
		          root$jscomp$0,
		          lanes,
		          0,
		          !workInProgressRootDidSkipSuspendedSiblings
		        );
		      else {
		        forceSync = root$jscomp$0.current.alternate;
		        if (
		          renderWasConcurrent &&
		          !isRenderConsistentWithExternalStores(forceSync)
		        ) {
		          exitStatus = renderRootSync(root$jscomp$0, lanes, false);
		          renderWasConcurrent = false;
		          continue;
		        }
		        if (2 === exitStatus) {
		          renderWasConcurrent = lanes;
		          if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
		            var JSCompiler_inline_result = 0;
		          else
		            (JSCompiler_inline_result =
		              root$jscomp$0.pendingLanes & -536870913),
		              (JSCompiler_inline_result =
		                0 !== JSCompiler_inline_result
		                  ? JSCompiler_inline_result
		                  : JSCompiler_inline_result & 536870912
		                    ? 536870912
		                    : 0);
		          if (0 !== JSCompiler_inline_result) {
		            lanes = JSCompiler_inline_result;
		            a: {
		              var root = root$jscomp$0;
		              exitStatus = workInProgressRootConcurrentErrors;
		              var wasRootDehydrated =
		                supportsHydration && root.current.memoizedState.isDehydrated;
		              wasRootDehydrated &&
		                (prepareFreshStack(root, JSCompiler_inline_result).flags |=
		                  256);
		              JSCompiler_inline_result = renderRootSync(
		                root,
		                JSCompiler_inline_result,
		                false
		              );
		              if (2 !== JSCompiler_inline_result) {
		                if (
		                  workInProgressRootDidAttachPingListener &&
		                  !wasRootDehydrated
		                ) {
		                  root.errorRecoveryDisabledLanes |= renderWasConcurrent;
		                  workInProgressRootInterleavedUpdatedLanes |=
		                    renderWasConcurrent;
		                  exitStatus = 4;
		                  break a;
		                }
		                renderWasConcurrent = workInProgressRootRecoverableErrors;
		                workInProgressRootRecoverableErrors = exitStatus;
		                null !== renderWasConcurrent &&
		                  queueRecoverableErrors(renderWasConcurrent);
		              }
		              exitStatus = JSCompiler_inline_result;
		            }
		            renderWasConcurrent = false;
		            if (2 !== exitStatus) continue;
		          }
		        }
		        if (1 === exitStatus) {
		          prepareFreshStack(root$jscomp$0, 0);
		          markRootSuspended(root$jscomp$0, lanes, 0, true);
		          break;
		        }
		        a: {
		          shouldTimeSlice = root$jscomp$0;
		          switch (exitStatus) {
		            case 0:
		            case 1:
		              throw Error(formatProdErrorMessage(345));
		            case 4:
		              if ((lanes & 4194176) === lanes) {
		                markRootSuspended(
		                  shouldTimeSlice,
		                  lanes,
		                  workInProgressDeferredLane,
		                  !workInProgressRootDidSkipSuspendedSiblings
		                );
		                break a;
		              }
		              break;
		            case 2:
		              workInProgressRootRecoverableErrors = null;
		              break;
		            case 3:
		            case 5:
		              break;
		            default:
		              throw Error(formatProdErrorMessage(329));
		          }
		          shouldTimeSlice.finishedWork = forceSync;
		          shouldTimeSlice.finishedLanes = lanes;
		          if (
		            (lanes & 62914560) === lanes &&
		            ((renderWasConcurrent = globalMostRecentFallbackTime + 300 - now()),
		            10 < renderWasConcurrent)
		          ) {
		            markRootSuspended(
		              shouldTimeSlice,
		              lanes,
		              workInProgressDeferredLane,
		              !workInProgressRootDidSkipSuspendedSiblings
		            );
		            if (0 !== getNextLanes(shouldTimeSlice, 0)) break a;
		            shouldTimeSlice.timeoutHandle = scheduleTimeout(
		              commitRootWhenReady.bind(
		                null,
		                shouldTimeSlice,
		                forceSync,
		                workInProgressRootRecoverableErrors,
		                workInProgressTransitions,
		                workInProgressRootDidIncludeRecursiveRenderUpdate,
		                lanes,
		                workInProgressDeferredLane,
		                workInProgressRootInterleavedUpdatedLanes,
		                workInProgressSuspendedRetryLanes,
		                workInProgressRootDidSkipSuspendedSiblings,
		                2,
		                -0,
		                0
		              ),
		              renderWasConcurrent
		            );
		            break a;
		          }
		          commitRootWhenReady(
		            shouldTimeSlice,
		            forceSync,
		            workInProgressRootRecoverableErrors,
		            workInProgressTransitions,
		            workInProgressRootDidIncludeRecursiveRenderUpdate,
		            lanes,
		            workInProgressDeferredLane,
		            workInProgressRootInterleavedUpdatedLanes,
		            workInProgressSuspendedRetryLanes,
		            workInProgressRootDidSkipSuspendedSiblings,
		            0,
		            -0,
		            0
		          );
		        }
		      }
		      break;
		    } while (1);
		    ensureRootIsScheduled(root$jscomp$0);
		  }
		  function queueRecoverableErrors(errors) {
		    null === workInProgressRootRecoverableErrors
		      ? (workInProgressRootRecoverableErrors = errors)
		      : workInProgressRootRecoverableErrors.push.apply(
		          workInProgressRootRecoverableErrors,
		          errors
		        );
		  }
		  function commitRootWhenReady(
		    root,
		    finishedWork,
		    recoverableErrors,
		    transitions,
		    didIncludeRenderPhaseUpdate,
		    lanes,
		    spawnedLane,
		    updatedLanes,
		    suspendedRetryLanes,
		    didSkipSuspendedSiblings,
		    suspendedCommitReason,
		    completedRenderStartTime,
		    completedRenderEndTime
		  ) {
		    var subtreeFlags = finishedWork.subtreeFlags;
		    if (subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408))
		      if (
		        (startSuspendingCommit(),
		        accumulateSuspenseyCommitOnFiber(finishedWork),
		        (finishedWork = waitForCommitToBeReady()),
		        null !== finishedWork)
		      ) {
		        root.cancelPendingCommit = finishedWork(
		          commitRoot.bind(
		            null,
		            root,
		            recoverableErrors,
		            transitions,
		            didIncludeRenderPhaseUpdate,
		            spawnedLane,
		            updatedLanes,
		            suspendedRetryLanes,
		            1,
		            completedRenderStartTime,
		            completedRenderEndTime
		          )
		        );
		        markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);
		        return;
		      }
		    commitRoot(
		      root,
		      recoverableErrors,
		      transitions,
		      didIncludeRenderPhaseUpdate,
		      spawnedLane,
		      updatedLanes,
		      suspendedRetryLanes,
		      suspendedCommitReason,
		      completedRenderStartTime,
		      completedRenderEndTime
		    );
		  }
		  function isRenderConsistentWithExternalStores(finishedWork) {
		    for (var node = finishedWork; ; ) {
		      var tag = node.tag;
		      if (
		        (0 === tag || 11 === tag || 15 === tag) &&
		        node.flags & 16384 &&
		        ((tag = node.updateQueue),
		        null !== tag && ((tag = tag.stores), null !== tag))
		      )
		        for (var i = 0; i < tag.length; i++) {
		          var check = tag[i],
		            getSnapshot = check.getSnapshot;
		          check = check.value;
		          try {
		            if (!objectIs(getSnapshot(), check)) return !1;
		          } catch (error) {
		            return false;
		          }
		        }
		      tag = node.child;
		      if (node.subtreeFlags & 16384 && null !== tag)
		        (tag.return = node), (node = tag);
		      else {
		        if (node === finishedWork) break;
		        for (; null === node.sibling; ) {
		          if (null === node.return || node.return === finishedWork) return true;
		          node = node.return;
		        }
		        node.sibling.return = node.return;
		        node = node.sibling;
		      }
		    }
		    return true;
		  }
		  function markRootSuspended(
		    root,
		    suspendedLanes,
		    spawnedLane,
		    didAttemptEntireTree
		  ) {
		    suspendedLanes &= ~workInProgressRootPingedLanes;
		    suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
		    root.suspendedLanes |= suspendedLanes;
		    root.pingedLanes &= ~suspendedLanes;
		    didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
		    didAttemptEntireTree = root.expirationTimes;
		    for (var lanes = suspendedLanes; 0 < lanes; ) {
		      var index$6 = 31 - clz32(lanes),
		        lane = 1 << index$6;
		      didAttemptEntireTree[index$6] = -1;
		      lanes &= ~lane;
		    }
		    0 !== spawnedLane &&
		      markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
		  }
		  function flushSyncWork() {
		    return 0 === (executionContext & 6)
		      ? (flushSyncWorkAcrossRoots_impl(0), false)
		      : true;
		  }
		  function resetWorkInProgressStack() {
		    if (null !== workInProgress) {
		      if (0 === workInProgressSuspendedReason)
		        var interruptedWork = workInProgress.return;
		      else
		        (interruptedWork = workInProgress),
		          (lastContextDependency = currentlyRenderingFiber = null),
		          resetHooksOnUnwind(interruptedWork),
		          (thenableState$1 = null),
		          (thenableIndexCounter$1 = 0),
		          (interruptedWork = workInProgress);
		      for (; null !== interruptedWork; )
		        unwindInterruptedWork(interruptedWork.alternate, interruptedWork),
		          (interruptedWork = interruptedWork.return);
		      workInProgress = null;
		    }
		  }
		  function prepareFreshStack(root, lanes) {
		    root.finishedWork = null;
		    root.finishedLanes = 0;
		    var timeoutHandle = root.timeoutHandle;
		    timeoutHandle !== noTimeout &&
		      ((root.timeoutHandle = noTimeout), cancelTimeout(timeoutHandle));
		    timeoutHandle = root.cancelPendingCommit;
		    null !== timeoutHandle &&
		      ((root.cancelPendingCommit = null), timeoutHandle());
		    resetWorkInProgressStack();
		    workInProgressRoot = root;
		    workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
		    workInProgressRootRenderLanes = lanes;
		    workInProgressSuspendedReason = 0;
		    workInProgressThrownValue = null;
		    workInProgressRootDidSkipSuspendedSiblings = false;
		    workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
		    workInProgressRootDidAttachPingListener = false;
		    workInProgressSuspendedRetryLanes =
		      workInProgressDeferredLane =
		      workInProgressRootPingedLanes =
		      workInProgressRootInterleavedUpdatedLanes =
		      workInProgressRootSkippedLanes =
		      workInProgressRootExitStatus =
		        0;
		    workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =
		      null;
		    workInProgressRootDidIncludeRecursiveRenderUpdate = false;
		    0 !== (lanes & 8) && (lanes |= lanes & 32);
		    var allEntangledLanes = root.entangledLanes;
		    if (0 !== allEntangledLanes)
		      for (
		        root = root.entanglements, allEntangledLanes &= lanes;
		        0 < allEntangledLanes;

		      ) {
		        var index$4 = 31 - clz32(allEntangledLanes),
		          lane = 1 << index$4;
		        lanes |= root[index$4];
		        allEntangledLanes &= ~lane;
		      }
		    entangledRenderLanes = lanes;
		    finishQueueingConcurrentUpdates();
		    return timeoutHandle;
		  }
		  function handleThrow(root, thrownValue) {
		    currentlyRenderingFiber$1 = null;
		    ReactSharedInternals.H = ContextOnlyDispatcher;
		    thrownValue === SuspenseException
		      ? ((thrownValue = getSuspendedThenable()),
		        (workInProgressSuspendedReason = 3))
		      : thrownValue === SuspenseyCommitException
		        ? ((thrownValue = getSuspendedThenable()),
		          (workInProgressSuspendedReason = 4))
		        : (workInProgressSuspendedReason =
		            thrownValue === SelectiveHydrationException
		              ? 8
		              : null !== thrownValue &&
		                  "object" === typeof thrownValue &&
		                  "function" === typeof thrownValue.then
		                ? 6
		                : 1);
		    workInProgressThrownValue = thrownValue;
		    null === workInProgress &&
		      ((workInProgressRootExitStatus = 1),
		      logUncaughtError(
		        root,
		        createCapturedValueAtFiber(thrownValue, root.current)
		      ));
		  }
		  function shouldRemainOnPreviousScreen() {
		    var handler = suspenseHandlerStackCursor.current;
		    return null === handler
		      ? true
		      : (workInProgressRootRenderLanes & 4194176) ===
		          workInProgressRootRenderLanes
		        ? null === shellBoundary
		          ? true
		          : false
		        : (workInProgressRootRenderLanes & 62914560) ===
		              workInProgressRootRenderLanes ||
		            0 !== (workInProgressRootRenderLanes & 536870912)
		          ? handler === shellBoundary
		          : false;
		  }
		  function pushDispatcher() {
		    var prevDispatcher = ReactSharedInternals.H;
		    ReactSharedInternals.H = ContextOnlyDispatcher;
		    return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
		  }
		  function pushAsyncDispatcher() {
		    var prevAsyncDispatcher = ReactSharedInternals.A;
		    ReactSharedInternals.A = DefaultAsyncDispatcher;
		    return prevAsyncDispatcher;
		  }
		  function renderDidSuspendDelayIfPossible() {
		    workInProgressRootExitStatus = 4;
		    workInProgressRootDidSkipSuspendedSiblings ||
		      ((workInProgressRootRenderLanes & 4194176) !==
		        workInProgressRootRenderLanes &&
		        null !== suspenseHandlerStackCursor.current) ||
		      (workInProgressRootIsPrerendering = true);
		    (0 === (workInProgressRootSkippedLanes & 134217727) &&
		      0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||
		      null === workInProgressRoot ||
		      markRootSuspended(
		        workInProgressRoot,
		        workInProgressRootRenderLanes,
		        workInProgressDeferredLane,
		        false
		      );
		  }
		  function renderRootSync(root, lanes, shouldYieldForPrerendering) {
		    var prevExecutionContext = executionContext;
		    executionContext |= 2;
		    var prevDispatcher = pushDispatcher(),
		      prevAsyncDispatcher = pushAsyncDispatcher();
		    if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes)
		      (workInProgressTransitions = null), prepareFreshStack(root, lanes);
		    lanes = false;
		    var exitStatus = workInProgressRootExitStatus;
		    a: do
		      try {
		        if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
		          var unitOfWork = workInProgress,
		            thrownValue = workInProgressThrownValue;
		          switch (workInProgressSuspendedReason) {
		            case 8:
		              resetWorkInProgressStack();
		              exitStatus = 6;
		              break a;
		            case 3:
		            case 2:
		            case 6:
		              null === suspenseHandlerStackCursor.current && (lanes = !0);
		              var reason = workInProgressSuspendedReason;
		              workInProgressSuspendedReason = 0;
		              workInProgressThrownValue = null;
		              throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
		              if (
		                shouldYieldForPrerendering &&
		                workInProgressRootIsPrerendering
		              ) {
		                exitStatus = 0;
		                break a;
		              }
		              break;
		            default:
		              (reason = workInProgressSuspendedReason),
		                (workInProgressSuspendedReason = 0),
		                (workInProgressThrownValue = null),
		                throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
		          }
		        }
		        workLoopSync();
		        exitStatus = workInProgressRootExitStatus;
		        break;
		      } catch (thrownValue$151) {
		        handleThrow(root, thrownValue$151);
		      }
		    while (1);
		    lanes && root.shellSuspendCounter++;
		    lastContextDependency = currentlyRenderingFiber = null;
		    executionContext = prevExecutionContext;
		    ReactSharedInternals.H = prevDispatcher;
		    ReactSharedInternals.A = prevAsyncDispatcher;
		    null === workInProgress &&
		      ((workInProgressRoot = null),
		      (workInProgressRootRenderLanes = 0),
		      finishQueueingConcurrentUpdates());
		    return exitStatus;
		  }
		  function workLoopSync() {
		    for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
		  }
		  function renderRootConcurrent(root, lanes) {
		    var prevExecutionContext = executionContext;
		    executionContext |= 2;
		    var prevDispatcher = pushDispatcher(),
		      prevAsyncDispatcher = pushAsyncDispatcher();
		    workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes
		      ? ((workInProgressTransitions = null),
		        (workInProgressRootRenderTargetTime = now() + 500),
		        prepareFreshStack(root, lanes))
		      : (workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
		          root,
		          lanes
		        ));
		    a: do
		      try {
		        if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
		          lanes = workInProgress;
		          var thrownValue = workInProgressThrownValue;
		          b: switch (workInProgressSuspendedReason) {
		            case 1:
		              workInProgressSuspendedReason = 0;
		              workInProgressThrownValue = null;
		              throwAndUnwindWorkLoop(root, lanes, thrownValue, 1);
		              break;
		            case 2:
		              if (isThenableResolved(thrownValue)) {
		                workInProgressSuspendedReason = 0;
		                workInProgressThrownValue = null;
		                replaySuspendedUnitOfWork(lanes);
		                break;
		              }
		              lanes = function () {
		                2 === workInProgressSuspendedReason &&
		                  workInProgressRoot === root &&
		                  (workInProgressSuspendedReason = 7);
		                ensureRootIsScheduled(root);
		              };
		              thrownValue.then(lanes, lanes);
		              break a;
		            case 3:
		              workInProgressSuspendedReason = 7;
		              break a;
		            case 4:
		              workInProgressSuspendedReason = 5;
		              break a;
		            case 7:
		              isThenableResolved(thrownValue)
		                ? ((workInProgressSuspendedReason = 0),
		                  (workInProgressThrownValue = null),
		                  replaySuspendedUnitOfWork(lanes))
		                : ((workInProgressSuspendedReason = 0),
		                  (workInProgressThrownValue = null),
		                  throwAndUnwindWorkLoop(root, lanes, thrownValue, 7));
		              break;
		            case 5:
		              var resource = null;
		              switch (workInProgress.tag) {
		                case 26:
		                  resource = workInProgress.memoizedState;
		                case 5:
		                case 27:
		                  var hostFiber = workInProgress,
		                    type = hostFiber.type,
		                    props = hostFiber.pendingProps;
		                  if (
		                    resource
		                      ? preloadResource(resource)
		                      : preloadInstance(type, props)
		                  ) {
		                    workInProgressSuspendedReason = 0;
		                    workInProgressThrownValue = null;
		                    var sibling = hostFiber.sibling;
		                    if (null !== sibling) workInProgress = sibling;
		                    else {
		                      var returnFiber = hostFiber.return;
		                      null !== returnFiber
		                        ? ((workInProgress = returnFiber),
		                          completeUnitOfWork(returnFiber))
		                        : (workInProgress = null);
		                    }
		                    break b;
		                  }
		              }
		              workInProgressSuspendedReason = 0;
		              workInProgressThrownValue = null;
		              throwAndUnwindWorkLoop(root, lanes, thrownValue, 5);
		              break;
		            case 6:
		              workInProgressSuspendedReason = 0;
		              workInProgressThrownValue = null;
		              throwAndUnwindWorkLoop(root, lanes, thrownValue, 6);
		              break;
		            case 8:
		              resetWorkInProgressStack();
		              workInProgressRootExitStatus = 6;
		              break a;
		            default:
		              throw Error(formatProdErrorMessage(462));
		          }
		        }
		        workLoopConcurrent();
		        break;
		      } catch (thrownValue$153) {
		        handleThrow(root, thrownValue$153);
		      }
		    while (1);
		    lastContextDependency = currentlyRenderingFiber = null;
		    ReactSharedInternals.H = prevDispatcher;
		    ReactSharedInternals.A = prevAsyncDispatcher;
		    executionContext = prevExecutionContext;
		    if (null !== workInProgress) return 0;
		    workInProgressRoot = null;
		    workInProgressRootRenderLanes = 0;
		    finishQueueingConcurrentUpdates();
		    return workInProgressRootExitStatus;
		  }
		  function workLoopConcurrent() {
		    for (; null !== workInProgress && !shouldYield(); )
		      performUnitOfWork(workInProgress);
		  }
		  function performUnitOfWork(unitOfWork) {
		    var next = beginWork(
		      unitOfWork.alternate,
		      unitOfWork,
		      entangledRenderLanes
		    );
		    unitOfWork.memoizedProps = unitOfWork.pendingProps;
		    null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
		  }
		  function replaySuspendedUnitOfWork(unitOfWork) {
		    var next = unitOfWork;
		    var current = next.alternate;
		    switch (next.tag) {
		      case 15:
		      case 0:
		        next = replayFunctionComponent(
		          current,
		          next,
		          next.pendingProps,
		          next.type,
		          void 0,
		          workInProgressRootRenderLanes
		        );
		        break;
		      case 11:
		        next = replayFunctionComponent(
		          current,
		          next,
		          next.pendingProps,
		          next.type.render,
		          next.ref,
		          workInProgressRootRenderLanes
		        );
		        break;
		      case 5:
		        resetHooksOnUnwind(next);
		      default:
		        unwindInterruptedWork(current, next),
		          (next = workInProgress =
		            resetWorkInProgress(next, entangledRenderLanes)),
		          (next = beginWork(current, next, entangledRenderLanes));
		    }
		    unitOfWork.memoizedProps = unitOfWork.pendingProps;
		    null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
		  }
		  function throwAndUnwindWorkLoop(
		    root,
		    unitOfWork,
		    thrownValue,
		    suspendedReason
		  ) {
		    lastContextDependency = currentlyRenderingFiber = null;
		    resetHooksOnUnwind(unitOfWork);
		    thenableState$1 = null;
		    thenableIndexCounter$1 = 0;
		    var returnFiber = unitOfWork.return;
		    try {
		      if (
		        throwException(
		          root,
		          returnFiber,
		          unitOfWork,
		          thrownValue,
		          workInProgressRootRenderLanes
		        )
		      ) {
		        workInProgressRootExitStatus = 1;
		        logUncaughtError(
		          root,
		          createCapturedValueAtFiber(thrownValue, root.current)
		        );
		        workInProgress = null;
		        return;
		      }
		    } catch (error) {
		      if (null !== returnFiber) throw ((workInProgress = returnFiber), error);
		      workInProgressRootExitStatus = 1;
		      logUncaughtError(
		        root,
		        createCapturedValueAtFiber(thrownValue, root.current)
		      );
		      workInProgress = null;
		      return;
		    }
		    if (unitOfWork.flags & 32768) {
		      if (isHydrating || 1 === suspendedReason) root = true;
		      else if (
		        workInProgressRootIsPrerendering ||
		        0 !== (workInProgressRootRenderLanes & 536870912)
		      )
		        root = false;
		      else if (
		        ((workInProgressRootDidSkipSuspendedSiblings = root = true),
		        2 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)
		      )
		        (suspendedReason = suspenseHandlerStackCursor.current),
		          null !== suspendedReason &&
		            13 === suspendedReason.tag &&
		            (suspendedReason.flags |= 16384);
		      unwindUnitOfWork(unitOfWork, root);
		    } else completeUnitOfWork(unitOfWork);
		  }
		  function completeUnitOfWork(unitOfWork) {
		    var completedWork = unitOfWork;
		    do {
		      if (0 !== (completedWork.flags & 32768)) {
		        unwindUnitOfWork(
		          completedWork,
		          workInProgressRootDidSkipSuspendedSiblings
		        );
		        return;
		      }
		      unitOfWork = completedWork.return;
		      var next = completeWork(
		        completedWork.alternate,
		        completedWork,
		        entangledRenderLanes
		      );
		      if (null !== next) {
		        workInProgress = next;
		        return;
		      }
		      completedWork = completedWork.sibling;
		      if (null !== completedWork) {
		        workInProgress = completedWork;
		        return;
		      }
		      workInProgress = completedWork = unitOfWork;
		    } while (null !== completedWork);
		    0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
		  }
		  function unwindUnitOfWork(unitOfWork, skipSiblings) {
		    do {
		      var next = unwindWork(unitOfWork.alternate, unitOfWork);
		      if (null !== next) {
		        next.flags &= 32767;
		        workInProgress = next;
		        return;
		      }
		      next = unitOfWork.return;
		      null !== next &&
		        ((next.flags |= 32768),
		        (next.subtreeFlags = 0),
		        (next.deletions = null));
		      if (
		        !skipSiblings &&
		        ((unitOfWork = unitOfWork.sibling), null !== unitOfWork)
		      ) {
		        workInProgress = unitOfWork;
		        return;
		      }
		      workInProgress = unitOfWork = next;
		    } while (null !== unitOfWork);
		    workInProgressRootExitStatus = 6;
		    workInProgress = null;
		  }
		  function commitRoot(
		    root,
		    recoverableErrors,
		    transitions,
		    didIncludeRenderPhaseUpdate,
		    spawnedLane,
		    updatedLanes,
		    suspendedRetryLanes,
		    suspendedCommitReason,
		    completedRenderStartTime,
		    completedRenderEndTime
		  ) {
		    var prevTransition = ReactSharedInternals.T,
		      previousUpdateLanePriority = getCurrentUpdatePriority();
		    try {
		      setCurrentUpdatePriority(2),
		        (ReactSharedInternals.T = null),
		        commitRootImpl(
		          root,
		          recoverableErrors,
		          transitions,
		          didIncludeRenderPhaseUpdate,
		          previousUpdateLanePriority,
		          spawnedLane,
		          updatedLanes,
		          suspendedRetryLanes,
		          suspendedCommitReason,
		          completedRenderStartTime,
		          completedRenderEndTime
		        );
		    } finally {
		      (ReactSharedInternals.T = prevTransition),
		        setCurrentUpdatePriority(previousUpdateLanePriority);
		    }
		  }
		  function commitRootImpl(
		    root,
		    recoverableErrors,
		    transitions,
		    didIncludeRenderPhaseUpdate,
		    renderPriorityLevel,
		    spawnedLane,
		    updatedLanes,
		    suspendedRetryLanes
		  ) {
		    do flushPassiveEffects();
		    while (null !== rootWithPendingPassiveEffects);
		    if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
		    var finishedWork = root.finishedWork;
		    didIncludeRenderPhaseUpdate = root.finishedLanes;
		    if (null === finishedWork) return null;
		    root.finishedWork = null;
		    root.finishedLanes = 0;
		    if (finishedWork === root.current) throw Error(formatProdErrorMessage(177));
		    root.callbackNode = null;
		    root.callbackPriority = 0;
		    root.cancelPendingCommit = null;
		    var remainingLanes = finishedWork.lanes | finishedWork.childLanes;
		    remainingLanes |= concurrentlyUpdatedLanes;
		    markRootFinished(
		      root,
		      didIncludeRenderPhaseUpdate,
		      remainingLanes,
		      spawnedLane,
		      updatedLanes,
		      suspendedRetryLanes
		    );
		    root === workInProgressRoot &&
		      ((workInProgress = workInProgressRoot = null),
		      (workInProgressRootRenderLanes = 0));
		    (0 === (finishedWork.subtreeFlags & 10256) &&
		      0 === (finishedWork.flags & 10256)) ||
		      rootDoesHavePassiveEffects ||
		      ((rootDoesHavePassiveEffects = true),
		      (pendingPassiveEffectsRemainingLanes = remainingLanes),
		      (pendingPassiveTransitions = transitions),
		      scheduleCallback(NormalPriority$1, function () {
		        flushPassiveEffects();
		        return null;
		      }));
		    transitions = 0 !== (finishedWork.flags & 15990);
		    0 !== (finishedWork.subtreeFlags & 15990) || transitions
		      ? ((transitions = ReactSharedInternals.T),
		        (ReactSharedInternals.T = null),
		        (spawnedLane = getCurrentUpdatePriority()),
		        setCurrentUpdatePriority(2),
		        (updatedLanes = executionContext),
		        (executionContext |= 4),
		        commitBeforeMutationEffects(root, finishedWork),
		        commitMutationEffectsOnFiber(finishedWork, root),
		        resetAfterCommit(root.containerInfo),
		        (root.current = finishedWork),
		        commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork),
		        requestPaint(),
		        (executionContext = updatedLanes),
		        setCurrentUpdatePriority(spawnedLane),
		        (ReactSharedInternals.T = transitions))
		      : (root.current = finishedWork);
		    rootDoesHavePassiveEffects
		      ? ((rootDoesHavePassiveEffects = false),
		        (rootWithPendingPassiveEffects = root),
		        (pendingPassiveEffectsLanes = didIncludeRenderPhaseUpdate))
		      : releaseRootPooledCache(root, remainingLanes);
		    remainingLanes = root.pendingLanes;
		    0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
		    onCommitRoot(finishedWork.stateNode);
		    ensureRootIsScheduled(root);
		    if (null !== recoverableErrors)
		      for (
		        renderPriorityLevel = root.onRecoverableError, finishedWork = 0;
		        finishedWork < recoverableErrors.length;
		        finishedWork++
		      )
		        (remainingLanes = recoverableErrors[finishedWork]),
		          renderPriorityLevel(remainingLanes.value, {
		            componentStack: remainingLanes.stack
		          });
		    0 !== (pendingPassiveEffectsLanes & 3) && flushPassiveEffects();
		    remainingLanes = root.pendingLanes;
		    0 !== (didIncludeRenderPhaseUpdate & 4194218) && 0 !== (remainingLanes & 42)
		      ? root === rootWithNestedUpdates
		        ? nestedUpdateCount++
		        : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root))
		      : (nestedUpdateCount = 0);
		    flushSyncWorkAcrossRoots_impl(0);
		    return null;
		  }
		  function releaseRootPooledCache(root, remainingLanes) {
		    0 === (root.pooledCacheLanes &= remainingLanes) &&
		      ((remainingLanes = root.pooledCache),
		      null != remainingLanes &&
		        ((root.pooledCache = null), releaseCache(remainingLanes)));
		  }
		  function flushPassiveEffects() {
		    if (null !== rootWithPendingPassiveEffects) {
		      var root = rootWithPendingPassiveEffects,
		        remainingLanes = pendingPassiveEffectsRemainingLanes;
		      pendingPassiveEffectsRemainingLanes = 0;
		      var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes),
		        priority = 32 > renderPriority ? 32 : renderPriority;
		      renderPriority = ReactSharedInternals.T;
		      var previousPriority = getCurrentUpdatePriority();
		      try {
		        setCurrentUpdatePriority(priority);
		        ReactSharedInternals.T = null;
		        if (null === rootWithPendingPassiveEffects)
		          var JSCompiler_inline_result = !1;
		        else {
		          priority = pendingPassiveTransitions;
		          pendingPassiveTransitions = null;
		          var root$jscomp$0 = rootWithPendingPassiveEffects,
		            lanes = pendingPassiveEffectsLanes;
		          rootWithPendingPassiveEffects = null;
		          pendingPassiveEffectsLanes = 0;
		          if (0 !== (executionContext & 6))
		            throw Error(formatProdErrorMessage(331));
		          var prevExecutionContext = executionContext;
		          executionContext |= 4;
		          commitPassiveUnmountOnFiber(root$jscomp$0.current);
		          commitPassiveMountOnFiber(
		            root$jscomp$0,
		            root$jscomp$0.current,
		            lanes,
		            priority
		          );
		          executionContext = prevExecutionContext;
		          flushSyncWorkAcrossRoots_impl(0, !1);
		          if (
		            injectedHook &&
		            "function" === typeof injectedHook.onPostCommitFiberRoot
		          )
		            try {
		              injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
		            } catch (err) {}
		          JSCompiler_inline_result = !0;
		        }
		        return JSCompiler_inline_result;
		      } finally {
		        setCurrentUpdatePriority(previousPriority),
		          (ReactSharedInternals.T = renderPriority),
		          releaseRootPooledCache(root, remainingLanes);
		      }
		    }
		    return false;
		  }
		  function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
		    sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
		    sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
		    rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
		    null !== rootFiber &&
		      (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
		  }
		  function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
		    if (3 === sourceFiber.tag)
		      captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
		    else
		      for (; null !== nearestMountedAncestor; ) {
		        if (3 === nearestMountedAncestor.tag) {
		          captureCommitPhaseErrorOnRoot(
		            nearestMountedAncestor,
		            sourceFiber,
		            error
		          );
		          break;
		        } else if (1 === nearestMountedAncestor.tag) {
		          var instance = nearestMountedAncestor.stateNode;
		          if (
		            "function" ===
		              typeof nearestMountedAncestor.type.getDerivedStateFromError ||
		            ("function" === typeof instance.componentDidCatch &&
		              (null === legacyErrorBoundariesThatAlreadyFailed ||
		                !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
		          ) {
		            sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
		            error = createClassErrorUpdate(2);
		            instance = enqueueUpdate(nearestMountedAncestor, error, 2);
		            null !== instance &&
		              (initializeClassErrorUpdate(
		                error,
		                instance,
		                nearestMountedAncestor,
		                sourceFiber
		              ),
		              markRootUpdated$1(instance, 2),
		              ensureRootIsScheduled(instance));
		            break;
		          }
		        }
		        nearestMountedAncestor = nearestMountedAncestor.return;
		      }
		  }
		  function attachPingListener(root, wakeable, lanes) {
		    var pingCache = root.pingCache;
		    if (null === pingCache) {
		      pingCache = root.pingCache = new PossiblyWeakMap();
		      var threadIDs = new Set();
		      pingCache.set(wakeable, threadIDs);
		    } else
		      (threadIDs = pingCache.get(wakeable)),
		        void 0 === threadIDs &&
		          ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs));
		    threadIDs.has(lanes) ||
		      ((workInProgressRootDidAttachPingListener = true),
		      threadIDs.add(lanes),
		      (root = pingSuspendedRoot.bind(null, root, wakeable, lanes)),
		      wakeable.then(root, root));
		  }
		  function pingSuspendedRoot(root, wakeable, pingedLanes) {
		    var pingCache = root.pingCache;
		    null !== pingCache && pingCache.delete(wakeable);
		    root.pingedLanes |= root.suspendedLanes & pingedLanes;
		    root.warmLanes &= ~pingedLanes;
		    workInProgressRoot === root &&
		      (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
		      (4 === workInProgressRootExitStatus ||
		      (3 === workInProgressRootExitStatus &&
		        (workInProgressRootRenderLanes & 62914560) ===
		          workInProgressRootRenderLanes &&
		        300 > now() - globalMostRecentFallbackTime)
		        ? 0 === (executionContext & 2) && prepareFreshStack(root, 0)
		        : (workInProgressRootPingedLanes |= pingedLanes),
		      workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes &&
		        (workInProgressSuspendedRetryLanes = 0));
		    ensureRootIsScheduled(root);
		  }
		  function retryTimedOutBoundary(boundaryFiber, retryLane) {
		    0 === retryLane && (retryLane = claimNextRetryLane());
		    boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
		    null !== boundaryFiber &&
		      (markRootUpdated$1(boundaryFiber, retryLane),
		      ensureRootIsScheduled(boundaryFiber));
		  }
		  function retryDehydratedSuspenseBoundary(boundaryFiber) {
		    var suspenseState = boundaryFiber.memoizedState,
		      retryLane = 0;
		    null !== suspenseState && (retryLane = suspenseState.retryLane);
		    retryTimedOutBoundary(boundaryFiber, retryLane);
		  }
		  function resolveRetryWakeable(boundaryFiber, wakeable) {
		    var retryLane = 0;
		    switch (boundaryFiber.tag) {
		      case 13:
		        var retryCache = boundaryFiber.stateNode;
		        var suspenseState = boundaryFiber.memoizedState;
		        null !== suspenseState && (retryLane = suspenseState.retryLane);
		        break;
		      case 19:
		        retryCache = boundaryFiber.stateNode;
		        break;
		      case 22:
		        retryCache = boundaryFiber.stateNode._retryCache;
		        break;
		      default:
		        throw Error(formatProdErrorMessage(314));
		    }
		    null !== retryCache && retryCache.delete(wakeable);
		    retryTimedOutBoundary(boundaryFiber, retryLane);
		  }
		  function scheduleCallback(priorityLevel, callback) {
		    return scheduleCallback$3(priorityLevel, callback);
		  }
		  function FiberNode(tag, pendingProps, key, mode) {
		    this.tag = tag;
		    this.key = key;
		    this.sibling =
		      this.child =
		      this.return =
		      this.stateNode =
		      this.type =
		      this.elementType =
		        null;
		    this.index = 0;
		    this.refCleanup = this.ref = null;
		    this.pendingProps = pendingProps;
		    this.dependencies =
		      this.memoizedState =
		      this.updateQueue =
		      this.memoizedProps =
		        null;
		    this.mode = mode;
		    this.subtreeFlags = this.flags = 0;
		    this.deletions = null;
		    this.childLanes = this.lanes = 0;
		    this.alternate = null;
		  }
		  function shouldConstruct(Component) {
		    Component = Component.prototype;
		    return !(!Component || !Component.isReactComponent);
		  }
		  function createWorkInProgress(current, pendingProps) {
		    var workInProgress = current.alternate;
		    null === workInProgress
		      ? ((workInProgress = createFiber(
		          current.tag,
		          pendingProps,
		          current.key,
		          current.mode
		        )),
		        (workInProgress.elementType = current.elementType),
		        (workInProgress.type = current.type),
		        (workInProgress.stateNode = current.stateNode),
		        (workInProgress.alternate = current),
		        (current.alternate = workInProgress))
		      : ((workInProgress.pendingProps = pendingProps),
		        (workInProgress.type = current.type),
		        (workInProgress.flags = 0),
		        (workInProgress.subtreeFlags = 0),
		        (workInProgress.deletions = null));
		    workInProgress.flags = current.flags & 31457280;
		    workInProgress.childLanes = current.childLanes;
		    workInProgress.lanes = current.lanes;
		    workInProgress.child = current.child;
		    workInProgress.memoizedProps = current.memoizedProps;
		    workInProgress.memoizedState = current.memoizedState;
		    workInProgress.updateQueue = current.updateQueue;
		    pendingProps = current.dependencies;
		    workInProgress.dependencies =
		      null === pendingProps
		        ? null
		        : {
		            lanes: pendingProps.lanes,
		            firstContext: pendingProps.firstContext
		          };
		    workInProgress.sibling = current.sibling;
		    workInProgress.index = current.index;
		    workInProgress.ref = current.ref;
		    workInProgress.refCleanup = current.refCleanup;
		    return workInProgress;
		  }
		  function resetWorkInProgress(workInProgress, renderLanes) {
		    workInProgress.flags &= 31457282;
		    var current = workInProgress.alternate;
		    null === current
		      ? ((workInProgress.childLanes = 0),
		        (workInProgress.lanes = renderLanes),
		        (workInProgress.child = null),
		        (workInProgress.subtreeFlags = 0),
		        (workInProgress.memoizedProps = null),
		        (workInProgress.memoizedState = null),
		        (workInProgress.updateQueue = null),
		        (workInProgress.dependencies = null),
		        (workInProgress.stateNode = null))
		      : ((workInProgress.childLanes = current.childLanes),
		        (workInProgress.lanes = current.lanes),
		        (workInProgress.child = current.child),
		        (workInProgress.subtreeFlags = 0),
		        (workInProgress.deletions = null),
		        (workInProgress.memoizedProps = current.memoizedProps),
		        (workInProgress.memoizedState = current.memoizedState),
		        (workInProgress.updateQueue = current.updateQueue),
		        (workInProgress.type = current.type),
		        (renderLanes = current.dependencies),
		        (workInProgress.dependencies =
		          null === renderLanes
		            ? null
		            : {
		                lanes: renderLanes.lanes,
		                firstContext: renderLanes.firstContext
		              }));
		    return workInProgress;
		  }
		  function createFiberFromTypeAndProps(
		    type,
		    key,
		    pendingProps,
		    owner,
		    mode,
		    lanes
		  ) {
		    var fiberTag = 0;
		    owner = type;
		    if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
		    else if ("string" === typeof type)
		      fiberTag =
		        supportsResources && supportsSingletons
		          ? isHostHoistableType(type, pendingProps, contextStackCursor.current)
		            ? 26
		            : isHostSingletonType(type)
		              ? 27
		              : 5
		          : supportsResources
		            ? isHostHoistableType(
		                type,
		                pendingProps,
		                contextStackCursor.current
		              )
		              ? 26
		              : 5
		            : supportsSingletons
		              ? isHostSingletonType(type)
		                ? 27
		                : 5
		              : 5;
		    else
		      a: switch (type) {
		        case REACT_FRAGMENT_TYPE:
		          return createFiberFromFragment(
		            pendingProps.children,
		            mode,
		            lanes,
		            key
		          );
		        case REACT_STRICT_MODE_TYPE:
		          fiberTag = 8;
		          mode |= 24;
		          break;
		        case REACT_PROFILER_TYPE:
		          return (
		            (type = createFiber(12, pendingProps, key, mode | 2)),
		            (type.elementType = REACT_PROFILER_TYPE),
		            (type.lanes = lanes),
		            type
		          );
		        case REACT_SUSPENSE_TYPE:
		          return (
		            (type = createFiber(13, pendingProps, key, mode)),
		            (type.elementType = REACT_SUSPENSE_TYPE),
		            (type.lanes = lanes),
		            type
		          );
		        case REACT_SUSPENSE_LIST_TYPE:
		          return (
		            (type = createFiber(19, pendingProps, key, mode)),
		            (type.elementType = REACT_SUSPENSE_LIST_TYPE),
		            (type.lanes = lanes),
		            type
		          );
		        case REACT_OFFSCREEN_TYPE:
		          return createFiberFromOffscreen(pendingProps, mode, lanes, key);
		        default:
		          if ("object" === typeof type && null !== type)
		            switch (type.$$typeof) {
		              case REACT_PROVIDER_TYPE:
		              case REACT_CONTEXT_TYPE:
		                fiberTag = 10;
		                break a;
		              case REACT_CONSUMER_TYPE:
		                fiberTag = 9;
		                break a;
		              case REACT_FORWARD_REF_TYPE:
		                fiberTag = 11;
		                break a;
		              case REACT_MEMO_TYPE:
		                fiberTag = 14;
		                break a;
		              case REACT_LAZY_TYPE:
		                fiberTag = 16;
		                owner = null;
		                break a;
		            }
		          fiberTag = 29;
		          pendingProps = Error(
		            formatProdErrorMessage(
		              130,
		              null === type ? "null" : typeof type,
		              ""
		            )
		          );
		          owner = null;
		      }
		    key = createFiber(fiberTag, pendingProps, key, mode);
		    key.elementType = type;
		    key.type = owner;
		    key.lanes = lanes;
		    return key;
		  }
		  function createFiberFromFragment(elements, mode, lanes, key) {
		    elements = createFiber(7, elements, key, mode);
		    elements.lanes = lanes;
		    return elements;
		  }
		  function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
		    pendingProps = createFiber(22, pendingProps, key, mode);
		    pendingProps.elementType = REACT_OFFSCREEN_TYPE;
		    pendingProps.lanes = lanes;
		    var primaryChildInstance = {
		      _visibility: 1,
		      _pendingVisibility: 1,
		      _pendingMarkers: null,
		      _retryCache: null,
		      _transitions: null,
		      _current: null,
		      detach: function () {
		        var fiber = primaryChildInstance._current;
		        if (null === fiber) throw Error(formatProdErrorMessage(456));
		        if (0 === (primaryChildInstance._pendingVisibility & 2)) {
		          var root = enqueueConcurrentRenderForLane(fiber, 2);
		          null !== root &&
		            ((primaryChildInstance._pendingVisibility |= 2),
		            scheduleUpdateOnFiber(root, fiber, 2));
		        }
		      },
		      attach: function () {
		        var fiber = primaryChildInstance._current;
		        if (null === fiber) throw Error(formatProdErrorMessage(456));
		        if (0 !== (primaryChildInstance._pendingVisibility & 2)) {
		          var root = enqueueConcurrentRenderForLane(fiber, 2);
		          null !== root &&
		            ((primaryChildInstance._pendingVisibility &= -3),
		            scheduleUpdateOnFiber(root, fiber, 2));
		        }
		      }
		    };
		    pendingProps.stateNode = primaryChildInstance;
		    return pendingProps;
		  }
		  function createFiberFromText(content, mode, lanes) {
		    content = createFiber(6, content, null, mode);
		    content.lanes = lanes;
		    return content;
		  }
		  function createFiberFromPortal(portal, mode, lanes) {
		    mode = createFiber(
		      4,
		      null !== portal.children ? portal.children : [],
		      portal.key,
		      mode
		    );
		    mode.lanes = lanes;
		    mode.stateNode = {
		      containerInfo: portal.containerInfo,
		      pendingChildren: null,
		      implementation: portal.implementation
		    };
		    return mode;
		  }
		  function FiberRootNode(
		    containerInfo,
		    tag,
		    hydrate,
		    identifierPrefix,
		    onUncaughtError,
		    onCaughtError,
		    onRecoverableError,
		    formState
		  ) {
		    this.tag = 1;
		    this.containerInfo = containerInfo;
		    this.finishedWork =
		      this.pingCache =
		      this.current =
		      this.pendingChildren =
		        null;
		    this.timeoutHandle = noTimeout;
		    this.callbackNode =
		      this.next =
		      this.pendingContext =
		      this.context =
		      this.cancelPendingCommit =
		        null;
		    this.callbackPriority = 0;
		    this.expirationTimes = createLaneMap(-1);
		    this.entangledLanes =
		      this.shellSuspendCounter =
		      this.errorRecoveryDisabledLanes =
		      this.finishedLanes =
		      this.expiredLanes =
		      this.warmLanes =
		      this.pingedLanes =
		      this.suspendedLanes =
		      this.pendingLanes =
		        0;
		    this.entanglements = createLaneMap(0);
		    this.hiddenUpdates = createLaneMap(null);
		    this.identifierPrefix = identifierPrefix;
		    this.onUncaughtError = onUncaughtError;
		    this.onCaughtError = onCaughtError;
		    this.onRecoverableError = onRecoverableError;
		    this.pooledCache = null;
		    this.pooledCacheLanes = 0;
		    this.formState = formState;
		    this.incompleteTransitions = new Map();
		  }
		  function createFiberRoot(
		    containerInfo,
		    tag,
		    hydrate,
		    initialChildren,
		    hydrationCallbacks,
		    isStrictMode,
		    identifierPrefix,
		    onUncaughtError,
		    onCaughtError,
		    onRecoverableError,
		    transitionCallbacks,
		    formState
		  ) {
		    containerInfo = new FiberRootNode(
		      containerInfo,
		      tag,
		      hydrate,
		      identifierPrefix,
		      onUncaughtError,
		      onCaughtError,
		      onRecoverableError,
		      formState
		    );
		    tag = 1;
		    true === isStrictMode && (tag |= 24);
		    isStrictMode = createFiber(3, null, null, tag);
		    containerInfo.current = isStrictMode;
		    isStrictMode.stateNode = containerInfo;
		    tag = createCache();
		    tag.refCount++;
		    containerInfo.pooledCache = tag;
		    tag.refCount++;
		    isStrictMode.memoizedState = {
		      element: initialChildren,
		      isDehydrated: hydrate,
		      cache: tag
		    };
		    initializeUpdateQueue(isStrictMode);
		    return containerInfo;
		  }
		  function getContextForSubtree(parentComponent) {
		    if (!parentComponent) return emptyContextObject;
		    parentComponent = emptyContextObject;
		    return parentComponent;
		  }
		  function findHostInstance(component) {
		    var fiber = component._reactInternals;
		    if (void 0 === fiber) {
		      if ("function" === typeof component.render)
		        throw Error(formatProdErrorMessage(188));
		      component = Object.keys(component).join(",");
		      throw Error(formatProdErrorMessage(268, component));
		    }
		    component = findCurrentFiberUsingSlowPath(fiber);
		    component = null !== component ? findCurrentHostFiberImpl(component) : null;
		    return null === component ? null : getPublicInstance(component.stateNode);
		  }
		  function updateContainerImpl(
		    rootFiber,
		    lane,
		    element,
		    container,
		    parentComponent,
		    callback
		  ) {
		    parentComponent = getContextForSubtree(parentComponent);
		    null === container.context
		      ? (container.context = parentComponent)
		      : (container.pendingContext = parentComponent);
		    container = createUpdate(lane);
		    container.payload = { element: element };
		    callback = void 0 === callback ? null : callback;
		    null !== callback && (container.callback = callback);
		    element = enqueueUpdate(rootFiber, container, lane);
		    null !== element &&
		      (scheduleUpdateOnFiber(element, rootFiber, lane),
		      entangleTransitions(element, rootFiber, lane));
		  }
		  function markRetryLaneImpl(fiber, retryLane) {
		    fiber = fiber.memoizedState;
		    if (null !== fiber && null !== fiber.dehydrated) {
		      var a = fiber.retryLane;
		      fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
		    }
		  }
		  function markRetryLaneIfNotHydrated(fiber, retryLane) {
		    markRetryLaneImpl(fiber, retryLane);
		    (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
		  }
		  var exports = {};
		  var React = React__default,
		    Scheduler = requireScheduler$1(),
		    assign = Object.assign,
		    REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
		    REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
		    REACT_PORTAL_TYPE = Symbol.for("react.portal"),
		    REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
		    REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
		    REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
		    REACT_PROVIDER_TYPE = Symbol.for("react.provider"),
		    REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
		    REACT_CONTEXT_TYPE = Symbol.for("react.context"),
		    REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
		    REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
		    REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
		    REACT_MEMO_TYPE = Symbol.for("react.memo"),
		    REACT_LAZY_TYPE = Symbol.for("react.lazy");
		  var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
		  var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
		    MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
		    REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
		    ReactSharedInternals =
		      React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
		    prefix,
		    suffix,
		    reentry = false,
		    isArrayImpl = Array.isArray,
		    rendererVersion = $$$config.rendererVersion,
		    rendererPackageName = $$$config.rendererPackageName,
		    extraDevToolsConfig = $$$config.extraDevToolsConfig,
		    getPublicInstance = $$$config.getPublicInstance,
		    getRootHostContext = $$$config.getRootHostContext,
		    getChildHostContext = $$$config.getChildHostContext,
		    prepareForCommit = $$$config.prepareForCommit,
		    resetAfterCommit = $$$config.resetAfterCommit,
		    createInstance = $$$config.createInstance,
		    appendInitialChild = $$$config.appendInitialChild,
		    finalizeInitialChildren = $$$config.finalizeInitialChildren,
		    shouldSetTextContent = $$$config.shouldSetTextContent,
		    createTextInstance = $$$config.createTextInstance,
		    scheduleTimeout = $$$config.scheduleTimeout,
		    cancelTimeout = $$$config.cancelTimeout,
		    noTimeout = $$$config.noTimeout,
		    isPrimaryRenderer = $$$config.isPrimaryRenderer;
		  $$$config.warnsIfNotActing;
		  var supportsMutation = $$$config.supportsMutation,
		    supportsPersistence = $$$config.supportsPersistence,
		    supportsHydration = $$$config.supportsHydration,
		    getInstanceFromNode = $$$config.getInstanceFromNode;
		  $$$config.beforeActiveInstanceBlur;
		  $$$config.afterActiveInstanceBlur;
		  var preparePortalMount = $$$config.preparePortalMount;
		  $$$config.prepareScopeUpdate;
		  $$$config.getInstanceFromScope;
		  var setCurrentUpdatePriority = $$$config.setCurrentUpdatePriority,
		    getCurrentUpdatePriority = $$$config.getCurrentUpdatePriority,
		    resolveUpdatePriority = $$$config.resolveUpdatePriority;
		  $$$config.resolveEventType;
		  $$$config.resolveEventTimeStamp;
		  var shouldAttemptEagerTransition = $$$config.shouldAttemptEagerTransition,
		    detachDeletedInstance = $$$config.detachDeletedInstance;
		  $$$config.requestPostPaintCallback;
		  var maySuspendCommit = $$$config.maySuspendCommit,
		    preloadInstance = $$$config.preloadInstance,
		    startSuspendingCommit = $$$config.startSuspendingCommit,
		    suspendInstance = $$$config.suspendInstance,
		    waitForCommitToBeReady = $$$config.waitForCommitToBeReady,
		    NotPendingTransition = $$$config.NotPendingTransition,
		    HostTransitionContext = $$$config.HostTransitionContext,
		    resetFormInstance = $$$config.resetFormInstance;
		  $$$config.bindToConsole;
		  var supportsMicrotasks = $$$config.supportsMicrotasks,
		    scheduleMicrotask = $$$config.scheduleMicrotask,
		    supportsTestSelectors = $$$config.supportsTestSelectors,
		    findFiberRoot = $$$config.findFiberRoot,
		    getBoundingRect = $$$config.getBoundingRect,
		    getTextContent = $$$config.getTextContent,
		    isHiddenSubtree = $$$config.isHiddenSubtree,
		    matchAccessibilityRole = $$$config.matchAccessibilityRole,
		    setFocusIfFocusable = $$$config.setFocusIfFocusable,
		    setupIntersectionObserver = $$$config.setupIntersectionObserver,
		    appendChild = $$$config.appendChild,
		    appendChildToContainer = $$$config.appendChildToContainer,
		    commitTextUpdate = $$$config.commitTextUpdate,
		    commitMount = $$$config.commitMount,
		    commitUpdate = $$$config.commitUpdate,
		    insertBefore = $$$config.insertBefore,
		    insertInContainerBefore = $$$config.insertInContainerBefore,
		    removeChild = $$$config.removeChild,
		    removeChildFromContainer = $$$config.removeChildFromContainer,
		    resetTextContent = $$$config.resetTextContent,
		    hideInstance = $$$config.hideInstance,
		    hideTextInstance = $$$config.hideTextInstance,
		    unhideInstance = $$$config.unhideInstance,
		    unhideTextInstance = $$$config.unhideTextInstance,
		    clearContainer = $$$config.clearContainer,
		    cloneInstance = $$$config.cloneInstance,
		    createContainerChildSet = $$$config.createContainerChildSet,
		    appendChildToContainerChildSet = $$$config.appendChildToContainerChildSet,
		    finalizeContainerChildren = $$$config.finalizeContainerChildren,
		    replaceContainerChildren = $$$config.replaceContainerChildren,
		    cloneHiddenInstance = $$$config.cloneHiddenInstance,
		    cloneHiddenTextInstance = $$$config.cloneHiddenTextInstance,
		    isSuspenseInstancePending = $$$config.isSuspenseInstancePending,
		    isSuspenseInstanceFallback = $$$config.isSuspenseInstanceFallback,
		    getSuspenseInstanceFallbackErrorDetails =
		      $$$config.getSuspenseInstanceFallbackErrorDetails,
		    registerSuspenseInstanceRetry = $$$config.registerSuspenseInstanceRetry,
		    canHydrateFormStateMarker = $$$config.canHydrateFormStateMarker,
		    isFormStateMarkerMatching = $$$config.isFormStateMarkerMatching,
		    getNextHydratableSibling = $$$config.getNextHydratableSibling,
		    getFirstHydratableChild = $$$config.getFirstHydratableChild,
		    getFirstHydratableChildWithinContainer =
		      $$$config.getFirstHydratableChildWithinContainer,
		    getFirstHydratableChildWithinSuspenseInstance =
		      $$$config.getFirstHydratableChildWithinSuspenseInstance,
		    canHydrateInstance = $$$config.canHydrateInstance,
		    canHydrateTextInstance = $$$config.canHydrateTextInstance,
		    canHydrateSuspenseInstance = $$$config.canHydrateSuspenseInstance,
		    hydrateInstance = $$$config.hydrateInstance,
		    hydrateTextInstance = $$$config.hydrateTextInstance,
		    hydrateSuspenseInstance = $$$config.hydrateSuspenseInstance,
		    getNextHydratableInstanceAfterSuspenseInstance =
		      $$$config.getNextHydratableInstanceAfterSuspenseInstance,
		    commitHydratedContainer = $$$config.commitHydratedContainer,
		    commitHydratedSuspenseInstance = $$$config.commitHydratedSuspenseInstance,
		    clearSuspenseBoundary = $$$config.clearSuspenseBoundary,
		    clearSuspenseBoundaryFromContainer =
		      $$$config.clearSuspenseBoundaryFromContainer,
		    shouldDeleteUnhydratedTailInstances =
		      $$$config.shouldDeleteUnhydratedTailInstances;
		  $$$config.diffHydratedPropsForDevWarnings;
		  $$$config.diffHydratedTextForDevWarnings;
		  $$$config.describeHydratableInstanceForDevWarnings;
		  var validateHydratableInstance = $$$config.validateHydratableInstance,
		    validateHydratableTextInstance = $$$config.validateHydratableTextInstance,
		    supportsResources = $$$config.supportsResources,
		    isHostHoistableType = $$$config.isHostHoistableType,
		    getHoistableRoot = $$$config.getHoistableRoot,
		    getResource = $$$config.getResource,
		    acquireResource = $$$config.acquireResource,
		    releaseResource = $$$config.releaseResource,
		    hydrateHoistable = $$$config.hydrateHoistable,
		    mountHoistable = $$$config.mountHoistable,
		    unmountHoistable = $$$config.unmountHoistable,
		    createHoistableInstance = $$$config.createHoistableInstance,
		    prepareToCommitHoistables = $$$config.prepareToCommitHoistables,
		    mayResourceSuspendCommit = $$$config.mayResourceSuspendCommit,
		    preloadResource = $$$config.preloadResource,
		    suspendResource = $$$config.suspendResource,
		    supportsSingletons = $$$config.supportsSingletons,
		    resolveSingletonInstance = $$$config.resolveSingletonInstance,
		    clearSingleton = $$$config.clearSingleton,
		    acquireSingletonInstance = $$$config.acquireSingletonInstance,
		    releaseSingletonInstance = $$$config.releaseSingletonInstance,
		    isHostSingletonType = $$$config.isHostSingletonType,
		    valueStack = [],
		    index$jscomp$0 = -1,
		    emptyContextObject = {},
		    clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
		    log$1 = Math.log,
		    LN2 = Math.LN2,
		    nextTransitionLane = 128,
		    nextRetryLane = 4194304,
		    scheduleCallback$3 = Scheduler.unstable_scheduleCallback,
		    cancelCallback$1 = Scheduler.unstable_cancelCallback,
		    shouldYield = Scheduler.unstable_shouldYield,
		    requestPaint = Scheduler.unstable_requestPaint,
		    now = Scheduler.unstable_now,
		    ImmediatePriority = Scheduler.unstable_ImmediatePriority,
		    UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
		    NormalPriority$1 = Scheduler.unstable_NormalPriority,
		    IdlePriority = Scheduler.unstable_IdlePriority,
		    log = Scheduler.log,
		    unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,
		    rendererID = null,
		    injectedHook = null,
		    objectIs = "function" === typeof Object.is ? Object.is : is,
		    CapturedStacks = new WeakMap(),
		    forkStack = [],
		    forkStackIndex = 0,
		    treeForkProvider = null,
		    treeForkCount = 0,
		    idStack = [],
		    idStackIndex = 0,
		    treeContextProvider = null,
		    treeContextId = 1,
		    treeContextOverflow = "",
		    contextStackCursor = createCursor(null),
		    contextFiberStackCursor = createCursor(null),
		    rootInstanceStackCursor = createCursor(null),
		    hostTransitionProviderCursor = createCursor(null),
		    hydrationParentFiber = null,
		    nextHydratableInstance = null,
		    isHydrating = false,
		    hydrationErrors = null,
		    rootOrSingletonContext = false,
		    HydrationMismatchException = Error(formatProdErrorMessage(519)),
		    concurrentQueues = [],
		    concurrentQueuesIndex = 0,
		    concurrentlyUpdatedLanes = 0,
		    firstScheduledRoot = null,
		    lastScheduledRoot = null,
		    didScheduleMicrotask = false,
		    mightHavePendingSyncWork = false,
		    isFlushingWork = false,
		    currentEventTransitionLane = 0,
		    currentEntangledListeners = null,
		    currentEntangledPendingCount = 0,
		    currentEntangledLane = 0,
		    currentEntangledActionThenable = null,
		    hasForceUpdate = false,
		    didReadFromEntangledAsyncAction = false,
		    hasOwnProperty = Object.prototype.hasOwnProperty,
		    SuspenseException = Error(formatProdErrorMessage(460)),
		    SuspenseyCommitException = Error(formatProdErrorMessage(474)),
		    noopSuspenseyCommitThenable = { then: function () {} },
		    suspendedThenable = null,
		    thenableState$1 = null,
		    thenableIndexCounter$1 = 0,
		    reconcileChildFibers = createChildReconciler(true),
		    mountChildFibers = createChildReconciler(false),
		    currentTreeHiddenStackCursor = createCursor(null),
		    prevEntangledRenderLanesCursor = createCursor(0),
		    suspenseHandlerStackCursor = createCursor(null),
		    shellBoundary = null,
		    suspenseStackCursor = createCursor(0),
		    renderLanes = 0,
		    currentlyRenderingFiber$1 = null,
		    currentHook = null,
		    workInProgressHook = null,
		    didScheduleRenderPhaseUpdate = false,
		    didScheduleRenderPhaseUpdateDuringThisPass = false,
		    shouldDoubleInvokeUserFnsInHooksDEV = false,
		    localIdCounter = 0,
		    thenableIndexCounter = 0,
		    thenableState = null,
		    globalClientIdCounter = 0;
		  var createFunctionComponentUpdateQueue = function () {
		    return { lastEffect: null, events: null, stores: null, memoCache: null };
		  };
		  var ContextOnlyDispatcher = {
		    readContext: readContext,
		    use: use,
		    useCallback: throwInvalidHookError,
		    useContext: throwInvalidHookError,
		    useEffect: throwInvalidHookError,
		    useImperativeHandle: throwInvalidHookError,
		    useLayoutEffect: throwInvalidHookError,
		    useInsertionEffect: throwInvalidHookError,
		    useMemo: throwInvalidHookError,
		    useReducer: throwInvalidHookError,
		    useRef: throwInvalidHookError,
		    useState: throwInvalidHookError,
		    useDebugValue: throwInvalidHookError,
		    useDeferredValue: throwInvalidHookError,
		    useTransition: throwInvalidHookError,
		    useSyncExternalStore: throwInvalidHookError,
		    useId: throwInvalidHookError
		  };
		  ContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError;
		  ContextOnlyDispatcher.useMemoCache = throwInvalidHookError;
		  ContextOnlyDispatcher.useHostTransitionStatus = throwInvalidHookError;
		  ContextOnlyDispatcher.useFormState = throwInvalidHookError;
		  ContextOnlyDispatcher.useActionState = throwInvalidHookError;
		  ContextOnlyDispatcher.useOptimistic = throwInvalidHookError;
		  var HooksDispatcherOnMount = {
		    readContext: readContext,
		    use: use,
		    useCallback: function (callback, deps) {
		      mountWorkInProgressHook().memoizedState = [
		        callback,
		        void 0 === deps ? null : deps
		      ];
		      return callback;
		    },
		    useContext: readContext,
		    useEffect: mountEffect,
		    useImperativeHandle: function (ref, create, deps) {
		      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
		      mountEffectImpl(
		        4194308,
		        4,
		        imperativeHandleEffect.bind(null, create, ref),
		        deps
		      );
		    },
		    useLayoutEffect: function (create, deps) {
		      return mountEffectImpl(4194308, 4, create, deps);
		    },
		    useInsertionEffect: function (create, deps) {
		      mountEffectImpl(4, 2, create, deps);
		    },
		    useMemo: function (nextCreate, deps) {
		      var hook = mountWorkInProgressHook();
		      deps = void 0 === deps ? null : deps;
		      var nextValue = nextCreate();
		      if (shouldDoubleInvokeUserFnsInHooksDEV) {
		        setIsStrictModeForDevtools(true);
		        try {
		          nextCreate();
		        } finally {
		          setIsStrictModeForDevtools(false);
		        }
		      }
		      hook.memoizedState = [nextValue, deps];
		      return nextValue;
		    },
		    useReducer: function (reducer, initialArg, init) {
		      var hook = mountWorkInProgressHook();
		      if (void 0 !== init) {
		        var initialState = init(initialArg);
		        if (shouldDoubleInvokeUserFnsInHooksDEV) {
		          setIsStrictModeForDevtools(true);
		          try {
		            init(initialArg);
		          } finally {
		            setIsStrictModeForDevtools(false);
		          }
		        }
		      } else initialState = initialArg;
		      hook.memoizedState = hook.baseState = initialState;
		      reducer = {
		        pending: null,
		        lanes: 0,
		        dispatch: null,
		        lastRenderedReducer: reducer,
		        lastRenderedState: initialState
		      };
		      hook.queue = reducer;
		      reducer = reducer.dispatch = dispatchReducerAction.bind(
		        null,
		        currentlyRenderingFiber$1,
		        reducer
		      );
		      return [hook.memoizedState, reducer];
		    },
		    useRef: function (initialValue) {
		      var hook = mountWorkInProgressHook();
		      initialValue = { current: initialValue };
		      return (hook.memoizedState = initialValue);
		    },
		    useState: function (initialState) {
		      initialState = mountStateImpl(initialState);
		      var queue = initialState.queue,
		        dispatch = dispatchSetState.bind(
		          null,
		          currentlyRenderingFiber$1,
		          queue
		        );
		      queue.dispatch = dispatch;
		      return [initialState.memoizedState, dispatch];
		    },
		    useDebugValue: mountDebugValue,
		    useDeferredValue: function (value, initialValue) {
		      var hook = mountWorkInProgressHook();
		      return mountDeferredValueImpl(hook, value, initialValue);
		    },
		    useTransition: function () {
		      var stateHook = mountStateImpl(false);
		      stateHook = startTransition.bind(
		        null,
		        currentlyRenderingFiber$1,
		        stateHook.queue,
		        true,
		        false
		      );
		      mountWorkInProgressHook().memoizedState = stateHook;
		      return [false, stateHook];
		    },
		    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
		      var fiber = currentlyRenderingFiber$1,
		        hook = mountWorkInProgressHook();
		      if (isHydrating) {
		        if (void 0 === getServerSnapshot)
		          throw Error(formatProdErrorMessage(407));
		        getServerSnapshot = getServerSnapshot();
		      } else {
		        getServerSnapshot = getSnapshot();
		        if (null === workInProgressRoot)
		          throw Error(formatProdErrorMessage(349));
		        0 !== (workInProgressRootRenderLanes & 60) ||
		          pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
		      }
		      hook.memoizedState = getServerSnapshot;
		      var inst = { value: getServerSnapshot, getSnapshot: getSnapshot };
		      hook.queue = inst;
		      mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
		        subscribe
		      ]);
		      fiber.flags |= 2048;
		      pushEffect(
		        9,
		        updateStoreInstance.bind(
		          null,
		          fiber,
		          inst,
		          getServerSnapshot,
		          getSnapshot
		        ),
		        { destroy: void 0 },
		        null
		      );
		      return getServerSnapshot;
		    },
		    useId: function () {
		      var hook = mountWorkInProgressHook(),
		        identifierPrefix = workInProgressRoot.identifierPrefix;
		      if (isHydrating) {
		        var JSCompiler_inline_result = treeContextOverflow;
		        var idWithLeadingBit = treeContextId;
		        JSCompiler_inline_result =
		          (
		            idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))
		          ).toString(32) + JSCompiler_inline_result;
		        identifierPrefix =
		          ":" + identifierPrefix + "R" + JSCompiler_inline_result;
		        JSCompiler_inline_result = localIdCounter++;
		        0 < JSCompiler_inline_result &&
		          (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
		        identifierPrefix += ":";
		      } else
		        (JSCompiler_inline_result = globalClientIdCounter++),
		          (identifierPrefix =
		            ":" +
		            identifierPrefix +
		            "r" +
		            JSCompiler_inline_result.toString(32) +
		            ":");
		      return (hook.memoizedState = identifierPrefix);
		    },
		    useCacheRefresh: function () {
		      return (mountWorkInProgressHook().memoizedState = refreshCache.bind(
		        null,
		        currentlyRenderingFiber$1
		      ));
		    }
		  };
		  HooksDispatcherOnMount.useMemoCache = useMemoCache;
		  HooksDispatcherOnMount.useHostTransitionStatus = useHostTransitionStatus;
		  HooksDispatcherOnMount.useFormState = mountActionState;
		  HooksDispatcherOnMount.useActionState = mountActionState;
		  HooksDispatcherOnMount.useOptimistic = function (passthrough) {
		    var hook = mountWorkInProgressHook();
		    hook.memoizedState = hook.baseState = passthrough;
		    var queue = {
		      pending: null,
		      lanes: 0,
		      dispatch: null,
		      lastRenderedReducer: null,
		      lastRenderedState: null
		    };
		    hook.queue = queue;
		    hook = dispatchOptimisticSetState.bind(
		      null,
		      currentlyRenderingFiber$1,
		      true,
		      queue
		    );
		    queue.dispatch = hook;
		    return [passthrough, hook];
		  };
		  var HooksDispatcherOnUpdate = {
		    readContext: readContext,
		    use: use,
		    useCallback: updateCallback,
		    useContext: readContext,
		    useEffect: updateEffect,
		    useImperativeHandle: updateImperativeHandle,
		    useInsertionEffect: updateInsertionEffect,
		    useLayoutEffect: updateLayoutEffect,
		    useMemo: updateMemo,
		    useReducer: updateReducer,
		    useRef: updateRef,
		    useState: function () {
		      return updateReducer(basicStateReducer);
		    },
		    useDebugValue: mountDebugValue,
		    useDeferredValue: function (value, initialValue) {
		      var hook = updateWorkInProgressHook();
		      return updateDeferredValueImpl(
		        hook,
		        currentHook.memoizedState,
		        value,
		        initialValue
		      );
		    },
		    useTransition: function () {
		      var booleanOrThenable = updateReducer(basicStateReducer)[0],
		        start = updateWorkInProgressHook().memoizedState;
		      return [
		        "boolean" === typeof booleanOrThenable
		          ? booleanOrThenable
		          : useThenable(booleanOrThenable),
		        start
		      ];
		    },
		    useSyncExternalStore: updateSyncExternalStore,
		    useId: updateId
		  };
		  HooksDispatcherOnUpdate.useCacheRefresh = updateRefresh;
		  HooksDispatcherOnUpdate.useMemoCache = useMemoCache;
		  HooksDispatcherOnUpdate.useHostTransitionStatus = useHostTransitionStatus;
		  HooksDispatcherOnUpdate.useFormState = updateActionState;
		  HooksDispatcherOnUpdate.useActionState = updateActionState;
		  HooksDispatcherOnUpdate.useOptimistic = function (passthrough, reducer) {
		    var hook = updateWorkInProgressHook();
		    return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
		  };
		  var HooksDispatcherOnRerender = {
		    readContext: readContext,
		    use: use,
		    useCallback: updateCallback,
		    useContext: readContext,
		    useEffect: updateEffect,
		    useImperativeHandle: updateImperativeHandle,
		    useInsertionEffect: updateInsertionEffect,
		    useLayoutEffect: updateLayoutEffect,
		    useMemo: updateMemo,
		    useReducer: rerenderReducer,
		    useRef: updateRef,
		    useState: function () {
		      return rerenderReducer(basicStateReducer);
		    },
		    useDebugValue: mountDebugValue,
		    useDeferredValue: function (value, initialValue) {
		      var hook = updateWorkInProgressHook();
		      return null === currentHook
		        ? mountDeferredValueImpl(hook, value, initialValue)
		        : updateDeferredValueImpl(
		            hook,
		            currentHook.memoizedState,
		            value,
		            initialValue
		          );
		    },
		    useTransition: function () {
		      var booleanOrThenable = rerenderReducer(basicStateReducer)[0],
		        start = updateWorkInProgressHook().memoizedState;
		      return [
		        "boolean" === typeof booleanOrThenable
		          ? booleanOrThenable
		          : useThenable(booleanOrThenable),
		        start
		      ];
		    },
		    useSyncExternalStore: updateSyncExternalStore,
		    useId: updateId
		  };
		  HooksDispatcherOnRerender.useCacheRefresh = updateRefresh;
		  HooksDispatcherOnRerender.useMemoCache = useMemoCache;
		  HooksDispatcherOnRerender.useHostTransitionStatus = useHostTransitionStatus;
		  HooksDispatcherOnRerender.useFormState = rerenderActionState;
		  HooksDispatcherOnRerender.useActionState = rerenderActionState;
		  HooksDispatcherOnRerender.useOptimistic = function (passthrough, reducer) {
		    var hook = updateWorkInProgressHook();
		    if (null !== currentHook)
		      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
		    hook.baseState = passthrough;
		    return [passthrough, hook.queue.dispatch];
		  };
		  var classComponentUpdater = {
		      isMounted: function (component) {
		        return (component = component._reactInternals)
		          ? getNearestMountedFiber(component) === component
		          : false;
		      },
		      enqueueSetState: function (inst, payload, callback) {
		        inst = inst._reactInternals;
		        var lane = requestUpdateLane(),
		          update = createUpdate(lane);
		        update.payload = payload;
		        void 0 !== callback &&
		          null !== callback &&
		          (update.callback = callback);
		        payload = enqueueUpdate(inst, update, lane);
		        null !== payload &&
		          (scheduleUpdateOnFiber(payload, inst, lane),
		          entangleTransitions(payload, inst, lane));
		      },
		      enqueueReplaceState: function (inst, payload, callback) {
		        inst = inst._reactInternals;
		        var lane = requestUpdateLane(),
		          update = createUpdate(lane);
		        update.tag = 1;
		        update.payload = payload;
		        void 0 !== callback &&
		          null !== callback &&
		          (update.callback = callback);
		        payload = enqueueUpdate(inst, update, lane);
		        null !== payload &&
		          (scheduleUpdateOnFiber(payload, inst, lane),
		          entangleTransitions(payload, inst, lane));
		      },
		      enqueueForceUpdate: function (inst, callback) {
		        inst = inst._reactInternals;
		        var lane = requestUpdateLane(),
		          update = createUpdate(lane);
		        update.tag = 2;
		        void 0 !== callback &&
		          null !== callback &&
		          (update.callback = callback);
		        callback = enqueueUpdate(inst, update, lane);
		        null !== callback &&
		          (scheduleUpdateOnFiber(callback, inst, lane),
		          entangleTransitions(callback, inst, lane));
		      }
		    },
		    reportGlobalError =
		      "function" === typeof reportError
		        ? reportError
		        : function (error) {
		            if (
		              "object" === typeof window &&
		              "function" === typeof window.ErrorEvent
		            ) {
		              var event = new window.ErrorEvent("error", {
		                bubbles: true,
		                cancelable: true,
		                message:
		                  "object" === typeof error &&
		                  null !== error &&
		                  "string" === typeof error.message
		                    ? String(error.message)
		                    : String(error),
		                error: error
		              });
		              if (!window.dispatchEvent(event)) return;
		            } else if (
		              "object" === typeof process &&
		              "function" === typeof process.emit
		            ) {
		              process.emit("uncaughtException", error);
		              return;
		            }
		            console.error(error);
		          },
		    SelectiveHydrationException = Error(formatProdErrorMessage(461)),
		    didReceiveUpdate = false,
		    SUSPENDED_MARKER = { dehydrated: null, treeContext: null, retryLane: 0 },
		    valueCursor = createCursor(null),
		    currentlyRenderingFiber = null,
		    lastContextDependency = null,
		    AbortControllerLocal =
		      "undefined" !== typeof AbortController
		        ? AbortController
		        : function () {
		            var listeners = [],
		              signal = (this.signal = {
		                aborted: false,
		                addEventListener: function (type, listener) {
		                  listeners.push(listener);
		                }
		              });
		            this.abort = function () {
		              signal.aborted = true;
		              listeners.forEach(function (listener) {
		                return listener();
		              });
		            };
		          },
		    scheduleCallback$1 = Scheduler.unstable_scheduleCallback,
		    NormalPriority = Scheduler.unstable_NormalPriority,
		    CacheContext = {
		      $$typeof: REACT_CONTEXT_TYPE,
		      Consumer: null,
		      Provider: null,
		      _currentValue: null,
		      _currentValue2: null,
		      _threadCount: 0
		    },
		    prevOnStartTransitionFinish = ReactSharedInternals.S;
		  ReactSharedInternals.S = function (transition, returnValue) {
		    "object" === typeof returnValue &&
		      null !== returnValue &&
		      "function" === typeof returnValue.then &&
		      entangleAsyncAction(transition, returnValue);
		    null !== prevOnStartTransitionFinish &&
		      prevOnStartTransitionFinish(transition, returnValue);
		  };
		  var resumedCache = createCursor(null),
		    offscreenSubtreeIsHidden = false,
		    offscreenSubtreeWasHidden = false,
		    needsFormReset = false,
		    PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
		    nextEffect = null,
		    shouldFireAfterActiveInstanceBlur = false,
		    hostParent = null,
		    hostParentIsContainer = false,
		    currentHoistableRoot = null,
		    suspenseyCommitFlag = 8192,
		    DefaultAsyncDispatcher = {
		      getCacheForType: function (resourceType) {
		        var cache = readContext(CacheContext),
		          cacheForType = cache.data.get(resourceType);
		        void 0 === cacheForType &&
		          ((cacheForType = resourceType()),
		          cache.data.set(resourceType, cacheForType));
		        return cacheForType;
		      }
		    },
		    COMPONENT_TYPE = 0,
		    HAS_PSEUDO_CLASS_TYPE = 1,
		    ROLE_TYPE = 2,
		    TEST_NAME_TYPE = 3,
		    TEXT_TYPE = 4;
		  if ("function" === typeof Symbol && Symbol.for) {
		    var symbolFor = Symbol.for;
		    COMPONENT_TYPE = symbolFor("selector.component");
		    HAS_PSEUDO_CLASS_TYPE = symbolFor("selector.has_pseudo_class");
		    ROLE_TYPE = symbolFor("selector.role");
		    TEST_NAME_TYPE = symbolFor("selector.test_id");
		    TEXT_TYPE = symbolFor("selector.text");
		  }
		  var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
		    executionContext = 0,
		    workInProgressRoot = null,
		    workInProgress = null,
		    workInProgressRootRenderLanes = 0,
		    workInProgressSuspendedReason = 0,
		    workInProgressThrownValue = null,
		    workInProgressRootDidSkipSuspendedSiblings = false,
		    workInProgressRootIsPrerendering = false,
		    workInProgressRootDidAttachPingListener = false,
		    entangledRenderLanes = 0,
		    workInProgressRootExitStatus = 0,
		    workInProgressRootSkippedLanes = 0,
		    workInProgressRootInterleavedUpdatedLanes = 0,
		    workInProgressRootPingedLanes = 0,
		    workInProgressDeferredLane = 0,
		    workInProgressSuspendedRetryLanes = 0,
		    workInProgressRootConcurrentErrors = null,
		    workInProgressRootRecoverableErrors = null,
		    workInProgressRootDidIncludeRecursiveRenderUpdate = false,
		    globalMostRecentFallbackTime = 0,
		    workInProgressRootRenderTargetTime = Infinity,
		    workInProgressTransitions = null,
		    legacyErrorBoundariesThatAlreadyFailed = null,
		    rootDoesHavePassiveEffects = false,
		    rootWithPendingPassiveEffects = null,
		    pendingPassiveEffectsLanes = 0,
		    pendingPassiveEffectsRemainingLanes = 0,
		    pendingPassiveTransitions = null,
		    nestedUpdateCount = 0,
		    rootWithNestedUpdates = null;
		  exports.attemptContinuousHydration = function (fiber) {
		    if (13 === fiber.tag) {
		      var root = enqueueConcurrentRenderForLane(fiber, 67108864);
		      null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);
		      markRetryLaneIfNotHydrated(fiber, 67108864);
		    }
		  };
		  exports.attemptHydrationAtCurrentPriority = function (fiber) {
		    if (13 === fiber.tag) {
		      var lane = requestUpdateLane(),
		        root = enqueueConcurrentRenderForLane(fiber, lane);
		      null !== root && scheduleUpdateOnFiber(root, fiber, lane);
		      markRetryLaneIfNotHydrated(fiber, lane);
		    }
		  };
		  exports.attemptSynchronousHydration = function (fiber) {
		    switch (fiber.tag) {
		      case 3:
		        fiber = fiber.stateNode;
		        if (fiber.current.memoizedState.isDehydrated) {
		          var lanes = getHighestPriorityLanes(fiber.pendingLanes);
		          if (0 !== lanes) {
		            fiber.pendingLanes |= 2;
		            for (fiber.entangledLanes |= 2; lanes; ) {
		              var lane = 1 << (31 - clz32(lanes));
		              fiber.entanglements[1] |= lane;
		              lanes &= ~lane;
		            }
		            ensureRootIsScheduled(fiber);
		            0 === (executionContext & 6) &&
		              ((workInProgressRootRenderTargetTime = now() + 500),
		              flushSyncWorkAcrossRoots_impl(0));
		          }
		        }
		        break;
		      case 13:
		        (lanes = enqueueConcurrentRenderForLane(fiber, 2)),
		          null !== lanes && scheduleUpdateOnFiber(lanes, fiber, 2),
		          flushSyncWork(),
		          markRetryLaneIfNotHydrated(fiber, 2);
		    }
		  };
		  exports.batchedUpdates = function (fn, a) {
		    return fn(a);
		  };
		  exports.createComponentSelector = function (component) {
		    return { $$typeof: COMPONENT_TYPE, value: component };
		  };
		  exports.createContainer = function (
		    containerInfo,
		    tag,
		    hydrationCallbacks,
		    isStrictMode,
		    concurrentUpdatesByDefaultOverride,
		    identifierPrefix,
		    onUncaughtError,
		    onCaughtError,
		    onRecoverableError,
		    transitionCallbacks
		  ) {
		    return createFiberRoot(
		      containerInfo,
		      tag,
		      false,
		      null,
		      hydrationCallbacks,
		      isStrictMode,
		      identifierPrefix,
		      onUncaughtError,
		      onCaughtError,
		      onRecoverableError,
		      transitionCallbacks,
		      null
		    );
		  };
		  exports.createHasPseudoClassSelector = function (selectors) {
		    return { $$typeof: HAS_PSEUDO_CLASS_TYPE, value: selectors };
		  };
		  exports.createHydrationContainer = function (
		    initialChildren,
		    callback,
		    containerInfo,
		    tag,
		    hydrationCallbacks,
		    isStrictMode,
		    concurrentUpdatesByDefaultOverride,
		    identifierPrefix,
		    onUncaughtError,
		    onCaughtError,
		    onRecoverableError,
		    transitionCallbacks,
		    formState
		  ) {
		    initialChildren = createFiberRoot(
		      containerInfo,
		      tag,
		      true,
		      initialChildren,
		      hydrationCallbacks,
		      isStrictMode,
		      identifierPrefix,
		      onUncaughtError,
		      onCaughtError,
		      onRecoverableError,
		      transitionCallbacks,
		      formState
		    );
		    initialChildren.context = getContextForSubtree(null);
		    containerInfo = initialChildren.current;
		    tag = requestUpdateLane();
		    hydrationCallbacks = createUpdate(tag);
		    hydrationCallbacks.callback =
		      void 0 !== callback && null !== callback ? callback : null;
		    enqueueUpdate(containerInfo, hydrationCallbacks, tag);
		    initialChildren.current.lanes = tag;
		    markRootUpdated$1(initialChildren, tag);
		    ensureRootIsScheduled(initialChildren);
		    return initialChildren;
		  };
		  exports.createPortal = function (children, containerInfo, implementation) {
		    var key =
		      3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
		    return {
		      $$typeof: REACT_PORTAL_TYPE,
		      key: null == key ? null : "" + key,
		      children: children,
		      containerInfo: containerInfo,
		      implementation: implementation
		    };
		  };
		  exports.createRoleSelector = function (role) {
		    return { $$typeof: ROLE_TYPE, value: role };
		  };
		  exports.createTestNameSelector = function (id) {
		    return { $$typeof: TEST_NAME_TYPE, value: id };
		  };
		  exports.createTextSelector = function (text) {
		    return { $$typeof: TEXT_TYPE, value: text };
		  };
		  exports.defaultOnCaughtError = function (error) {
		    console.error(error);
		  };
		  exports.defaultOnRecoverableError = function (error) {
		    reportGlobalError(error);
		  };
		  exports.defaultOnUncaughtError = function (error) {
		    reportGlobalError(error);
		  };
		  exports.deferredUpdates = function (fn) {
		    var prevTransition = ReactSharedInternals.T,
		      previousPriority = getCurrentUpdatePriority();
		    try {
		      return (
		        setCurrentUpdatePriority(32), (ReactSharedInternals.T = null), fn()
		      );
		    } finally {
		      setCurrentUpdatePriority(previousPriority),
		        (ReactSharedInternals.T = prevTransition);
		    }
		  };
		  exports.discreteUpdates = function (fn, a, b, c, d) {
		    var prevTransition = ReactSharedInternals.T,
		      previousPriority = getCurrentUpdatePriority();
		    try {
		      return (
		        setCurrentUpdatePriority(2),
		        (ReactSharedInternals.T = null),
		        fn(a, b, c, d)
		      );
		    } finally {
		      setCurrentUpdatePriority(previousPriority),
		        (ReactSharedInternals.T = prevTransition),
		        0 === executionContext &&
		          (workInProgressRootRenderTargetTime = now() + 500);
		    }
		  };
		  exports.findAllNodes = findAllNodes;
		  exports.findBoundingRects = function (hostRoot, selectors) {
		    if (!supportsTestSelectors) throw Error(formatProdErrorMessage(363));
		    selectors = findAllNodes(hostRoot, selectors);
		    hostRoot = [];
		    for (var i = 0; i < selectors.length; i++)
		      hostRoot.push(getBoundingRect(selectors[i]));
		    for (selectors = hostRoot.length - 1; 0 < selectors; selectors--) {
		      i = hostRoot[selectors];
		      for (
		        var targetLeft = i.x,
		          targetRight = targetLeft + i.width,
		          targetTop = i.y,
		          targetBottom = targetTop + i.height,
		          j = selectors - 1;
		        0 <= j;
		        j--
		      )
		        if (selectors !== j) {
		          var otherRect = hostRoot[j],
		            otherLeft = otherRect.x,
		            otherRight = otherLeft + otherRect.width,
		            otherTop = otherRect.y,
		            otherBottom = otherTop + otherRect.height;
		          if (
		            targetLeft >= otherLeft &&
		            targetTop >= otherTop &&
		            targetRight <= otherRight &&
		            targetBottom <= otherBottom
		          ) {
		            hostRoot.splice(selectors, 1);
		            break;
		          } else if (
		            !(
		              targetLeft !== otherLeft ||
		              i.width !== otherRect.width ||
		              otherBottom < targetTop ||
		              otherTop > targetBottom
		            )
		          ) {
		            otherTop > targetTop &&
		              ((otherRect.height += otherTop - targetTop),
		              (otherRect.y = targetTop));
		            otherBottom < targetBottom &&
		              (otherRect.height = targetBottom - otherTop);
		            hostRoot.splice(selectors, 1);
		            break;
		          } else if (
		            !(
		              targetTop !== otherTop ||
		              i.height !== otherRect.height ||
		              otherRight < targetLeft ||
		              otherLeft > targetRight
		            )
		          ) {
		            otherLeft > targetLeft &&
		              ((otherRect.width += otherLeft - targetLeft),
		              (otherRect.x = targetLeft));
		            otherRight < targetRight &&
		              (otherRect.width = targetRight - otherLeft);
		            hostRoot.splice(selectors, 1);
		            break;
		          }
		        }
		    }
		    return hostRoot;
		  };
		  exports.findHostInstance = findHostInstance;
		  exports.findHostInstanceWithNoPortals = function (fiber) {
		    fiber = findCurrentFiberUsingSlowPath(fiber);
		    fiber =
		      null !== fiber ? findCurrentHostFiberWithNoPortalsImpl(fiber) : null;
		    return null === fiber ? null : getPublicInstance(fiber.stateNode);
		  };
		  exports.findHostInstanceWithWarning = function (component) {
		    return findHostInstance(component);
		  };
		  exports.flushPassiveEffects = flushPassiveEffects;
		  exports.flushSyncFromReconciler = function (fn) {
		    var prevExecutionContext = executionContext;
		    executionContext |= 1;
		    var prevTransition = ReactSharedInternals.T,
		      previousPriority = getCurrentUpdatePriority();
		    try {
		      if ((setCurrentUpdatePriority(2), (ReactSharedInternals.T = null), fn))
		        return fn();
		    } finally {
		      setCurrentUpdatePriority(previousPriority),
		        (ReactSharedInternals.T = prevTransition),
		        (executionContext = prevExecutionContext),
		        0 === (executionContext & 6) && flushSyncWorkAcrossRoots_impl(0);
		    }
		  };
		  exports.flushSyncWork = flushSyncWork;
		  exports.focusWithin = function (hostRoot, selectors) {
		    if (!supportsTestSelectors) throw Error(formatProdErrorMessage(363));
		    hostRoot = findFiberRootForHostRoot(hostRoot);
		    selectors = findPaths(hostRoot, selectors);
		    selectors = Array.from(selectors);
		    for (hostRoot = 0; hostRoot < selectors.length; ) {
		      var fiber = selectors[hostRoot++],
		        tag = fiber.tag;
		      if (!isHiddenSubtree(fiber)) {
		        if (
		          (5 === tag || 26 === tag || 27 === tag) &&
		          setFocusIfFocusable(fiber.stateNode)
		        )
		          return true;
		        for (fiber = fiber.child; null !== fiber; )
		          selectors.push(fiber), (fiber = fiber.sibling);
		      }
		    }
		    return false;
		  };
		  exports.getFindAllNodesFailureDescription = function (hostRoot, selectors) {
		    if (!supportsTestSelectors) throw Error(formatProdErrorMessage(363));
		    var maxSelectorIndex = 0,
		      matchedNames = [];
		    hostRoot = [findFiberRootForHostRoot(hostRoot), 0];
		    for (var index = 0; index < hostRoot.length; ) {
		      var fiber = hostRoot[index++],
		        tag = fiber.tag,
		        selectorIndex = hostRoot[index++],
		        selector = selectors[selectorIndex];
		      if ((5 !== tag && 26 !== tag && 27 !== tag) || !isHiddenSubtree(fiber))
		        if (
		          (matchSelector(fiber, selector) &&
		            (matchedNames.push(selectorToString(selector)),
		            selectorIndex++,
		            selectorIndex > maxSelectorIndex &&
		              (maxSelectorIndex = selectorIndex)),
		          selectorIndex < selectors.length)
		        )
		          for (fiber = fiber.child; null !== fiber; )
		            hostRoot.push(fiber, selectorIndex), (fiber = fiber.sibling);
		    }
		    if (maxSelectorIndex < selectors.length) {
		      for (
		        hostRoot = [];
		        maxSelectorIndex < selectors.length;
		        maxSelectorIndex++
		      )
		        hostRoot.push(selectorToString(selectors[maxSelectorIndex]));
		      return (
		        "findAllNodes was able to match part of the selector:\n  " +
		        (matchedNames.join(" > ") +
		          "\n\nNo matching component was found for:\n  ") +
		        hostRoot.join(" > ")
		      );
		    }
		    return null;
		  };
		  exports.getPublicRootInstance = function (container) {
		    container = container.current;
		    if (!container.child) return null;
		    switch (container.child.tag) {
		      case 27:
		      case 5:
		        return getPublicInstance(container.child.stateNode);
		      default:
		        return container.child.stateNode;
		    }
		  };
		  exports.injectIntoDevTools = function () {
		    var internals = {
		      bundleType: 0,
		      version: rendererVersion,
		      rendererPackageName: rendererPackageName,
		      currentDispatcherRef: ReactSharedInternals,
		      findFiberByHostInstance: getInstanceFromNode,
		      reconcilerVersion: "19.0.0"
		    };
		    null !== extraDevToolsConfig &&
		      (internals.rendererConfig = extraDevToolsConfig);
		    if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) internals = false;
		    else {
		      var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
		      if (hook.isDisabled || !hook.supportsFiber) internals = true;
		      else {
		        try {
		          (rendererID = hook.inject(internals)), (injectedHook = hook);
		        } catch (err) {}
		        internals = hook.checkDCE ? true : false;
		      }
		    }
		    return internals;
		  };
		  exports.isAlreadyRendering = function () {
		    return false;
		  };
		  exports.observeVisibleRects = function (
		    hostRoot,
		    selectors,
		    callback,
		    options
		  ) {
		    if (!supportsTestSelectors) throw Error(formatProdErrorMessage(363));
		    hostRoot = findAllNodes(hostRoot, selectors);
		    var disconnect = setupIntersectionObserver(
		      hostRoot,
		      callback,
		      options
		    ).disconnect;
		    return {
		      disconnect: function () {
		        disconnect();
		      }
		    };
		  };
		  exports.shouldError = function () {
		    return null;
		  };
		  exports.shouldSuspend = function () {
		    return false;
		  };
		  exports.startHostTransition = function (
		    formFiber,
		    pendingState,
		    action,
		    formData
		  ) {
		    if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
		    var queue = ensureFormComponentIsStateful(formFiber).queue;
		    startTransition(
		      formFiber,
		      queue,
		      pendingState,
		      NotPendingTransition,
		      null === action
		        ? noop
		        : function () {
		            var resetStateQueue =
		              ensureFormComponentIsStateful(formFiber).next.queue;
		            dispatchSetStateInternal(
		              formFiber,
		              resetStateQueue,
		              {},
		              requestUpdateLane()
		            );
		            return action(formData);
		          }
		    );
		  };
		  exports.updateContainer = function (
		    element,
		    container,
		    parentComponent,
		    callback
		  ) {
		    var current = container.current,
		      lane = requestUpdateLane();
		    updateContainerImpl(
		      current,
		      lane,
		      element,
		      container,
		      parentComponent,
		      callback
		    );
		    return lane;
		  };
		  exports.updateContainerSync = function (
		    element,
		    container,
		    parentComponent,
		    callback
		  ) {
		    0 === container.tag && flushPassiveEffects();
		    updateContainerImpl(
		      container.current,
		      2,
		      element,
		      container,
		      parentComponent,
		      callback
		    );
		    return 2;
		  };
		  return exports;
		};
		module.exports.default = module.exports;
		Object.defineProperty(module.exports, "__esModule", { value: true }); 
	} (reactReconciler_production));
	return reactReconciler_production.exports;
}

var reactReconciler_development = {exports: {}};

/**
 * @license React
 * react-reconciler.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactReconciler_development;

function requireReactReconciler_development () {
	if (hasRequiredReactReconciler_development) return reactReconciler_development.exports;
	hasRequiredReactReconciler_development = 1;
	(function (module) {
		"production" !== process.env.NODE_ENV &&
		  ((module.exports = function ($$$config) {
		    function findHook(fiber, id) {
		      for (fiber = fiber.memoizedState; null !== fiber && 0 < id; )
		        (fiber = fiber.next), id--;
		      return fiber;
		    }
		    function copyWithSetImpl(obj, path, index, value) {
		      if (index >= path.length) return value;
		      var key = path[index],
		        updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
		      updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
		      return updated;
		    }
		    function copyWithRename(obj, oldPath, newPath) {
		      if (oldPath.length !== newPath.length)
		        console.warn("copyWithRename() expects paths of the same length");
		      else {
		        for (var i = 0; i < newPath.length - 1; i++)
		          if (oldPath[i] !== newPath[i]) {
		            console.warn(
		              "copyWithRename() expects paths to be the same except for the deepest key"
		            );
		            return;
		          }
		        return copyWithRenameImpl(obj, oldPath, newPath, 0);
		      }
		    }
		    function copyWithRenameImpl(obj, oldPath, newPath, index) {
		      var oldKey = oldPath[index],
		        updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
		      index + 1 === oldPath.length
		        ? ((updated[newPath[index]] = updated[oldKey]),
		          isArrayImpl(updated)
		            ? updated.splice(oldKey, 1)
		            : delete updated[oldKey])
		        : (updated[oldKey] = copyWithRenameImpl(
		            obj[oldKey],
		            oldPath,
		            newPath,
		            index + 1
		          ));
		      return updated;
		    }
		    function copyWithDeleteImpl(obj, path, index) {
		      var key = path[index],
		        updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
		      if (index + 1 === path.length)
		        return (
		          isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key],
		          updated
		        );
		      updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
		      return updated;
		    }
		    function shouldSuspendImpl() {
		      return false;
		    }
		    function shouldErrorImpl() {
		      return null;
		    }
		    function createFiber(tag, pendingProps, key, mode) {
		      return new FiberNode(tag, pendingProps, key, mode);
		    }
		    function scheduleRoot(root, element) {
		      root.context === emptyContextObject &&
		        (updateContainerSync(element, root, null, null), flushSyncWork());
		    }
		    function scheduleRefresh(root, update) {
		      if (null !== resolveFamily) {
		        var staleFamilies = update.staleFamilies;
		        update = update.updatedFamilies;
		        flushPassiveEffects();
		        scheduleFibersWithFamiliesRecursively(
		          root.current,
		          update,
		          staleFamilies
		        );
		        flushSyncWork();
		      }
		    }
		    function setRefreshHandler(handler) {
		      resolveFamily = handler;
		    }
		    function warnInvalidHookAccess() {
		      console.error(
		        "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
		      );
		    }
		    function warnInvalidContextAccess() {
		      console.error(
		        "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
		      );
		    }
		    function noop() {}
		    function warnForMissingKey() {}
		    function setToSortedString(set) {
		      var array = [];
		      set.forEach(function (value) {
		        array.push(value);
		      });
		      return array.sort().join(", ");
		    }
		    function getIteratorFn(maybeIterable) {
		      if (null === maybeIterable || "object" !== typeof maybeIterable)
		        return null;
		      maybeIterable =
		        (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
		        maybeIterable["@@iterator"];
		      return "function" === typeof maybeIterable ? maybeIterable : null;
		    }
		    function getComponentNameFromType(type) {
		      if (null == type) return null;
		      if ("function" === typeof type)
		        return type.$$typeof === REACT_CLIENT_REFERENCE
		          ? null
		          : type.displayName || type.name || null;
		      if ("string" === typeof type) return type;
		      switch (type) {
		        case REACT_FRAGMENT_TYPE:
		          return "Fragment";
		        case REACT_PORTAL_TYPE:
		          return "Portal";
		        case REACT_PROFILER_TYPE:
		          return "Profiler";
		        case REACT_STRICT_MODE_TYPE:
		          return "StrictMode";
		        case REACT_SUSPENSE_TYPE:
		          return "Suspense";
		        case REACT_SUSPENSE_LIST_TYPE:
		          return "SuspenseList";
		      }
		      if ("object" === typeof type)
		        switch (
		          ("number" === typeof type.tag &&
		            console.error(
		              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
		            ),
		          type.$$typeof)
		        ) {
		          case REACT_CONTEXT_TYPE:
		            return (type.displayName || "Context") + ".Provider";
		          case REACT_CONSUMER_TYPE:
		            return (type._context.displayName || "Context") + ".Consumer";
		          case REACT_FORWARD_REF_TYPE:
		            var innerType = type.render;
		            type = type.displayName;
		            type ||
		              ((type = innerType.displayName || innerType.name || ""),
		              (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
		            return type;
		          case REACT_MEMO_TYPE:
		            return (
		              (innerType = type.displayName || null),
		              null !== innerType
		                ? innerType
		                : getComponentNameFromType(type.type) || "Memo"
		            );
		          case REACT_LAZY_TYPE:
		            innerType = type._payload;
		            type = type._init;
		            try {
		              return getComponentNameFromType(type(innerType));
		            } catch (x) {}
		        }
		      return null;
		    }
		    function getComponentNameFromFiber(fiber) {
		      var type = fiber.type;
		      switch (fiber.tag) {
		        case 24:
		          return "Cache";
		        case 9:
		          return (type._context.displayName || "Context") + ".Consumer";
		        case 10:
		          return (type.displayName || "Context") + ".Provider";
		        case 18:
		          return "DehydratedFragment";
		        case 11:
		          return (
		            (fiber = type.render),
		            (fiber = fiber.displayName || fiber.name || ""),
		            type.displayName ||
		              ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef")
		          );
		        case 7:
		          return "Fragment";
		        case 26:
		        case 27:
		        case 5:
		          return type;
		        case 4:
		          return "Portal";
		        case 3:
		          return "Root";
		        case 6:
		          return "Text";
		        case 16:
		          return getComponentNameFromType(type);
		        case 8:
		          return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
		        case 22:
		          return "Offscreen";
		        case 12:
		          return "Profiler";
		        case 21:
		          return "Scope";
		        case 13:
		          return "Suspense";
		        case 19:
		          return "SuspenseList";
		        case 25:
		          return "TracingMarker";
		        case 1:
		        case 0:
		        case 14:
		        case 15:
		          if ("function" === typeof type)
		            return type.displayName || type.name || null;
		          if ("string" === typeof type) return type;
		          break;
		        case 29:
		          type = fiber._debugInfo;
		          if (null != type)
		            for (var i = type.length - 1; 0 <= i; i--)
		              if ("string" === typeof type[i].name) return type[i].name;
		          if (null !== fiber.return)
		            return getComponentNameFromFiber(fiber.return);
		      }
		      return null;
		    }
		    function disabledLog() {}
		    function disableLogs() {
		      if (0 === disabledDepth) {
		        prevLog = console.log;
		        prevInfo = console.info;
		        prevWarn = console.warn;
		        prevError = console.error;
		        prevGroup = console.group;
		        prevGroupCollapsed = console.groupCollapsed;
		        prevGroupEnd = console.groupEnd;
		        var props = {
		          configurable: true,
		          enumerable: true,
		          value: disabledLog,
		          writable: true
		        };
		        Object.defineProperties(console, {
		          info: props,
		          log: props,
		          warn: props,
		          error: props,
		          group: props,
		          groupCollapsed: props,
		          groupEnd: props
		        });
		      }
		      disabledDepth++;
		    }
		    function reenableLogs() {
		      disabledDepth--;
		      if (0 === disabledDepth) {
		        var props = { configurable: true, enumerable: true, writable: true };
		        Object.defineProperties(console, {
		          log: assign({}, props, { value: prevLog }),
		          info: assign({}, props, { value: prevInfo }),
		          warn: assign({}, props, { value: prevWarn }),
		          error: assign({}, props, { value: prevError }),
		          group: assign({}, props, { value: prevGroup }),
		          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
		          groupEnd: assign({}, props, { value: prevGroupEnd })
		        });
		      }
		      0 > disabledDepth &&
		        console.error(
		          "disabledDepth fell below zero. This is a bug in React. Please file an issue."
		        );
		    }
		    function describeBuiltInComponentFrame(name) {
		      if (void 0 === prefix)
		        try {
		          throw Error();
		        } catch (x) {
		          var match = x.stack.trim().match(/\n( *(at )?)/);
		          prefix = (match && match[1]) || "";
		          suffix =
		            -1 < x.stack.indexOf("\n    at")
		              ? " (<anonymous>)"
		              : -1 < x.stack.indexOf("@")
		                ? "@unknown:0:0"
		                : "";
		        }
		      return "\n" + prefix + name + suffix;
		    }
		    function describeNativeComponentFrame(fn, construct) {
		      if (!fn || reentry) return "";
		      var frame = componentFrameCache.get(fn);
		      if (void 0 !== frame) return frame;
		      reentry = true;
		      frame = Error.prepareStackTrace;
		      Error.prepareStackTrace = void 0;
		      var previousDispatcher = null;
		      previousDispatcher = ReactSharedInternals.H;
		      ReactSharedInternals.H = null;
		      disableLogs();
		      try {
		        var RunInRootFrame = {
		          DetermineComponentFrameRoot: function () {
		            try {
		              if (construct) {
		                var Fake = function () {
		                  throw Error();
		                };
		                Object.defineProperty(Fake.prototype, "props", {
		                  set: function () {
		                    throw Error();
		                  }
		                });
		                if ("object" === typeof Reflect && Reflect.construct) {
		                  try {
		                    Reflect.construct(Fake, []);
		                  } catch (x) {
		                    var control = x;
		                  }
		                  Reflect.construct(fn, [], Fake);
		                } else {
		                  try {
		                    Fake.call();
		                  } catch (x$0) {
		                    control = x$0;
		                  }
		                  fn.call(Fake.prototype);
		                }
		              } else {
		                try {
		                  throw Error();
		                } catch (x$1) {
		                  control = x$1;
		                }
		                (Fake = fn()) &&
		                  "function" === typeof Fake.catch &&
		                  Fake.catch(function () {});
		              }
		            } catch (sample) {
		              if (sample && control && "string" === typeof sample.stack)
		                return [sample.stack, control.stack];
		            }
		            return [null, null];
		          }
		        };
		        RunInRootFrame.DetermineComponentFrameRoot.displayName =
		          "DetermineComponentFrameRoot";
		        var namePropDescriptor = Object.getOwnPropertyDescriptor(
		          RunInRootFrame.DetermineComponentFrameRoot,
		          "name"
		        );
		        namePropDescriptor &&
		          namePropDescriptor.configurable &&
		          Object.defineProperty(
		            RunInRootFrame.DetermineComponentFrameRoot,
		            "name",
		            { value: "DetermineComponentFrameRoot" }
		          );
		        var _RunInRootFrame$Deter =
		            RunInRootFrame.DetermineComponentFrameRoot(),
		          sampleStack = _RunInRootFrame$Deter[0],
		          controlStack = _RunInRootFrame$Deter[1];
		        if (sampleStack && controlStack) {
		          var sampleLines = sampleStack.split("\n"),
		            controlLines = controlStack.split("\n");
		          for (
		            _RunInRootFrame$Deter = namePropDescriptor = 0;
		            namePropDescriptor < sampleLines.length &&
		            !sampleLines[namePropDescriptor].includes(
		              "DetermineComponentFrameRoot"
		            );

		          )
		            namePropDescriptor++;
		          for (
		            ;
		            _RunInRootFrame$Deter < controlLines.length &&
		            !controlLines[_RunInRootFrame$Deter].includes(
		              "DetermineComponentFrameRoot"
		            );

		          )
		            _RunInRootFrame$Deter++;
		          if (
		            namePropDescriptor === sampleLines.length ||
		            _RunInRootFrame$Deter === controlLines.length
		          )
		            for (
		              namePropDescriptor = sampleLines.length - 1,
		                _RunInRootFrame$Deter = controlLines.length - 1;
		              1 <= namePropDescriptor &&
		              0 <= _RunInRootFrame$Deter &&
		              sampleLines[namePropDescriptor] !==
		                controlLines[_RunInRootFrame$Deter];

		            )
		              _RunInRootFrame$Deter--;
		          for (
		            ;
		            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;
		            namePropDescriptor--, _RunInRootFrame$Deter--
		          )
		            if (
		              sampleLines[namePropDescriptor] !==
		              controlLines[_RunInRootFrame$Deter]
		            ) {
		              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
		                do
		                  if (
		                    (namePropDescriptor--,
		                    _RunInRootFrame$Deter--,
		                    0 > _RunInRootFrame$Deter ||
		                      sampleLines[namePropDescriptor] !==
		                        controlLines[_RunInRootFrame$Deter])
		                  ) {
		                    var _frame =
		                      "\n" +
		                      sampleLines[namePropDescriptor].replace(
		                        " at new ",
		                        " at "
		                      );
		                    fn.displayName &&
		                      _frame.includes("<anonymous>") &&
		                      (_frame = _frame.replace("<anonymous>", fn.displayName));
		                    "function" === typeof fn &&
		                      componentFrameCache.set(fn, _frame);
		                    return _frame;
		                  }
		                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
		              }
		              break;
		            }
		        }
		      } finally {
		        (reentry = false),
		          (ReactSharedInternals.H = previousDispatcher),
		          reenableLogs(),
		          (Error.prepareStackTrace = frame);
		      }
		      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "")
		        ? describeBuiltInComponentFrame(sampleLines)
		        : "";
		      "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
		      return sampleLines;
		    }
		    function describeFiber(fiber) {
		      switch (fiber.tag) {
		        case 26:
		        case 27:
		        case 5:
		          return describeBuiltInComponentFrame(fiber.type);
		        case 16:
		          return describeBuiltInComponentFrame("Lazy");
		        case 13:
		          return describeBuiltInComponentFrame("Suspense");
		        case 19:
		          return describeBuiltInComponentFrame("SuspenseList");
		        case 0:
		        case 15:
		          return (fiber = describeNativeComponentFrame(fiber.type, false)), fiber;
		        case 11:
		          return (
		            (fiber = describeNativeComponentFrame(fiber.type.render, false)), fiber
		          );
		        case 1:
		          return (fiber = describeNativeComponentFrame(fiber.type, true)), fiber;
		        default:
		          return "";
		      }
		    }
		    function getStackByFiberInDevAndProd(workInProgress) {
		      try {
		        var info = "";
		        do {
		          info += describeFiber(workInProgress);
		          var debugInfo = workInProgress._debugInfo;
		          if (debugInfo)
		            for (var i = debugInfo.length - 1; 0 <= i; i--) {
		              var entry = debugInfo[i];
		              if ("string" === typeof entry.name) {
		                var JSCompiler_temp_const = info,
		                  env = entry.env;
		                var JSCompiler_inline_result = describeBuiltInComponentFrame(
		                  entry.name + (env ? " [" + env + "]" : "")
		                );
		                info = JSCompiler_temp_const + JSCompiler_inline_result;
		              }
		            }
		          workInProgress = workInProgress.return;
		        } while (workInProgress);
		        return info;
		      } catch (x) {
		        return "\nError generating stack: " + x.message + "\n" + x.stack;
		      }
		    }
		    function getCurrentFiberStackInDev() {
		      return null === current ? "" : getStackByFiberInDevAndProd(current);
		    }
		    function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {
		      var previousFiber = current;
		      ReactSharedInternals.getCurrentStack =
		        null === fiber ? null : getCurrentFiberStackInDev;
		      isRendering = false;
		      current = fiber;
		      try {
		        return callback(arg0, arg1, arg2, arg3, arg4);
		      } finally {
		        current = previousFiber;
		      }
		      throw Error(
		        "runWithFiberInDEV should never be called in production. This is a bug in React."
		      );
		    }
		    function getNearestMountedFiber(fiber) {
		      var node = fiber,
		        nearestMounted = fiber;
		      if (fiber.alternate) for (; node.return; ) node = node.return;
		      else {
		        fiber = node;
		        do
		          (node = fiber),
		            0 !== (node.flags & 4098) && (nearestMounted = node.return),
		            (fiber = node.return);
		        while (fiber);
		      }
		      return 3 === node.tag ? nearestMounted : null;
		    }
		    function assertIsMounted(fiber) {
		      if (getNearestMountedFiber(fiber) !== fiber)
		        throw Error("Unable to find node on an unmounted component.");
		    }
		    function findCurrentFiberUsingSlowPath(fiber) {
		      var alternate = fiber.alternate;
		      if (!alternate) {
		        alternate = getNearestMountedFiber(fiber);
		        if (null === alternate)
		          throw Error("Unable to find node on an unmounted component.");
		        return alternate !== fiber ? null : fiber;
		      }
		      for (var a = fiber, b = alternate; ; ) {
		        var parentA = a.return;
		        if (null === parentA) break;
		        var parentB = parentA.alternate;
		        if (null === parentB) {
		          b = parentA.return;
		          if (null !== b) {
		            a = b;
		            continue;
		          }
		          break;
		        }
		        if (parentA.child === parentB.child) {
		          for (parentB = parentA.child; parentB; ) {
		            if (parentB === a) return assertIsMounted(parentA), fiber;
		            if (parentB === b) return assertIsMounted(parentA), alternate;
		            parentB = parentB.sibling;
		          }
		          throw Error("Unable to find node on an unmounted component.");
		        }
		        if (a.return !== b.return) (a = parentA), (b = parentB);
		        else {
		          for (var didFindChild = false, _child = parentA.child; _child; ) {
		            if (_child === a) {
		              didFindChild = true;
		              a = parentA;
		              b = parentB;
		              break;
		            }
		            if (_child === b) {
		              didFindChild = true;
		              b = parentA;
		              a = parentB;
		              break;
		            }
		            _child = _child.sibling;
		          }
		          if (!didFindChild) {
		            for (_child = parentB.child; _child; ) {
		              if (_child === a) {
		                didFindChild = true;
		                a = parentB;
		                b = parentA;
		                break;
		              }
		              if (_child === b) {
		                didFindChild = true;
		                b = parentB;
		                a = parentA;
		                break;
		              }
		              _child = _child.sibling;
		            }
		            if (!didFindChild)
		              throw Error(
		                "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue."
		              );
		          }
		        }
		        if (a.alternate !== b)
		          throw Error(
		            "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
		          );
		      }
		      if (3 !== a.tag)
		        throw Error("Unable to find node on an unmounted component.");
		      return a.stateNode.current === a ? fiber : alternate;
		    }
		    function findCurrentHostFiber(parent) {
		      parent = findCurrentFiberUsingSlowPath(parent);
		      return null !== parent ? findCurrentHostFiberImpl(parent) : null;
		    }
		    function findCurrentHostFiberImpl(node) {
		      var tag = node.tag;
		      if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
		      for (node = node.child; null !== node; ) {
		        tag = findCurrentHostFiberImpl(node);
		        if (null !== tag) return tag;
		        node = node.sibling;
		      }
		      return null;
		    }
		    function findCurrentHostFiberWithNoPortalsImpl(node) {
		      var tag = node.tag;
		      if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
		      for (node = node.child; null !== node; ) {
		        if (
		          4 !== node.tag &&
		          ((tag = findCurrentHostFiberWithNoPortalsImpl(node)), null !== tag)
		        )
		          return tag;
		        node = node.sibling;
		      }
		      return null;
		    }
		    function createCursor(defaultValue) {
		      return { current: defaultValue };
		    }
		    function pop(cursor, fiber) {
		      0 > index$jscomp$0
		        ? console.error("Unexpected pop.")
		        : (fiber !== fiberStack[index$jscomp$0] &&
		            console.error("Unexpected Fiber popped."),
		          (cursor.current = valueStack[index$jscomp$0]),
		          (valueStack[index$jscomp$0] = null),
		          (fiberStack[index$jscomp$0] = null),
		          index$jscomp$0--);
		    }
		    function push(cursor, value, fiber) {
		      index$jscomp$0++;
		      valueStack[index$jscomp$0] = cursor.current;
		      fiberStack[index$jscomp$0] = fiber;
		      cursor.current = value;
		    }
		    function clz32Fallback(x) {
		      x >>>= 0;
		      return 0 === x ? 32 : (31 - ((log$1(x) / LN2) | 0)) | 0;
		    }
		    function getLabelForLane(lane) {
		      if (lane & 1) return "SyncHydrationLane";
		      if (lane & 2) return "Sync";
		      if (lane & 4) return "InputContinuousHydration";
		      if (lane & 8) return "InputContinuous";
		      if (lane & 16) return "DefaultHydration";
		      if (lane & 32) return "Default";
		      if (lane & 64) return "TransitionHydration";
		      if (lane & 4194176) return "Transition";
		      if (lane & 62914560) return "Retry";
		      if (lane & 67108864) return "SelectiveHydration";
		      if (lane & 134217728) return "IdleHydration";
		      if (lane & 268435456) return "Idle";
		      if (lane & 536870912) return "Offscreen";
		      if (lane & 1073741824) return "Deferred";
		    }
		    function getHighestPriorityLanes(lanes) {
		      var pendingSyncLanes = lanes & 42;
		      if (0 !== pendingSyncLanes) return pendingSyncLanes;
		      switch (lanes & -lanes) {
		        case 1:
		          return 1;
		        case 2:
		          return 2;
		        case 4:
		          return 4;
		        case 8:
		          return 8;
		        case 16:
		          return 16;
		        case 32:
		          return 32;
		        case 64:
		          return 64;
		        case 128:
		        case 256:
		        case 512:
		        case 1024:
		        case 2048:
		        case 4096:
		        case 8192:
		        case 16384:
		        case 32768:
		        case 65536:
		        case 131072:
		        case 262144:
		        case 524288:
		        case 1048576:
		        case 2097152:
		          return lanes & 4194176;
		        case 4194304:
		        case 8388608:
		        case 16777216:
		        case 33554432:
		          return lanes & 62914560;
		        case 67108864:
		          return 67108864;
		        case 134217728:
		          return 134217728;
		        case 268435456:
		          return 268435456;
		        case 536870912:
		          return 536870912;
		        case 1073741824:
		          return 0;
		        default:
		          return (
		            console.error(
		              "Should have found matching lanes. This is a bug in React."
		            ),
		            lanes
		          );
		      }
		    }
		    function getNextLanes(root, wipLanes) {
		      var pendingLanes = root.pendingLanes;
		      if (0 === pendingLanes) return 0;
		      var nextLanes = 0,
		        suspendedLanes = root.suspendedLanes,
		        pingedLanes = root.pingedLanes,
		        warmLanes = root.warmLanes;
		      root = 0 !== root.finishedLanes;
		      var nonIdlePendingLanes = pendingLanes & 134217727;
		      0 !== nonIdlePendingLanes
		        ? ((pendingLanes = nonIdlePendingLanes & ~suspendedLanes),
		          0 !== pendingLanes
		            ? (nextLanes = getHighestPriorityLanes(pendingLanes))
		            : ((pingedLanes &= nonIdlePendingLanes),
		              0 !== pingedLanes
		                ? (nextLanes = getHighestPriorityLanes(pingedLanes))
		                : root ||
		                  ((warmLanes = nonIdlePendingLanes & ~warmLanes),
		                  0 !== warmLanes &&
		                    (nextLanes = getHighestPriorityLanes(warmLanes)))))
		        : ((nonIdlePendingLanes = pendingLanes & ~suspendedLanes),
		          0 !== nonIdlePendingLanes
		            ? (nextLanes = getHighestPriorityLanes(nonIdlePendingLanes))
		            : 0 !== pingedLanes
		              ? (nextLanes = getHighestPriorityLanes(pingedLanes))
		              : root ||
		                ((warmLanes = pendingLanes & ~warmLanes),
		                0 !== warmLanes &&
		                  (nextLanes = getHighestPriorityLanes(warmLanes))));
		      return 0 === nextLanes
		        ? 0
		        : 0 !== wipLanes &&
		            wipLanes !== nextLanes &&
		            0 === (wipLanes & suspendedLanes) &&
		            ((suspendedLanes = nextLanes & -nextLanes),
		            (warmLanes = wipLanes & -wipLanes),
		            suspendedLanes >= warmLanes ||
		              (32 === suspendedLanes && 0 !== (warmLanes & 4194176)))
		          ? wipLanes
		          : nextLanes;
		    }
		    function checkIfRootIsPrerendering(root, renderLanes) {
		      return (
		        0 ===
		        (root.pendingLanes &
		          ~(root.suspendedLanes & ~root.pingedLanes) &
		          renderLanes)
		      );
		    }
		    function computeExpirationTime(lane, currentTime) {
		      switch (lane) {
		        case 1:
		        case 2:
		        case 4:
		        case 8:
		          return currentTime + 250;
		        case 16:
		        case 32:
		        case 64:
		        case 128:
		        case 256:
		        case 512:
		        case 1024:
		        case 2048:
		        case 4096:
		        case 8192:
		        case 16384:
		        case 32768:
		        case 65536:
		        case 131072:
		        case 262144:
		        case 524288:
		        case 1048576:
		        case 2097152:
		          return currentTime + 5e3;
		        case 4194304:
		        case 8388608:
		        case 16777216:
		        case 33554432:
		          return -1;
		        case 67108864:
		        case 134217728:
		        case 268435456:
		        case 536870912:
		        case 1073741824:
		          return -1;
		        default:
		          return (
		            console.error(
		              "Should have found matching lanes. This is a bug in React."
		            ),
		            -1
		          );
		      }
		    }
		    function claimNextTransitionLane() {
		      var lane = nextTransitionLane;
		      nextTransitionLane <<= 1;
		      0 === (nextTransitionLane & 4194176) && (nextTransitionLane = 128);
		      return lane;
		    }
		    function claimNextRetryLane() {
		      var lane = nextRetryLane;
		      nextRetryLane <<= 1;
		      0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
		      return lane;
		    }
		    function createLaneMap(initial) {
		      for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
		      return laneMap;
		    }
		    function markRootUpdated$1(root, updateLane) {
		      root.pendingLanes |= updateLane;
		      268435456 !== updateLane &&
		        ((root.suspendedLanes = 0),
		        (root.pingedLanes = 0),
		        (root.warmLanes = 0));
		    }
		    function markRootFinished(
		      root,
		      finishedLanes,
		      remainingLanes,
		      spawnedLane,
		      updatedLanes,
		      suspendedRetryLanes
		    ) {
		      var previouslyPendingLanes = root.pendingLanes;
		      root.pendingLanes = remainingLanes;
		      root.suspendedLanes = 0;
		      root.pingedLanes = 0;
		      root.warmLanes = 0;
		      root.expiredLanes &= remainingLanes;
		      root.entangledLanes &= remainingLanes;
		      root.errorRecoveryDisabledLanes &= remainingLanes;
		      root.shellSuspendCounter = 0;
		      var entanglements = root.entanglements,
		        expirationTimes = root.expirationTimes,
		        hiddenUpdates = root.hiddenUpdates;
		      for (
		        remainingLanes = previouslyPendingLanes & ~remainingLanes;
		        0 < remainingLanes;

		      ) {
		        var index = 31 - clz32(remainingLanes),
		          lane = 1 << index;
		        entanglements[index] = 0;
		        expirationTimes[index] = -1;
		        var hiddenUpdatesForLane = hiddenUpdates[index];
		        if (null !== hiddenUpdatesForLane)
		          for (
		            hiddenUpdates[index] = null, index = 0;
		            index < hiddenUpdatesForLane.length;
		            index++
		          ) {
		            var update = hiddenUpdatesForLane[index];
		            null !== update && (update.lane &= -536870913);
		          }
		        remainingLanes &= ~lane;
		      }
		      0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
		      0 !== suspendedRetryLanes &&
		        0 === updatedLanes &&
		        0 !== root.tag &&
		        (root.suspendedLanes |=
		          suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
		    }
		    function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
		      root.pendingLanes |= spawnedLane;
		      root.suspendedLanes &= ~spawnedLane;
		      var spawnedLaneIndex = 31 - clz32(spawnedLane);
		      root.entangledLanes |= spawnedLane;
		      root.entanglements[spawnedLaneIndex] =
		        root.entanglements[spawnedLaneIndex] |
		        1073741824 |
		        (entangledLanes & 4194218);
		    }
		    function markRootEntangled(root, entangledLanes) {
		      var rootEntangledLanes = (root.entangledLanes |= entangledLanes);
		      for (root = root.entanglements; rootEntangledLanes; ) {
		        var index = 31 - clz32(rootEntangledLanes),
		          lane = 1 << index;
		        (lane & entangledLanes) | (root[index] & entangledLanes) &&
		          (root[index] |= entangledLanes);
		        rootEntangledLanes &= ~lane;
		      }
		    }
		    function addFiberToLanesMap(root, fiber, lanes) {
		      if (isDevToolsPresent)
		        for (root = root.pendingUpdatersLaneMap; 0 < lanes; ) {
		          var index = 31 - clz32(lanes),
		            lane = 1 << index;
		          root[index].add(fiber);
		          lanes &= ~lane;
		        }
		    }
		    function movePendingFibersToMemoized(root, lanes) {
		      if (isDevToolsPresent)
		        for (
		          var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap,
		            memoizedUpdaters = root.memoizedUpdaters;
		          0 < lanes;

		        ) {
		          var index = 31 - clz32(lanes);
		          root = 1 << index;
		          index = pendingUpdatersLaneMap[index];
		          0 < index.size &&
		            (index.forEach(function (fiber) {
		              var alternate = fiber.alternate;
		              (null !== alternate && memoizedUpdaters.has(alternate)) ||
		                memoizedUpdaters.add(fiber);
		            }),
		            index.clear());
		          lanes &= ~root;
		        }
		    }
		    function lanesToEventPriority(lanes) {
		      lanes &= -lanes;
		      return 2 < lanes
		        ? 8 < lanes
		          ? 0 !== (lanes & 134217727)
		            ? 32
		            : 268435456
		          : 8
		        : 2;
		    }
		    function injectInternals(internals) {
		      if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return false;
		      var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
		      if (hook.isDisabled) return true;
		      if (!hook.supportsFiber)
		        return (
		          console.error(
		            "The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"
		          ),
		          true
		        );
		      try {
		        (rendererID = hook.inject(internals)), (injectedHook = hook);
		      } catch (err) {
		        console.error("React instrumentation encountered an error: %s.", err);
		      }
		      return hook.checkDCE ? true : false;
		    }
		    function onCommitRoot$1(root, eventPriority) {
		      if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
		        try {
		          var didError = 128 === (root.current.flags & 128);
		          switch (eventPriority) {
		            case 2:
		              var schedulerPriority = ImmediatePriority;
		              break;
		            case 8:
		              schedulerPriority = UserBlockingPriority;
		              break;
		            case 32:
		              schedulerPriority = NormalPriority$1;
		              break;
		            case 268435456:
		              schedulerPriority = IdlePriority;
		              break;
		            default:
		              schedulerPriority = NormalPriority$1;
		          }
		          injectedHook.onCommitFiberRoot(
		            rendererID,
		            root,
		            schedulerPriority,
		            didError
		          );
		        } catch (err) {
		          hasLoggedError ||
		            ((hasLoggedError = true),
		            console.error(
		              "React instrumentation encountered an error: %s",
		              err
		            ));
		        }
		    }
		    function setIsStrictModeForDevtools(newIsStrictMode) {
		      "function" === typeof log &&
		        unstable_setDisableYieldValue(newIsStrictMode);
		      if (injectedHook && "function" === typeof injectedHook.setStrictMode)
		        try {
		          injectedHook.setStrictMode(rendererID, newIsStrictMode);
		        } catch (err) {
		          hasLoggedError ||
		            ((hasLoggedError = true),
		            console.error(
		              "React instrumentation encountered an error: %s",
		              err
		            ));
		        }
		    }
		    function injectProfilingHooks(profilingHooks) {
		      injectedProfilingHooks = profilingHooks;
		    }
		    function markCommitStopped() {
		      null !== injectedProfilingHooks &&
		        "function" === typeof injectedProfilingHooks.markCommitStopped &&
		        injectedProfilingHooks.markCommitStopped();
		    }
		    function markComponentRenderStarted(fiber) {
		      null !== injectedProfilingHooks &&
		        "function" ===
		          typeof injectedProfilingHooks.markComponentRenderStarted &&
		        injectedProfilingHooks.markComponentRenderStarted(fiber);
		    }
		    function markComponentRenderStopped() {
		      null !== injectedProfilingHooks &&
		        "function" ===
		          typeof injectedProfilingHooks.markComponentRenderStopped &&
		        injectedProfilingHooks.markComponentRenderStopped();
		    }
		    function markRenderStarted(lanes) {
		      null !== injectedProfilingHooks &&
		        "function" === typeof injectedProfilingHooks.markRenderStarted &&
		        injectedProfilingHooks.markRenderStarted(lanes);
		    }
		    function markRenderStopped() {
		      null !== injectedProfilingHooks &&
		        "function" === typeof injectedProfilingHooks.markRenderStopped &&
		        injectedProfilingHooks.markRenderStopped();
		    }
		    function markStateUpdateScheduled(fiber, lane) {
		      null !== injectedProfilingHooks &&
		        "function" === typeof injectedProfilingHooks.markStateUpdateScheduled &&
		        injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
		    }
		    function is(x, y) {
		      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
		    }
		    function createCapturedValueAtFiber(value, source) {
		      if ("object" === typeof value && null !== value) {
		        var existing = CapturedStacks.get(value);
		        if (void 0 !== existing) return existing;
		        source = {
		          value: value,
		          source: source,
		          stack: getStackByFiberInDevAndProd(source)
		        };
		        CapturedStacks.set(value, source);
		        return source;
		      }
		      return {
		        value: value,
		        source: source,
		        stack: getStackByFiberInDevAndProd(source)
		      };
		    }
		    function pushTreeFork(workInProgress, totalChildren) {
		      warnIfNotHydrating();
		      forkStack[forkStackIndex++] = treeForkCount;
		      forkStack[forkStackIndex++] = treeForkProvider;
		      treeForkProvider = workInProgress;
		      treeForkCount = totalChildren;
		    }
		    function pushTreeId(workInProgress, totalChildren, index) {
		      warnIfNotHydrating();
		      idStack[idStackIndex++] = treeContextId;
		      idStack[idStackIndex++] = treeContextOverflow;
		      idStack[idStackIndex++] = treeContextProvider;
		      treeContextProvider = workInProgress;
		      var baseIdWithLeadingBit = treeContextId;
		      workInProgress = treeContextOverflow;
		      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
		      baseIdWithLeadingBit &= ~(1 << baseLength);
		      index += 1;
		      var length = 32 - clz32(totalChildren) + baseLength;
		      if (30 < length) {
		        var numberOfOverflowBits = baseLength - (baseLength % 5);
		        length = (
		          baseIdWithLeadingBit &
		          ((1 << numberOfOverflowBits) - 1)
		        ).toString(32);
		        baseIdWithLeadingBit >>= numberOfOverflowBits;
		        baseLength -= numberOfOverflowBits;
		        treeContextId =
		          (1 << (32 - clz32(totalChildren) + baseLength)) |
		          (index << baseLength) |
		          baseIdWithLeadingBit;
		        treeContextOverflow = length + workInProgress;
		      } else
		        (treeContextId =
		          (1 << length) | (index << baseLength) | baseIdWithLeadingBit),
		          (treeContextOverflow = workInProgress);
		    }
		    function pushMaterializedTreeId(workInProgress) {
		      warnIfNotHydrating();
		      null !== workInProgress.return &&
		        (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));
		    }
		    function popTreeContext(workInProgress) {
		      for (; workInProgress === treeForkProvider; )
		        (treeForkProvider = forkStack[--forkStackIndex]),
		          (forkStack[forkStackIndex] = null),
		          (treeForkCount = forkStack[--forkStackIndex]),
		          (forkStack[forkStackIndex] = null);
		      for (; workInProgress === treeContextProvider; )
		        (treeContextProvider = idStack[--idStackIndex]),
		          (idStack[idStackIndex] = null),
		          (treeContextOverflow = idStack[--idStackIndex]),
		          (idStack[idStackIndex] = null),
		          (treeContextId = idStack[--idStackIndex]),
		          (idStack[idStackIndex] = null);
		    }
		    function warnIfNotHydrating() {
		      isHydrating ||
		        console.error(
		          "Expected to be hydrating. This is a bug in React. Please file an issue."
		        );
		    }
		    function requiredContext(c) {
		      null === c &&
		        console.error(
		          "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
		        );
		      return c;
		    }
		    function pushHostContainer(fiber, nextRootInstance) {
		      push(rootInstanceStackCursor, nextRootInstance, fiber);
		      push(contextFiberStackCursor, fiber, fiber);
		      push(contextStackCursor, null, fiber);
		      nextRootInstance = getRootHostContext(nextRootInstance);
		      pop(contextStackCursor, fiber);
		      push(contextStackCursor, nextRootInstance, fiber);
		    }
		    function popHostContainer(fiber) {
		      pop(contextStackCursor, fiber);
		      pop(contextFiberStackCursor, fiber);
		      pop(rootInstanceStackCursor, fiber);
		    }
		    function getHostContext() {
		      return requiredContext(contextStackCursor.current);
		    }
		    function pushHostContext(fiber) {
		      null !== fiber.memoizedState &&
		        push(hostTransitionProviderCursor, fiber, fiber);
		      var context = requiredContext(contextStackCursor.current),
		        nextContext = getChildHostContext(context, fiber.type);
		      context !== nextContext &&
		        (push(contextFiberStackCursor, fiber, fiber),
		        push(contextStackCursor, nextContext, fiber));
		    }
		    function popHostContext(fiber) {
		      contextFiberStackCursor.current === fiber &&
		        (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));
		      hostTransitionProviderCursor.current === fiber &&
		        (pop(hostTransitionProviderCursor, fiber),
		        isPrimaryRenderer
		          ? (HostTransitionContext._currentValue = NotPendingTransition)
		          : (HostTransitionContext._currentValue2 = NotPendingTransition));
		    }
		    function findNotableNode(node, indent) {
		      return void 0 === node.serverProps &&
		        0 === node.serverTail.length &&
		        1 === node.children.length &&
		        3 < node.distanceFromLeaf &&
		        node.distanceFromLeaf > 15 - indent
		        ? findNotableNode(node.children[0], indent)
		        : node;
		    }
		    function indentation(indent) {
		      return "  " + "  ".repeat(indent);
		    }
		    function added(indent) {
		      return "+ " + "  ".repeat(indent);
		    }
		    function removed(indent) {
		      return "- " + "  ".repeat(indent);
		    }
		    function describeFiberType(fiber) {
		      switch (fiber.tag) {
		        case 26:
		        case 27:
		        case 5:
		          return fiber.type;
		        case 16:
		          return "Lazy";
		        case 13:
		          return "Suspense";
		        case 19:
		          return "SuspenseList";
		        case 0:
		        case 15:
		          return (fiber = fiber.type), fiber.displayName || fiber.name || null;
		        case 11:
		          return (
		            (fiber = fiber.type.render), fiber.displayName || fiber.name || null
		          );
		        case 1:
		          return (fiber = fiber.type), fiber.displayName || fiber.name || null;
		        default:
		          return null;
		      }
		    }
		    function describeTextNode(content, maxLength) {
		      return needsEscaping.test(content)
		        ? ((content = JSON.stringify(content)),
		          content.length > maxLength - 2
		            ? 8 > maxLength
		              ? '{"..."}'
		              : "{" + content.slice(0, maxLength - 7) + '..."}'
		            : "{" + content + "}")
		        : content.length > maxLength
		          ? 5 > maxLength
		            ? '{"..."}'
		            : content.slice(0, maxLength - 3) + "..."
		          : content;
		    }
		    function describeTextDiff(clientText, serverProps, indent) {
		      var maxLength = 120 - 2 * indent;
		      if (null === serverProps)
		        return added(indent) + describeTextNode(clientText, maxLength) + "\n";
		      if ("string" === typeof serverProps) {
		        for (
		          var firstDiff = 0;
		          firstDiff < serverProps.length &&
		          firstDiff < clientText.length &&
		          serverProps.charCodeAt(firstDiff) ===
		            clientText.charCodeAt(firstDiff);
		          firstDiff++
		        );
		        firstDiff > maxLength - 8 &&
		          10 < firstDiff &&
		          ((clientText = "..." + clientText.slice(firstDiff - 8)),
		          (serverProps = "..." + serverProps.slice(firstDiff - 8)));
		        return (
		          added(indent) +
		          describeTextNode(clientText, maxLength) +
		          "\n" +
		          removed(indent) +
		          describeTextNode(serverProps, maxLength) +
		          "\n"
		        );
		      }
		      return (
		        indentation(indent) + describeTextNode(clientText, maxLength) + "\n"
		      );
		    }
		    function objectName(object) {
		      return Object.prototype.toString
		        .call(object)
		        .replace(/^\[object (.*)\]$/, function (m, p0) {
		          return p0;
		        });
		    }
		    function describeValue(value, maxLength) {
		      switch (typeof value) {
		        case "string":
		          return (
		            (value = JSON.stringify(value)),
		            value.length > maxLength
		              ? 5 > maxLength
		                ? '"..."'
		                : value.slice(0, maxLength - 4) + '..."'
		              : value
		          );
		        case "object":
		          if (null === value) return "null";
		          if (isArrayImpl(value)) return "[...]";
		          if (value.$$typeof === REACT_ELEMENT_TYPE)
		            return (maxLength = getComponentNameFromType(value.type))
		              ? "<" + maxLength + ">"
		              : "<...>";
		          var name = objectName(value);
		          if ("Object" === name) {
		            name = "";
		            maxLength -= 2;
		            for (var propName in value)
		              if (value.hasOwnProperty(propName)) {
		                var jsonPropName = JSON.stringify(propName);
		                jsonPropName !== '"' + propName + '"' &&
		                  (propName = jsonPropName);
		                maxLength -= propName.length - 2;
		                jsonPropName = describeValue(
		                  value[propName],
		                  15 > maxLength ? maxLength : 15
		                );
		                maxLength -= jsonPropName.length;
		                if (0 > maxLength) {
		                  name += "" === name ? "..." : ", ...";
		                  break;
		                }
		                name +=
		                  ("" === name ? "" : ",") + propName + ":" + jsonPropName;
		              }
		            return "{" + name + "}";
		          }
		          return name;
		        case "function":
		          return (maxLength = value.displayName || value.name)
		            ? "function " + maxLength
		            : "function";
		        default:
		          return String(value);
		      }
		    }
		    function describePropValue(value, maxLength) {
		      return "string" !== typeof value || needsEscaping.test(value)
		        ? "{" + describeValue(value, maxLength - 2) + "}"
		        : value.length > maxLength - 2
		          ? 5 > maxLength
		            ? '"..."'
		            : '"' + value.slice(0, maxLength - 5) + '..."'
		          : '"' + value + '"';
		    }
		    function describeExpandedElement(type, props, rowPrefix) {
		      var remainingRowLength = 120 - rowPrefix.length - type.length,
		        properties = [],
		        propName;
		      for (propName in props)
		        if (props.hasOwnProperty(propName) && "children" !== propName) {
		          var propValue = describePropValue(
		            props[propName],
		            120 - rowPrefix.length - propName.length - 1
		          );
		          remainingRowLength -= propName.length + propValue.length + 2;
		          properties.push(propName + "=" + propValue);
		        }
		      return 0 === properties.length
		        ? rowPrefix + "<" + type + ">\n"
		        : 0 < remainingRowLength
		          ? rowPrefix + "<" + type + " " + properties.join(" ") + ">\n"
		          : rowPrefix +
		            "<" +
		            type +
		            "\n" +
		            rowPrefix +
		            "  " +
		            properties.join("\n" + rowPrefix + "  ") +
		            "\n" +
		            rowPrefix +
		            ">\n";
		    }
		    function describePropertiesDiff(clientObject, serverObject, indent) {
		      var properties = "",
		        remainingServerProperties = assign({}, serverObject),
		        propName;
		      for (propName in clientObject)
		        if (clientObject.hasOwnProperty(propName)) {
		          delete remainingServerProperties[propName];
		          var maxLength = 120 - 2 * indent - propName.length - 2,
		            clientPropValue = describeValue(clientObject[propName], maxLength);
		          serverObject.hasOwnProperty(propName)
		            ? ((maxLength = describeValue(serverObject[propName], maxLength)),
		              (properties +=
		                added(indent) + propName + ": " + clientPropValue + "\n"),
		              (properties +=
		                removed(indent) + propName + ": " + maxLength + "\n"))
		            : (properties +=
		                added(indent) + propName + ": " + clientPropValue + "\n");
		        }
		      for (var _propName in remainingServerProperties)
		        remainingServerProperties.hasOwnProperty(_propName) &&
		          ((clientObject = describeValue(
		            remainingServerProperties[_propName],
		            120 - 2 * indent - _propName.length - 2
		          )),
		          (properties +=
		            removed(indent) + _propName + ": " + clientObject + "\n"));
		      return properties;
		    }
		    function describeElementDiff(type, clientProps, serverProps, indent) {
		      var content = "",
		        serverPropNames = new Map();
		      for (propName$jscomp$0 in serverProps)
		        serverProps.hasOwnProperty(propName$jscomp$0) &&
		          serverPropNames.set(
		            propName$jscomp$0.toLowerCase(),
		            propName$jscomp$0
		          );
		      if (1 === serverPropNames.size && serverPropNames.has("children"))
		        content += describeExpandedElement(
		          type,
		          clientProps,
		          indentation(indent)
		        );
		      else {
		        for (var _propName2 in clientProps)
		          if (
		            clientProps.hasOwnProperty(_propName2) &&
		            "children" !== _propName2
		          ) {
		            var maxLength$jscomp$0 =
		                120 - 2 * (indent + 1) - _propName2.length - 1,
		              serverPropName = serverPropNames.get(_propName2.toLowerCase());
		            if (void 0 !== serverPropName) {
		              serverPropNames.delete(_propName2.toLowerCase());
		              var propName$jscomp$0 = clientProps[_propName2];
		              serverPropName = serverProps[serverPropName];
		              var clientPropValue = describePropValue(
		                propName$jscomp$0,
		                maxLength$jscomp$0
		              );
		              maxLength$jscomp$0 = describePropValue(
		                serverPropName,
		                maxLength$jscomp$0
		              );
		              "object" === typeof propName$jscomp$0 &&
		              null !== propName$jscomp$0 &&
		              "object" === typeof serverPropName &&
		              null !== serverPropName &&
		              "Object" === objectName(propName$jscomp$0) &&
		              "Object" === objectName(serverPropName) &&
		              (2 < Object.keys(propName$jscomp$0).length ||
		                2 < Object.keys(serverPropName).length ||
		                -1 < clientPropValue.indexOf("...") ||
		                -1 < maxLength$jscomp$0.indexOf("..."))
		                ? (content +=
		                    indentation(indent + 1) +
		                    _propName2 +
		                    "={{\n" +
		                    describePropertiesDiff(
		                      propName$jscomp$0,
		                      serverPropName,
		                      indent + 2
		                    ) +
		                    indentation(indent + 1) +
		                    "}}\n")
		                : ((content +=
		                    added(indent + 1) +
		                    _propName2 +
		                    "=" +
		                    clientPropValue +
		                    "\n"),
		                  (content +=
		                    removed(indent + 1) +
		                    _propName2 +
		                    "=" +
		                    maxLength$jscomp$0 +
		                    "\n"));
		            } else
		              content +=
		                indentation(indent + 1) +
		                _propName2 +
		                "=" +
		                describePropValue(clientProps[_propName2], maxLength$jscomp$0) +
		                "\n";
		          }
		        serverPropNames.forEach(function (propName) {
		          if ("children" !== propName) {
		            var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;
		            content +=
		              removed(indent + 1) +
		              propName +
		              "=" +
		              describePropValue(serverProps[propName], maxLength) +
		              "\n";
		          }
		        });
		        content =
		          "" === content
		            ? indentation(indent) + "<" + type + ">\n"
		            : indentation(indent) +
		              "<" +
		              type +
		              "\n" +
		              content +
		              indentation(indent) +
		              ">\n";
		      }
		      type = serverProps.children;
		      clientProps = clientProps.children;
		      if (
		        "string" === typeof type ||
		        "number" === typeof type ||
		        "bigint" === typeof type
		      ) {
		        serverPropNames = "";
		        if (
		          "string" === typeof clientProps ||
		          "number" === typeof clientProps ||
		          "bigint" === typeof clientProps
		        )
		          serverPropNames = "" + clientProps;
		        content += describeTextDiff(serverPropNames, "" + type, indent + 1);
		      } else if (
		        "string" === typeof clientProps ||
		        "number" === typeof clientProps ||
		        "bigint" === typeof clientProps
		      )
		        content =
		          null == type
		            ? content + describeTextDiff("" + clientProps, null, indent + 1)
		            : content + describeTextDiff("" + clientProps, void 0, indent + 1);
		      return content;
		    }
		    function describeSiblingFiber(fiber, indent) {
		      var type = describeFiberType(fiber);
		      if (null === type) {
		        type = "";
		        for (fiber = fiber.child; fiber; )
		          (type += describeSiblingFiber(fiber, indent)),
		            (fiber = fiber.sibling);
		        return type;
		      }
		      return indentation(indent) + "<" + type + ">\n";
		    }
		    function describeNode(node, indent) {
		      var skipToNode = findNotableNode(node, indent);
		      if (
		        skipToNode !== node &&
		        (1 !== node.children.length || node.children[0] !== skipToNode)
		      )
		        return (
		          indentation(indent) + "...\n" + describeNode(skipToNode, indent + 1)
		        );
		      skipToNode = "";
		      var debugInfo = node.fiber._debugInfo;
		      if (debugInfo)
		        for (var i = 0; i < debugInfo.length; i++) {
		          var serverComponentName = debugInfo[i].name;
		          "string" === typeof serverComponentName &&
		            ((skipToNode +=
		              indentation(indent) + "<" + serverComponentName + ">\n"),
		            indent++);
		        }
		      debugInfo = "";
		      i = node.fiber.pendingProps;
		      if (6 === node.fiber.tag)
		        (debugInfo = describeTextDiff(i, node.serverProps, indent)), indent++;
		      else if (
		        ((serverComponentName = describeFiberType(node.fiber)),
		        null !== serverComponentName)
		      )
		        if (void 0 === node.serverProps) {
		          debugInfo = indent;
		          var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2,
		            content = "";
		          for (propName in i)
		            if (i.hasOwnProperty(propName) && "children" !== propName) {
		              var propValue = describePropValue(i[propName], 15);
		              maxLength -= propName.length + propValue.length + 2;
		              if (0 > maxLength) {
		                content += " ...";
		                break;
		              }
		              content += " " + propName + "=" + propValue;
		            }
		          debugInfo =
		            indentation(debugInfo) +
		            "<" +
		            serverComponentName +
		            content +
		            ">\n";
		          indent++;
		        } else
		          null === node.serverProps
		            ? ((debugInfo = describeExpandedElement(
		                serverComponentName,
		                i,
		                added(indent)
		              )),
		              indent++)
		            : "string" === typeof node.serverProps
		              ? console.error(
		                  "Should not have matched a non HostText fiber to a Text node. This is a bug in React."
		                )
		              : ((debugInfo = describeElementDiff(
		                  serverComponentName,
		                  i,
		                  node.serverProps,
		                  indent
		                )),
		                indent++);
		      var propName = "";
		      i = node.fiber.child;
		      for (
		        serverComponentName = 0;
		        i && serverComponentName < node.children.length;

		      )
		        (maxLength = node.children[serverComponentName]),
		          maxLength.fiber === i
		            ? ((propName += describeNode(maxLength, indent)),
		              serverComponentName++)
		            : (propName += describeSiblingFiber(i, indent)),
		          (i = i.sibling);
		      i &&
		        0 < node.children.length &&
		        (propName += indentation(indent) + "...\n");
		      i = node.serverTail;
		      null === node.serverProps && indent--;
		      for (node = 0; node < i.length; node++)
		        (serverComponentName = i[node]),
		          (propName =
		            "string" === typeof serverComponentName
		              ? propName +
		                (removed(indent) +
		                  describeTextNode(serverComponentName, 120 - 2 * indent) +
		                  "\n")
		              : propName +
		                describeExpandedElement(
		                  serverComponentName.type,
		                  serverComponentName.props,
		                  removed(indent)
		                ));
		      return skipToNode + debugInfo + propName;
		    }
		    function describeDiff(rootNode) {
		      try {
		        return "\n\n" + describeNode(rootNode, 0);
		      } catch (x) {
		        return "";
		      }
		    }
		    function buildHydrationDiffNode(fiber, distanceFromLeaf) {
		      if (null === fiber.return) {
		        if (null === hydrationDiffRootDEV)
		          hydrationDiffRootDEV = {
		            fiber: fiber,
		            children: [],
		            serverProps: void 0,
		            serverTail: [],
		            distanceFromLeaf: distanceFromLeaf
		          };
		        else {
		          if (hydrationDiffRootDEV.fiber !== fiber)
		            throw Error(
		              "Saw multiple hydration diff roots in a pass. This is a bug in React."
		            );
		          hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf &&
		            (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);
		        }
		        return hydrationDiffRootDEV;
		      }
		      var siblings = buildHydrationDiffNode(
		        fiber.return,
		        distanceFromLeaf + 1
		      ).children;
		      if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber)
		        return (
		          (siblings = siblings[siblings.length - 1]),
		          siblings.distanceFromLeaf > distanceFromLeaf &&
		            (siblings.distanceFromLeaf = distanceFromLeaf),
		          siblings
		        );
		      distanceFromLeaf = {
		        fiber: fiber,
		        children: [],
		        serverProps: void 0,
		        serverTail: [],
		        distanceFromLeaf: distanceFromLeaf
		      };
		      siblings.push(distanceFromLeaf);
		      return distanceFromLeaf;
		    }
		    function warnNonHydratedInstance(fiber, rejectedCandidate) {
		      didSuspendOrErrorDEV ||
		        ((fiber = buildHydrationDiffNode(fiber, 0)),
		        (fiber.serverProps = null),
		        null !== rejectedCandidate &&
		          ((rejectedCandidate =
		            describeHydratableInstanceForDevWarnings(rejectedCandidate)),
		          fiber.serverTail.push(rejectedCandidate)));
		    }
		    function throwOnHydrationMismatch(fiber) {
		      var diff = "",
		        diffRoot = hydrationDiffRootDEV;
		      null !== diffRoot &&
		        ((hydrationDiffRootDEV = null), (diff = describeDiff(diffRoot)));
		      queueHydrationError(
		        createCapturedValueAtFiber(
		          Error(
		            "Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\nhttps://react.dev/link/hydration-mismatch" +
		              diff
		          ),
		          fiber
		        )
		      );
		      throw HydrationMismatchException;
		    }
		    function prepareToHydrateHostInstance(fiber, hostContext) {
		      if (!supportsHydration)
		        throw Error(
		          "Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
		        );
		      hydrateInstance(
		        fiber.stateNode,
		        fiber.type,
		        fiber.memoizedProps,
		        hostContext,
		        fiber
		      ) || throwOnHydrationMismatch(fiber);
		    }
		    function popToNextHostParent(fiber) {
		      for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
		        switch (hydrationParentFiber.tag) {
		          case 3:
		          case 27:
		            rootOrSingletonContext = true;
		            return;
		          case 5:
		          case 13:
		            rootOrSingletonContext = false;
		            return;
		          default:
		            hydrationParentFiber = hydrationParentFiber.return;
		        }
		    }
		    function popHydrationState(fiber) {
		      if (!supportsHydration || fiber !== hydrationParentFiber) return false;
		      if (!isHydrating)
		        return popToNextHostParent(fiber), (isHydrating = true), false;
		      var shouldClear = false;
		      supportsSingletons
		        ? 3 !== fiber.tag &&
		          27 !== fiber.tag &&
		          (5 !== fiber.tag ||
		            (shouldDeleteUnhydratedTailInstances(fiber.type) &&
		              !shouldSetTextContent(fiber.type, fiber.memoizedProps))) &&
		          (shouldClear = true)
		        : 3 !== fiber.tag &&
		          (5 !== fiber.tag ||
		            (shouldDeleteUnhydratedTailInstances(fiber.type) &&
		              !shouldSetTextContent(fiber.type, fiber.memoizedProps))) &&
		          (shouldClear = true);
		      if (shouldClear && nextHydratableInstance) {
		        for (shouldClear = nextHydratableInstance; shouldClear; ) {
		          var diffNode = buildHydrationDiffNode(fiber, 0),
		            description = describeHydratableInstanceForDevWarnings(shouldClear);
		          diffNode.serverTail.push(description);
		          shouldClear =
		            "Suspense" === description.type
		              ? getNextHydratableInstanceAfterSuspenseInstance(shouldClear)
		              : getNextHydratableSibling(shouldClear);
		        }
		        throwOnHydrationMismatch(fiber);
		      }
		      popToNextHostParent(fiber);
		      if (13 === fiber.tag) {
		        if (!supportsHydration)
		          throw Error(
		            "Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
		          );
		        fiber = fiber.memoizedState;
		        fiber = null !== fiber ? fiber.dehydrated : null;
		        if (!fiber)
		          throw Error(
		            "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
		          );
		        nextHydratableInstance =
		          getNextHydratableInstanceAfterSuspenseInstance(fiber);
		      } else
		        nextHydratableInstance = hydrationParentFiber
		          ? getNextHydratableSibling(fiber.stateNode)
		          : null;
		      return true;
		    }
		    function resetHydrationState() {
		      supportsHydration &&
		        ((nextHydratableInstance = hydrationParentFiber = null),
		        (didSuspendOrErrorDEV = isHydrating = false));
		    }
		    function queueHydrationError(error) {
		      null === hydrationErrors
		        ? (hydrationErrors = [error])
		        : hydrationErrors.push(error);
		    }
		    function emitPendingHydrationWarnings() {
		      var diffRoot = hydrationDiffRootDEV;
		      null !== diffRoot &&
		        ((hydrationDiffRootDEV = null),
		        (diffRoot = describeDiff(diffRoot)),
		        console.error(
		          "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\n%s%s",
		          "https://react.dev/link/hydration-mismatch",
		          diffRoot
		        ));
		    }
		    function finishQueueingConcurrentUpdates() {
		      for (
		        var endIndex = concurrentQueuesIndex,
		          i = (concurrentlyUpdatedLanes = concurrentQueuesIndex = 0);
		        i < endIndex;

		      ) {
		        var fiber = concurrentQueues[i];
		        concurrentQueues[i++] = null;
		        var queue = concurrentQueues[i];
		        concurrentQueues[i++] = null;
		        var update = concurrentQueues[i];
		        concurrentQueues[i++] = null;
		        var lane = concurrentQueues[i];
		        concurrentQueues[i++] = null;
		        if (null !== queue && null !== update) {
		          var pending = queue.pending;
		          null === pending
		            ? (update.next = update)
		            : ((update.next = pending.next), (pending.next = update));
		          queue.pending = update;
		        }
		        0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
		      }
		    }
		    function enqueueUpdate$1(fiber, queue, update, lane) {
		      concurrentQueues[concurrentQueuesIndex++] = fiber;
		      concurrentQueues[concurrentQueuesIndex++] = queue;
		      concurrentQueues[concurrentQueuesIndex++] = update;
		      concurrentQueues[concurrentQueuesIndex++] = lane;
		      concurrentlyUpdatedLanes |= lane;
		      fiber.lanes |= lane;
		      fiber = fiber.alternate;
		      null !== fiber && (fiber.lanes |= lane);
		    }
		    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
		      enqueueUpdate$1(fiber, queue, update, lane);
		      return getRootForUpdatedFiber(fiber);
		    }
		    function enqueueConcurrentRenderForLane(fiber, lane) {
		      enqueueUpdate$1(fiber, null, null, lane);
		      return getRootForUpdatedFiber(fiber);
		    }
		    function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
		      sourceFiber.lanes |= lane;
		      var alternate = sourceFiber.alternate;
		      null !== alternate && (alternate.lanes |= lane);
		      for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
		        (parent.childLanes |= lane),
		          (alternate = parent.alternate),
		          null !== alternate && (alternate.childLanes |= lane),
		          22 === parent.tag &&
		            ((sourceFiber = parent.stateNode),
		            null === sourceFiber ||
		              sourceFiber._visibility & 1 ||
		              (isHidden = true)),
		          (sourceFiber = parent),
		          (parent = parent.return);
		      isHidden &&
		        null !== update &&
		        3 === sourceFiber.tag &&
		        ((parent = sourceFiber.stateNode),
		        (isHidden = 31 - clz32(lane)),
		        (parent = parent.hiddenUpdates),
		        (sourceFiber = parent[isHidden]),
		        null === sourceFiber
		          ? (parent[isHidden] = [update])
		          : sourceFiber.push(update),
		        (update.lane = lane | 536870912));
		    }
		    function getRootForUpdatedFiber(sourceFiber) {
		      if (nestedUpdateCount > NESTED_UPDATE_LIMIT)
		        throw (
		          ((nestedPassiveUpdateCount = nestedUpdateCount = 0),
		          (rootWithPassiveNestedUpdates = rootWithNestedUpdates = null),
		          Error(
		            "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
		          ))
		        );
		      nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT &&
		        ((nestedPassiveUpdateCount = 0),
		        (rootWithPassiveNestedUpdates = null),
		        console.error(
		          "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
		        ));
		      null === sourceFiber.alternate &&
		        0 !== (sourceFiber.flags & 4098) &&
		        warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
		      for (var node = sourceFiber, parent = node.return; null !== parent; )
		        null === node.alternate &&
		          0 !== (node.flags & 4098) &&
		          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber),
		          (node = parent),
		          (parent = node.return);
		      return 3 === node.tag ? node.stateNode : null;
		    }
		    function pushNestedEffectDurations() {
		      var prevEffectDuration = profilerEffectDuration;
		      profilerEffectDuration = 0;
		      return prevEffectDuration;
		    }
		    function popNestedEffectDurations(prevEffectDuration) {
		      var elapsedTime = profilerEffectDuration;
		      profilerEffectDuration = prevEffectDuration;
		      return elapsedTime;
		    }
		    function bubbleNestedEffectDurations(prevEffectDuration) {
		      var elapsedTime = profilerEffectDuration;
		      profilerEffectDuration += prevEffectDuration;
		      return elapsedTime;
		    }
		    function startProfilerTimer(fiber) {
		      profilerStartTime = now();
		      0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);
		    }
		    function stopProfilerTimerIfRunningAndRecordDuration(fiber) {
		      if (0 <= profilerStartTime) {
		        var elapsedTime = now() - profilerStartTime;
		        fiber.actualDuration += elapsedTime;
		        fiber.selfBaseDuration = elapsedTime;
		        profilerStartTime = -1;
		      }
		    }
		    function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {
		      if (0 <= profilerStartTime) {
		        var elapsedTime = now() - profilerStartTime;
		        fiber.actualDuration += elapsedTime;
		        profilerStartTime = -1;
		      }
		    }
		    function recordEffectDuration() {
		      if (0 <= profilerStartTime) {
		        var elapsedTime = now() - profilerStartTime;
		        profilerStartTime = -1;
		        profilerEffectDuration += elapsedTime;
		      }
		    }
		    function startEffectTimer() {
		      profilerStartTime = now();
		    }
		    function transferActualDuration(fiber) {
		      for (var child = fiber.child; child; )
		        (fiber.actualDuration += child.actualDuration), (child = child.sibling);
		    }
		    function ensureRootIsScheduled(root) {
		      root !== lastScheduledRoot &&
		        null === root.next &&
		        (null === lastScheduledRoot
		          ? (firstScheduledRoot = lastScheduledRoot = root)
		          : (lastScheduledRoot = lastScheduledRoot.next = root));
		      mightHavePendingSyncWork = true;
		      null !== ReactSharedInternals.actQueue
		        ? didScheduleMicrotask_act ||
		          ((didScheduleMicrotask_act = true),
		          scheduleImmediateTask(processRootScheduleInMicrotask))
		        : didScheduleMicrotask ||
		          ((didScheduleMicrotask = true),
		          scheduleImmediateTask(processRootScheduleInMicrotask));
		    }
		    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
		      if (!isFlushingWork && mightHavePendingSyncWork) {
		        isFlushingWork = true;
		        do {
		          var didPerformSomeWork = false;
		          for (var root = firstScheduledRoot; null !== root; ) {
		            if (0 !== syncTransitionLanes) {
		                var pendingLanes = root.pendingLanes;
		                if (0 === pendingLanes) var nextLanes = 0;
		                else {
		                  var suspendedLanes = root.suspendedLanes,
		                    pingedLanes = root.pingedLanes;
		                  nextLanes =
		                    (1 << (31 - clz32(42 | syncTransitionLanes) + 1)) - 1;
		                  nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
		                  nextLanes =
		                    nextLanes & 201326677
		                      ? (nextLanes & 201326677) | 1
		                      : nextLanes
		                        ? nextLanes | 2
		                        : 0;
		                }
		                0 !== nextLanes &&
		                  ((didPerformSomeWork = true),
		                  performSyncWorkOnRoot(root, nextLanes));
		              } else
		                (nextLanes = workInProgressRootRenderLanes),
		                  (nextLanes = getNextLanes(
		                    root,
		                    root === workInProgressRoot ? nextLanes : 0
		                  )),
		                  0 === (nextLanes & 3) ||
		                    checkIfRootIsPrerendering(root, nextLanes) ||
		                    ((didPerformSomeWork = true),
		                    performSyncWorkOnRoot(root, nextLanes));
		            root = root.next;
		          }
		        } while (didPerformSomeWork);
		        isFlushingWork = false;
		      }
		    }
		    function processRootScheduleInMicrotask() {
		      mightHavePendingSyncWork =
		        didScheduleMicrotask_act =
		        didScheduleMicrotask =
		          false;
		      var syncTransitionLanes = 0;
		      0 !== currentEventTransitionLane &&
		        (shouldAttemptEagerTransition() &&
		          (syncTransitionLanes = currentEventTransitionLane),
		        (currentEventTransitionLane = 0));
		      for (
		        var currentTime = now$1(), prev = null, root = firstScheduledRoot;
		        null !== root;

		      ) {
		        var next = root.next,
		          nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
		        if (0 === nextLanes)
		          (root.next = null),
		            null === prev ? (firstScheduledRoot = next) : (prev.next = next),
		            null === next && (lastScheduledRoot = prev);
		        else if (
		          ((prev = root), 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
		        )
		          mightHavePendingSyncWork = true;
		        root = next;
		      }
		      flushSyncWorkAcrossRoots_impl(syncTransitionLanes);
		    }
		    function scheduleTaskForRootDuringMicrotask(root, currentTime) {
		      for (
		        var suspendedLanes = root.suspendedLanes,
		          pingedLanes = root.pingedLanes,
		          expirationTimes = root.expirationTimes,
		          lanes = root.pendingLanes & -62914561;
		        0 < lanes;

		      ) {
		        var index = 31 - clz32(lanes),
		          lane = 1 << index,
		          expirationTime = expirationTimes[index];
		        if (-1 === expirationTime) {
		          if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
		            expirationTimes[index] = computeExpirationTime(lane, currentTime);
		        } else expirationTime <= currentTime && (root.expiredLanes |= lane);
		        lanes &= ~lane;
		      }
		      currentTime = workInProgressRoot;
		      suspendedLanes = workInProgressRootRenderLanes;
		      suspendedLanes = getNextLanes(
		        root,
		        root === currentTime ? suspendedLanes : 0
		      );
		      pingedLanes = root.callbackNode;
		      if (
		        0 === suspendedLanes ||
		        (root === currentTime &&
		          workInProgressSuspendedReason === SuspendedOnData) ||
		        null !== root.cancelPendingCommit
		      )
		        return (
		          null !== pingedLanes && cancelCallback(pingedLanes),
		          (root.callbackNode = null),
		          (root.callbackPriority = 0)
		        );
		      if (
		        0 === (suspendedLanes & 3) ||
		        checkIfRootIsPrerendering(root, suspendedLanes)
		      ) {
		        currentTime = suspendedLanes & -suspendedLanes;
		        if (
		          currentTime !== root.callbackPriority ||
		          (null !== ReactSharedInternals.actQueue &&
		            pingedLanes !== fakeActCallbackNode$1)
		        )
		          cancelCallback(pingedLanes);
		        else return currentTime;
		        switch (lanesToEventPriority(suspendedLanes)) {
		          case 2:
		          case 8:
		            suspendedLanes = UserBlockingPriority;
		            break;
		          case 32:
		            suspendedLanes = NormalPriority$1;
		            break;
		          case 268435456:
		            suspendedLanes = IdlePriority;
		            break;
		          default:
		            suspendedLanes = NormalPriority$1;
		        }
		        pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
		        null !== ReactSharedInternals.actQueue
		          ? (ReactSharedInternals.actQueue.push(pingedLanes),
		            (suspendedLanes = fakeActCallbackNode$1))
		          : (suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes));
		        root.callbackPriority = currentTime;
		        root.callbackNode = suspendedLanes;
		        return currentTime;
		      }
		      null !== pingedLanes && cancelCallback(pingedLanes);
		      root.callbackPriority = 2;
		      root.callbackNode = null;
		      return 2;
		    }
		    function performWorkOnRootViaSchedulerTask(root, didTimeout) {
		      nestedUpdateScheduled = currentUpdateIsNested = false;
		      var originalCallbackNode = root.callbackNode;
		      if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode)
		        return null;
		      var workInProgressRootRenderLanes$jscomp$0 =
		        workInProgressRootRenderLanes;
		      workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
		        root,
		        root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0
		      );
		      if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
		      performWorkOnRoot(
		        root,
		        workInProgressRootRenderLanes$jscomp$0,
		        didTimeout
		      );
		      scheduleTaskForRootDuringMicrotask(root, now$1());
		      return null != root.callbackNode &&
		        root.callbackNode === originalCallbackNode
		        ? performWorkOnRootViaSchedulerTask.bind(null, root)
		        : null;
		    }
		    function performSyncWorkOnRoot(root, lanes) {
		      if (flushPassiveEffects()) return null;
		      currentUpdateIsNested = nestedUpdateScheduled;
		      nestedUpdateScheduled = false;
		      performWorkOnRoot(root, lanes, true);
		    }
		    function cancelCallback(callbackNode) {
		      callbackNode !== fakeActCallbackNode$1 &&
		        null !== callbackNode &&
		        cancelCallback$1(callbackNode);
		    }
		    function scheduleImmediateTask(cb) {
		      null !== ReactSharedInternals.actQueue &&
		        ReactSharedInternals.actQueue.push(function () {
		          cb();
		          return null;
		        });
		      supportsMicrotasks
		        ? scheduleMicrotask(function () {
		            (executionContext & (RenderContext | CommitContext)) !== NoContext
		              ? scheduleCallback$3(ImmediatePriority, cb)
		              : cb();
		          })
		        : scheduleCallback$3(ImmediatePriority, cb);
		    }
		    function requestTransitionLane() {
		      0 === currentEventTransitionLane &&
		        (currentEventTransitionLane = claimNextTransitionLane());
		      return currentEventTransitionLane;
		    }
		    function entangleAsyncAction(transition, thenable) {
		      if (null === currentEntangledListeners) {
		        var entangledListeners = (currentEntangledListeners = []);
		        currentEntangledPendingCount = 0;
		        currentEntangledLane = requestTransitionLane();
		        currentEntangledActionThenable = {
		          status: "pending",
		          value: void 0,
		          then: function (resolve) {
		            entangledListeners.push(resolve);
		          }
		        };
		      }
		      currentEntangledPendingCount++;
		      thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
		      return thenable;
		    }
		    function pingEngtangledActionScope() {
		      if (
		        0 === --currentEntangledPendingCount &&
		        null !== currentEntangledListeners
		      ) {
		        null !== currentEntangledActionThenable &&
		          (currentEntangledActionThenable.status = "fulfilled");
		        var listeners = currentEntangledListeners;
		        currentEntangledListeners = null;
		        currentEntangledLane = 0;
		        currentEntangledActionThenable = null;
		        for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
		      }
		    }
		    function chainThenableValue(thenable, result) {
		      var listeners = [],
		        thenableWithOverride = {
		          status: "pending",
		          value: null,
		          reason: null,
		          then: function (resolve) {
		            listeners.push(resolve);
		          }
		        };
		      thenable.then(
		        function () {
		          thenableWithOverride.status = "fulfilled";
		          thenableWithOverride.value = result;
		          for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
		        },
		        function (error) {
		          thenableWithOverride.status = "rejected";
		          thenableWithOverride.reason = error;
		          for (error = 0; error < listeners.length; error++)
		            (0, listeners[error])(void 0);
		        }
		      );
		      return thenableWithOverride;
		    }
		    function initializeUpdateQueue(fiber) {
		      fiber.updateQueue = {
		        baseState: fiber.memoizedState,
		        firstBaseUpdate: null,
		        lastBaseUpdate: null,
		        shared: { pending: null, lanes: 0, hiddenCallbacks: null },
		        callbacks: null
		      };
		    }
		    function cloneUpdateQueue(current, workInProgress) {
		      current = current.updateQueue;
		      workInProgress.updateQueue === current &&
		        (workInProgress.updateQueue = {
		          baseState: current.baseState,
		          firstBaseUpdate: current.firstBaseUpdate,
		          lastBaseUpdate: current.lastBaseUpdate,
		          shared: current.shared,
		          callbacks: null
		        });
		    }
		    function createUpdate(lane) {
		      return {
		        lane: lane,
		        tag: UpdateState,
		        payload: null,
		        callback: null,
		        next: null
		      };
		    }
		    function enqueueUpdate(fiber, update, lane) {
		      var updateQueue = fiber.updateQueue;
		      if (null === updateQueue) return null;
		      updateQueue = updateQueue.shared;
		      if (
		        currentlyProcessingQueue === updateQueue &&
		        !didWarnUpdateInsideUpdate
		      ) {
		        var componentName = getComponentNameFromFiber(fiber);
		        console.error(
		          "An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\n\nPlease update the following component: %s",
		          componentName
		        );
		        didWarnUpdateInsideUpdate = true;
		      }
		      if ((executionContext & RenderContext) !== NoContext)
		        return (
		          (componentName = updateQueue.pending),
		          null === componentName
		            ? (update.next = update)
		            : ((update.next = componentName.next),
		              (componentName.next = update)),
		          (updateQueue.pending = update),
		          (update = getRootForUpdatedFiber(fiber)),
		          markUpdateLaneFromFiberToRoot(fiber, null, lane),
		          update
		        );
		      enqueueUpdate$1(fiber, updateQueue, update, lane);
		      return getRootForUpdatedFiber(fiber);
		    }
		    function entangleTransitions(root, fiber, lane) {
		      fiber = fiber.updateQueue;
		      if (null !== fiber && ((fiber = fiber.shared), 0 !== (lane & 4194176))) {
		        var queueLanes = fiber.lanes;
		        queueLanes &= root.pendingLanes;
		        lane |= queueLanes;
		        fiber.lanes = lane;
		        markRootEntangled(root, lane);
		      }
		    }
		    function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
		      var queue = workInProgress.updateQueue,
		        current = workInProgress.alternate;
		      if (
		        null !== current &&
		        ((current = current.updateQueue), queue === current)
		      ) {
		        var newFirst = null,
		          newLast = null;
		        queue = queue.firstBaseUpdate;
		        if (null !== queue) {
		          do {
		            var clone = {
		              lane: queue.lane,
		              tag: queue.tag,
		              payload: queue.payload,
		              callback: null,
		              next: null
		            };
		            null === newLast
		              ? (newFirst = newLast = clone)
		              : (newLast = newLast.next = clone);
		            queue = queue.next;
		          } while (null !== queue);
		          null === newLast
		            ? (newFirst = newLast = capturedUpdate)
		            : (newLast = newLast.next = capturedUpdate);
		        } else newFirst = newLast = capturedUpdate;
		        queue = {
		          baseState: current.baseState,
		          firstBaseUpdate: newFirst,
		          lastBaseUpdate: newLast,
		          shared: current.shared,
		          callbacks: current.callbacks
		        };
		        workInProgress.updateQueue = queue;
		        return;
		      }
		      workInProgress = queue.lastBaseUpdate;
		      null === workInProgress
		        ? (queue.firstBaseUpdate = capturedUpdate)
		        : (workInProgress.next = capturedUpdate);
		      queue.lastBaseUpdate = capturedUpdate;
		    }
		    function suspendIfUpdateReadFromEntangledAsyncAction() {
		      if (didReadFromEntangledAsyncAction) {
		        var entangledActionThenable = currentEntangledActionThenable;
		        if (null !== entangledActionThenable) throw entangledActionThenable;
		      }
		    }
		    function processUpdateQueue(
		      workInProgress,
		      props,
		      instance$jscomp$0,
		      renderLanes
		    ) {
		      didReadFromEntangledAsyncAction = false;
		      var queue = workInProgress.updateQueue;
		      hasForceUpdate = false;
		      currentlyProcessingQueue = queue.shared;
		      var firstBaseUpdate = queue.firstBaseUpdate,
		        lastBaseUpdate = queue.lastBaseUpdate,
		        pendingQueue = queue.shared.pending;
		      if (null !== pendingQueue) {
		        queue.shared.pending = null;
		        var lastPendingUpdate = pendingQueue,
		          firstPendingUpdate = lastPendingUpdate.next;
		        lastPendingUpdate.next = null;
		        null === lastBaseUpdate
		          ? (firstBaseUpdate = firstPendingUpdate)
		          : (lastBaseUpdate.next = firstPendingUpdate);
		        lastBaseUpdate = lastPendingUpdate;
		        var current = workInProgress.alternate;
		        null !== current &&
		          ((current = current.updateQueue),
		          (pendingQueue = current.lastBaseUpdate),
		          pendingQueue !== lastBaseUpdate &&
		            (null === pendingQueue
		              ? (current.firstBaseUpdate = firstPendingUpdate)
		              : (pendingQueue.next = firstPendingUpdate),
		            (current.lastBaseUpdate = lastPendingUpdate)));
		      }
		      if (null !== firstBaseUpdate) {
		        var newState = queue.baseState;
		        lastBaseUpdate = 0;
		        current = firstPendingUpdate = lastPendingUpdate = null;
		        pendingQueue = firstBaseUpdate;
		        do {
		          var updateLane = pendingQueue.lane & -536870913,
		            isHiddenUpdate = updateLane !== pendingQueue.lane;
		          if (
		            isHiddenUpdate
		              ? (workInProgressRootRenderLanes & updateLane) === updateLane
		              : (renderLanes & updateLane) === updateLane
		          ) {
		            0 !== updateLane &&
		              updateLane === currentEntangledLane &&
		              (didReadFromEntangledAsyncAction = true);
		            null !== current &&
		              (current = current.next =
		                {
		                  lane: 0,
		                  tag: pendingQueue.tag,
		                  payload: pendingQueue.payload,
		                  callback: null,
		                  next: null
		                });
		            a: {
		              updateLane = workInProgress;
		              var partialState = pendingQueue;
		              var nextProps = props,
		                instance = instance$jscomp$0;
		              switch (partialState.tag) {
		                case ReplaceState:
		                  partialState = partialState.payload;
		                  if ("function" === typeof partialState) {
		                    isDisallowedContextReadInDEV = true;
		                    var nextState = partialState.call(
		                      instance,
		                      newState,
		                      nextProps
		                    );
		                    if (updateLane.mode & 8) {
		                      setIsStrictModeForDevtools(true);
		                      try {
		                        partialState.call(instance, newState, nextProps);
		                      } finally {
		                        setIsStrictModeForDevtools(false);
		                      }
		                    }
		                    isDisallowedContextReadInDEV = false;
		                    newState = nextState;
		                    break a;
		                  }
		                  newState = partialState;
		                  break a;
		                case CaptureUpdate:
		                  updateLane.flags = (updateLane.flags & -65537) | 128;
		                case UpdateState:
		                  nextState = partialState.payload;
		                  if ("function" === typeof nextState) {
		                    isDisallowedContextReadInDEV = true;
		                    partialState = nextState.call(
		                      instance,
		                      newState,
		                      nextProps
		                    );
		                    if (updateLane.mode & 8) {
		                      setIsStrictModeForDevtools(true);
		                      try {
		                        nextState.call(instance, newState, nextProps);
		                      } finally {
		                        setIsStrictModeForDevtools(false);
		                      }
		                    }
		                    isDisallowedContextReadInDEV = false;
		                  } else partialState = nextState;
		                  if (null === partialState || void 0 === partialState) break a;
		                  newState = assign({}, newState, partialState);
		                  break a;
		                case ForceUpdate:
		                  hasForceUpdate = true;
		              }
		            }
		            updateLane = pendingQueue.callback;
		            null !== updateLane &&
		              ((workInProgress.flags |= 64),
		              isHiddenUpdate && (workInProgress.flags |= 8192),
		              (isHiddenUpdate = queue.callbacks),
		              null === isHiddenUpdate
		                ? (queue.callbacks = [updateLane])
		                : isHiddenUpdate.push(updateLane));
		          } else
		            (isHiddenUpdate = {
		              lane: updateLane,
		              tag: pendingQueue.tag,
		              payload: pendingQueue.payload,
		              callback: pendingQueue.callback,
		              next: null
		            }),
		              null === current
		                ? ((firstPendingUpdate = current = isHiddenUpdate),
		                  (lastPendingUpdate = newState))
		                : (current = current.next = isHiddenUpdate),
		              (lastBaseUpdate |= updateLane);
		          pendingQueue = pendingQueue.next;
		          if (null === pendingQueue)
		            if (((pendingQueue = queue.shared.pending), null === pendingQueue))
		              break;
		            else
		              (isHiddenUpdate = pendingQueue),
		                (pendingQueue = isHiddenUpdate.next),
		                (isHiddenUpdate.next = null),
		                (queue.lastBaseUpdate = isHiddenUpdate),
		                (queue.shared.pending = null);
		        } while (1);
		        null === current && (lastPendingUpdate = newState);
		        queue.baseState = lastPendingUpdate;
		        queue.firstBaseUpdate = firstPendingUpdate;
		        queue.lastBaseUpdate = current;
		        null === firstBaseUpdate && (queue.shared.lanes = 0);
		        workInProgressRootSkippedLanes |= lastBaseUpdate;
		        workInProgress.lanes = lastBaseUpdate;
		        workInProgress.memoizedState = newState;
		      }
		      currentlyProcessingQueue = null;
		    }
		    function callCallback(callback, context) {
		      if ("function" !== typeof callback)
		        throw Error(
		          "Invalid argument passed as callback. Expected a function. Instead received: " +
		            callback
		        );
		      callback.call(context);
		    }
		    function commitHiddenCallbacks(updateQueue, context) {
		      var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;
		      if (null !== hiddenCallbacks)
		        for (
		          updateQueue.shared.hiddenCallbacks = null, updateQueue = 0;
		          updateQueue < hiddenCallbacks.length;
		          updateQueue++
		        )
		          callCallback(hiddenCallbacks[updateQueue], context);
		    }
		    function commitCallbacks(updateQueue, context) {
		      var callbacks = updateQueue.callbacks;
		      if (null !== callbacks)
		        for (
		          updateQueue.callbacks = null, updateQueue = 0;
		          updateQueue < callbacks.length;
		          updateQueue++
		        )
		          callCallback(callbacks[updateQueue], context);
		    }
		    function shallowEqual(objA, objB) {
		      if (objectIs(objA, objB)) return true;
		      if (
		        "object" !== typeof objA ||
		        null === objA ||
		        "object" !== typeof objB ||
		        null === objB
		      )
		        return false;
		      var keysA = Object.keys(objA),
		        keysB = Object.keys(objB);
		      if (keysA.length !== keysB.length) return false;
		      for (keysB = 0; keysB < keysA.length; keysB++) {
		        var currentKey = keysA[keysB];
		        if (
		          !hasOwnProperty.call(objB, currentKey) ||
		          !objectIs(objA[currentKey], objB[currentKey])
		        )
		          return false;
		      }
		      return true;
		    }
		    function createThenableState() {
		      return { didWarnAboutUncachedPromise: false, thenables: [] };
		    }
		    function isThenableResolved(thenable) {
		      thenable = thenable.status;
		      return "fulfilled" === thenable || "rejected" === thenable;
		    }
		    function noop$1() {}
		    function trackUsedThenable(thenableState, thenable, index) {
		      null !== ReactSharedInternals.actQueue &&
		        (ReactSharedInternals.didUsePromise = true);
		      var trackedThenables = thenableState.thenables;
		      index = trackedThenables[index];
		      void 0 === index
		        ? trackedThenables.push(thenable)
		        : index !== thenable &&
		          (thenableState.didWarnAboutUncachedPromise ||
		            ((thenableState.didWarnAboutUncachedPromise = true),
		            console.error(
		              "A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework."
		            )),
		          thenable.then(noop$1, noop$1),
		          (thenable = index));
		      switch (thenable.status) {
		        case "fulfilled":
		          return thenable.value;
		        case "rejected":
		          throw (
		            ((thenableState = thenable.reason),
		            checkIfUseWrappedInAsyncCatch(thenableState),
		            thenableState)
		          );
		        default:
		          if ("string" === typeof thenable.status)
		            thenable.then(noop$1, noop$1);
		          else {
		            thenableState = workInProgressRoot;
		            if (
		              null !== thenableState &&
		              100 < thenableState.shellSuspendCounter
		            )
		              throw Error(
		                "async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
		              );
		            thenableState = thenable;
		            thenableState.status = "pending";
		            thenableState.then(
		              function (fulfilledValue) {
		                if ("pending" === thenable.status) {
		                  var fulfilledThenable = thenable;
		                  fulfilledThenable.status = "fulfilled";
		                  fulfilledThenable.value = fulfilledValue;
		                }
		              },
		              function (error) {
		                if ("pending" === thenable.status) {
		                  var rejectedThenable = thenable;
		                  rejectedThenable.status = "rejected";
		                  rejectedThenable.reason = error;
		                }
		              }
		            );
		          }
		          switch (thenable.status) {
		            case "fulfilled":
		              return thenable.value;
		            case "rejected":
		              throw (
		                ((thenableState = thenable.reason),
		                checkIfUseWrappedInAsyncCatch(thenableState),
		                thenableState)
		              );
		          }
		          suspendedThenable = thenable;
		          needsToResetSuspendedThenableDEV = true;
		          throw SuspenseException;
		      }
		    }
		    function getSuspendedThenable() {
		      if (null === suspendedThenable)
		        throw Error(
		          "Expected a suspended thenable. This is a bug in React. Please file an issue."
		        );
		      var thenable = suspendedThenable;
		      suspendedThenable = null;
		      needsToResetSuspendedThenableDEV = false;
		      return thenable;
		    }
		    function checkIfUseWrappedInAsyncCatch(rejectedReason) {
		      if (rejectedReason === SuspenseException)
		        throw Error(
		          "Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
		        );
		    }
		    function pushDebugInfo(debugInfo) {
		      var previousDebugInfo = currentDebugInfo;
		      null != debugInfo &&
		        (currentDebugInfo =
		          null === previousDebugInfo
		            ? debugInfo
		            : previousDebugInfo.concat(debugInfo));
		      return previousDebugInfo;
		    }
		    function validateFragmentProps(element, fiber, returnFiber) {
		      for (var keys = Object.keys(element.props), i = 0; i < keys.length; i++) {
		        var key = keys[i];
		        if ("children" !== key && "key" !== key) {
		          null === fiber &&
		            ((fiber = createFiberFromElement(element, returnFiber.mode, 0)),
		            (fiber._debugInfo = currentDebugInfo),
		            (fiber.return = returnFiber));
		          runWithFiberInDEV(
		            fiber,
		            function (erroredKey) {
		              console.error(
		                "Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",
		                erroredKey
		              );
		            },
		            key
		          );
		          break;
		        }
		      }
		    }
		    function unwrapThenable(thenable) {
		      var index = thenableIndexCounter$1;
		      thenableIndexCounter$1 += 1;
		      null === thenableState$1 && (thenableState$1 = createThenableState());
		      return trackUsedThenable(thenableState$1, thenable, index);
		    }
		    function coerceRef(workInProgress, element) {
		      element = element.props.ref;
		      workInProgress.ref = void 0 !== element ? element : null;
		    }
		    function throwOnInvalidObjectType(returnFiber, newChild) {
		      if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
		        throw Error(
		          'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
		        );
		      returnFiber = Object.prototype.toString.call(newChild);
		      throw Error(
		        "Objects are not valid as a React child (found: " +
		          ("[object Object]" === returnFiber
		            ? "object with keys {" + Object.keys(newChild).join(", ") + "}"
		            : returnFiber) +
		          "). If you meant to render a collection of children, use an array instead."
		      );
		    }
		    function warnOnFunctionType(returnFiber, invalidChild) {
		      var parentName = getComponentNameFromFiber(returnFiber) || "Component";
		      ownerHasFunctionTypeWarning[parentName] ||
		        ((ownerHasFunctionTypeWarning[parentName] = true),
		        (invalidChild =
		          invalidChild.displayName || invalidChild.name || "Component"),
		        3 === returnFiber.tag
		          ? console.error(
		              "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  root.render(%s)",
		              invalidChild,
		              invalidChild,
		              invalidChild
		            )
		          : console.error(
		              "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  <%s>{%s}</%s>",
		              invalidChild,
		              invalidChild,
		              parentName,
		              invalidChild,
		              parentName
		            ));
		    }
		    function warnOnSymbolType(returnFiber, invalidChild) {
		      var parentName = getComponentNameFromFiber(returnFiber) || "Component";
		      ownerHasSymbolTypeWarning[parentName] ||
		        ((ownerHasSymbolTypeWarning[parentName] = true),
		        (invalidChild = String(invalidChild)),
		        3 === returnFiber.tag
		          ? console.error(
		              "Symbols are not valid as a React child.\n  root.render(%s)",
		              invalidChild
		            )
		          : console.error(
		              "Symbols are not valid as a React child.\n  <%s>%s</%s>",
		              parentName,
		              invalidChild,
		              parentName
		            ));
		    }
		    function createChildReconciler(shouldTrackSideEffects) {
		      function deleteChild(returnFiber, childToDelete) {
		        if (shouldTrackSideEffects) {
		          var deletions = returnFiber.deletions;
		          null === deletions
		            ? ((returnFiber.deletions = [childToDelete]),
		              (returnFiber.flags |= 16))
		            : deletions.push(childToDelete);
		        }
		      }
		      function deleteRemainingChildren(returnFiber, currentFirstChild) {
		        if (!shouldTrackSideEffects) return null;
		        for (; null !== currentFirstChild; )
		          deleteChild(returnFiber, currentFirstChild),
		            (currentFirstChild = currentFirstChild.sibling);
		        return null;
		      }
		      function mapRemainingChildren(currentFirstChild) {
		        for (var existingChildren = new Map(); null !== currentFirstChild; )
		          null !== currentFirstChild.key
		            ? existingChildren.set(currentFirstChild.key, currentFirstChild)
		            : existingChildren.set(currentFirstChild.index, currentFirstChild),
		            (currentFirstChild = currentFirstChild.sibling);
		        return existingChildren;
		      }
		      function useFiber(fiber, pendingProps) {
		        fiber = createWorkInProgress(fiber, pendingProps);
		        fiber.index = 0;
		        fiber.sibling = null;
		        return fiber;
		      }
		      function placeChild(newFiber, lastPlacedIndex, newIndex) {
		        newFiber.index = newIndex;
		        if (!shouldTrackSideEffects)
		          return (newFiber.flags |= 1048576), lastPlacedIndex;
		        newIndex = newFiber.alternate;
		        if (null !== newIndex)
		          return (
		            (newIndex = newIndex.index),
		            newIndex < lastPlacedIndex
		              ? ((newFiber.flags |= 33554434), lastPlacedIndex)
		              : newIndex
		          );
		        newFiber.flags |= 33554434;
		        return lastPlacedIndex;
		      }
		      function placeSingleChild(newFiber) {
		        shouldTrackSideEffects &&
		          null === newFiber.alternate &&
		          (newFiber.flags |= 33554434);
		        return newFiber;
		      }
		      function updateTextNode(returnFiber, current, textContent, lanes) {
		        if (null === current || 6 !== current.tag)
		          return (
		            (current = createFiberFromText(
		              textContent,
		              returnFiber.mode,
		              lanes
		            )),
		            (current.return = returnFiber),
		            (current._debugOwner = returnFiber),
		            (current._debugInfo = currentDebugInfo),
		            current
		          );
		        current = useFiber(current, textContent);
		        current.return = returnFiber;
		        current._debugInfo = currentDebugInfo;
		        return current;
		      }
		      function updateElement(returnFiber, current, element, lanes) {
		        var elementType = element.type;
		        if (elementType === REACT_FRAGMENT_TYPE)
		          return (
		            (current = updateFragment(
		              returnFiber,
		              current,
		              element.props.children,
		              lanes,
		              element.key
		            )),
		            validateFragmentProps(element, current, returnFiber),
		            current
		          );
		        if (
		          null !== current &&
		          (current.elementType === elementType ||
		            isCompatibleFamilyForHotReloading(current, element) ||
		            ("object" === typeof elementType &&
		              null !== elementType &&
		              elementType.$$typeof === REACT_LAZY_TYPE &&
		              callLazyInitInDEV(elementType) === current.type))
		        )
		          return (
		            (current = useFiber(current, element.props)),
		            coerceRef(current, element),
		            (current.return = returnFiber),
		            (current._debugOwner = element._owner),
		            (current._debugInfo = currentDebugInfo),
		            current
		          );
		        current = createFiberFromElement(element, returnFiber.mode, lanes);
		        coerceRef(current, element);
		        current.return = returnFiber;
		        current._debugInfo = currentDebugInfo;
		        return current;
		      }
		      function updatePortal(returnFiber, current, portal, lanes) {
		        if (
		          null === current ||
		          4 !== current.tag ||
		          current.stateNode.containerInfo !== portal.containerInfo ||
		          current.stateNode.implementation !== portal.implementation
		        )
		          return (
		            (current = createFiberFromPortal(portal, returnFiber.mode, lanes)),
		            (current.return = returnFiber),
		            (current._debugInfo = currentDebugInfo),
		            current
		          );
		        current = useFiber(current, portal.children || []);
		        current.return = returnFiber;
		        current._debugInfo = currentDebugInfo;
		        return current;
		      }
		      function updateFragment(returnFiber, current, fragment, lanes, key) {
		        if (null === current || 7 !== current.tag)
		          return (
		            (current = createFiberFromFragment(
		              fragment,
		              returnFiber.mode,
		              lanes,
		              key
		            )),
		            (current.return = returnFiber),
		            (current._debugOwner = returnFiber),
		            (current._debugInfo = currentDebugInfo),
		            current
		          );
		        current = useFiber(current, fragment);
		        current.return = returnFiber;
		        current._debugInfo = currentDebugInfo;
		        return current;
		      }
		      function createChild(returnFiber, newChild, lanes) {
		        if (
		          ("string" === typeof newChild && "" !== newChild) ||
		          "number" === typeof newChild ||
		          "bigint" === typeof newChild
		        )
		          return (
		            (newChild = createFiberFromText(
		              "" + newChild,
		              returnFiber.mode,
		              lanes
		            )),
		            (newChild.return = returnFiber),
		            (newChild._debugOwner = returnFiber),
		            (newChild._debugInfo = currentDebugInfo),
		            newChild
		          );
		        if ("object" === typeof newChild && null !== newChild) {
		          switch (newChild.$$typeof) {
		            case REACT_ELEMENT_TYPE:
		              return (
		                (lanes = createFiberFromElement(
		                  newChild,
		                  returnFiber.mode,
		                  lanes
		                )),
		                coerceRef(lanes, newChild),
		                (lanes.return = returnFiber),
		                (returnFiber = pushDebugInfo(newChild._debugInfo)),
		                (lanes._debugInfo = currentDebugInfo),
		                (currentDebugInfo = returnFiber),
		                lanes
		              );
		            case REACT_PORTAL_TYPE:
		              return (
		                (newChild = createFiberFromPortal(
		                  newChild,
		                  returnFiber.mode,
		                  lanes
		                )),
		                (newChild.return = returnFiber),
		                (newChild._debugInfo = currentDebugInfo),
		                newChild
		              );
		            case REACT_LAZY_TYPE:
		              var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);
		              newChild = callLazyInitInDEV(newChild);
		              returnFiber = createChild(returnFiber, newChild, lanes);
		              currentDebugInfo = _prevDebugInfo;
		              return returnFiber;
		          }
		          if (isArrayImpl(newChild) || getIteratorFn(newChild))
		            return (
		              (lanes = createFiberFromFragment(
		                newChild,
		                returnFiber.mode,
		                lanes,
		                null
		              )),
		              (lanes.return = returnFiber),
		              (lanes._debugOwner = returnFiber),
		              (returnFiber = pushDebugInfo(newChild._debugInfo)),
		              (lanes._debugInfo = currentDebugInfo),
		              (currentDebugInfo = returnFiber),
		              lanes
		            );
		          if ("function" === typeof newChild.then)
		            return (
		              (_prevDebugInfo = pushDebugInfo(newChild._debugInfo)),
		              (returnFiber = createChild(
		                returnFiber,
		                unwrapThenable(newChild),
		                lanes
		              )),
		              (currentDebugInfo = _prevDebugInfo),
		              returnFiber
		            );
		          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
		            return createChild(
		              returnFiber,
		              readContextDuringReconciliation(returnFiber, newChild),
		              lanes
		            );
		          throwOnInvalidObjectType(returnFiber, newChild);
		        }
		        "function" === typeof newChild &&
		          warnOnFunctionType(returnFiber, newChild);
		        "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
		        return null;
		      }
		      function updateSlot(returnFiber, oldFiber, newChild, lanes) {
		        var key = null !== oldFiber ? oldFiber.key : null;
		        if (
		          ("string" === typeof newChild && "" !== newChild) ||
		          "number" === typeof newChild ||
		          "bigint" === typeof newChild
		        )
		          return null !== key
		            ? null
		            : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
		        if ("object" === typeof newChild && null !== newChild) {
		          switch (newChild.$$typeof) {
		            case REACT_ELEMENT_TYPE:
		              return newChild.key === key
		                ? ((key = pushDebugInfo(newChild._debugInfo)),
		                  (returnFiber = updateElement(
		                    returnFiber,
		                    oldFiber,
		                    newChild,
		                    lanes
		                  )),
		                  (currentDebugInfo = key),
		                  returnFiber)
		                : null;
		            case REACT_PORTAL_TYPE:
		              return newChild.key === key
		                ? updatePortal(returnFiber, oldFiber, newChild, lanes)
		                : null;
		            case REACT_LAZY_TYPE:
		              return (
		                (key = pushDebugInfo(newChild._debugInfo)),
		                (newChild = callLazyInitInDEV(newChild)),
		                (returnFiber = updateSlot(
		                  returnFiber,
		                  oldFiber,
		                  newChild,
		                  lanes
		                )),
		                (currentDebugInfo = key),
		                returnFiber
		              );
		          }
		          if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
		            if (null !== key) return null;
		            key = pushDebugInfo(newChild._debugInfo);
		            returnFiber = updateFragment(
		              returnFiber,
		              oldFiber,
		              newChild,
		              lanes,
		              null
		            );
		            currentDebugInfo = key;
		            return returnFiber;
		          }
		          if ("function" === typeof newChild.then)
		            return (
		              (key = pushDebugInfo(newChild._debugInfo)),
		              (returnFiber = updateSlot(
		                returnFiber,
		                oldFiber,
		                unwrapThenable(newChild),
		                lanes
		              )),
		              (currentDebugInfo = key),
		              returnFiber
		            );
		          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
		            return updateSlot(
		              returnFiber,
		              oldFiber,
		              readContextDuringReconciliation(returnFiber, newChild),
		              lanes
		            );
		          throwOnInvalidObjectType(returnFiber, newChild);
		        }
		        "function" === typeof newChild &&
		          warnOnFunctionType(returnFiber, newChild);
		        "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
		        return null;
		      }
		      function updateFromMap(
		        existingChildren,
		        returnFiber,
		        newIdx,
		        newChild,
		        lanes
		      ) {
		        if (
		          ("string" === typeof newChild && "" !== newChild) ||
		          "number" === typeof newChild ||
		          "bigint" === typeof newChild
		        )
		          return (
		            (existingChildren = existingChildren.get(newIdx) || null),
		            updateTextNode(returnFiber, existingChildren, "" + newChild, lanes)
		          );
		        if ("object" === typeof newChild && null !== newChild) {
		          switch (newChild.$$typeof) {
		            case REACT_ELEMENT_TYPE:
		              return (
		                (newIdx =
		                  existingChildren.get(
		                    null === newChild.key ? newIdx : newChild.key
		                  ) || null),
		                (existingChildren = pushDebugInfo(newChild._debugInfo)),
		                (returnFiber = updateElement(
		                  returnFiber,
		                  newIdx,
		                  newChild,
		                  lanes
		                )),
		                (currentDebugInfo = existingChildren),
		                returnFiber
		              );
		            case REACT_PORTAL_TYPE:
		              return (
		                (existingChildren =
		                  existingChildren.get(
		                    null === newChild.key ? newIdx : newChild.key
		                  ) || null),
		                updatePortal(returnFiber, existingChildren, newChild, lanes)
		              );
		            case REACT_LAZY_TYPE:
		              var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);
		              newChild = callLazyInitInDEV(newChild);
		              returnFiber = updateFromMap(
		                existingChildren,
		                returnFiber,
		                newIdx,
		                newChild,
		                lanes
		              );
		              currentDebugInfo = _prevDebugInfo7;
		              return returnFiber;
		          }
		          if (isArrayImpl(newChild) || getIteratorFn(newChild))
		            return (
		              (newIdx = existingChildren.get(newIdx) || null),
		              (existingChildren = pushDebugInfo(newChild._debugInfo)),
		              (returnFiber = updateFragment(
		                returnFiber,
		                newIdx,
		                newChild,
		                lanes,
		                null
		              )),
		              (currentDebugInfo = existingChildren),
		              returnFiber
		            );
		          if ("function" === typeof newChild.then)
		            return (
		              (_prevDebugInfo7 = pushDebugInfo(newChild._debugInfo)),
		              (returnFiber = updateFromMap(
		                existingChildren,
		                returnFiber,
		                newIdx,
		                unwrapThenable(newChild),
		                lanes
		              )),
		              (currentDebugInfo = _prevDebugInfo7),
		              returnFiber
		            );
		          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
		            return updateFromMap(
		              existingChildren,
		              returnFiber,
		              newIdx,
		              readContextDuringReconciliation(returnFiber, newChild),
		              lanes
		            );
		          throwOnInvalidObjectType(returnFiber, newChild);
		        }
		        "function" === typeof newChild &&
		          warnOnFunctionType(returnFiber, newChild);
		        "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
		        return null;
		      }
		      function warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys) {
		        if ("object" !== typeof child || null === child) return knownKeys;
		        switch (child.$$typeof) {
		          case REACT_ELEMENT_TYPE:
		          case REACT_PORTAL_TYPE:
		            warnForMissingKey(returnFiber, workInProgress, child);
		            var key = child.key;
		            if ("string" !== typeof key) break;
		            if (null === knownKeys) {
		              knownKeys = new Set();
		              knownKeys.add(key);
		              break;
		            }
		            if (!knownKeys.has(key)) {
		              knownKeys.add(key);
		              break;
		            }
		            runWithFiberInDEV(workInProgress, function () {
		              console.error(
		                "Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.",
		                key
		              );
		            });
		            break;
		          case REACT_LAZY_TYPE:
		            (child = callLazyInitInDEV(child)),
		              warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys);
		        }
		        return knownKeys;
		      }
		      function reconcileChildrenArray(
		        returnFiber,
		        currentFirstChild,
		        newChildren,
		        lanes
		      ) {
		        for (
		          var knownKeys = null,
		            resultingFirstChild = null,
		            previousNewFiber = null,
		            oldFiber = currentFirstChild,
		            newIdx = (currentFirstChild = 0),
		            nextOldFiber = null;
		          null !== oldFiber && newIdx < newChildren.length;
		          newIdx++
		        ) {
		          oldFiber.index > newIdx
		            ? ((nextOldFiber = oldFiber), (oldFiber = null))
		            : (nextOldFiber = oldFiber.sibling);
		          var newFiber = updateSlot(
		            returnFiber,
		            oldFiber,
		            newChildren[newIdx],
		            lanes
		          );
		          if (null === newFiber) {
		            null === oldFiber && (oldFiber = nextOldFiber);
		            break;
		          }
		          knownKeys = warnOnInvalidKey(
		            returnFiber,
		            newFiber,
		            newChildren[newIdx],
		            knownKeys
		          );
		          shouldTrackSideEffects &&
		            oldFiber &&
		            null === newFiber.alternate &&
		            deleteChild(returnFiber, oldFiber);
		          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
		          null === previousNewFiber
		            ? (resultingFirstChild = newFiber)
		            : (previousNewFiber.sibling = newFiber);
		          previousNewFiber = newFiber;
		          oldFiber = nextOldFiber;
		        }
		        if (newIdx === newChildren.length)
		          return (
		            deleteRemainingChildren(returnFiber, oldFiber),
		            isHydrating && pushTreeFork(returnFiber, newIdx),
		            resultingFirstChild
		          );
		        if (null === oldFiber) {
		          for (; newIdx < newChildren.length; newIdx++)
		            (oldFiber = createChild(returnFiber, newChildren[newIdx], lanes)),
		              null !== oldFiber &&
		                ((knownKeys = warnOnInvalidKey(
		                  returnFiber,
		                  oldFiber,
		                  newChildren[newIdx],
		                  knownKeys
		                )),
		                (currentFirstChild = placeChild(
		                  oldFiber,
		                  currentFirstChild,
		                  newIdx
		                )),
		                null === previousNewFiber
		                  ? (resultingFirstChild = oldFiber)
		                  : (previousNewFiber.sibling = oldFiber),
		                (previousNewFiber = oldFiber));
		          isHydrating && pushTreeFork(returnFiber, newIdx);
		          return resultingFirstChild;
		        }
		        for (
		          oldFiber = mapRemainingChildren(oldFiber);
		          newIdx < newChildren.length;
		          newIdx++
		        )
		          (nextOldFiber = updateFromMap(
		            oldFiber,
		            returnFiber,
		            newIdx,
		            newChildren[newIdx],
		            lanes
		          )),
		            null !== nextOldFiber &&
		              ((knownKeys = warnOnInvalidKey(
		                returnFiber,
		                nextOldFiber,
		                newChildren[newIdx],
		                knownKeys
		              )),
		              shouldTrackSideEffects &&
		                null !== nextOldFiber.alternate &&
		                oldFiber.delete(
		                  null === nextOldFiber.key ? newIdx : nextOldFiber.key
		                ),
		              (currentFirstChild = placeChild(
		                nextOldFiber,
		                currentFirstChild,
		                newIdx
		              )),
		              null === previousNewFiber
		                ? (resultingFirstChild = nextOldFiber)
		                : (previousNewFiber.sibling = nextOldFiber),
		              (previousNewFiber = nextOldFiber));
		        shouldTrackSideEffects &&
		          oldFiber.forEach(function (child) {
		            return deleteChild(returnFiber, child);
		          });
		        isHydrating && pushTreeFork(returnFiber, newIdx);
		        return resultingFirstChild;
		      }
		      function reconcileChildrenIterator(
		        returnFiber,
		        currentFirstChild,
		        newChildren,
		        lanes
		      ) {
		        if (null == newChildren)
		          throw Error("An iterable object provided no iterator.");
		        for (
		          var resultingFirstChild = null,
		            previousNewFiber = null,
		            oldFiber = currentFirstChild,
		            newIdx = (currentFirstChild = 0),
		            nextOldFiber = null,
		            knownKeys = null,
		            step = newChildren.next();
		          null !== oldFiber && !step.done;
		          newIdx++, step = newChildren.next()
		        ) {
		          oldFiber.index > newIdx
		            ? ((nextOldFiber = oldFiber), (oldFiber = null))
		            : (nextOldFiber = oldFiber.sibling);
		          var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
		          if (null === newFiber) {
		            null === oldFiber && (oldFiber = nextOldFiber);
		            break;
		          }
		          knownKeys = warnOnInvalidKey(
		            returnFiber,
		            newFiber,
		            step.value,
		            knownKeys
		          );
		          shouldTrackSideEffects &&
		            oldFiber &&
		            null === newFiber.alternate &&
		            deleteChild(returnFiber, oldFiber);
		          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
		          null === previousNewFiber
		            ? (resultingFirstChild = newFiber)
		            : (previousNewFiber.sibling = newFiber);
		          previousNewFiber = newFiber;
		          oldFiber = nextOldFiber;
		        }
		        if (step.done)
		          return (
		            deleteRemainingChildren(returnFiber, oldFiber),
		            isHydrating && pushTreeFork(returnFiber, newIdx),
		            resultingFirstChild
		          );
		        if (null === oldFiber) {
		          for (; !step.done; newIdx++, step = newChildren.next())
		            (oldFiber = createChild(returnFiber, step.value, lanes)),
		              null !== oldFiber &&
		                ((knownKeys = warnOnInvalidKey(
		                  returnFiber,
		                  oldFiber,
		                  step.value,
		                  knownKeys
		                )),
		                (currentFirstChild = placeChild(
		                  oldFiber,
		                  currentFirstChild,
		                  newIdx
		                )),
		                null === previousNewFiber
		                  ? (resultingFirstChild = oldFiber)
		                  : (previousNewFiber.sibling = oldFiber),
		                (previousNewFiber = oldFiber));
		          isHydrating && pushTreeFork(returnFiber, newIdx);
		          return resultingFirstChild;
		        }
		        for (
		          oldFiber = mapRemainingChildren(oldFiber);
		          !step.done;
		          newIdx++, step = newChildren.next()
		        )
		          (nextOldFiber = updateFromMap(
		            oldFiber,
		            returnFiber,
		            newIdx,
		            step.value,
		            lanes
		          )),
		            null !== nextOldFiber &&
		              ((knownKeys = warnOnInvalidKey(
		                returnFiber,
		                nextOldFiber,
		                step.value,
		                knownKeys
		              )),
		              shouldTrackSideEffects &&
		                null !== nextOldFiber.alternate &&
		                oldFiber.delete(
		                  null === nextOldFiber.key ? newIdx : nextOldFiber.key
		                ),
		              (currentFirstChild = placeChild(
		                nextOldFiber,
		                currentFirstChild,
		                newIdx
		              )),
		              null === previousNewFiber
		                ? (resultingFirstChild = nextOldFiber)
		                : (previousNewFiber.sibling = nextOldFiber),
		              (previousNewFiber = nextOldFiber));
		        shouldTrackSideEffects &&
		          oldFiber.forEach(function (child) {
		            return deleteChild(returnFiber, child);
		          });
		        isHydrating && pushTreeFork(returnFiber, newIdx);
		        return resultingFirstChild;
		      }
		      function reconcileChildFibersImpl(
		        returnFiber,
		        currentFirstChild,
		        newChild,
		        lanes
		      ) {
		        "object" === typeof newChild &&
		          null !== newChild &&
		          newChild.type === REACT_FRAGMENT_TYPE &&
		          null === newChild.key &&
		          (validateFragmentProps(newChild, null, returnFiber),
		          (newChild = newChild.props.children));
		        if ("object" === typeof newChild && null !== newChild) {
		          switch (newChild.$$typeof) {
		            case REACT_ELEMENT_TYPE:
		              var prevDebugInfo = pushDebugInfo(newChild._debugInfo);
		              a: {
		                for (var key = newChild.key; null !== currentFirstChild; ) {
		                  if (currentFirstChild.key === key) {
		                    key = newChild.type;
		                    if (key === REACT_FRAGMENT_TYPE) {
		                      if (7 === currentFirstChild.tag) {
		                        deleteRemainingChildren(
		                          returnFiber,
		                          currentFirstChild.sibling
		                        );
		                        lanes = useFiber(
		                          currentFirstChild,
		                          newChild.props.children
		                        );
		                        lanes.return = returnFiber;
		                        lanes._debugOwner = newChild._owner;
		                        lanes._debugInfo = currentDebugInfo;
		                        validateFragmentProps(newChild, lanes, returnFiber);
		                        returnFiber = lanes;
		                        break a;
		                      }
		                    } else if (
		                      currentFirstChild.elementType === key ||
		                      isCompatibleFamilyForHotReloading(
		                        currentFirstChild,
		                        newChild
		                      ) ||
		                      ("object" === typeof key &&
		                        null !== key &&
		                        key.$$typeof === REACT_LAZY_TYPE &&
		                        callLazyInitInDEV(key) === currentFirstChild.type)
		                    ) {
		                      deleteRemainingChildren(
		                        returnFiber,
		                        currentFirstChild.sibling
		                      );
		                      lanes = useFiber(currentFirstChild, newChild.props);
		                      coerceRef(lanes, newChild);
		                      lanes.return = returnFiber;
		                      lanes._debugOwner = newChild._owner;
		                      lanes._debugInfo = currentDebugInfo;
		                      returnFiber = lanes;
		                      break a;
		                    }
		                    deleteRemainingChildren(returnFiber, currentFirstChild);
		                    break;
		                  } else deleteChild(returnFiber, currentFirstChild);
		                  currentFirstChild = currentFirstChild.sibling;
		                }
		                newChild.type === REACT_FRAGMENT_TYPE
		                  ? ((lanes = createFiberFromFragment(
		                      newChild.props.children,
		                      returnFiber.mode,
		                      lanes,
		                      newChild.key
		                    )),
		                    (lanes.return = returnFiber),
		                    (lanes._debugOwner = returnFiber),
		                    (lanes._debugInfo = currentDebugInfo),
		                    validateFragmentProps(newChild, lanes, returnFiber),
		                    (returnFiber = lanes))
		                  : ((lanes = createFiberFromElement(
		                      newChild,
		                      returnFiber.mode,
		                      lanes
		                    )),
		                    coerceRef(lanes, newChild),
		                    (lanes.return = returnFiber),
		                    (lanes._debugInfo = currentDebugInfo),
		                    (returnFiber = lanes));
		              }
		              returnFiber = placeSingleChild(returnFiber);
		              currentDebugInfo = prevDebugInfo;
		              return returnFiber;
		            case REACT_PORTAL_TYPE:
		              a: {
		                prevDebugInfo = newChild;
		                for (
		                  newChild = prevDebugInfo.key;
		                  null !== currentFirstChild;

		                ) {
		                  if (currentFirstChild.key === newChild)
		                    if (
		                      4 === currentFirstChild.tag &&
		                      currentFirstChild.stateNode.containerInfo ===
		                        prevDebugInfo.containerInfo &&
		                      currentFirstChild.stateNode.implementation ===
		                        prevDebugInfo.implementation
		                    ) {
		                      deleteRemainingChildren(
		                        returnFiber,
		                        currentFirstChild.sibling
		                      );
		                      lanes = useFiber(
		                        currentFirstChild,
		                        prevDebugInfo.children || []
		                      );
		                      lanes.return = returnFiber;
		                      returnFiber = lanes;
		                      break a;
		                    } else {
		                      deleteRemainingChildren(returnFiber, currentFirstChild);
		                      break;
		                    }
		                  else deleteChild(returnFiber, currentFirstChild);
		                  currentFirstChild = currentFirstChild.sibling;
		                }
		                lanes = createFiberFromPortal(
		                  prevDebugInfo,
		                  returnFiber.mode,
		                  lanes
		                );
		                lanes.return = returnFiber;
		                returnFiber = lanes;
		              }
		              return placeSingleChild(returnFiber);
		            case REACT_LAZY_TYPE:
		              return (
		                (prevDebugInfo = pushDebugInfo(newChild._debugInfo)),
		                (newChild = callLazyInitInDEV(newChild)),
		                (returnFiber = reconcileChildFibersImpl(
		                  returnFiber,
		                  currentFirstChild,
		                  newChild,
		                  lanes
		                )),
		                (currentDebugInfo = prevDebugInfo),
		                returnFiber
		              );
		          }
		          if (isArrayImpl(newChild))
		            return (
		              (prevDebugInfo = pushDebugInfo(newChild._debugInfo)),
		              (returnFiber = reconcileChildrenArray(
		                returnFiber,
		                currentFirstChild,
		                newChild,
		                lanes
		              )),
		              (currentDebugInfo = prevDebugInfo),
		              returnFiber
		            );
		          if (getIteratorFn(newChild)) {
		            prevDebugInfo = pushDebugInfo(newChild._debugInfo);
		            key = getIteratorFn(newChild);
		            if ("function" !== typeof key)
		              throw Error(
		                "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue."
		              );
		            var newChildren = key.call(newChild);
		            if (newChildren === newChild) {
		              if (
		                0 !== returnFiber.tag ||
		                "[object GeneratorFunction]" !==
		                  Object.prototype.toString.call(returnFiber.type) ||
		                "[object Generator]" !==
		                  Object.prototype.toString.call(newChildren)
		              )
		                didWarnAboutGenerators ||
		                  console.error(
		                    "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
		                  ),
		                  (didWarnAboutGenerators = true);
		            } else
		              newChild.entries !== key ||
		                didWarnAboutMaps ||
		                (console.error(
		                  "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
		                ),
		                (didWarnAboutMaps = true));
		            returnFiber = reconcileChildrenIterator(
		              returnFiber,
		              currentFirstChild,
		              newChildren,
		              lanes
		            );
		            currentDebugInfo = prevDebugInfo;
		            return returnFiber;
		          }
		          if ("function" === typeof newChild.then)
		            return (
		              (prevDebugInfo = pushDebugInfo(newChild._debugInfo)),
		              (returnFiber = reconcileChildFibersImpl(
		                returnFiber,
		                currentFirstChild,
		                unwrapThenable(newChild),
		                lanes
		              )),
		              (currentDebugInfo = prevDebugInfo),
		              returnFiber
		            );
		          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
		            return reconcileChildFibersImpl(
		              returnFiber,
		              currentFirstChild,
		              readContextDuringReconciliation(returnFiber, newChild),
		              lanes
		            );
		          throwOnInvalidObjectType(returnFiber, newChild);
		        }
		        if (
		          ("string" === typeof newChild && "" !== newChild) ||
		          "number" === typeof newChild ||
		          "bigint" === typeof newChild
		        )
		          return (
		            (prevDebugInfo = "" + newChild),
		            null !== currentFirstChild && 6 === currentFirstChild.tag
		              ? (deleteRemainingChildren(
		                  returnFiber,
		                  currentFirstChild.sibling
		                ),
		                (lanes = useFiber(currentFirstChild, prevDebugInfo)),
		                (lanes.return = returnFiber),
		                (returnFiber = lanes))
		              : (deleteRemainingChildren(returnFiber, currentFirstChild),
		                (lanes = createFiberFromText(
		                  prevDebugInfo,
		                  returnFiber.mode,
		                  lanes
		                )),
		                (lanes.return = returnFiber),
		                (lanes._debugOwner = returnFiber),
		                (lanes._debugInfo = currentDebugInfo),
		                (returnFiber = lanes)),
		            placeSingleChild(returnFiber)
		          );
		        "function" === typeof newChild &&
		          warnOnFunctionType(returnFiber, newChild);
		        "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
		        return deleteRemainingChildren(returnFiber, currentFirstChild);
		      }
		      return function (returnFiber, currentFirstChild, newChild, lanes) {
		        var prevDebugInfo = currentDebugInfo;
		        currentDebugInfo = null;
		        try {
		          thenableIndexCounter$1 = 0;
		          var firstChildFiber = reconcileChildFibersImpl(
		            returnFiber,
		            currentFirstChild,
		            newChild,
		            lanes
		          );
		          thenableState$1 = null;
		          return firstChildFiber;
		        } catch (x) {
		          if (x === SuspenseException) throw x;
		          var fiber = createFiber(29, x, null, returnFiber.mode);
		          fiber.lanes = lanes;
		          fiber.return = returnFiber;
		          var debugInfo = (fiber._debugInfo = currentDebugInfo);
		          fiber._debugOwner = returnFiber._debugOwner;
		          if (null != debugInfo)
		            for (var i = debugInfo.length - 1; 0 <= i; i--)
		              if ("string" === typeof debugInfo[i].stack) {
		                fiber._debugOwner = debugInfo[i];
		                break;
		              }
		          return fiber;
		        } finally {
		          currentDebugInfo = prevDebugInfo;
		        }
		      };
		    }
		    function pushHiddenContext(fiber, context) {
		      var prevEntangledRenderLanes = entangledRenderLanes;
		      push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);
		      push(currentTreeHiddenStackCursor, context, fiber);
		      entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;
		    }
		    function reuseHiddenContextOnStack(fiber) {
		      push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);
		      push(
		        currentTreeHiddenStackCursor,
		        currentTreeHiddenStackCursor.current,
		        fiber
		      );
		    }
		    function popHiddenContext(fiber) {
		      entangledRenderLanes = prevEntangledRenderLanesCursor.current;
		      pop(currentTreeHiddenStackCursor, fiber);
		      pop(prevEntangledRenderLanesCursor, fiber);
		    }
		    function pushPrimaryTreeSuspenseHandler(handler) {
		      var current = handler.alternate;
		      push(
		        suspenseStackCursor,
		        suspenseStackCursor.current & SubtreeSuspenseContextMask,
		        handler
		      );
		      push(suspenseHandlerStackCursor, handler, handler);
		      null === shellBoundary &&
		        (null === current || null !== currentTreeHiddenStackCursor.current
		          ? (shellBoundary = handler)
		          : null !== current.memoizedState && (shellBoundary = handler));
		    }
		    function pushOffscreenSuspenseHandler(fiber) {
		      if (22 === fiber.tag) {
		        if (
		          (push(suspenseStackCursor, suspenseStackCursor.current, fiber),
		          push(suspenseHandlerStackCursor, fiber, fiber),
		          null === shellBoundary)
		        ) {
		          var current = fiber.alternate;
		          null !== current &&
		            null !== current.memoizedState &&
		            (shellBoundary = fiber);
		        }
		      } else reuseSuspenseHandlerOnStack(fiber);
		    }
		    function reuseSuspenseHandlerOnStack(fiber) {
		      push(suspenseStackCursor, suspenseStackCursor.current, fiber);
		      push(
		        suspenseHandlerStackCursor,
		        suspenseHandlerStackCursor.current,
		        fiber
		      );
		    }
		    function popSuspenseHandler(fiber) {
		      pop(suspenseHandlerStackCursor, fiber);
		      shellBoundary === fiber && (shellBoundary = null);
		      pop(suspenseStackCursor, fiber);
		    }
		    function findFirstSuspended(row) {
		      for (var node = row; null !== node; ) {
		        if (13 === node.tag) {
		          var state = node.memoizedState;
		          if (
		            null !== state &&
		            ((state = state.dehydrated),
		            null === state ||
		              isSuspenseInstancePending(state) ||
		              isSuspenseInstanceFallback(state))
		          )
		            return node;
		        } else if (
		          19 === node.tag &&
		          void 0 !== node.memoizedProps.revealOrder
		        ) {
		          if (0 !== (node.flags & 128)) return node;
		        } else if (null !== node.child) {
		          node.child.return = node;
		          node = node.child;
		          continue;
		        }
		        if (node === row) break;
		        for (; null === node.sibling; ) {
		          if (null === node.return || node.return === row) return null;
		          node = node.return;
		        }
		        node.sibling.return = node.return;
		        node = node.sibling;
		      }
		      return null;
		    }
		    function mountHookTypesDev() {
		      var hookName = currentHookNameInDev;
		      null === hookTypesDev
		        ? (hookTypesDev = [hookName])
		        : hookTypesDev.push(hookName);
		    }
		    function updateHookTypesDev() {
		      var hookName = currentHookNameInDev;
		      if (
		        null !== hookTypesDev &&
		        (hookTypesUpdateIndexDev++,
		        hookTypesDev[hookTypesUpdateIndexDev] !== hookName)
		      ) {
		        var componentName = getComponentNameFromFiber(
		          currentlyRenderingFiber$1
		        );
		        if (
		          !didWarnAboutMismatchedHooksForComponent.has(componentName) &&
		          (didWarnAboutMismatchedHooksForComponent.add(componentName),
		          null !== hookTypesDev)
		        ) {
		          for (var table = "", i = 0; i <= hookTypesUpdateIndexDev; i++) {
		            var oldHookName = hookTypesDev[i],
		              newHookName =
		                i === hookTypesUpdateIndexDev ? hookName : oldHookName;
		            for (
		              oldHookName = i + 1 + ". " + oldHookName;
		              30 > oldHookName.length;

		            )
		              oldHookName += " ";
		            oldHookName += newHookName + "\n";
		            table += oldHookName;
		          }
		          console.error(
		            "React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
		            componentName,
		            table
		          );
		        }
		      }
		    }
		    function checkDepsAreArrayDev(deps) {
		      void 0 === deps ||
		        null === deps ||
		        isArrayImpl(deps) ||
		        console.error(
		          "%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",
		          currentHookNameInDev,
		          typeof deps
		        );
		    }
		    function warnOnUseFormStateInDev() {
		      var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
		      didWarnAboutUseFormState.has(componentName) ||
		        (didWarnAboutUseFormState.add(componentName),
		        console.error(
		          "ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.",
		          componentName
		        ));
		    }
		    function throwInvalidHookError() {
		      throw Error(
		        "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
		      );
		    }
		    function areHookInputsEqual(nextDeps, prevDeps) {
		      if (ignorePreviousDependencies) return false;
		      if (null === prevDeps)
		        return (
		          console.error(
		            "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
		            currentHookNameInDev
		          ),
		          false
		        );
		      nextDeps.length !== prevDeps.length &&
		        console.error(
		          "The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",
		          currentHookNameInDev,
		          "[" + prevDeps.join(", ") + "]",
		          "[" + nextDeps.join(", ") + "]"
		        );
		      for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
		        if (!objectIs(nextDeps[i], prevDeps[i])) return false;
		      return true;
		    }
		    function renderWithHooks(
		      current,
		      workInProgress,
		      Component,
		      props,
		      secondArg,
		      nextRenderLanes
		    ) {
		      renderLanes = nextRenderLanes;
		      currentlyRenderingFiber$1 = workInProgress;
		      hookTypesDev = null !== current ? current._debugHookTypes : null;
		      hookTypesUpdateIndexDev = -1;
		      ignorePreviousDependencies =
		        null !== current && current.type !== workInProgress.type;
		      if (
		        "[object AsyncFunction]" ===
		          Object.prototype.toString.call(Component) ||
		        "[object AsyncGeneratorFunction]" ===
		          Object.prototype.toString.call(Component)
		      )
		        (nextRenderLanes = getComponentNameFromFiber(
		          currentlyRenderingFiber$1
		        )),
		          didWarnAboutAsyncClientComponent.has(nextRenderLanes) ||
		            (didWarnAboutAsyncClientComponent.add(nextRenderLanes),
		            console.error(
		              "async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
		            ));
		      workInProgress.memoizedState = null;
		      workInProgress.updateQueue = null;
		      workInProgress.lanes = 0;
		      ReactSharedInternals.H =
		        null !== current && null !== current.memoizedState
		          ? HooksDispatcherOnUpdateInDEV
		          : null !== hookTypesDev
		            ? HooksDispatcherOnMountWithHookTypesInDEV
		            : HooksDispatcherOnMountInDEV;
		      shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes =
		        (workInProgress.mode & 8) !== NoMode;
		      var children = callComponentInDEV(Component, props, secondArg);
		      shouldDoubleInvokeUserFnsInHooksDEV = false;
		      didScheduleRenderPhaseUpdateDuringThisPass &&
		        (children = renderWithHooksAgain(
		          workInProgress,
		          Component,
		          props,
		          secondArg
		        ));
		      if (nextRenderLanes) {
		        setIsStrictModeForDevtools(true);
		        try {
		          children = renderWithHooksAgain(
		            workInProgress,
		            Component,
		            props,
		            secondArg
		          );
		        } finally {
		          setIsStrictModeForDevtools(false);
		        }
		      }
		      finishRenderingHooks(current, workInProgress);
		      return children;
		    }
		    function finishRenderingHooks(current, workInProgress) {
		      workInProgress._debugHookTypes = hookTypesDev;
		      null === workInProgress.dependencies
		        ? null !== thenableState &&
		          (workInProgress.dependencies = {
		            lanes: 0,
		            firstContext: null,
		            _debugThenableState: thenableState
		          })
		        : (workInProgress.dependencies._debugThenableState = thenableState);
		      ReactSharedInternals.H = ContextOnlyDispatcher;
		      var didRenderTooFewHooks =
		        null !== currentHook && null !== currentHook.next;
		      renderLanes = 0;
		      hookTypesDev =
		        currentHookNameInDev =
		        workInProgressHook =
		        currentHook =
		        currentlyRenderingFiber$1 =
		          null;
		      hookTypesUpdateIndexDev = -1;
		      null !== current &&
		        (current.flags & 31457280) !== (workInProgress.flags & 31457280) &&
		        console.error(
		          "Internal React error: Expected static flag was missing. Please notify the React team."
		        );
		      didScheduleRenderPhaseUpdate = false;
		      thenableIndexCounter = 0;
		      thenableState = null;
		      if (didRenderTooFewHooks)
		        throw Error(
		          "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
		        );
		      null === current ||
		        didReceiveUpdate ||
		        ((current = current.dependencies),
		        null !== current &&
		          checkIfContextChanged(current) &&
		          (didReceiveUpdate = true));
		      needsToResetSuspendedThenableDEV
		        ? ((needsToResetSuspendedThenableDEV = false), (current = true))
		        : (current = false);
		      current &&
		        ((workInProgress =
		          getComponentNameFromFiber(workInProgress) || "Unknown"),
		        didWarnAboutUseWrappedInTryCatch.has(workInProgress) ||
		          didWarnAboutAsyncClientComponent.has(workInProgress) ||
		          (didWarnAboutUseWrappedInTryCatch.add(workInProgress),
		          console.error(
		            "`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary."
		          )));
		    }
		    function renderWithHooksAgain(workInProgress, Component, props, secondArg) {
		      currentlyRenderingFiber$1 = workInProgress;
		      var numberOfReRenders = 0;
		      do {
		        didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
		        thenableIndexCounter = 0;
		        didScheduleRenderPhaseUpdateDuringThisPass = false;
		        if (numberOfReRenders >= RE_RENDER_LIMIT)
		          throw Error(
		            "Too many re-renders. React limits the number of renders to prevent an infinite loop."
		          );
		        numberOfReRenders += 1;
		        ignorePreviousDependencies = false;
		        workInProgressHook = currentHook = null;
		        if (null != workInProgress.updateQueue) {
		          var children = workInProgress.updateQueue;
		          children.lastEffect = null;
		          children.events = null;
		          children.stores = null;
		          null != children.memoCache && (children.memoCache.index = 0);
		        }
		        hookTypesUpdateIndexDev = -1;
		        ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;
		        children = callComponentInDEV(Component, props, secondArg);
		      } while (didScheduleRenderPhaseUpdateDuringThisPass);
		      return children;
		    }
		    function TransitionAwareHostComponent() {
		      var dispatcher = ReactSharedInternals.H,
		        maybeThenable = dispatcher.useState()[0];
		      maybeThenable =
		        "function" === typeof maybeThenable.then
		          ? useThenable(maybeThenable)
		          : maybeThenable;
		      dispatcher = dispatcher.useState()[0];
		      (null !== currentHook ? currentHook.memoizedState : null) !==
		        dispatcher && (currentlyRenderingFiber$1.flags |= 1024);
		      return maybeThenable;
		    }
		    function checkDidRenderIdHook() {
		      var didRenderIdHook = 0 !== localIdCounter;
		      localIdCounter = 0;
		      return didRenderIdHook;
		    }
		    function bailoutHooks(current, workInProgress, lanes) {
		      workInProgress.updateQueue = current.updateQueue;
		      workInProgress.flags =
		        (workInProgress.mode & 16) !== NoMode
		          ? workInProgress.flags & -201328645
		          : workInProgress.flags & -2053;
		      current.lanes &= ~lanes;
		    }
		    function resetHooksOnUnwind(workInProgress) {
		      if (didScheduleRenderPhaseUpdate) {
		        for (
		          workInProgress = workInProgress.memoizedState;
		          null !== workInProgress;

		        ) {
		          var queue = workInProgress.queue;
		          null !== queue && (queue.pending = null);
		          workInProgress = workInProgress.next;
		        }
		        didScheduleRenderPhaseUpdate = false;
		      }
		      renderLanes = 0;
		      hookTypesDev =
		        workInProgressHook =
		        currentHook =
		        currentlyRenderingFiber$1 =
		          null;
		      hookTypesUpdateIndexDev = -1;
		      currentHookNameInDev = null;
		      didScheduleRenderPhaseUpdateDuringThisPass = false;
		      thenableIndexCounter = localIdCounter = 0;
		      thenableState = null;
		    }
		    function mountWorkInProgressHook() {
		      var hook = {
		        memoizedState: null,
		        baseState: null,
		        baseQueue: null,
		        queue: null,
		        next: null
		      };
		      null === workInProgressHook
		        ? (currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook)
		        : (workInProgressHook = workInProgressHook.next = hook);
		      return workInProgressHook;
		    }
		    function updateWorkInProgressHook() {
		      if (null === currentHook) {
		        var nextCurrentHook = currentlyRenderingFiber$1.alternate;
		        nextCurrentHook =
		          null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
		      } else nextCurrentHook = currentHook.next;
		      var nextWorkInProgressHook =
		        null === workInProgressHook
		          ? currentlyRenderingFiber$1.memoizedState
		          : workInProgressHook.next;
		      if (null !== nextWorkInProgressHook)
		        (workInProgressHook = nextWorkInProgressHook),
		          (currentHook = nextCurrentHook);
		      else {
		        if (null === nextCurrentHook) {
		          if (null === currentlyRenderingFiber$1.alternate)
		            throw Error(
		              "Update hook called on initial render. This is likely a bug in React. Please file an issue."
		            );
		          throw Error("Rendered more hooks than during the previous render.");
		        }
		        currentHook = nextCurrentHook;
		        nextCurrentHook = {
		          memoizedState: currentHook.memoizedState,
		          baseState: currentHook.baseState,
		          baseQueue: currentHook.baseQueue,
		          queue: currentHook.queue,
		          next: null
		        };
		        null === workInProgressHook
		          ? (currentlyRenderingFiber$1.memoizedState = workInProgressHook =
		              nextCurrentHook)
		          : (workInProgressHook = workInProgressHook.next = nextCurrentHook);
		      }
		      return workInProgressHook;
		    }
		    function useThenable(thenable) {
		      var index = thenableIndexCounter;
		      thenableIndexCounter += 1;
		      null === thenableState && (thenableState = createThenableState());
		      thenable = trackUsedThenable(thenableState, thenable, index);
		      index = currentlyRenderingFiber$1;
		      null ===
		        (null === workInProgressHook
		          ? index.memoizedState
		          : workInProgressHook.next) &&
		        ((index = index.alternate),
		        (ReactSharedInternals.H =
		          null !== index && null !== index.memoizedState
		            ? HooksDispatcherOnUpdateInDEV
		            : HooksDispatcherOnMountInDEV));
		      return thenable;
		    }
		    function use(usable) {
		      if (null !== usable && "object" === typeof usable) {
		        if ("function" === typeof usable.then) return useThenable(usable);
		        if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
		      }
		      throw Error("An unsupported type was passed to use(): " + String(usable));
		    }
		    function useMemoCache(size) {
		      var memoCache = null,
		        updateQueue = currentlyRenderingFiber$1.updateQueue;
		      null !== updateQueue && (memoCache = updateQueue.memoCache);
		      if (null == memoCache) {
		        var current = currentlyRenderingFiber$1.alternate;
		        null !== current &&
		          ((current = current.updateQueue),
		          null !== current &&
		            ((current = current.memoCache),
		            null != current &&
		              (memoCache = {
		                data: current.data.map(function (array) {
		                  return array.slice();
		                }),
		                index: 0
		              })));
		      }
		      null == memoCache && (memoCache = { data: [], index: 0 });
		      null === updateQueue &&
		        ((updateQueue = createFunctionComponentUpdateQueue()),
		        (currentlyRenderingFiber$1.updateQueue = updateQueue));
		      updateQueue.memoCache = memoCache;
		      updateQueue = memoCache.data[memoCache.index];
		      if (void 0 === updateQueue || ignorePreviousDependencies)
		        for (
		          updateQueue = memoCache.data[memoCache.index] = Array(size),
		            current = 0;
		          current < size;
		          current++
		        )
		          updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
		      else
		        updateQueue.length !== size &&
		          console.error(
		            "Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.",
		            updateQueue.length,
		            size
		          );
		      memoCache.index++;
		      return updateQueue;
		    }
		    function basicStateReducer(state, action) {
		      return "function" === typeof action ? action(state) : action;
		    }
		    function mountReducer(reducer, initialArg, init) {
		      var hook = mountWorkInProgressHook();
		      if (void 0 !== init) {
		        var initialState = init(initialArg);
		        if (shouldDoubleInvokeUserFnsInHooksDEV) {
		          setIsStrictModeForDevtools(true);
		          try {
		            init(initialArg);
		          } finally {
		            setIsStrictModeForDevtools(false);
		          }
		        }
		      } else initialState = initialArg;
		      hook.memoizedState = hook.baseState = initialState;
		      reducer = {
		        pending: null,
		        lanes: 0,
		        dispatch: null,
		        lastRenderedReducer: reducer,
		        lastRenderedState: initialState
		      };
		      hook.queue = reducer;
		      reducer = reducer.dispatch = dispatchReducerAction.bind(
		        null,
		        currentlyRenderingFiber$1,
		        reducer
		      );
		      return [hook.memoizedState, reducer];
		    }
		    function updateReducer(reducer) {
		      var hook = updateWorkInProgressHook();
		      return updateReducerImpl(hook, currentHook, reducer);
		    }
		    function updateReducerImpl(hook, current, reducer) {
		      var queue = hook.queue;
		      if (null === queue)
		        throw Error(
		          "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
		        );
		      queue.lastRenderedReducer = reducer;
		      var baseQueue = hook.baseQueue,
		        pendingQueue = queue.pending;
		      if (null !== pendingQueue) {
		        if (null !== baseQueue) {
		          var baseFirst = baseQueue.next;
		          baseQueue.next = pendingQueue.next;
		          pendingQueue.next = baseFirst;
		        }
		        current.baseQueue !== baseQueue &&
		          console.error(
		            "Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."
		          );
		        current.baseQueue = baseQueue = pendingQueue;
		        queue.pending = null;
		      }
		      pendingQueue = hook.baseState;
		      if (null === baseQueue) hook.memoizedState = pendingQueue;
		      else {
		        current = baseQueue.next;
		        var newBaseQueueFirst = (baseFirst = null),
		          newBaseQueueLast = null,
		          update = current,
		          didReadFromEntangledAsyncAction = false;
		        do {
		          var updateLane = update.lane & -536870913;
		          if (
		            updateLane !== update.lane
		              ? (workInProgressRootRenderLanes & updateLane) === updateLane
		              : (renderLanes & updateLane) === updateLane
		          ) {
		            var revertLane = update.revertLane;
		            if (0 === revertLane)
		              null !== newBaseQueueLast &&
		                (newBaseQueueLast = newBaseQueueLast.next =
		                  {
		                    lane: 0,
		                    revertLane: 0,
		                    action: update.action,
		                    hasEagerState: update.hasEagerState,
		                    eagerState: update.eagerState,
		                    next: null
		                  }),
		                updateLane === currentEntangledLane &&
		                  (didReadFromEntangledAsyncAction = true);
		            else if ((renderLanes & revertLane) === revertLane) {
		              update = update.next;
		              revertLane === currentEntangledLane &&
		                (didReadFromEntangledAsyncAction = true);
		              continue;
		            } else
		              (updateLane = {
		                lane: 0,
		                revertLane: update.revertLane,
		                action: update.action,
		                hasEagerState: update.hasEagerState,
		                eagerState: update.eagerState,
		                next: null
		              }),
		                null === newBaseQueueLast
		                  ? ((newBaseQueueFirst = newBaseQueueLast = updateLane),
		                    (baseFirst = pendingQueue))
		                  : (newBaseQueueLast = newBaseQueueLast.next = updateLane),
		                (currentlyRenderingFiber$1.lanes |= revertLane),
		                (workInProgressRootSkippedLanes |= revertLane);
		            updateLane = update.action;
		            shouldDoubleInvokeUserFnsInHooksDEV &&
		              reducer(pendingQueue, updateLane);
		            pendingQueue = update.hasEagerState
		              ? update.eagerState
		              : reducer(pendingQueue, updateLane);
		          } else
		            (revertLane = {
		              lane: updateLane,
		              revertLane: update.revertLane,
		              action: update.action,
		              hasEagerState: update.hasEagerState,
		              eagerState: update.eagerState,
		              next: null
		            }),
		              null === newBaseQueueLast
		                ? ((newBaseQueueFirst = newBaseQueueLast = revertLane),
		                  (baseFirst = pendingQueue))
		                : (newBaseQueueLast = newBaseQueueLast.next = revertLane),
		              (currentlyRenderingFiber$1.lanes |= updateLane),
		              (workInProgressRootSkippedLanes |= updateLane);
		          update = update.next;
		        } while (null !== update && update !== current);
		        null === newBaseQueueLast
		          ? (baseFirst = pendingQueue)
		          : (newBaseQueueLast.next = newBaseQueueFirst);
		        if (
		          !objectIs(pendingQueue, hook.memoizedState) &&
		          ((didReceiveUpdate = true),
		          didReadFromEntangledAsyncAction &&
		            ((reducer = currentEntangledActionThenable), null !== reducer))
		        )
		          throw reducer;
		        hook.memoizedState = pendingQueue;
		        hook.baseState = baseFirst;
		        hook.baseQueue = newBaseQueueLast;
		        queue.lastRenderedState = pendingQueue;
		      }
		      null === baseQueue && (queue.lanes = 0);
		      return [hook.memoizedState, queue.dispatch];
		    }
		    function rerenderReducer(reducer) {
		      var hook = updateWorkInProgressHook(),
		        queue = hook.queue;
		      if (null === queue)
		        throw Error(
		          "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
		        );
		      queue.lastRenderedReducer = reducer;
		      var dispatch = queue.dispatch,
		        lastRenderPhaseUpdate = queue.pending,
		        newState = hook.memoizedState;
		      if (null !== lastRenderPhaseUpdate) {
		        queue.pending = null;
		        var update = (lastRenderPhaseUpdate = lastRenderPhaseUpdate.next);
		        do
		          (newState = reducer(newState, update.action)), (update = update.next);
		        while (update !== lastRenderPhaseUpdate);
		        objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
		        hook.memoizedState = newState;
		        null === hook.baseQueue && (hook.baseState = newState);
		        queue.lastRenderedState = newState;
		      }
		      return [newState, dispatch];
		    }
		    function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
		      var fiber = currentlyRenderingFiber$1,
		        hook = mountWorkInProgressHook();
		      if (isHydrating) {
		        if (void 0 === getServerSnapshot)
		          throw Error(
		            "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
		          );
		        var nextSnapshot = getServerSnapshot();
		        didWarnUncachedGetSnapshot ||
		          nextSnapshot === getServerSnapshot() ||
		          (console.error(
		            "The result of getServerSnapshot should be cached to avoid an infinite loop"
		          ),
		          (didWarnUncachedGetSnapshot = true));
		      } else {
		        nextSnapshot = getSnapshot();
		        didWarnUncachedGetSnapshot ||
		          ((getServerSnapshot = getSnapshot()),
		          objectIs(nextSnapshot, getServerSnapshot) ||
		            (console.error(
		              "The result of getSnapshot should be cached to avoid an infinite loop"
		            ),
		            (didWarnUncachedGetSnapshot = true)));
		        if (null === workInProgressRoot)
		          throw Error(
		            "Expected a work-in-progress root. This is a bug in React. Please file an issue."
		          );
		        0 !== (workInProgressRootRenderLanes & 60) ||
		          pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
		      }
		      hook.memoizedState = nextSnapshot;
		      getServerSnapshot = { value: nextSnapshot, getSnapshot: getSnapshot };
		      hook.queue = getServerSnapshot;
		      mountEffect(
		        subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe),
		        [subscribe]
		      );
		      fiber.flags |= 2048;
		      pushEffect(
		        HasEffect | Passive,
		        updateStoreInstance.bind(
		          null,
		          fiber,
		          getServerSnapshot,
		          nextSnapshot,
		          getSnapshot
		        ),
		        { destroy: void 0 },
		        null
		      );
		      return nextSnapshot;
		    }
		    function updateSyncExternalStore(
		      subscribe,
		      getSnapshot,
		      getServerSnapshot
		    ) {
		      var fiber = currentlyRenderingFiber$1,
		        hook = updateWorkInProgressHook(),
		        isHydrating$jscomp$0 = isHydrating;
		      if (isHydrating$jscomp$0) {
		        if (void 0 === getServerSnapshot)
		          throw Error(
		            "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
		          );
		        getServerSnapshot = getServerSnapshot();
		      } else if (
		        ((getServerSnapshot = getSnapshot()), !didWarnUncachedGetSnapshot)
		      ) {
		        var cachedSnapshot = getSnapshot();
		        objectIs(getServerSnapshot, cachedSnapshot) ||
		          (console.error(
		            "The result of getSnapshot should be cached to avoid an infinite loop"
		          ),
		          (didWarnUncachedGetSnapshot = true));
		      }
		      if (
		        (cachedSnapshot = !objectIs(
		          (currentHook || hook).memoizedState,
		          getServerSnapshot
		        ))
		      )
		        (hook.memoizedState = getServerSnapshot), (didReceiveUpdate = true);
		      hook = hook.queue;
		      var create = subscribeToStore.bind(null, fiber, hook, subscribe);
		      updateEffectImpl(2048, Passive, create, [subscribe]);
		      if (
		        hook.getSnapshot !== getSnapshot ||
		        cachedSnapshot ||
		        (null !== workInProgressHook &&
		          workInProgressHook.memoizedState.tag & HasEffect)
		      ) {
		        fiber.flags |= 2048;
		        pushEffect(
		          HasEffect | Passive,
		          updateStoreInstance.bind(
		            null,
		            fiber,
		            hook,
		            getServerSnapshot,
		            getSnapshot
		          ),
		          { destroy: void 0 },
		          null
		        );
		        if (null === workInProgressRoot)
		          throw Error(
		            "Expected a work-in-progress root. This is a bug in React. Please file an issue."
		          );
		        isHydrating$jscomp$0 ||
		          0 !== (renderLanes & 60) ||
		          pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
		      }
		      return getServerSnapshot;
		    }
		    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
		      fiber.flags |= 16384;
		      fiber = { getSnapshot: getSnapshot, value: renderedSnapshot };
		      getSnapshot = currentlyRenderingFiber$1.updateQueue;
		      null === getSnapshot
		        ? ((getSnapshot = createFunctionComponentUpdateQueue()),
		          (currentlyRenderingFiber$1.updateQueue = getSnapshot),
		          (getSnapshot.stores = [fiber]))
		        : ((renderedSnapshot = getSnapshot.stores),
		          null === renderedSnapshot
		            ? (getSnapshot.stores = [fiber])
		            : renderedSnapshot.push(fiber));
		    }
		    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
		      inst.value = nextSnapshot;
		      inst.getSnapshot = getSnapshot;
		      checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
		    }
		    function subscribeToStore(fiber, inst, subscribe) {
		      return subscribe(function () {
		        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
		      });
		    }
		    function checkIfSnapshotChanged(inst) {
		      var latestGetSnapshot = inst.getSnapshot;
		      inst = inst.value;
		      try {
		        var nextValue = latestGetSnapshot();
		        return !objectIs(inst, nextValue);
		      } catch (error) {
		        return true;
		      }
		    }
		    function forceStoreRerender(fiber) {
		      var root = enqueueConcurrentRenderForLane(fiber, 2);
		      null !== root && scheduleUpdateOnFiber(root, fiber, 2);
		    }
		    function mountStateImpl(initialState) {
		      var hook = mountWorkInProgressHook();
		      if ("function" === typeof initialState) {
		        var initialStateInitializer = initialState;
		        initialState = initialStateInitializer();
		        if (shouldDoubleInvokeUserFnsInHooksDEV) {
		          setIsStrictModeForDevtools(true);
		          try {
		            initialStateInitializer();
		          } finally {
		            setIsStrictModeForDevtools(false);
		          }
		        }
		      }
		      hook.memoizedState = hook.baseState = initialState;
		      hook.queue = {
		        pending: null,
		        lanes: 0,
		        dispatch: null,
		        lastRenderedReducer: basicStateReducer,
		        lastRenderedState: initialState
		      };
		      return hook;
		    }
		    function mountState(initialState) {
		      initialState = mountStateImpl(initialState);
		      var queue = initialState.queue,
		        dispatch = dispatchSetState.bind(
		          null,
		          currentlyRenderingFiber$1,
		          queue
		        );
		      queue.dispatch = dispatch;
		      return [initialState.memoizedState, dispatch];
		    }
		    function mountOptimistic(passthrough) {
		      var hook = mountWorkInProgressHook();
		      hook.memoizedState = hook.baseState = passthrough;
		      var queue = {
		        pending: null,
		        lanes: 0,
		        dispatch: null,
		        lastRenderedReducer: null,
		        lastRenderedState: null
		      };
		      hook.queue = queue;
		      hook = dispatchOptimisticSetState.bind(
		        null,
		        currentlyRenderingFiber$1,
		        true,
		        queue
		      );
		      queue.dispatch = hook;
		      return [passthrough, hook];
		    }
		    function updateOptimistic(passthrough, reducer) {
		      var hook = updateWorkInProgressHook();
		      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
		    }
		    function updateOptimisticImpl(hook, current, passthrough, reducer) {
		      hook.baseState = passthrough;
		      return updateReducerImpl(
		        hook,
		        currentHook,
		        "function" === typeof reducer ? reducer : basicStateReducer
		      );
		    }
		    function rerenderOptimistic(passthrough, reducer) {
		      var hook = updateWorkInProgressHook();
		      if (null !== currentHook)
		        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
		      hook.baseState = passthrough;
		      return [passthrough, hook.queue.dispatch];
		    }
		    function dispatchActionState(
		      fiber,
		      actionQueue,
		      setPendingState,
		      setState,
		      payload
		    ) {
		      if (isRenderPhaseUpdate(fiber))
		        throw Error("Cannot update form state while rendering.");
		      fiber = actionQueue.action;
		      if (null !== fiber) {
		        var actionNode = {
		          payload: payload,
		          action: fiber,
		          next: null,
		          isTransition: true,
		          status: "pending",
		          value: null,
		          reason: null,
		          listeners: [],
		          then: function (listener) {
		            actionNode.listeners.push(listener);
		          }
		        };
		        null !== ReactSharedInternals.T
		          ? setPendingState(true)
		          : (actionNode.isTransition = false);
		        setState(actionNode);
		        setPendingState = actionQueue.pending;
		        null === setPendingState
		          ? ((actionNode.next = actionQueue.pending = actionNode),
		            runActionStateAction(actionQueue, actionNode))
		          : ((actionNode.next = setPendingState.next),
		            (actionQueue.pending = setPendingState.next = actionNode));
		      }
		    }
		    function runActionStateAction(actionQueue, node) {
		      var action = node.action,
		        payload = node.payload,
		        prevState = actionQueue.state;
		      if (node.isTransition) {
		        var prevTransition = ReactSharedInternals.T,
		          currentTransition = {};
		        ReactSharedInternals.T = currentTransition;
		        ReactSharedInternals.T._updatedFibers = new Set();
		        try {
		          var returnValue = action(prevState, payload),
		            onStartTransitionFinish = ReactSharedInternals.S;
		          null !== onStartTransitionFinish &&
		            onStartTransitionFinish(currentTransition, returnValue);
		          handleActionReturnValue(actionQueue, node, returnValue);
		        } catch (error) {
		          onActionError(actionQueue, node, error);
		        } finally {
		          (ReactSharedInternals.T = prevTransition),
		            null === prevTransition &&
		              currentTransition._updatedFibers &&
		              ((actionQueue = currentTransition._updatedFibers.size),
		              currentTransition._updatedFibers.clear(),
		              10 < actionQueue &&
		                console.warn(
		                  "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
		                ));
		        }
		      } else
		        try {
		          (currentTransition = action(prevState, payload)),
		            handleActionReturnValue(actionQueue, node, currentTransition);
		        } catch (error$2) {
		          onActionError(actionQueue, node, error$2);
		        }
		    }
		    function handleActionReturnValue(actionQueue, node, returnValue) {
		      null !== returnValue &&
		      "object" === typeof returnValue &&
		      "function" === typeof returnValue.then
		        ? (returnValue.then(
		            function (nextState) {
		              onActionSuccess(actionQueue, node, nextState);
		            },
		            function (error) {
		              return onActionError(actionQueue, node, error);
		            }
		          ),
		          node.isTransition ||
		            console.error(
		              "An async function was passed to useActionState, but it was dispatched outside of an action context. This is likely not what you intended. Either pass the dispatch function to an `action` prop, or dispatch manually inside `startTransition`"
		            ))
		        : onActionSuccess(actionQueue, node, returnValue);
		    }
		    function onActionSuccess(actionQueue, actionNode, nextState) {
		      actionNode.status = "fulfilled";
		      actionNode.value = nextState;
		      notifyActionListeners(actionNode);
		      actionQueue.state = nextState;
		      actionNode = actionQueue.pending;
		      null !== actionNode &&
		        ((nextState = actionNode.next),
		        nextState === actionNode
		          ? (actionQueue.pending = null)
		          : ((nextState = nextState.next),
		            (actionNode.next = nextState),
		            runActionStateAction(actionQueue, nextState)));
		    }
		    function onActionError(actionQueue, actionNode, error) {
		      var last = actionQueue.pending;
		      actionQueue.pending = null;
		      if (null !== last) {
		        last = last.next;
		        do
		          (actionNode.status = "rejected"),
		            (actionNode.reason = error),
		            notifyActionListeners(actionNode),
		            (actionNode = actionNode.next);
		        while (actionNode !== last);
		      }
		      actionQueue.action = null;
		    }
		    function notifyActionListeners(actionNode) {
		      actionNode = actionNode.listeners;
		      for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
		    }
		    function actionStateReducer(oldState, newState) {
		      return newState;
		    }
		    function mountActionState(action, initialStateProp) {
		      if (isHydrating) {
		        var ssrFormState = workInProgressRoot.formState;
		        if (null !== ssrFormState) {
		          a: {
		            var isMatching = currentlyRenderingFiber$1;
		            if (isHydrating) {
		              if (nextHydratableInstance) {
		                var markerInstance = canHydrateFormStateMarker(
		                  nextHydratableInstance,
		                  rootOrSingletonContext
		                );
		                if (markerInstance) {
		                  nextHydratableInstance =
		                    getNextHydratableSibling(markerInstance);
		                  isMatching = isFormStateMarkerMatching(markerInstance);
		                  break a;
		                }
		              }
		              throwOnHydrationMismatch(isMatching);
		            }
		            isMatching = false;
		          }
		          isMatching && (initialStateProp = ssrFormState[0]);
		        }
		      }
		      ssrFormState = mountWorkInProgressHook();
		      ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
		      isMatching = {
		        pending: null,
		        lanes: 0,
		        dispatch: null,
		        lastRenderedReducer: actionStateReducer,
		        lastRenderedState: initialStateProp
		      };
		      ssrFormState.queue = isMatching;
		      ssrFormState = dispatchSetState.bind(
		        null,
		        currentlyRenderingFiber$1,
		        isMatching
		      );
		      isMatching.dispatch = ssrFormState;
		      isMatching = mountStateImpl(false);
		      var setPendingState = dispatchOptimisticSetState.bind(
		        null,
		        currentlyRenderingFiber$1,
		        false,
		        isMatching.queue
		      );
		      isMatching = mountWorkInProgressHook();
		      markerInstance = {
		        state: initialStateProp,
		        dispatch: null,
		        action: action,
		        pending: null
		      };
		      isMatching.queue = markerInstance;
		      ssrFormState = dispatchActionState.bind(
		        null,
		        currentlyRenderingFiber$1,
		        markerInstance,
		        setPendingState,
		        ssrFormState
		      );
		      markerInstance.dispatch = ssrFormState;
		      isMatching.memoizedState = action;
		      return [initialStateProp, ssrFormState, false];
		    }
		    function updateActionState(action) {
		      var stateHook = updateWorkInProgressHook();
		      return updateActionStateImpl(stateHook, currentHook, action);
		    }
		    function updateActionStateImpl(stateHook, currentStateHook, action) {
		      currentStateHook = updateReducerImpl(
		        stateHook,
		        currentStateHook,
		        actionStateReducer
		      )[0];
		      stateHook = updateReducer(basicStateReducer)[0];
		      currentStateHook =
		        "object" === typeof currentStateHook &&
		        null !== currentStateHook &&
		        "function" === typeof currentStateHook.then
		          ? useThenable(currentStateHook)
		          : currentStateHook;
		      var actionQueueHook = updateWorkInProgressHook(),
		        actionQueue = actionQueueHook.queue,
		        dispatch = actionQueue.dispatch;
		      action !== actionQueueHook.memoizedState &&
		        ((currentlyRenderingFiber$1.flags |= 2048),
		        pushEffect(
		          HasEffect | Passive,
		          actionStateActionEffect.bind(null, actionQueue, action),
		          { destroy: void 0 },
		          null
		        ));
		      return [currentStateHook, dispatch, stateHook];
		    }
		    function actionStateActionEffect(actionQueue, action) {
		      actionQueue.action = action;
		    }
		    function rerenderActionState(action) {
		      var stateHook = updateWorkInProgressHook(),
		        currentStateHook = currentHook;
		      if (null !== currentStateHook)
		        return updateActionStateImpl(stateHook, currentStateHook, action);
		      updateWorkInProgressHook();
		      stateHook = stateHook.memoizedState;
		      currentStateHook = updateWorkInProgressHook();
		      var dispatch = currentStateHook.queue.dispatch;
		      currentStateHook.memoizedState = action;
		      return [stateHook, dispatch, false];
		    }
		    function pushEffect(tag, create, inst, deps) {
		      tag = { tag: tag, create: create, inst: inst, deps: deps, next: null };
		      create = currentlyRenderingFiber$1.updateQueue;
		      null === create &&
		        ((create = createFunctionComponentUpdateQueue()),
		        (currentlyRenderingFiber$1.updateQueue = create));
		      inst = create.lastEffect;
		      null === inst
		        ? (create.lastEffect = tag.next = tag)
		        : ((deps = inst.next),
		          (inst.next = tag),
		          (tag.next = deps),
		          (create.lastEffect = tag));
		      return tag;
		    }
		    function mountRef(initialValue) {
		      var hook = mountWorkInProgressHook();
		      initialValue = { current: initialValue };
		      return (hook.memoizedState = initialValue);
		    }
		    function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
		      var hook = mountWorkInProgressHook();
		      currentlyRenderingFiber$1.flags |= fiberFlags;
		      hook.memoizedState = pushEffect(
		        HasEffect | hookFlags,
		        create,
		        { destroy: void 0 },
		        void 0 === deps ? null : deps
		      );
		    }
		    function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
		      var hook = updateWorkInProgressHook();
		      deps = void 0 === deps ? null : deps;
		      var inst = hook.memoizedState.inst;
		      null !== currentHook &&
		      null !== deps &&
		      areHookInputsEqual(deps, currentHook.memoizedState.deps)
		        ? (hook.memoizedState = pushEffect(hookFlags, create, inst, deps))
		        : ((currentlyRenderingFiber$1.flags |= fiberFlags),
		          (hook.memoizedState = pushEffect(
		            HasEffect | hookFlags,
		            create,
		            inst,
		            deps
		          )));
		    }
		    function mountEffect(create, deps) {
		      (currentlyRenderingFiber$1.mode & 16) !== NoMode &&
		      (currentlyRenderingFiber$1.mode & 64) === NoMode
		        ? mountEffectImpl(142608384, Passive, create, deps)
		        : mountEffectImpl(8390656, Passive, create, deps);
		    }
		    function mountLayoutEffect(create, deps) {
		      var fiberFlags = 4194308;
		      (currentlyRenderingFiber$1.mode & 16) !== NoMode &&
		        (fiberFlags |= 67108864);
		      return mountEffectImpl(fiberFlags, Layout, create, deps);
		    }
		    function imperativeHandleEffect(create, ref) {
		      if ("function" === typeof ref) {
		        create = create();
		        var refCleanup = ref(create);
		        return function () {
		          "function" === typeof refCleanup ? refCleanup() : ref(null);
		        };
		      }
		      if (null !== ref && void 0 !== ref)
		        return (
		          ref.hasOwnProperty("current") ||
		            console.error(
		              "Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.",
		              "an object with keys {" + Object.keys(ref).join(", ") + "}"
		            ),
		          (create = create()),
		          (ref.current = create),
		          function () {
		            ref.current = null;
		          }
		        );
		    }
		    function mountImperativeHandle(ref, create, deps) {
		      "function" !== typeof create &&
		        console.error(
		          "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
		          null !== create ? typeof create : "null"
		        );
		      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
		      var fiberFlags = 4194308;
		      (currentlyRenderingFiber$1.mode & 16) !== NoMode &&
		        (fiberFlags |= 67108864);
		      mountEffectImpl(
		        fiberFlags,
		        Layout,
		        imperativeHandleEffect.bind(null, create, ref),
		        deps
		      );
		    }
		    function updateImperativeHandle(ref, create, deps) {
		      "function" !== typeof create &&
		        console.error(
		          "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
		          null !== create ? typeof create : "null"
		        );
		      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
		      updateEffectImpl(
		        4,
		        Layout,
		        imperativeHandleEffect.bind(null, create, ref),
		        deps
		      );
		    }
		    function mountCallback(callback, deps) {
		      mountWorkInProgressHook().memoizedState = [
		        callback,
		        void 0 === deps ? null : deps
		      ];
		      return callback;
		    }
		    function updateCallback(callback, deps) {
		      var hook = updateWorkInProgressHook();
		      deps = void 0 === deps ? null : deps;
		      var prevState = hook.memoizedState;
		      if (null !== deps && areHookInputsEqual(deps, prevState[1]))
		        return prevState[0];
		      hook.memoizedState = [callback, deps];
		      return callback;
		    }
		    function mountMemo(nextCreate, deps) {
		      var hook = mountWorkInProgressHook();
		      deps = void 0 === deps ? null : deps;
		      var nextValue = nextCreate();
		      if (shouldDoubleInvokeUserFnsInHooksDEV) {
		        setIsStrictModeForDevtools(true);
		        try {
		          nextCreate();
		        } finally {
		          setIsStrictModeForDevtools(false);
		        }
		      }
		      hook.memoizedState = [nextValue, deps];
		      return nextValue;
		    }
		    function updateMemo(nextCreate, deps) {
		      var hook = updateWorkInProgressHook();
		      deps = void 0 === deps ? null : deps;
		      var prevState = hook.memoizedState;
		      if (null !== deps && areHookInputsEqual(deps, prevState[1]))
		        return prevState[0];
		      prevState = nextCreate();
		      if (shouldDoubleInvokeUserFnsInHooksDEV) {
		        setIsStrictModeForDevtools(true);
		        try {
		          nextCreate();
		        } finally {
		          setIsStrictModeForDevtools(false);
		        }
		      }
		      hook.memoizedState = [prevState, deps];
		      return prevState;
		    }
		    function mountDeferredValue(value, initialValue) {
		      var hook = mountWorkInProgressHook();
		      return mountDeferredValueImpl(hook, value, initialValue);
		    }
		    function updateDeferredValue(value, initialValue) {
		      var hook = updateWorkInProgressHook();
		      return updateDeferredValueImpl(
		        hook,
		        currentHook.memoizedState,
		        value,
		        initialValue
		      );
		    }
		    function rerenderDeferredValue(value, initialValue) {
		      var hook = updateWorkInProgressHook();
		      return null === currentHook
		        ? mountDeferredValueImpl(hook, value, initialValue)
		        : updateDeferredValueImpl(
		            hook,
		            currentHook.memoizedState,
		            value,
		            initialValue
		          );
		    }
		    function mountDeferredValueImpl(hook, value, initialValue) {
		      if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
		        return (hook.memoizedState = value);
		      hook.memoizedState = initialValue;
		      hook = requestDeferredLane();
		      currentlyRenderingFiber$1.lanes |= hook;
		      workInProgressRootSkippedLanes |= hook;
		      return initialValue;
		    }
		    function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
		      if (objectIs(value, prevValue)) return value;
		      if (null !== currentTreeHiddenStackCursor.current)
		        return (
		          (hook = mountDeferredValueImpl(hook, value, initialValue)),
		          objectIs(hook, prevValue) || (didReceiveUpdate = true),
		          hook
		        );
		      if (0 === (renderLanes & 42))
		        return (didReceiveUpdate = true), (hook.memoizedState = value);
		      hook = requestDeferredLane();
		      currentlyRenderingFiber$1.lanes |= hook;
		      workInProgressRootSkippedLanes |= hook;
		      return prevValue;
		    }
		    function startTransition(
		      fiber,
		      queue,
		      pendingState,
		      finishedState,
		      callback
		    ) {
		      var previousPriority = getCurrentUpdatePriority();
		      setCurrentUpdatePriority(
		        0 !== previousPriority && 8 > previousPriority ? previousPriority : 8
		      );
		      var prevTransition = ReactSharedInternals.T,
		        currentTransition = {};
		      ReactSharedInternals.T = currentTransition;
		      dispatchOptimisticSetState(fiber, false, queue, pendingState);
		      currentTransition._updatedFibers = new Set();
		      try {
		        var returnValue = callback(),
		          onStartTransitionFinish = ReactSharedInternals.S;
		        null !== onStartTransitionFinish &&
		          onStartTransitionFinish(currentTransition, returnValue);
		        if (
		          null !== returnValue &&
		          "object" === typeof returnValue &&
		          "function" === typeof returnValue.then
		        ) {
		          var thenableForFinishedState = chainThenableValue(
		            returnValue,
		            finishedState
		          );
		          dispatchSetStateInternal(
		            fiber,
		            queue,
		            thenableForFinishedState,
		            requestUpdateLane(fiber)
		          );
		        } else
		          dispatchSetStateInternal(
		            fiber,
		            queue,
		            finishedState,
		            requestUpdateLane(fiber)
		          );
		      } catch (error) {
		        dispatchSetStateInternal(
		          fiber,
		          queue,
		          { then: function () {}, status: "rejected", reason: error },
		          requestUpdateLane(fiber)
		        );
		      } finally {
		        setCurrentUpdatePriority(previousPriority),
		          (ReactSharedInternals.T = prevTransition),
		          null === prevTransition &&
		            currentTransition._updatedFibers &&
		            ((fiber = currentTransition._updatedFibers.size),
		            currentTransition._updatedFibers.clear(),
		            10 < fiber &&
		              console.warn(
		                "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
		              ));
		      }
		    }
		    function ensureFormComponentIsStateful(formFiber) {
		      var existingStateHook = formFiber.memoizedState;
		      if (null !== existingStateHook) return existingStateHook;
		      existingStateHook = {
		        memoizedState: NotPendingTransition,
		        baseState: NotPendingTransition,
		        baseQueue: null,
		        queue: {
		          pending: null,
		          lanes: 0,
		          dispatch: null,
		          lastRenderedReducer: basicStateReducer,
		          lastRenderedState: NotPendingTransition
		        },
		        next: null
		      };
		      var initialResetState = {};
		      existingStateHook.next = {
		        memoizedState: initialResetState,
		        baseState: initialResetState,
		        baseQueue: null,
		        queue: {
		          pending: null,
		          lanes: 0,
		          dispatch: null,
		          lastRenderedReducer: basicStateReducer,
		          lastRenderedState: initialResetState
		        },
		        next: null
		      };
		      formFiber.memoizedState = existingStateHook;
		      formFiber = formFiber.alternate;
		      null !== formFiber && (formFiber.memoizedState = existingStateHook);
		      return existingStateHook;
		    }
		    function mountTransition() {
		      var stateHook = mountStateImpl(false);
		      stateHook = startTransition.bind(
		        null,
		        currentlyRenderingFiber$1,
		        stateHook.queue,
		        true,
		        false
		      );
		      mountWorkInProgressHook().memoizedState = stateHook;
		      return [false, stateHook];
		    }
		    function updateTransition() {
		      var booleanOrThenable = updateReducer(basicStateReducer)[0],
		        start = updateWorkInProgressHook().memoizedState;
		      return [
		        "boolean" === typeof booleanOrThenable
		          ? booleanOrThenable
		          : useThenable(booleanOrThenable),
		        start
		      ];
		    }
		    function rerenderTransition() {
		      var booleanOrThenable = rerenderReducer(basicStateReducer)[0],
		        start = updateWorkInProgressHook().memoizedState;
		      return [
		        "boolean" === typeof booleanOrThenable
		          ? booleanOrThenable
		          : useThenable(booleanOrThenable),
		        start
		      ];
		    }
		    function useHostTransitionStatus() {
		      return readContext(HostTransitionContext);
		    }
		    function mountId() {
		      var hook = mountWorkInProgressHook(),
		        identifierPrefix = workInProgressRoot.identifierPrefix;
		      if (isHydrating) {
		        var treeId = treeContextOverflow;
		        var idWithLeadingBit = treeContextId;
		        treeId =
		          (
		            idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))
		          ).toString(32) + treeId;
		        identifierPrefix = ":" + identifierPrefix + "R" + treeId;
		        treeId = localIdCounter++;
		        0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
		        identifierPrefix += ":";
		      } else
		        (treeId = globalClientIdCounter++),
		          (identifierPrefix =
		            ":" + identifierPrefix + "r" + treeId.toString(32) + ":");
		      return (hook.memoizedState = identifierPrefix);
		    }
		    function mountRefresh() {
		      return (mountWorkInProgressHook().memoizedState = refreshCache.bind(
		        null,
		        currentlyRenderingFiber$1
		      ));
		    }
		    function refreshCache(fiber, seedKey) {
		      for (var provider = fiber.return; null !== provider; ) {
		        switch (provider.tag) {
		          case 24:
		          case 3:
		            var lane = requestUpdateLane(provider);
		            fiber = createUpdate(lane);
		            var root = enqueueUpdate(provider, fiber, lane);
		            null !== root &&
		              (scheduleUpdateOnFiber(root, provider, lane),
		              entangleTransitions(root, provider, lane));
		            provider = createCache();
		            null !== seedKey &&
		              void 0 !== seedKey &&
		              null !== root &&
		              console.error(
		                "The seed argument is not enabled outside experimental channels."
		              );
		            fiber.payload = { cache: provider };
		            return;
		        }
		        provider = provider.return;
		      }
		    }
		    function dispatchReducerAction(
		      fiber,
		      queue,
		      action,
		      JSCompiler_OptimizeArgumentsArray_p0
		    ) {
		      "function" === typeof JSCompiler_OptimizeArgumentsArray_p0 &&
		        console.error(
		          "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
		        );
		      JSCompiler_OptimizeArgumentsArray_p0 = requestUpdateLane(fiber);
		      action = {
		        lane: JSCompiler_OptimizeArgumentsArray_p0,
		        revertLane: 0,
		        action: action,
		        hasEagerState: false,
		        eagerState: null,
		        next: null
		      };
		      isRenderPhaseUpdate(fiber)
		        ? enqueueRenderPhaseUpdate(queue, action)
		        : ((action = enqueueConcurrentHookUpdate(
		            fiber,
		            queue,
		            action,
		            JSCompiler_OptimizeArgumentsArray_p0
		          )),
		          null !== action &&
		            (scheduleUpdateOnFiber(
		              action,
		              fiber,
		              JSCompiler_OptimizeArgumentsArray_p0
		            ),
		            entangleTransitionUpdate(
		              action,
		              queue,
		              JSCompiler_OptimizeArgumentsArray_p0
		            )));
		      markStateUpdateScheduled(fiber, JSCompiler_OptimizeArgumentsArray_p0);
		    }
		    function dispatchSetState(
		      fiber,
		      queue,
		      action,
		      JSCompiler_OptimizeArgumentsArray_p1
		    ) {
		      "function" === typeof JSCompiler_OptimizeArgumentsArray_p1 &&
		        console.error(
		          "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
		        );
		      JSCompiler_OptimizeArgumentsArray_p1 = requestUpdateLane(fiber);
		      dispatchSetStateInternal(
		        fiber,
		        queue,
		        action,
		        JSCompiler_OptimizeArgumentsArray_p1
		      );
		      markStateUpdateScheduled(fiber, JSCompiler_OptimizeArgumentsArray_p1);
		    }
		    function dispatchSetStateInternal(fiber, queue, action, lane) {
		      var update = {
		        lane: lane,
		        revertLane: 0,
		        action: action,
		        hasEagerState: false,
		        eagerState: null,
		        next: null
		      };
		      if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
		      else {
		        var alternate = fiber.alternate;
		        if (
		          0 === fiber.lanes &&
		          (null === alternate || 0 === alternate.lanes) &&
		          ((alternate = queue.lastRenderedReducer), null !== alternate)
		        ) {
		          var prevDispatcher = ReactSharedInternals.H;
		          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
		          try {
		            var currentState = queue.lastRenderedState,
		              eagerState = alternate(currentState, action);
		            update.hasEagerState = !0;
		            update.eagerState = eagerState;
		            if (objectIs(eagerState, currentState))
		              return (
		                enqueueUpdate$1(fiber, queue, update, 0),
		                null === workInProgressRoot &&
		                  finishQueueingConcurrentUpdates(),
		                !1
		              );
		          } catch (error) {
		          } finally {
		            ReactSharedInternals.H = prevDispatcher;
		          }
		        }
		        action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
		        if (null !== action)
		          return (
		            scheduleUpdateOnFiber(action, fiber, lane),
		            entangleTransitionUpdate(action, queue, lane),
		            true
		          );
		      }
		      return false;
		    }
		    function dispatchOptimisticSetState(
		      fiber,
		      throwIfDuringRender,
		      queue,
		      action
		    ) {
		      null === ReactSharedInternals.T &&
		        0 === currentEntangledLane &&
		        console.error(
		          "An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."
		        );
		      action = {
		        lane: 2,
		        revertLane: requestTransitionLane(),
		        action: action,
		        hasEagerState: false,
		        eagerState: null,
		        next: null
		      };
		      if (isRenderPhaseUpdate(fiber)) {
		        if (throwIfDuringRender)
		          throw Error("Cannot update optimistic state while rendering.");
		        console.error("Cannot call startTransition while rendering.");
		      } else
		        (throwIfDuringRender = enqueueConcurrentHookUpdate(
		          fiber,
		          queue,
		          action,
		          2
		        )),
		          null !== throwIfDuringRender &&
		            scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
		      markStateUpdateScheduled(fiber, 2);
		    }
		    function isRenderPhaseUpdate(fiber) {
		      var alternate = fiber.alternate;
		      return (
		        fiber === currentlyRenderingFiber$1 ||
		        (null !== alternate && alternate === currentlyRenderingFiber$1)
		      );
		    }
		    function enqueueRenderPhaseUpdate(queue, update) {
		      didScheduleRenderPhaseUpdateDuringThisPass =
		        didScheduleRenderPhaseUpdate = true;
		      var pending = queue.pending;
		      null === pending
		        ? (update.next = update)
		        : ((update.next = pending.next), (pending.next = update));
		      queue.pending = update;
		    }
		    function entangleTransitionUpdate(root, queue, lane) {
		      if (0 !== (lane & 4194176)) {
		        var queueLanes = queue.lanes;
		        queueLanes &= root.pendingLanes;
		        lane |= queueLanes;
		        queue.lanes = lane;
		        markRootEntangled(root, lane);
		      }
		    }
		    function warnOnInvalidCallback(callback) {
		      if (null !== callback && "function" !== typeof callback) {
		        var key = String(callback);
		        didWarnOnInvalidCallback.has(key) ||
		          (didWarnOnInvalidCallback.add(key),
		          console.error(
		            "Expected the last optional `callback` argument to be a function. Instead received: %s.",
		            callback
		          ));
		      }
		    }
		    function applyDerivedStateFromProps(
		      workInProgress,
		      ctor,
		      getDerivedStateFromProps,
		      nextProps
		    ) {
		      var prevState = workInProgress.memoizedState,
		        partialState = getDerivedStateFromProps(nextProps, prevState);
		      if (workInProgress.mode & 8) {
		        setIsStrictModeForDevtools(true);
		        try {
		          partialState = getDerivedStateFromProps(nextProps, prevState);
		        } finally {
		          setIsStrictModeForDevtools(false);
		        }
		      }
		      void 0 === partialState &&
		        ((ctor = getComponentNameFromType(ctor) || "Component"),
		        didWarnAboutUndefinedDerivedState.has(ctor) ||
		          (didWarnAboutUndefinedDerivedState.add(ctor),
		          console.error(
		            "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
		            ctor
		          )));
		      prevState =
		        null === partialState || void 0 === partialState
		          ? prevState
		          : assign({}, prevState, partialState);
		      workInProgress.memoizedState = prevState;
		      0 === workInProgress.lanes &&
		        (workInProgress.updateQueue.baseState = prevState);
		    }
		    function checkShouldComponentUpdate(
		      workInProgress,
		      ctor,
		      oldProps,
		      newProps,
		      oldState,
		      newState,
		      nextContext
		    ) {
		      var instance = workInProgress.stateNode;
		      if ("function" === typeof instance.shouldComponentUpdate) {
		        oldProps = instance.shouldComponentUpdate(
		          newProps,
		          newState,
		          nextContext
		        );
		        if (workInProgress.mode & 8) {
		          setIsStrictModeForDevtools(true);
		          try {
		            oldProps = instance.shouldComponentUpdate(
		              newProps,
		              newState,
		              nextContext
		            );
		          } finally {
		            setIsStrictModeForDevtools(false);
		          }
		        }
		        void 0 === oldProps &&
		          console.error(
		            "%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",
		            getComponentNameFromType(ctor) || "Component"
		          );
		        return oldProps;
		      }
		      return ctor.prototype && ctor.prototype.isPureReactComponent
		        ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
		        : true;
		    }
		    function callComponentWillReceiveProps(
		      workInProgress,
		      instance,
		      newProps,
		      nextContext
		    ) {
		      var oldState = instance.state;
		      "function" === typeof instance.componentWillReceiveProps &&
		        instance.componentWillReceiveProps(newProps, nextContext);
		      "function" === typeof instance.UNSAFE_componentWillReceiveProps &&
		        instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
		      instance.state !== oldState &&
		        ((workInProgress =
		          getComponentNameFromFiber(workInProgress) || "Component"),
		        didWarnAboutStateAssignmentForComponent.has(workInProgress) ||
		          (didWarnAboutStateAssignmentForComponent.add(workInProgress),
		          console.error(
		            "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
		            workInProgress
		          )),
		        classComponentUpdater.enqueueReplaceState(
		          instance,
		          instance.state,
		          null
		        ));
		    }
		    function resolveClassComponentProps(Component, baseProps) {
		      var newProps = baseProps;
		      if ("ref" in baseProps) {
		        newProps = {};
		        for (var propName in baseProps)
		          "ref" !== propName && (newProps[propName] = baseProps[propName]);
		      }
		      if ((Component = Component.defaultProps)) {
		        newProps === baseProps && (newProps = assign({}, newProps));
		        for (var _propName in Component)
		          void 0 === newProps[_propName] &&
		            (newProps[_propName] = Component[_propName]);
		      }
		      return newProps;
		    }
		    function logUncaughtError(root, errorInfo) {
		      try {
		        componentName = errorInfo.source
		          ? getComponentNameFromFiber(errorInfo.source)
		          : null;
		        errorBoundaryName = null;
		        var error = errorInfo.value;
		        if (null !== ReactSharedInternals.actQueue)
		          ReactSharedInternals.thrownErrors.push(error);
		        else {
		          var onUncaughtError = root.onUncaughtError;
		          onUncaughtError(error, { componentStack: errorInfo.stack });
		        }
		      } catch (e) {
		        setTimeout(function () {
		          throw e;
		        });
		      }
		    }
		    function logCaughtError(root, boundary, errorInfo) {
		      try {
		        componentName = errorInfo.source
		          ? getComponentNameFromFiber(errorInfo.source)
		          : null;
		        errorBoundaryName = getComponentNameFromFiber(boundary);
		        var onCaughtError = root.onCaughtError;
		        onCaughtError(errorInfo.value, {
		          componentStack: errorInfo.stack,
		          errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
		        });
		      } catch (e) {
		        setTimeout(function () {
		          throw e;
		        });
		      }
		    }
		    function createRootErrorUpdate(root, errorInfo, lane) {
		      lane = createUpdate(lane);
		      lane.tag = CaptureUpdate;
		      lane.payload = { element: null };
		      lane.callback = function () {
		        runWithFiberInDEV(errorInfo.source, logUncaughtError, root, errorInfo);
		      };
		      return lane;
		    }
		    function createClassErrorUpdate(lane) {
		      lane = createUpdate(lane);
		      lane.tag = CaptureUpdate;
		      return lane;
		    }
		    function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
		      var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
		      if ("function" === typeof getDerivedStateFromError) {
		        var error = errorInfo.value;
		        update.payload = function () {
		          return getDerivedStateFromError(error);
		        };
		        update.callback = function () {
		          markFailedErrorBoundaryForHotReloading(fiber);
		          runWithFiberInDEV(
		            errorInfo.source,
		            logCaughtError,
		            root,
		            fiber,
		            errorInfo
		          );
		        };
		      }
		      var inst = fiber.stateNode;
		      null !== inst &&
		        "function" === typeof inst.componentDidCatch &&
		        (update.callback = function () {
		          markFailedErrorBoundaryForHotReloading(fiber);
		          runWithFiberInDEV(
		            errorInfo.source,
		            logCaughtError,
		            root,
		            fiber,
		            errorInfo
		          );
		          "function" !== typeof getDerivedStateFromError &&
		            (null === legacyErrorBoundariesThatAlreadyFailed
		              ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))
		              : legacyErrorBoundariesThatAlreadyFailed.add(this));
		          callComponentDidCatchInDEV(this, errorInfo);
		          "function" === typeof getDerivedStateFromError ||
		            (0 === (fiber.lanes & 2) &&
		              console.error(
		                "%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",
		                getComponentNameFromFiber(fiber) || "Unknown"
		              ));
		        });
		    }
		    function throwException(
		      root,
		      returnFiber,
		      sourceFiber,
		      value,
		      rootRenderLanes
		    ) {
		      sourceFiber.flags |= 32768;
		      isDevToolsPresent && restorePendingUpdaters(root, rootRenderLanes);
		      if (
		        null !== value &&
		        "object" === typeof value &&
		        "function" === typeof value.then
		      ) {
		        returnFiber = sourceFiber.alternate;
		        null !== returnFiber &&
		          propagateParentContextChanges(
		            returnFiber,
		            sourceFiber,
		            rootRenderLanes,
		            true
		          );
		        isHydrating && (didSuspendOrErrorDEV = true);
		        sourceFiber = suspenseHandlerStackCursor.current;
		        if (null !== sourceFiber) {
		          switch (sourceFiber.tag) {
		            case 13:
		              return (
		                null === shellBoundary
		                  ? renderDidSuspendDelayIfPossible()
		                  : null === sourceFiber.alternate &&
		                    workInProgressRootExitStatus === RootInProgress &&
		                    (workInProgressRootExitStatus = RootSuspended),
		                (sourceFiber.flags &= -257),
		                (sourceFiber.flags |= 65536),
		                (sourceFiber.lanes = rootRenderLanes),
		                value === noopSuspenseyCommitThenable
		                  ? (sourceFiber.flags |= 16384)
		                  : ((returnFiber = sourceFiber.updateQueue),
		                    null === returnFiber
		                      ? (sourceFiber.updateQueue = new Set([value]))
		                      : returnFiber.add(value),
		                    attachPingListener(root, value, rootRenderLanes)),
		                false
		              );
		            case 22:
		              return (
		                (sourceFiber.flags |= 65536),
		                value === noopSuspenseyCommitThenable
		                  ? (sourceFiber.flags |= 16384)
		                  : ((returnFiber = sourceFiber.updateQueue),
		                    null === returnFiber
		                      ? ((returnFiber = {
		                          transitions: null,
		                          markerInstances: null,
		                          retryQueue: new Set([value])
		                        }),
		                        (sourceFiber.updateQueue = returnFiber))
		                      : ((sourceFiber = returnFiber.retryQueue),
		                        null === sourceFiber
		                          ? (returnFiber.retryQueue = new Set([value]))
		                          : sourceFiber.add(value)),
		                    attachPingListener(root, value, rootRenderLanes)),
		                false
		              );
		          }
		          throw Error(
		            "Unexpected Suspense handler tag (" +
		              sourceFiber.tag +
		              "). This is a bug in React."
		          );
		        }
		        attachPingListener(root, value, rootRenderLanes);
		        renderDidSuspendDelayIfPossible();
		        return false;
		      }
		      if (isHydrating)
		        return (
		          (didSuspendOrErrorDEV = true),
		          (returnFiber = suspenseHandlerStackCursor.current),
		          null !== returnFiber
		            ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256),
		              (returnFiber.flags |= 65536),
		              (returnFiber.lanes = rootRenderLanes),
		              value !== HydrationMismatchException &&
		                queueHydrationError(
		                  createCapturedValueAtFiber(
		                    Error(
		                      "There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.",
		                      { cause: value }
		                    ),
		                    sourceFiber
		                  )
		                ))
		            : (value !== HydrationMismatchException &&
		                queueHydrationError(
		                  createCapturedValueAtFiber(
		                    Error(
		                      "There was an error while hydrating but React was able to recover by instead client rendering the entire root.",
		                      { cause: value }
		                    ),
		                    sourceFiber
		                  )
		                ),
		              (root = root.current.alternate),
		              (root.flags |= 65536),
		              (rootRenderLanes &= -rootRenderLanes),
		              (root.lanes |= rootRenderLanes),
		              (value = createCapturedValueAtFiber(value, sourceFiber)),
		              (rootRenderLanes = createRootErrorUpdate(
		                root.stateNode,
		                value,
		                rootRenderLanes
		              )),
		              enqueueCapturedUpdate(root, rootRenderLanes),
		              workInProgressRootExitStatus !== RootSuspendedWithDelay &&
		                (workInProgressRootExitStatus = RootErrored)),
		          false
		        );
		      var error = createCapturedValueAtFiber(
		        Error(
		          "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
		          { cause: value }
		        ),
		        sourceFiber
		      );
		      null === workInProgressRootConcurrentErrors
		        ? (workInProgressRootConcurrentErrors = [error])
		        : workInProgressRootConcurrentErrors.push(error);
		      workInProgressRootExitStatus !== RootSuspendedWithDelay &&
		        (workInProgressRootExitStatus = RootErrored);
		      if (null === returnFiber) return true;
		      value = createCapturedValueAtFiber(value, sourceFiber);
		      sourceFiber = returnFiber;
		      do {
		        switch (sourceFiber.tag) {
		          case 3:
		            return (
		              (sourceFiber.flags |= 65536),
		              (root = rootRenderLanes & -rootRenderLanes),
		              (sourceFiber.lanes |= root),
		              (root = createRootErrorUpdate(
		                sourceFiber.stateNode,
		                value,
		                root
		              )),
		              enqueueCapturedUpdate(sourceFiber, root),
		              false
		            );
		          case 1:
		            if (
		              ((returnFiber = sourceFiber.type),
		              (error = sourceFiber.stateNode),
		              0 === (sourceFiber.flags & 128) &&
		                ("function" === typeof returnFiber.getDerivedStateFromError ||
		                  (null !== error &&
		                    "function" === typeof error.componentDidCatch &&
		                    (null === legacyErrorBoundariesThatAlreadyFailed ||
		                      !legacyErrorBoundariesThatAlreadyFailed.has(error)))))
		            )
		              return (
		                (sourceFiber.flags |= 65536),
		                (rootRenderLanes &= -rootRenderLanes),
		                (sourceFiber.lanes |= rootRenderLanes),
		                (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),
		                initializeClassErrorUpdate(
		                  rootRenderLanes,
		                  root,
		                  sourceFiber,
		                  value
		                ),
		                enqueueCapturedUpdate(sourceFiber, rootRenderLanes),
		                false
		              );
		        }
		        sourceFiber = sourceFiber.return;
		      } while (null !== sourceFiber);
		      return false;
		    }
		    function reconcileChildren(
		      current,
		      workInProgress,
		      nextChildren,
		      renderLanes
		    ) {
		      workInProgress.child =
		        null === current
		          ? mountChildFibers(workInProgress, null, nextChildren, renderLanes)
		          : reconcileChildFibers(
		              workInProgress,
		              current.child,
		              nextChildren,
		              renderLanes
		            );
		    }
		    function updateForwardRef(
		      current,
		      workInProgress,
		      Component,
		      nextProps,
		      renderLanes
		    ) {
		      Component = Component.render;
		      var ref = workInProgress.ref;
		      if ("ref" in nextProps) {
		        var propsWithoutRef = {};
		        for (var key in nextProps)
		          "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
		      } else propsWithoutRef = nextProps;
		      prepareToReadContext(workInProgress);
		      markComponentRenderStarted(workInProgress);
		      nextProps = renderWithHooks(
		        current,
		        workInProgress,
		        Component,
		        propsWithoutRef,
		        ref,
		        renderLanes
		      );
		      key = checkDidRenderIdHook();
		      markComponentRenderStopped();
		      if (null !== current && !didReceiveUpdate)
		        return (
		          bailoutHooks(current, workInProgress, renderLanes),
		          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
		        );
		      isHydrating && key && pushMaterializedTreeId(workInProgress);
		      workInProgress.flags |= 1;
		      reconcileChildren(current, workInProgress, nextProps, renderLanes);
		      return workInProgress.child;
		    }
		    function updateMemoComponent(
		      current,
		      workInProgress,
		      Component,
		      nextProps,
		      renderLanes
		    ) {
		      if (null === current) {
		        var type = Component.type;
		        if (
		          "function" === typeof type &&
		          !shouldConstruct(type) &&
		          void 0 === type.defaultProps &&
		          null === Component.compare
		        )
		          return (
		            (Component = resolveFunctionForHotReloading(type)),
		            (workInProgress.tag = 15),
		            (workInProgress.type = Component),
		            validateFunctionComponentInDev(workInProgress, type),
		            updateSimpleMemoComponent(
		              current,
		              workInProgress,
		              Component,
		              nextProps,
		              renderLanes
		            )
		          );
		        current = createFiberFromTypeAndProps(
		          Component.type,
		          null,
		          nextProps,
		          workInProgress,
		          workInProgress.mode,
		          renderLanes
		        );
		        current.ref = workInProgress.ref;
		        current.return = workInProgress;
		        return (workInProgress.child = current);
		      }
		      type = current.child;
		      if (!checkScheduledUpdateOrContext(current, renderLanes)) {
		        var prevProps = type.memoizedProps;
		        Component = Component.compare;
		        Component = null !== Component ? Component : shallowEqual;
		        if (
		          Component(prevProps, nextProps) &&
		          current.ref === workInProgress.ref
		        )
		          return bailoutOnAlreadyFinishedWork(
		            current,
		            workInProgress,
		            renderLanes
		          );
		      }
		      workInProgress.flags |= 1;
		      current = createWorkInProgress(type, nextProps);
		      current.ref = workInProgress.ref;
		      current.return = workInProgress;
		      return (workInProgress.child = current);
		    }
		    function updateSimpleMemoComponent(
		      current,
		      workInProgress,
		      Component,
		      nextProps,
		      renderLanes
		    ) {
		      if (null !== current) {
		        var prevProps = current.memoizedProps;
		        if (
		          shallowEqual(prevProps, nextProps) &&
		          current.ref === workInProgress.ref &&
		          workInProgress.type === current.type
		        )
		          if (
		            ((didReceiveUpdate = false),
		            (workInProgress.pendingProps = nextProps = prevProps),
		            checkScheduledUpdateOrContext(current, renderLanes))
		          )
		            0 !== (current.flags & 131072) && (didReceiveUpdate = true);
		          else
		            return (
		              (workInProgress.lanes = current.lanes),
		              bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
		            );
		      }
		      return updateFunctionComponent(
		        current,
		        workInProgress,
		        Component,
		        nextProps,
		        renderLanes
		      );
		    }
		    function updateOffscreenComponent(current, workInProgress, renderLanes) {
		      var nextProps = workInProgress.pendingProps,
		        nextChildren = nextProps.children,
		        nextIsDetached =
		          0 !== (workInProgress.stateNode._pendingVisibility & 2),
		        prevState = null !== current ? current.memoizedState : null;
		      markRef(current, workInProgress);
		      if ("hidden" === nextProps.mode || nextIsDetached) {
		        if (0 !== (workInProgress.flags & 128)) {
		          nextProps =
		            null !== prevState
		              ? prevState.baseLanes | renderLanes
		              : renderLanes;
		          if (null !== current) {
		            nextChildren = workInProgress.child = current.child;
		            for (nextIsDetached = 0; null !== nextChildren; )
		              (nextIsDetached =
		                nextIsDetached | nextChildren.lanes | nextChildren.childLanes),
		                (nextChildren = nextChildren.sibling);
		            workInProgress.childLanes = nextIsDetached & ~nextProps;
		          } else (workInProgress.childLanes = 0), (workInProgress.child = null);
		          return deferHiddenOffscreenComponent(
		            current,
		            workInProgress,
		            nextProps,
		            renderLanes
		          );
		        }
		        if (0 !== (renderLanes & 536870912))
		          (workInProgress.memoizedState = { baseLanes: 0, cachePool: null }),
		            null !== current &&
		              pushTransition(
		                workInProgress,
		                null !== prevState ? prevState.cachePool : null
		              ),
		            null !== prevState
		              ? pushHiddenContext(workInProgress, prevState)
		              : reuseHiddenContextOnStack(workInProgress),
		            pushOffscreenSuspenseHandler(workInProgress);
		        else
		          return (
		            (workInProgress.lanes = workInProgress.childLanes = 536870912),
		            deferHiddenOffscreenComponent(
		              current,
		              workInProgress,
		              null !== prevState
		                ? prevState.baseLanes | renderLanes
		                : renderLanes,
		              renderLanes
		            )
		          );
		      } else
		        null !== prevState
		          ? (pushTransition(workInProgress, prevState.cachePool),
		            pushHiddenContext(workInProgress, prevState),
		            reuseSuspenseHandlerOnStack(workInProgress),
		            (workInProgress.memoizedState = null))
		          : (null !== current && pushTransition(workInProgress, null),
		            reuseHiddenContextOnStack(workInProgress),
		            reuseSuspenseHandlerOnStack(workInProgress));
		      reconcileChildren(current, workInProgress, nextChildren, renderLanes);
		      return workInProgress.child;
		    }
		    function deferHiddenOffscreenComponent(
		      current,
		      workInProgress,
		      nextBaseLanes,
		      renderLanes
		    ) {
		      var JSCompiler_inline_result = peekCacheFromPool();
		      JSCompiler_inline_result =
		        null === JSCompiler_inline_result
		          ? null
		          : {
		              parent: isPrimaryRenderer
		                ? CacheContext._currentValue
		                : CacheContext._currentValue2,
		              pool: JSCompiler_inline_result
		            };
		      workInProgress.memoizedState = {
		        baseLanes: nextBaseLanes,
		        cachePool: JSCompiler_inline_result
		      };
		      null !== current && pushTransition(workInProgress, null);
		      reuseHiddenContextOnStack(workInProgress);
		      pushOffscreenSuspenseHandler(workInProgress);
		      null !== current &&
		        propagateParentContextChanges(current, workInProgress, renderLanes, true);
		      return null;
		    }
		    function markRef(current, workInProgress) {
		      var ref = workInProgress.ref;
		      if (null === ref)
		        null !== current &&
		          null !== current.ref &&
		          (workInProgress.flags |= 2097664);
		      else {
		        if ("function" !== typeof ref && "object" !== typeof ref)
		          throw Error(
		            "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
		          );
		        if (null === current || current.ref !== ref)
		          workInProgress.flags |= 2097664;
		      }
		    }
		    function updateFunctionComponent(
		      current,
		      workInProgress,
		      Component,
		      nextProps,
		      renderLanes
		    ) {
		      if (
		        Component.prototype &&
		        "function" === typeof Component.prototype.render
		      ) {
		        var componentName = getComponentNameFromType(Component) || "Unknown";
		        didWarnAboutBadClass[componentName] ||
		          (console.error(
		            "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
		            componentName,
		            componentName
		          ),
		          (didWarnAboutBadClass[componentName] = true));
		      }
		      workInProgress.mode & 8 &&
		        ReactStrictModeWarnings.recordLegacyContextWarning(
		          workInProgress,
		          null
		        );
		      null === current &&
		        (validateFunctionComponentInDev(workInProgress, workInProgress.type),
		        Component.contextTypes &&
		          ((componentName = getComponentNameFromType(Component) || "Unknown"),
		          didWarnAboutContextTypes[componentName] ||
		            ((didWarnAboutContextTypes[componentName] = true),
		            console.error(
		              "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
		              componentName
		            ))));
		      prepareToReadContext(workInProgress);
		      markComponentRenderStarted(workInProgress);
		      Component = renderWithHooks(
		        current,
		        workInProgress,
		        Component,
		        nextProps,
		        void 0,
		        renderLanes
		      );
		      nextProps = checkDidRenderIdHook();
		      markComponentRenderStopped();
		      if (null !== current && !didReceiveUpdate)
		        return (
		          bailoutHooks(current, workInProgress, renderLanes),
		          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
		        );
		      isHydrating && nextProps && pushMaterializedTreeId(workInProgress);
		      workInProgress.flags |= 1;
		      reconcileChildren(current, workInProgress, Component, renderLanes);
		      return workInProgress.child;
		    }
		    function replayFunctionComponent(
		      current,
		      workInProgress,
		      nextProps,
		      Component,
		      secondArg,
		      renderLanes
		    ) {
		      prepareToReadContext(workInProgress);
		      markComponentRenderStarted(workInProgress);
		      hookTypesUpdateIndexDev = -1;
		      ignorePreviousDependencies =
		        null !== current && current.type !== workInProgress.type;
		      workInProgress.updateQueue = null;
		      nextProps = renderWithHooksAgain(
		        workInProgress,
		        Component,
		        nextProps,
		        secondArg
		      );
		      finishRenderingHooks(current, workInProgress);
		      Component = checkDidRenderIdHook();
		      markComponentRenderStopped();
		      if (null !== current && !didReceiveUpdate)
		        return (
		          bailoutHooks(current, workInProgress, renderLanes),
		          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
		        );
		      isHydrating && Component && pushMaterializedTreeId(workInProgress);
		      workInProgress.flags |= 1;
		      reconcileChildren(current, workInProgress, nextProps, renderLanes);
		      return workInProgress.child;
		    }
		    function updateClassComponent(
		      current$jscomp$0,
		      workInProgress,
		      Component,
		      nextProps,
		      renderLanes
		    ) {
		      switch (shouldErrorImpl(workInProgress)) {
		        case false:
		          var _instance = workInProgress.stateNode,
		            state = new workInProgress.type(
		              workInProgress.memoizedProps,
		              _instance.context
		            ).state;
		          _instance.updater.enqueueSetState(_instance, state, null);
		          break;
		        case true:
		          workInProgress.flags |= 128;
		          workInProgress.flags |= 65536;
		          _instance = Error("Simulated error coming from DevTools");
		          var lane = renderLanes & -renderLanes;
		          workInProgress.lanes |= lane;
		          state = workInProgressRoot;
		          if (null === state)
		            throw Error(
		              "Expected a work-in-progress root. This is a bug in React. Please file an issue."
		            );
		          lane = createClassErrorUpdate(lane);
		          initializeClassErrorUpdate(
		            lane,
		            state,
		            workInProgress,
		            createCapturedValueAtFiber(_instance, workInProgress)
		          );
		          enqueueCapturedUpdate(workInProgress, lane);
		      }
		      prepareToReadContext(workInProgress);
		      if (null === workInProgress.stateNode) {
		        state = emptyContextObject;
		        _instance = Component.contextType;
		        "contextType" in Component &&
		          null !== _instance &&
		          (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) &&
		          !didWarnAboutInvalidateContextType.has(Component) &&
		          (didWarnAboutInvalidateContextType.add(Component),
		          (lane =
		            void 0 === _instance
		              ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file."
		              : "object" !== typeof _instance
		                ? " However, it is set to a " + typeof _instance + "."
		                : _instance.$$typeof === REACT_CONSUMER_TYPE
		                  ? " Did you accidentally pass the Context.Consumer instead?"
		                  : " However, it is set to an object with keys {" +
		                    Object.keys(_instance).join(", ") +
		                    "}."),
		          console.error(
		            "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
		            getComponentNameFromType(Component) || "Component",
		            lane
		          ));
		        "object" === typeof _instance &&
		          null !== _instance &&
		          (state = readContext(_instance));
		        _instance = new Component(nextProps, state);
		        if (workInProgress.mode & 8) {
		          setIsStrictModeForDevtools(true);
		          try {
		            _instance = new Component(nextProps, state);
		          } finally {
		            setIsStrictModeForDevtools(false);
		          }
		        }
		        state = workInProgress.memoizedState =
		          null !== _instance.state && void 0 !== _instance.state
		            ? _instance.state
		            : null;
		        _instance.updater = classComponentUpdater;
		        workInProgress.stateNode = _instance;
		        _instance._reactInternals = workInProgress;
		        _instance._reactInternalInstance = fakeInternalInstance;
		        "function" === typeof Component.getDerivedStateFromProps &&
		          null === state &&
		          ((state = getComponentNameFromType(Component) || "Component"),
		          didWarnAboutUninitializedState.has(state) ||
		            (didWarnAboutUninitializedState.add(state),
		            console.error(
		              "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
		              state,
		              null === _instance.state ? "null" : "undefined",
		              state
		            )));
		        if (
		          "function" === typeof Component.getDerivedStateFromProps ||
		          "function" === typeof _instance.getSnapshotBeforeUpdate
		        ) {
		          var foundWillUpdateName = (lane = state = null);
		          "function" === typeof _instance.componentWillMount &&
		          true !== _instance.componentWillMount.__suppressDeprecationWarning
		            ? (state = "componentWillMount")
		            : "function" === typeof _instance.UNSAFE_componentWillMount &&
		              (state = "UNSAFE_componentWillMount");
		          "function" === typeof _instance.componentWillReceiveProps &&
		          true !==
		            _instance.componentWillReceiveProps.__suppressDeprecationWarning
		            ? (lane = "componentWillReceiveProps")
		            : "function" ===
		                typeof _instance.UNSAFE_componentWillReceiveProps &&
		              (lane = "UNSAFE_componentWillReceiveProps");
		          "function" === typeof _instance.componentWillUpdate &&
		          true !== _instance.componentWillUpdate.__suppressDeprecationWarning
		            ? (foundWillUpdateName = "componentWillUpdate")
		            : "function" === typeof _instance.UNSAFE_componentWillUpdate &&
		              (foundWillUpdateName = "UNSAFE_componentWillUpdate");
		          if (null !== state || null !== lane || null !== foundWillUpdateName) {
		            _instance = getComponentNameFromType(Component) || "Component";
		            var newApiName =
		              "function" === typeof Component.getDerivedStateFromProps
		                ? "getDerivedStateFromProps()"
		                : "getSnapshotBeforeUpdate()";
		            didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) ||
		              (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance),
		              console.error(
		                "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles",
		                _instance,
		                newApiName,
		                null !== state ? "\n  " + state : "",
		                null !== lane ? "\n  " + lane : "",
		                null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""
		              ));
		          }
		        }
		        _instance = workInProgress.stateNode;
		        state = getComponentNameFromType(Component) || "Component";
		        _instance.render ||
		          (Component.prototype &&
		          "function" === typeof Component.prototype.render
		            ? console.error(
		                "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
		                state
		              )
		            : console.error(
		                "No `render` method found on the %s instance: you may have forgotten to define `render`.",
		                state
		              ));
		        !_instance.getInitialState ||
		          _instance.getInitialState.isReactClassApproved ||
		          _instance.state ||
		          console.error(
		            "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
		            state
		          );
		        _instance.getDefaultProps &&
		          !_instance.getDefaultProps.isReactClassApproved &&
		          console.error(
		            "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
		            state
		          );
		        _instance.contextType &&
		          console.error(
		            "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
		            state
		          );
		        Component.childContextTypes &&
		          !didWarnAboutChildContextTypes.has(Component) &&
		          (didWarnAboutChildContextTypes.add(Component),
		          console.error(
		            "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
		            state
		          ));
		        Component.contextTypes &&
		          !didWarnAboutContextTypes$1.has(Component) &&
		          (didWarnAboutContextTypes$1.add(Component),
		          console.error(
		            "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
		            state
		          ));
		        "function" === typeof _instance.componentShouldUpdate &&
		          console.error(
		            "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
		            state
		          );
		        Component.prototype &&
		          Component.prototype.isPureReactComponent &&
		          "undefined" !== typeof _instance.shouldComponentUpdate &&
		          console.error(
		            "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
		            getComponentNameFromType(Component) || "A pure component"
		          );
		        "function" === typeof _instance.componentDidUnmount &&
		          console.error(
		            "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
		            state
		          );
		        "function" === typeof _instance.componentDidReceiveProps &&
		          console.error(
		            "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
		            state
		          );
		        "function" === typeof _instance.componentWillRecieveProps &&
		          console.error(
		            "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
		            state
		          );
		        "function" === typeof _instance.UNSAFE_componentWillRecieveProps &&
		          console.error(
		            "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
		            state
		          );
		        lane = _instance.props !== nextProps;
		        void 0 !== _instance.props &&
		          lane &&
		          console.error(
		            "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
		            state
		          );
		        _instance.defaultProps &&
		          console.error(
		            "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
		            state,
		            state
		          );
		        "function" !== typeof _instance.getSnapshotBeforeUpdate ||
		          "function" === typeof _instance.componentDidUpdate ||
		          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) ||
		          (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component),
		          console.error(
		            "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
		            getComponentNameFromType(Component)
		          ));
		        "function" === typeof _instance.getDerivedStateFromProps &&
		          console.error(
		            "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
		            state
		          );
		        "function" === typeof _instance.getDerivedStateFromError &&
		          console.error(
		            "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
		            state
		          );
		        "function" === typeof Component.getSnapshotBeforeUpdate &&
		          console.error(
		            "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
		            state
		          );
		        (lane = _instance.state) &&
		          ("object" !== typeof lane || isArrayImpl(lane)) &&
		          console.error("%s.state: must be set to an object or null", state);
		        "function" === typeof _instance.getChildContext &&
		          "object" !== typeof Component.childContextTypes &&
		          console.error(
		            "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
		            state
		          );
		        _instance = workInProgress.stateNode;
		        _instance.props = nextProps;
		        _instance.state = workInProgress.memoizedState;
		        _instance.refs = {};
		        initializeUpdateQueue(workInProgress);
		        state = Component.contextType;
		        _instance.context =
		          "object" === typeof state && null !== state
		            ? readContext(state)
		            : emptyContextObject;
		        _instance.state === nextProps &&
		          ((state = getComponentNameFromType(Component) || "Component"),
		          didWarnAboutDirectlyAssigningPropsToState.has(state) ||
		            (didWarnAboutDirectlyAssigningPropsToState.add(state),
		            console.error(
		              "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
		              state
		            )));
		        workInProgress.mode & 8 &&
		          ReactStrictModeWarnings.recordLegacyContextWarning(
		            workInProgress,
		            _instance
		          );
		        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(
		          workInProgress,
		          _instance
		        );
		        _instance.state = workInProgress.memoizedState;
		        state = Component.getDerivedStateFromProps;
		        "function" === typeof state &&
		          (applyDerivedStateFromProps(
		            workInProgress,
		            Component,
		            state,
		            nextProps
		          ),
		          (_instance.state = workInProgress.memoizedState));
		        "function" === typeof Component.getDerivedStateFromProps ||
		          "function" === typeof _instance.getSnapshotBeforeUpdate ||
		          ("function" !== typeof _instance.UNSAFE_componentWillMount &&
		            "function" !== typeof _instance.componentWillMount) ||
		          ((state = _instance.state),
		          "function" === typeof _instance.componentWillMount &&
		            _instance.componentWillMount(),
		          "function" === typeof _instance.UNSAFE_componentWillMount &&
		            _instance.UNSAFE_componentWillMount(),
		          state !== _instance.state &&
		            (console.error(
		              "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
		              getComponentNameFromFiber(workInProgress) || "Component"
		            ),
		            classComponentUpdater.enqueueReplaceState(
		              _instance,
		              _instance.state,
		              null
		            )),
		          processUpdateQueue(workInProgress, nextProps, _instance, renderLanes),
		          suspendIfUpdateReadFromEntangledAsyncAction(),
		          (_instance.state = workInProgress.memoizedState));
		        "function" === typeof _instance.componentDidMount &&
		          (workInProgress.flags |= 4194308);
		        (workInProgress.mode & 16) !== NoMode &&
		          (workInProgress.flags |= 67108864);
		        _instance = true;
		      } else if (null === current$jscomp$0) {
		        _instance = workInProgress.stateNode;
		        var unresolvedOldProps = workInProgress.memoizedProps;
		        lane = resolveClassComponentProps(Component, unresolvedOldProps);
		        _instance.props = lane;
		        var oldContext = _instance.context;
		        foundWillUpdateName = Component.contextType;
		        state = emptyContextObject;
		        "object" === typeof foundWillUpdateName &&
		          null !== foundWillUpdateName &&
		          (state = readContext(foundWillUpdateName));
		        newApiName = Component.getDerivedStateFromProps;
		        foundWillUpdateName =
		          "function" === typeof newApiName ||
		          "function" === typeof _instance.getSnapshotBeforeUpdate;
		        unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;
		        foundWillUpdateName ||
		          ("function" !== typeof _instance.UNSAFE_componentWillReceiveProps &&
		            "function" !== typeof _instance.componentWillReceiveProps) ||
		          ((unresolvedOldProps || oldContext !== state) &&
		            callComponentWillReceiveProps(
		              workInProgress,
		              _instance,
		              nextProps,
		              state
		            ));
		        hasForceUpdate = false;
		        var oldState = workInProgress.memoizedState;
		        _instance.state = oldState;
		        processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);
		        suspendIfUpdateReadFromEntangledAsyncAction();
		        oldContext = workInProgress.memoizedState;
		        unresolvedOldProps || oldState !== oldContext || hasForceUpdate
		          ? ("function" === typeof newApiName &&
		              (applyDerivedStateFromProps(
		                workInProgress,
		                Component,
		                newApiName,
		                nextProps
		              ),
		              (oldContext = workInProgress.memoizedState)),
		            (lane =
		              hasForceUpdate ||
		              checkShouldComponentUpdate(
		                workInProgress,
		                Component,
		                lane,
		                nextProps,
		                oldState,
		                oldContext,
		                state
		              ))
		              ? (foundWillUpdateName ||
		                  ("function" !== typeof _instance.UNSAFE_componentWillMount &&
		                    "function" !== typeof _instance.componentWillMount) ||
		                  ("function" === typeof _instance.componentWillMount &&
		                    _instance.componentWillMount(),
		                  "function" === typeof _instance.UNSAFE_componentWillMount &&
		                    _instance.UNSAFE_componentWillMount()),
		                "function" === typeof _instance.componentDidMount &&
		                  (workInProgress.flags |= 4194308),
		                (workInProgress.mode & 16) !== NoMode &&
		                  (workInProgress.flags |= 67108864))
		              : ("function" === typeof _instance.componentDidMount &&
		                  (workInProgress.flags |= 4194308),
		                (workInProgress.mode & 16) !== NoMode &&
		                  (workInProgress.flags |= 67108864),
		                (workInProgress.memoizedProps = nextProps),
		                (workInProgress.memoizedState = oldContext)),
		            (_instance.props = nextProps),
		            (_instance.state = oldContext),
		            (_instance.context = state),
		            (_instance = lane))
		          : ("function" === typeof _instance.componentDidMount &&
		              (workInProgress.flags |= 4194308),
		            (workInProgress.mode & 16) !== NoMode &&
		              (workInProgress.flags |= 67108864),
		            (_instance = false));
		      } else {
		        _instance = workInProgress.stateNode;
		        cloneUpdateQueue(current$jscomp$0, workInProgress);
		        state = workInProgress.memoizedProps;
		        foundWillUpdateName = resolveClassComponentProps(Component, state);
		        _instance.props = foundWillUpdateName;
		        newApiName = workInProgress.pendingProps;
		        oldState = _instance.context;
		        oldContext = Component.contextType;
		        lane = emptyContextObject;
		        "object" === typeof oldContext &&
		          null !== oldContext &&
		          (lane = readContext(oldContext));
		        unresolvedOldProps = Component.getDerivedStateFromProps;
		        (oldContext =
		          "function" === typeof unresolvedOldProps ||
		          "function" === typeof _instance.getSnapshotBeforeUpdate) ||
		          ("function" !== typeof _instance.UNSAFE_componentWillReceiveProps &&
		            "function" !== typeof _instance.componentWillReceiveProps) ||
		          ((state !== newApiName || oldState !== lane) &&
		            callComponentWillReceiveProps(
		              workInProgress,
		              _instance,
		              nextProps,
		              lane
		            ));
		        hasForceUpdate = false;
		        oldState = workInProgress.memoizedState;
		        _instance.state = oldState;
		        processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);
		        suspendIfUpdateReadFromEntangledAsyncAction();
		        var newState = workInProgress.memoizedState;
		        state !== newApiName ||
		        oldState !== newState ||
		        hasForceUpdate ||
		        (null !== current$jscomp$0 &&
		          null !== current$jscomp$0.dependencies &&
		          checkIfContextChanged(current$jscomp$0.dependencies))
		          ? ("function" === typeof unresolvedOldProps &&
		              (applyDerivedStateFromProps(
		                workInProgress,
		                Component,
		                unresolvedOldProps,
		                nextProps
		              ),
		              (newState = workInProgress.memoizedState)),
		            (foundWillUpdateName =
		              hasForceUpdate ||
		              checkShouldComponentUpdate(
		                workInProgress,
		                Component,
		                foundWillUpdateName,
		                nextProps,
		                oldState,
		                newState,
		                lane
		              ) ||
		              (null !== current$jscomp$0 &&
		                null !== current$jscomp$0.dependencies &&
		                checkIfContextChanged(current$jscomp$0.dependencies)))
		              ? (oldContext ||
		                  ("function" !== typeof _instance.UNSAFE_componentWillUpdate &&
		                    "function" !== typeof _instance.componentWillUpdate) ||
		                  ("function" === typeof _instance.componentWillUpdate &&
		                    _instance.componentWillUpdate(nextProps, newState, lane),
		                  "function" === typeof _instance.UNSAFE_componentWillUpdate &&
		                    _instance.UNSAFE_componentWillUpdate(
		                      nextProps,
		                      newState,
		                      lane
		                    )),
		                "function" === typeof _instance.componentDidUpdate &&
		                  (workInProgress.flags |= 4),
		                "function" === typeof _instance.getSnapshotBeforeUpdate &&
		                  (workInProgress.flags |= 1024))
		              : ("function" !== typeof _instance.componentDidUpdate ||
		                  (state === current$jscomp$0.memoizedProps &&
		                    oldState === current$jscomp$0.memoizedState) ||
		                  (workInProgress.flags |= 4),
		                "function" !== typeof _instance.getSnapshotBeforeUpdate ||
		                  (state === current$jscomp$0.memoizedProps &&
		                    oldState === current$jscomp$0.memoizedState) ||
		                  (workInProgress.flags |= 1024),
		                (workInProgress.memoizedProps = nextProps),
		                (workInProgress.memoizedState = newState)),
		            (_instance.props = nextProps),
		            (_instance.state = newState),
		            (_instance.context = lane),
		            (_instance = foundWillUpdateName))
		          : ("function" !== typeof _instance.componentDidUpdate ||
		              (state === current$jscomp$0.memoizedProps &&
		                oldState === current$jscomp$0.memoizedState) ||
		              (workInProgress.flags |= 4),
		            "function" !== typeof _instance.getSnapshotBeforeUpdate ||
		              (state === current$jscomp$0.memoizedProps &&
		                oldState === current$jscomp$0.memoizedState) ||
		              (workInProgress.flags |= 1024),
		            (_instance = false));
		      }
		      lane = _instance;
		      markRef(current$jscomp$0, workInProgress);
		      state = 0 !== (workInProgress.flags & 128);
		      if (lane || state) {
		        lane = workInProgress.stateNode;
		        ReactSharedInternals.getCurrentStack =
		          null === workInProgress ? null : getCurrentFiberStackInDev;
		        isRendering = false;
		        current = workInProgress;
		        if (state && "function" !== typeof Component.getDerivedStateFromError)
		          (Component = null), (profilerStartTime = -1);
		        else {
		          markComponentRenderStarted(workInProgress);
		          Component = callRenderInDEV(lane);
		          if (workInProgress.mode & 8) {
		            setIsStrictModeForDevtools(true);
		            try {
		              callRenderInDEV(lane);
		            } finally {
		              setIsStrictModeForDevtools(false);
		            }
		          }
		          markComponentRenderStopped();
		        }
		        workInProgress.flags |= 1;
		        null !== current$jscomp$0 && state
		          ? ((workInProgress.child = reconcileChildFibers(
		              workInProgress,
		              current$jscomp$0.child,
		              null,
		              renderLanes
		            )),
		            (workInProgress.child = reconcileChildFibers(
		              workInProgress,
		              null,
		              Component,
		              renderLanes
		            )))
		          : reconcileChildren(
		              current$jscomp$0,
		              workInProgress,
		              Component,
		              renderLanes
		            );
		        workInProgress.memoizedState = lane.state;
		        current$jscomp$0 = workInProgress.child;
		      } else
		        current$jscomp$0 = bailoutOnAlreadyFinishedWork(
		          current$jscomp$0,
		          workInProgress,
		          renderLanes
		        );
		      renderLanes = workInProgress.stateNode;
		      _instance &&
		        renderLanes.props !== nextProps &&
		        (didWarnAboutReassigningProps ||
		          console.error(
		            "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
		            getComponentNameFromFiber(workInProgress) || "a component"
		          ),
		        (didWarnAboutReassigningProps = true));
		      return current$jscomp$0;
		    }
		    function mountHostRootWithoutHydrating(
		      current,
		      workInProgress,
		      nextChildren,
		      renderLanes
		    ) {
		      resetHydrationState();
		      workInProgress.flags |= 256;
		      reconcileChildren(current, workInProgress, nextChildren, renderLanes);
		      return workInProgress.child;
		    }
		    function validateFunctionComponentInDev(workInProgress, Component) {
		      Component &&
		        Component.childContextTypes &&
		        console.error(
		          "childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...",
		          Component.displayName || Component.name || "Component"
		        );
		      "function" === typeof Component.getDerivedStateFromProps &&
		        ((workInProgress = getComponentNameFromType(Component) || "Unknown"),
		        didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] ||
		          (console.error(
		            "%s: Function components do not support getDerivedStateFromProps.",
		            workInProgress
		          ),
		          (didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] =
		            true)));
		      "object" === typeof Component.contextType &&
		        null !== Component.contextType &&
		        ((Component = getComponentNameFromType(Component) || "Unknown"),
		        didWarnAboutContextTypeOnFunctionComponent[Component] ||
		          (console.error(
		            "%s: Function components do not support contextType.",
		            Component
		          ),
		          (didWarnAboutContextTypeOnFunctionComponent[Component] = true)));
		    }
		    function mountSuspenseOffscreenState(renderLanes) {
		      return { baseLanes: renderLanes, cachePool: getSuspendedCache() };
		    }
		    function getRemainingWorkInPrimaryTree(
		      current,
		      primaryTreeDidDefer,
		      renderLanes
		    ) {
		      current = null !== current ? current.childLanes & ~renderLanes : 0;
		      primaryTreeDidDefer && (current |= workInProgressDeferredLane);
		      return current;
		    }
		    function updateSuspenseComponent(current, workInProgress, renderLanes) {
		      var nextProps = workInProgress.pendingProps;
		      shouldSuspendImpl(workInProgress) && (workInProgress.flags |= 128);
		      var showFallback = false,
		        didSuspend = 0 !== (workInProgress.flags & 128),
		        JSCompiler_temp;
		      (JSCompiler_temp = didSuspend) ||
		        (JSCompiler_temp =
		          null !== current && null === current.memoizedState
		            ? false
		            : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));
		      JSCompiler_temp && ((showFallback = true), (workInProgress.flags &= -129));
		      JSCompiler_temp = 0 !== (workInProgress.flags & 32);
		      workInProgress.flags &= -33;
		      if (null === current) {
		        if (isHydrating) {
		          showFallback
		            ? pushPrimaryTreeSuspenseHandler(workInProgress)
		            : reuseSuspenseHandlerOnStack(workInProgress);
		          if (isHydrating) {
		            var nextInstance = nextHydratableInstance,
		              JSCompiler_temp$jscomp$0;
		            (JSCompiler_temp$jscomp$0 = !nextInstance) ||
		              ((JSCompiler_temp$jscomp$0 = canHydrateSuspenseInstance(
		                nextInstance,
		                rootOrSingletonContext
		              )),
		              null !== JSCompiler_temp$jscomp$0
		                ? (warnIfNotHydrating(),
		                  (workInProgress.memoizedState = {
		                    dehydrated: JSCompiler_temp$jscomp$0,
		                    treeContext:
		                      null !== treeContextProvider
		                        ? { id: treeContextId, overflow: treeContextOverflow }
		                        : null,
		                    retryLane: 536870912
		                  }),
		                  (didSuspend = createFiber(18, null, null, NoMode)),
		                  (didSuspend.stateNode = JSCompiler_temp$jscomp$0),
		                  (didSuspend.return = workInProgress),
		                  (workInProgress.child = didSuspend),
		                  (hydrationParentFiber = workInProgress),
		                  (nextHydratableInstance = null),
		                  (JSCompiler_temp$jscomp$0 = true))
		                : (JSCompiler_temp$jscomp$0 = false),
		              (JSCompiler_temp$jscomp$0 = !JSCompiler_temp$jscomp$0));
		            JSCompiler_temp$jscomp$0 &&
		              (warnNonHydratedInstance(workInProgress, nextInstance),
		              throwOnHydrationMismatch(workInProgress));
		          }
		          nextInstance = workInProgress.memoizedState;
		          if (
		            null !== nextInstance &&
		            ((nextInstance = nextInstance.dehydrated), null !== nextInstance)
		          )
		            return (
		              isSuspenseInstanceFallback(nextInstance)
		                ? (workInProgress.lanes = 16)
		                : (workInProgress.lanes = 536870912),
		              null
		            );
		          popSuspenseHandler(workInProgress);
		        }
		        nextInstance = nextProps.children;
		        nextProps = nextProps.fallback;
		        if (showFallback)
		          return (
		            reuseSuspenseHandlerOnStack(workInProgress),
		            (showFallback = workInProgress.mode),
		            (nextInstance = mountWorkInProgressOffscreenFiber(
		              { mode: "hidden", children: nextInstance },
		              showFallback
		            )),
		            (nextProps = createFiberFromFragment(
		              nextProps,
		              showFallback,
		              renderLanes,
		              null
		            )),
		            (nextInstance.return = workInProgress),
		            (nextProps.return = workInProgress),
		            (nextInstance.sibling = nextProps),
		            (workInProgress.child = nextInstance),
		            (showFallback = workInProgress.child),
		            (showFallback.memoizedState =
		              mountSuspenseOffscreenState(renderLanes)),
		            (showFallback.childLanes = getRemainingWorkInPrimaryTree(
		              current,
		              JSCompiler_temp,
		              renderLanes
		            )),
		            (workInProgress.memoizedState = SUSPENDED_MARKER),
		            nextProps
		          );
		        pushPrimaryTreeSuspenseHandler(workInProgress);
		        return mountSuspensePrimaryChildren(workInProgress, nextInstance);
		      }
		      JSCompiler_temp$jscomp$0 = current.memoizedState;
		      if (
		        null !== JSCompiler_temp$jscomp$0 &&
		        ((nextInstance = JSCompiler_temp$jscomp$0.dehydrated),
		        null !== nextInstance)
		      ) {
		        if (didSuspend)
		          workInProgress.flags & 256
		            ? (pushPrimaryTreeSuspenseHandler(workInProgress),
		              (workInProgress.flags &= -257),
		              (workInProgress = retrySuspenseComponentWithoutHydrating(
		                current,
		                workInProgress,
		                renderLanes
		              )))
		            : null !== workInProgress.memoizedState
		              ? (reuseSuspenseHandlerOnStack(workInProgress),
		                (workInProgress.child = current.child),
		                (workInProgress.flags |= 128),
		                (workInProgress = null))
		              : (reuseSuspenseHandlerOnStack(workInProgress),
		                (showFallback = nextProps.fallback),
		                (nextInstance = workInProgress.mode),
		                (nextProps = mountWorkInProgressOffscreenFiber(
		                  { mode: "visible", children: nextProps.children },
		                  nextInstance
		                )),
		                (showFallback = createFiberFromFragment(
		                  showFallback,
		                  nextInstance,
		                  renderLanes,
		                  null
		                )),
		                (showFallback.flags |= 2),
		                (nextProps.return = workInProgress),
		                (showFallback.return = workInProgress),
		                (nextProps.sibling = showFallback),
		                (workInProgress.child = nextProps),
		                reconcileChildFibers(
		                  workInProgress,
		                  current.child,
		                  null,
		                  renderLanes
		                ),
		                (nextProps = workInProgress.child),
		                (nextProps.memoizedState =
		                  mountSuspenseOffscreenState(renderLanes)),
		                (nextProps.childLanes = getRemainingWorkInPrimaryTree(
		                  current,
		                  JSCompiler_temp,
		                  renderLanes
		                )),
		                (workInProgress.memoizedState = SUSPENDED_MARKER),
		                (workInProgress = showFallback));
		        else if (
		          (pushPrimaryTreeSuspenseHandler(workInProgress),
		          isHydrating &&
		            console.error(
		              "We should not be hydrating here. This is a bug in React. Please file a bug."
		            ),
		          isSuspenseInstanceFallback(nextInstance))
		        )
		          (nextInstance =
		            getSuspenseInstanceFallbackErrorDetails(nextInstance)),
		            (JSCompiler_temp = nextInstance.digest),
		            (showFallback = nextInstance.message),
		            (nextProps = nextInstance.stack),
		            (nextInstance = nextInstance.componentStack),
		            (showFallback = showFallback
		              ? Error(showFallback)
		              : Error(
		                  "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."
		                )),
		            (showFallback.stack = nextProps || ""),
		            (showFallback.digest = JSCompiler_temp),
		            (JSCompiler_temp = void 0 === nextInstance ? null : nextInstance),
		            (nextProps = {
		              value: showFallback,
		              source: null,
		              stack: JSCompiler_temp
		            }),
		            "string" === typeof JSCompiler_temp &&
		              CapturedStacks.set(showFallback, nextProps),
		            queueHydrationError(nextProps),
		            (workInProgress = retrySuspenseComponentWithoutHydrating(
		              current,
		              workInProgress,
		              renderLanes
		            ));
		        else if (
		          (didReceiveUpdate ||
		            propagateParentContextChanges(
		              current,
		              workInProgress,
		              renderLanes,
		              false
		            ),
		          (JSCompiler_temp = 0 !== (renderLanes & current.childLanes)),
		          didReceiveUpdate || JSCompiler_temp)
		        ) {
		          JSCompiler_temp = workInProgressRoot;
		          if (null !== JSCompiler_temp) {
		            nextProps = renderLanes & -renderLanes;
		            if (0 !== (nextProps & 42)) nextProps = 1;
		            else
		              switch (nextProps) {
		                case 2:
		                  nextProps = 1;
		                  break;
		                case 8:
		                  nextProps = 4;
		                  break;
		                case 32:
		                  nextProps = 16;
		                  break;
		                case 128:
		                case 256:
		                case 512:
		                case 1024:
		                case 2048:
		                case 4096:
		                case 8192:
		                case 16384:
		                case 32768:
		                case 65536:
		                case 131072:
		                case 262144:
		                case 524288:
		                case 1048576:
		                case 2097152:
		                case 4194304:
		                case 8388608:
		                case 16777216:
		                case 33554432:
		                  nextProps = 64;
		                  break;
		                case 268435456:
		                  nextProps = 134217728;
		                  break;
		                default:
		                  nextProps = 0;
		              }
		            nextProps =
		              0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes))
		                ? 0
		                : nextProps;
		            if (
		              0 !== nextProps &&
		              nextProps !== JSCompiler_temp$jscomp$0.retryLane
		            )
		              throw (
		                ((JSCompiler_temp$jscomp$0.retryLane = nextProps),
		                enqueueConcurrentRenderForLane(current, nextProps),
		                scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps),
		                SelectiveHydrationException)
		              );
		          }
		          isSuspenseInstancePending(nextInstance) ||
		            renderDidSuspendDelayIfPossible();
		          workInProgress = retrySuspenseComponentWithoutHydrating(
		            current,
		            workInProgress,
		            renderLanes
		          );
		        } else
		          isSuspenseInstancePending(nextInstance)
		            ? ((workInProgress.flags |= 128),
		              (workInProgress.child = current.child),
		              (workInProgress = retryDehydratedSuspenseBoundary.bind(
		                null,
		                current
		              )),
		              registerSuspenseInstanceRetry(nextInstance, workInProgress),
		              (workInProgress = null))
		            : ((current = JSCompiler_temp$jscomp$0.treeContext),
		              supportsHydration &&
		                ((nextHydratableInstance =
		                  getFirstHydratableChildWithinSuspenseInstance(nextInstance)),
		                (hydrationParentFiber = workInProgress),
		                (isHydrating = true),
		                (hydrationErrors = null),
		                (didSuspendOrErrorDEV = false),
		                (hydrationDiffRootDEV = null),
		                (rootOrSingletonContext = false),
		                null !== current &&
		                  (warnIfNotHydrating(),
		                  (idStack[idStackIndex++] = treeContextId),
		                  (idStack[idStackIndex++] = treeContextOverflow),
		                  (idStack[idStackIndex++] = treeContextProvider),
		                  (treeContextId = current.id),
		                  (treeContextOverflow = current.overflow),
		                  (treeContextProvider = workInProgress))),
		              (workInProgress = mountSuspensePrimaryChildren(
		                workInProgress,
		                nextProps.children
		              )),
		              (workInProgress.flags |= 4096));
		        return workInProgress;
		      }
		      if (showFallback)
		        return (
		          reuseSuspenseHandlerOnStack(workInProgress),
		          (showFallback = nextProps.fallback),
		          (nextInstance = workInProgress.mode),
		          (JSCompiler_temp$jscomp$0 = current.child),
		          (didSuspend = JSCompiler_temp$jscomp$0.sibling),
		          (nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {
		            mode: "hidden",
		            children: nextProps.children
		          })),
		          (nextProps.subtreeFlags =
		            JSCompiler_temp$jscomp$0.subtreeFlags & 31457280),
		          null !== didSuspend
		            ? (showFallback = createWorkInProgress(didSuspend, showFallback))
		            : ((showFallback = createFiberFromFragment(
		                showFallback,
		                nextInstance,
		                renderLanes,
		                null
		              )),
		              (showFallback.flags |= 2)),
		          (showFallback.return = workInProgress),
		          (nextProps.return = workInProgress),
		          (nextProps.sibling = showFallback),
		          (workInProgress.child = nextProps),
		          (nextProps = showFallback),
		          (showFallback = workInProgress.child),
		          (nextInstance = current.child.memoizedState),
		          null === nextInstance
		            ? (nextInstance = mountSuspenseOffscreenState(renderLanes))
		            : ((JSCompiler_temp$jscomp$0 = nextInstance.cachePool),
		              null !== JSCompiler_temp$jscomp$0
		                ? ((didSuspend = isPrimaryRenderer
		                    ? CacheContext._currentValue
		                    : CacheContext._currentValue2),
		                  (JSCompiler_temp$jscomp$0 =
		                    JSCompiler_temp$jscomp$0.parent !== didSuspend
		                      ? { parent: didSuspend, pool: didSuspend }
		                      : JSCompiler_temp$jscomp$0))
		                : (JSCompiler_temp$jscomp$0 = getSuspendedCache()),
		              (nextInstance = {
		                baseLanes: nextInstance.baseLanes | renderLanes,
		                cachePool: JSCompiler_temp$jscomp$0
		              })),
		          (showFallback.memoizedState = nextInstance),
		          (showFallback.childLanes = getRemainingWorkInPrimaryTree(
		            current,
		            JSCompiler_temp,
		            renderLanes
		          )),
		          (workInProgress.memoizedState = SUSPENDED_MARKER),
		          nextProps
		        );
		      pushPrimaryTreeSuspenseHandler(workInProgress);
		      renderLanes = current.child;
		      current = renderLanes.sibling;
		      renderLanes = createWorkInProgress(renderLanes, {
		        mode: "visible",
		        children: nextProps.children
		      });
		      renderLanes.return = workInProgress;
		      renderLanes.sibling = null;
		      null !== current &&
		        ((JSCompiler_temp = workInProgress.deletions),
		        null === JSCompiler_temp
		          ? ((workInProgress.deletions = [current]),
		            (workInProgress.flags |= 16))
		          : JSCompiler_temp.push(current));
		      workInProgress.child = renderLanes;
		      workInProgress.memoizedState = null;
		      return renderLanes;
		    }
		    function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
		      primaryChildren = mountWorkInProgressOffscreenFiber(
		        { mode: "visible", children: primaryChildren },
		        workInProgress.mode
		      );
		      primaryChildren.return = workInProgress;
		      return (workInProgress.child = primaryChildren);
		    }
		    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
		      return createFiberFromOffscreen(offscreenProps, mode, 0, null);
		    }
		    function retrySuspenseComponentWithoutHydrating(
		      current,
		      workInProgress,
		      renderLanes
		    ) {
		      reconcileChildFibers(workInProgress, current.child, null, renderLanes);
		      current = mountSuspensePrimaryChildren(
		        workInProgress,
		        workInProgress.pendingProps.children
		      );
		      current.flags |= 2;
		      workInProgress.memoizedState = null;
		      return current;
		    }
		    function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {
		      fiber.lanes |= renderLanes;
		      var alternate = fiber.alternate;
		      null !== alternate && (alternate.lanes |= renderLanes);
		      scheduleContextWorkOnParentPath(
		        fiber.return,
		        renderLanes,
		        propagationRoot
		      );
		    }
		    function validateSuspenseListNestedChild(childSlot, index) {
		      var isAnArray = isArrayImpl(childSlot);
		      childSlot = !isAnArray && "function" === typeof getIteratorFn(childSlot);
		      return isAnArray || childSlot
		        ? ((isAnArray = isAnArray ? "array" : "iterable"),
		          console.error(
		            "A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>",
		            isAnArray,
		            index,
		            isAnArray
		          ),
		          false)
		        : true;
		    }
		    function initSuspenseListRenderState(
		      workInProgress,
		      isBackwards,
		      tail,
		      lastContentRow,
		      tailMode
		    ) {
		      var renderState = workInProgress.memoizedState;
		      null === renderState
		        ? (workInProgress.memoizedState = {
		            isBackwards: isBackwards,
		            rendering: null,
		            renderingStartTime: 0,
		            last: lastContentRow,
		            tail: tail,
		            tailMode: tailMode
		          })
		        : ((renderState.isBackwards = isBackwards),
		          (renderState.rendering = null),
		          (renderState.renderingStartTime = 0),
		          (renderState.last = lastContentRow),
		          (renderState.tail = tail),
		          (renderState.tailMode = tailMode));
		    }
		    function updateSuspenseListComponent(current, workInProgress, renderLanes) {
		      var nextProps = workInProgress.pendingProps,
		        revealOrder = nextProps.revealOrder,
		        tailMode = nextProps.tail;
		      nextProps = nextProps.children;
		      if (
		        void 0 !== revealOrder &&
		        "forwards" !== revealOrder &&
		        "backwards" !== revealOrder &&
		        "together" !== revealOrder &&
		        !didWarnAboutRevealOrder[revealOrder]
		      )
		        if (
		          ((didWarnAboutRevealOrder[revealOrder] = true),
		          "string" === typeof revealOrder)
		        )
		          switch (revealOrder.toLowerCase()) {
		            case "together":
		            case "forwards":
		            case "backwards":
		              console.error(
		                '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
		                revealOrder,
		                revealOrder.toLowerCase()
		              );
		              break;
		            case "forward":
		            case "backward":
		              console.error(
		                '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
		                revealOrder,
		                revealOrder.toLowerCase()
		              );
		              break;
		            default:
		              console.error(
		                '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
		                revealOrder
		              );
		          }
		        else
		          console.error(
		            '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
		            revealOrder
		          );
		      void 0 === tailMode ||
		        didWarnAboutTailOptions[tailMode] ||
		        ("collapsed" !== tailMode && "hidden" !== tailMode
		          ? ((didWarnAboutTailOptions[tailMode] = true),
		            console.error(
		              '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?',
		              tailMode
		            ))
		          : "forwards" !== revealOrder &&
		            "backwards" !== revealOrder &&
		            ((didWarnAboutTailOptions[tailMode] = true),
		            console.error(
		              '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
		              tailMode
		            )));
		      a: if (
		        ("forwards" === revealOrder || "backwards" === revealOrder) &&
		        void 0 !== nextProps &&
		        null !== nextProps &&
		        false !== nextProps
		      )
		        if (isArrayImpl(nextProps))
		          for (var i = 0; i < nextProps.length; i++) {
		            if (!validateSuspenseListNestedChild(nextProps[i], i)) break a;
		          }
		        else if (((i = getIteratorFn(nextProps)), "function" === typeof i)) {
		          if ((i = i.call(nextProps)))
		            for (var step = i.next(), _i = 0; !step.done; step = i.next()) {
		              if (!validateSuspenseListNestedChild(step.value, _i)) break a;
		              _i++;
		            }
		        } else
		          console.error(
		            'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
		            revealOrder
		          );
		      reconcileChildren(current, workInProgress, nextProps, renderLanes);
		      nextProps = suspenseStackCursor.current;
		      if (0 !== (nextProps & ForceSuspenseFallback))
		        (nextProps =
		          (nextProps & SubtreeSuspenseContextMask) | ForceSuspenseFallback),
		          (workInProgress.flags |= 128);
		      else {
		        if (null !== current && 0 !== (current.flags & 128))
		          a: for (current = workInProgress.child; null !== current; ) {
		            if (13 === current.tag)
		              null !== current.memoizedState &&
		                scheduleSuspenseWorkOnFiber(
		                  current,
		                  renderLanes,
		                  workInProgress
		                );
		            else if (19 === current.tag)
		              scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
		            else if (null !== current.child) {
		              current.child.return = current;
		              current = current.child;
		              continue;
		            }
		            if (current === workInProgress) break a;
		            for (; null === current.sibling; ) {
		              if (null === current.return || current.return === workInProgress)
		                break a;
		              current = current.return;
		            }
		            current.sibling.return = current.return;
		            current = current.sibling;
		          }
		        nextProps &= SubtreeSuspenseContextMask;
		      }
		      push(suspenseStackCursor, nextProps, workInProgress);
		      switch (revealOrder) {
		        case "forwards":
		          renderLanes = workInProgress.child;
		          for (revealOrder = null; null !== renderLanes; )
		            (current = renderLanes.alternate),
		              null !== current &&
		                null === findFirstSuspended(current) &&
		                (revealOrder = renderLanes),
		              (renderLanes = renderLanes.sibling);
		          renderLanes = revealOrder;
		          null === renderLanes
		            ? ((revealOrder = workInProgress.child),
		              (workInProgress.child = null))
		            : ((revealOrder = renderLanes.sibling),
		              (renderLanes.sibling = null));
		          initSuspenseListRenderState(
		            workInProgress,
		            false,
		            revealOrder,
		            renderLanes,
		            tailMode
		          );
		          break;
		        case "backwards":
		          renderLanes = null;
		          revealOrder = workInProgress.child;
		          for (workInProgress.child = null; null !== revealOrder; ) {
		            current = revealOrder.alternate;
		            if (null !== current && null === findFirstSuspended(current)) {
		              workInProgress.child = revealOrder;
		              break;
		            }
		            current = revealOrder.sibling;
		            revealOrder.sibling = renderLanes;
		            renderLanes = revealOrder;
		            revealOrder = current;
		          }
		          initSuspenseListRenderState(
		            workInProgress,
		            true,
		            renderLanes,
		            null,
		            tailMode
		          );
		          break;
		        case "together":
		          initSuspenseListRenderState(workInProgress, false, null, null, void 0);
		          break;
		        default:
		          workInProgress.memoizedState = null;
		      }
		      return workInProgress.child;
		    }
		    function bailoutOnAlreadyFinishedWork(
		      current,
		      workInProgress,
		      renderLanes
		    ) {
		      null !== current && (workInProgress.dependencies = current.dependencies);
		      profilerStartTime = -1;
		      workInProgressRootSkippedLanes |= workInProgress.lanes;
		      if (0 === (renderLanes & workInProgress.childLanes))
		        if (null !== current) {
		          if (
		            (propagateParentContextChanges(
		              current,
		              workInProgress,
		              renderLanes,
		              false
		            ),
		            0 === (renderLanes & workInProgress.childLanes))
		          )
		            return null;
		        } else return null;
		      if (null !== current && workInProgress.child !== current.child)
		        throw Error("Resuming work not yet implemented.");
		      if (null !== workInProgress.child) {
		        current = workInProgress.child;
		        renderLanes = createWorkInProgress(current, current.pendingProps);
		        workInProgress.child = renderLanes;
		        for (renderLanes.return = workInProgress; null !== current.sibling; )
		          (current = current.sibling),
		            (renderLanes = renderLanes.sibling =
		              createWorkInProgress(current, current.pendingProps)),
		            (renderLanes.return = workInProgress);
		        renderLanes.sibling = null;
		      }
		      return workInProgress.child;
		    }
		    function checkScheduledUpdateOrContext(current, renderLanes) {
		      if (0 !== (current.lanes & renderLanes)) return true;
		      current = current.dependencies;
		      return null !== current && checkIfContextChanged(current) ? true : false;
		    }
		    function attemptEarlyBailoutIfNoScheduledUpdate(
		      current,
		      workInProgress,
		      renderLanes
		    ) {
		      switch (workInProgress.tag) {
		        case 3:
		          pushHostContainer(
		            workInProgress,
		            workInProgress.stateNode.containerInfo
		          );
		          pushProvider(
		            workInProgress,
		            CacheContext,
		            current.memoizedState.cache
		          );
		          resetHydrationState();
		          break;
		        case 27:
		        case 5:
		          pushHostContext(workInProgress);
		          break;
		        case 4:
		          pushHostContainer(
		            workInProgress,
		            workInProgress.stateNode.containerInfo
		          );
		          break;
		        case 10:
		          pushProvider(
		            workInProgress,
		            workInProgress.type,
		            workInProgress.memoizedProps.value
		          );
		          break;
		        case 12:
		          0 !== (renderLanes & workInProgress.childLanes) &&
		            (workInProgress.flags |= 4);
		          workInProgress.flags |= 2048;
		          var stateNode = workInProgress.stateNode;
		          stateNode.effectDuration = -0;
		          stateNode.passiveEffectDuration = -0;
		          break;
		        case 13:
		          stateNode = workInProgress.memoizedState;
		          if (null !== stateNode) {
		            if (null !== stateNode.dehydrated)
		              return (
		                pushPrimaryTreeSuspenseHandler(workInProgress),
		                (workInProgress.flags |= 128),
		                null
		              );
		            if (0 !== (renderLanes & workInProgress.child.childLanes))
		              return updateSuspenseComponent(
		                current,
		                workInProgress,
		                renderLanes
		              );
		            pushPrimaryTreeSuspenseHandler(workInProgress);
		            current = bailoutOnAlreadyFinishedWork(
		              current,
		              workInProgress,
		              renderLanes
		            );
		            return null !== current ? current.sibling : null;
		          }
		          pushPrimaryTreeSuspenseHandler(workInProgress);
		          break;
		        case 19:
		          var didSuspendBefore = 0 !== (current.flags & 128);
		          stateNode = 0 !== (renderLanes & workInProgress.childLanes);
		          stateNode ||
		            (propagateParentContextChanges(
		              current,
		              workInProgress,
		              renderLanes,
		              false
		            ),
		            (stateNode = 0 !== (renderLanes & workInProgress.childLanes)));
		          if (didSuspendBefore) {
		            if (stateNode)
		              return updateSuspenseListComponent(
		                current,
		                workInProgress,
		                renderLanes
		              );
		            workInProgress.flags |= 128;
		          }
		          didSuspendBefore = workInProgress.memoizedState;
		          null !== didSuspendBefore &&
		            ((didSuspendBefore.rendering = null),
		            (didSuspendBefore.tail = null),
		            (didSuspendBefore.lastEffect = null));
		          push(
		            suspenseStackCursor,
		            suspenseStackCursor.current,
		            workInProgress
		          );
		          if (stateNode) break;
		          else return null;
		        case 22:
		        case 23:
		          return (
		            (workInProgress.lanes = 0),
		            updateOffscreenComponent(current, workInProgress, renderLanes)
		          );
		        case 24:
		          pushProvider(
		            workInProgress,
		            CacheContext,
		            current.memoizedState.cache
		          );
		      }
		      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
		    }
		    function beginWork(current, workInProgress, renderLanes) {
		      if (workInProgress._debugNeedsRemount && null !== current) {
		        renderLanes = createFiberFromTypeAndProps(
		          workInProgress.type,
		          workInProgress.key,
		          workInProgress.pendingProps,
		          workInProgress._debugOwner || null,
		          workInProgress.mode,
		          workInProgress.lanes
		        );
		        var returnFiber = workInProgress.return;
		        if (null === returnFiber) throw Error("Cannot swap the root fiber.");
		        current.alternate = null;
		        workInProgress.alternate = null;
		        renderLanes.index = workInProgress.index;
		        renderLanes.sibling = workInProgress.sibling;
		        renderLanes.return = workInProgress.return;
		        renderLanes.ref = workInProgress.ref;
		        renderLanes._debugInfo = workInProgress._debugInfo;
		        if (workInProgress === returnFiber.child)
		          returnFiber.child = renderLanes;
		        else {
		          var prevSibling = returnFiber.child;
		          if (null === prevSibling)
		            throw Error("Expected parent to have a child.");
		          for (; prevSibling.sibling !== workInProgress; )
		            if (((prevSibling = prevSibling.sibling), null === prevSibling))
		              throw Error("Expected to find the previous sibling.");
		          prevSibling.sibling = renderLanes;
		        }
		        workInProgress = returnFiber.deletions;
		        null === workInProgress
		          ? ((returnFiber.deletions = [current]), (returnFiber.flags |= 16))
		          : workInProgress.push(current);
		        renderLanes.flags |= 2;
		        return renderLanes;
		      }
		      if (null !== current)
		        if (
		          current.memoizedProps !== workInProgress.pendingProps ||
		          workInProgress.type !== current.type
		        )
		          didReceiveUpdate = true;
		        else {
		          if (
		            !checkScheduledUpdateOrContext(current, renderLanes) &&
		            0 === (workInProgress.flags & 128)
		          )
		            return (
		              (didReceiveUpdate = false),
		              attemptEarlyBailoutIfNoScheduledUpdate(
		                current,
		                workInProgress,
		                renderLanes
		              )
		            );
		          didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
		        }
		      else {
		        didReceiveUpdate = false;
		        if ((returnFiber = isHydrating))
		          warnIfNotHydrating(),
		            (returnFiber = 0 !== (workInProgress.flags & 1048576));
		        returnFiber &&
		          ((returnFiber = workInProgress.index),
		          warnIfNotHydrating(),
		          pushTreeId(workInProgress, treeForkCount, returnFiber));
		      }
		      workInProgress.lanes = 0;
		      switch (workInProgress.tag) {
		        case 16:
		          a: if (
		            ((returnFiber = workInProgress.pendingProps),
		            (current = callLazyInitInDEV(workInProgress.elementType)),
		            (workInProgress.type = current),
		            "function" === typeof current)
		          )
		            shouldConstruct(current)
		              ? ((returnFiber = resolveClassComponentProps(
		                  current,
		                  returnFiber
		                )),
		                (workInProgress.tag = 1),
		                (workInProgress.type = current =
		                  resolveFunctionForHotReloading(current)),
		                (workInProgress = updateClassComponent(
		                  null,
		                  workInProgress,
		                  current,
		                  returnFiber,
		                  renderLanes
		                )))
		              : ((workInProgress.tag = 0),
		                validateFunctionComponentInDev(workInProgress, current),
		                (workInProgress.type = current =
		                  resolveFunctionForHotReloading(current)),
		                (workInProgress = updateFunctionComponent(
		                  null,
		                  workInProgress,
		                  current,
		                  returnFiber,
		                  renderLanes
		                )));
		          else {
		            if (void 0 !== current && null !== current)
		              if (
		                ((prevSibling = current.$$typeof),
		                prevSibling === REACT_FORWARD_REF_TYPE)
		              ) {
		                workInProgress.tag = 11;
		                workInProgress.type = current =
		                  resolveForwardRefForHotReloading(current);
		                workInProgress = updateForwardRef(
		                  null,
		                  workInProgress,
		                  current,
		                  returnFiber,
		                  renderLanes
		                );
		                break a;
		              } else if (prevSibling === REACT_MEMO_TYPE) {
		                workInProgress.tag = 14;
		                workInProgress = updateMemoComponent(
		                  null,
		                  workInProgress,
		                  current,
		                  returnFiber,
		                  renderLanes
		                );
		                break a;
		              }
		            workInProgress = "";
		            null !== current &&
		              "object" === typeof current &&
		              current.$$typeof === REACT_LAZY_TYPE &&
		              (workInProgress =
		                " Did you wrap a component in React.lazy() more than once?");
		            current = getComponentNameFromType(current) || current;
		            throw Error(
		              "Element type is invalid. Received a promise that resolves to: " +
		                current +
		                ". Lazy element type must resolve to a class or function." +
		                workInProgress
		            );
		          }
		          return workInProgress;
		        case 0:
		          return updateFunctionComponent(
		            current,
		            workInProgress,
		            workInProgress.type,
		            workInProgress.pendingProps,
		            renderLanes
		          );
		        case 1:
		          return (
		            (returnFiber = workInProgress.type),
		            (prevSibling = resolveClassComponentProps(
		              returnFiber,
		              workInProgress.pendingProps
		            )),
		            updateClassComponent(
		              current,
		              workInProgress,
		              returnFiber,
		              prevSibling,
		              renderLanes
		            )
		          );
		        case 3:
		          a: {
		            pushHostContainer(
		              workInProgress,
		              workInProgress.stateNode.containerInfo
		            );
		            if (null === current)
		              throw Error(
		                "Should have a current fiber. This is a bug in React."
		              );
		            var nextProps = workInProgress.pendingProps;
		            prevSibling = workInProgress.memoizedState;
		            returnFiber = prevSibling.element;
		            cloneUpdateQueue(current, workInProgress);
		            processUpdateQueue(workInProgress, nextProps, null, renderLanes);
		            var nextState = workInProgress.memoizedState;
		            nextProps = nextState.cache;
		            pushProvider(workInProgress, CacheContext, nextProps);
		            nextProps !== prevSibling.cache &&
		              propagateContextChanges(
		                workInProgress,
		                [CacheContext],
		                renderLanes,
		                true
		              );
		            suspendIfUpdateReadFromEntangledAsyncAction();
		            nextProps = nextState.element;
		            if (supportsHydration && prevSibling.isDehydrated)
		              if (
		                ((prevSibling = {
		                  element: nextProps,
		                  isDehydrated: false,
		                  cache: nextState.cache
		                }),
		                (workInProgress.updateQueue.baseState = prevSibling),
		                (workInProgress.memoizedState = prevSibling),
		                workInProgress.flags & 256)
		              ) {
		                workInProgress = mountHostRootWithoutHydrating(
		                  current,
		                  workInProgress,
		                  nextProps,
		                  renderLanes
		                );
		                break a;
		              } else if (nextProps !== returnFiber) {
		                returnFiber = createCapturedValueAtFiber(
		                  Error(
		                    "This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."
		                  ),
		                  workInProgress
		                );
		                queueHydrationError(returnFiber);
		                workInProgress = mountHostRootWithoutHydrating(
		                  current,
		                  workInProgress,
		                  nextProps,
		                  renderLanes
		                );
		                break a;
		              } else
		                for (
		                  supportsHydration &&
		                    ((nextHydratableInstance =
		                      getFirstHydratableChildWithinContainer(
		                        workInProgress.stateNode.containerInfo
		                      )),
		                    (hydrationParentFiber = workInProgress),
		                    (isHydrating = true),
		                    (hydrationErrors = null),
		                    (didSuspendOrErrorDEV = false),
		                    (hydrationDiffRootDEV = null),
		                    (rootOrSingletonContext = true)),
		                    current = mountChildFibers(
		                      workInProgress,
		                      null,
		                      nextProps,
		                      renderLanes
		                    ),
		                    workInProgress.child = current;
		                  current;

		                )
		                  (current.flags = (current.flags & -3) | 4096),
		                    (current = current.sibling);
		            else {
		              resetHydrationState();
		              if (nextProps === returnFiber) {
		                workInProgress = bailoutOnAlreadyFinishedWork(
		                  current,
		                  workInProgress,
		                  renderLanes
		                );
		                break a;
		              }
		              reconcileChildren(
		                current,
		                workInProgress,
		                nextProps,
		                renderLanes
		              );
		            }
		            workInProgress = workInProgress.child;
		          }
		          return workInProgress;
		        case 26:
		          if (supportsResources)
		            return (
		              markRef(current, workInProgress),
		              null === current
		                ? (current = getResource(
		                    workInProgress.type,
		                    null,
		                    workInProgress.pendingProps,
		                    null
		                  ))
		                  ? (workInProgress.memoizedState = current)
		                  : isHydrating ||
		                    (workInProgress.stateNode = createHoistableInstance(
		                      workInProgress.type,
		                      workInProgress.pendingProps,
		                      requiredContext(rootInstanceStackCursor.current),
		                      workInProgress
		                    ))
		                : (workInProgress.memoizedState = getResource(
		                    workInProgress.type,
		                    current.memoizedProps,
		                    workInProgress.pendingProps,
		                    current.memoizedState
		                  )),
		              null
		            );
		        case 27:
		          if (supportsSingletons)
		            return (
		              pushHostContext(workInProgress),
		              null === current &&
		                supportsSingletons &&
		                isHydrating &&
		                ((prevSibling = requiredContext(
		                  rootInstanceStackCursor.current
		                )),
		                (returnFiber = getHostContext()),
		                (prevSibling = workInProgress.stateNode =
		                  resolveSingletonInstance(
		                    workInProgress.type,
		                    workInProgress.pendingProps,
		                    prevSibling,
		                    returnFiber,
		                    false
		                  )),
		                didSuspendOrErrorDEV ||
		                  ((returnFiber = diffHydratedPropsForDevWarnings(
		                    prevSibling,
		                    workInProgress.type,
		                    workInProgress.pendingProps,
		                    returnFiber
		                  )),
		                  null !== returnFiber &&
		                    (buildHydrationDiffNode(workInProgress, 0).serverProps =
		                      returnFiber)),
		                (hydrationParentFiber = workInProgress),
		                (rootOrSingletonContext = true),
		                (nextHydratableInstance =
		                  getFirstHydratableChild(prevSibling))),
		              (returnFiber = workInProgress.pendingProps.children),
		              null !== current || isHydrating
		                ? reconcileChildren(
		                    current,
		                    workInProgress,
		                    returnFiber,
		                    renderLanes
		                  )
		                : (workInProgress.child = reconcileChildFibers(
		                    workInProgress,
		                    null,
		                    returnFiber,
		                    renderLanes
		                  )),
		              markRef(current, workInProgress),
		              workInProgress.child
		            );
		        case 5:
		          return (
		            null === current &&
		              isHydrating &&
		              ((nextProps = getHostContext()),
		              (returnFiber = validateHydratableInstance(
		                workInProgress.type,
		                workInProgress.pendingProps,
		                nextProps
		              )),
		              (prevSibling = nextHydratableInstance),
		              (nextState = !prevSibling) ||
		                ((nextState = canHydrateInstance(
		                  prevSibling,
		                  workInProgress.type,
		                  workInProgress.pendingProps,
		                  rootOrSingletonContext
		                )),
		                null !== nextState
		                  ? ((workInProgress.stateNode = nextState),
		                    didSuspendOrErrorDEV ||
		                      ((nextProps = diffHydratedPropsForDevWarnings(
		                        nextState,
		                        workInProgress.type,
		                        workInProgress.pendingProps,
		                        nextProps
		                      )),
		                      null !== nextProps &&
		                        (buildHydrationDiffNode(workInProgress, 0).serverProps =
		                          nextProps)),
		                    (hydrationParentFiber = workInProgress),
		                    (nextHydratableInstance =
		                      getFirstHydratableChild(nextState)),
		                    (rootOrSingletonContext = false),
		                    (nextProps = true))
		                  : (nextProps = false),
		                (nextState = !nextProps)),
		              nextState &&
		                (returnFiber &&
		                  warnNonHydratedInstance(workInProgress, prevSibling),
		                throwOnHydrationMismatch(workInProgress))),
		            pushHostContext(workInProgress),
		            (prevSibling = workInProgress.type),
		            (nextProps = workInProgress.pendingProps),
		            (nextState = null !== current ? current.memoizedProps : null),
		            (returnFiber = nextProps.children),
		            shouldSetTextContent(prevSibling, nextProps)
		              ? (returnFiber = null)
		              : null !== nextState &&
		                shouldSetTextContent(prevSibling, nextState) &&
		                (workInProgress.flags |= 32),
		            null !== workInProgress.memoizedState &&
		              ((prevSibling = renderWithHooks(
		                current,
		                workInProgress,
		                TransitionAwareHostComponent,
		                null,
		                null,
		                renderLanes
		              )),
		              isPrimaryRenderer
		                ? (HostTransitionContext._currentValue = prevSibling)
		                : (HostTransitionContext._currentValue2 = prevSibling)),
		            markRef(current, workInProgress),
		            reconcileChildren(
		              current,
		              workInProgress,
		              returnFiber,
		              renderLanes
		            ),
		            workInProgress.child
		          );
		        case 6:
		          return (
		            null === current &&
		              isHydrating &&
		              ((current = workInProgress.pendingProps),
		              (renderLanes = getHostContext()),
		              (current = validateHydratableTextInstance(current, renderLanes)),
		              (renderLanes = nextHydratableInstance),
		              (returnFiber = !renderLanes) ||
		                ((returnFiber = canHydrateTextInstance(
		                  renderLanes,
		                  workInProgress.pendingProps,
		                  rootOrSingletonContext
		                )),
		                null !== returnFiber
		                  ? ((workInProgress.stateNode = returnFiber),
		                    (hydrationParentFiber = workInProgress),
		                    (nextHydratableInstance = null),
		                    (returnFiber = true))
		                  : (returnFiber = false),
		                (returnFiber = !returnFiber)),
		              returnFiber &&
		                (current &&
		                  warnNonHydratedInstance(workInProgress, renderLanes),
		                throwOnHydrationMismatch(workInProgress))),
		            null
		          );
		        case 13:
		          return updateSuspenseComponent(current, workInProgress, renderLanes);
		        case 4:
		          return (
		            pushHostContainer(
		              workInProgress,
		              workInProgress.stateNode.containerInfo
		            ),
		            (returnFiber = workInProgress.pendingProps),
		            null === current
		              ? (workInProgress.child = reconcileChildFibers(
		                  workInProgress,
		                  null,
		                  returnFiber,
		                  renderLanes
		                ))
		              : reconcileChildren(
		                  current,
		                  workInProgress,
		                  returnFiber,
		                  renderLanes
		                ),
		            workInProgress.child
		          );
		        case 11:
		          return updateForwardRef(
		            current,
		            workInProgress,
		            workInProgress.type,
		            workInProgress.pendingProps,
		            renderLanes
		          );
		        case 7:
		          return (
		            reconcileChildren(
		              current,
		              workInProgress,
		              workInProgress.pendingProps,
		              renderLanes
		            ),
		            workInProgress.child
		          );
		        case 8:
		          return (
		            reconcileChildren(
		              current,
		              workInProgress,
		              workInProgress.pendingProps.children,
		              renderLanes
		            ),
		            workInProgress.child
		          );
		        case 12:
		          return (
		            (workInProgress.flags |= 4),
		            (workInProgress.flags |= 2048),
		            (returnFiber = workInProgress.stateNode),
		            (returnFiber.effectDuration = -0),
		            (returnFiber.passiveEffectDuration = -0),
		            reconcileChildren(
		              current,
		              workInProgress,
		              workInProgress.pendingProps.children,
		              renderLanes
		            ),
		            workInProgress.child
		          );
		        case 10:
		          return (
		            (returnFiber = workInProgress.type),
		            (prevSibling = workInProgress.pendingProps),
		            (nextProps = prevSibling.value),
		            "value" in prevSibling ||
		              hasWarnedAboutUsingNoValuePropOnContextProvider ||
		              ((hasWarnedAboutUsingNoValuePropOnContextProvider = true),
		              console.error(
		                "The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
		              )),
		            pushProvider(workInProgress, returnFiber, nextProps),
		            reconcileChildren(
		              current,
		              workInProgress,
		              prevSibling.children,
		              renderLanes
		            ),
		            workInProgress.child
		          );
		        case 9:
		          return (
		            (prevSibling = workInProgress.type._context),
		            (returnFiber = workInProgress.pendingProps.children),
		            "function" !== typeof returnFiber &&
		              console.error(
		                "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
		              ),
		            prepareToReadContext(workInProgress),
		            (prevSibling = readContext(prevSibling)),
		            markComponentRenderStarted(workInProgress),
		            (returnFiber = callComponentInDEV(
		              returnFiber,
		              prevSibling,
		              void 0
		            )),
		            markComponentRenderStopped(),
		            (workInProgress.flags |= 1),
		            reconcileChildren(
		              current,
		              workInProgress,
		              returnFiber,
		              renderLanes
		            ),
		            workInProgress.child
		          );
		        case 14:
		          return updateMemoComponent(
		            current,
		            workInProgress,
		            workInProgress.type,
		            workInProgress.pendingProps,
		            renderLanes
		          );
		        case 15:
		          return updateSimpleMemoComponent(
		            current,
		            workInProgress,
		            workInProgress.type,
		            workInProgress.pendingProps,
		            renderLanes
		          );
		        case 19:
		          return updateSuspenseListComponent(
		            current,
		            workInProgress,
		            renderLanes
		          );
		        case 22:
		          return updateOffscreenComponent(current, workInProgress, renderLanes);
		        case 24:
		          return (
		            prepareToReadContext(workInProgress),
		            (returnFiber = readContext(CacheContext)),
		            null === current
		              ? ((prevSibling = peekCacheFromPool()),
		                null === prevSibling &&
		                  ((prevSibling = workInProgressRoot),
		                  (nextProps = createCache()),
		                  (prevSibling.pooledCache = nextProps),
		                  retainCache(nextProps),
		                  null !== nextProps &&
		                    (prevSibling.pooledCacheLanes |= renderLanes),
		                  (prevSibling = nextProps)),
		                (workInProgress.memoizedState = {
		                  parent: returnFiber,
		                  cache: prevSibling
		                }),
		                initializeUpdateQueue(workInProgress),
		                pushProvider(workInProgress, CacheContext, prevSibling))
		              : (0 !== (current.lanes & renderLanes) &&
		                  (cloneUpdateQueue(current, workInProgress),
		                  processUpdateQueue(workInProgress, null, null, renderLanes),
		                  suspendIfUpdateReadFromEntangledAsyncAction()),
		                (prevSibling = current.memoizedState),
		                (nextProps = workInProgress.memoizedState),
		                prevSibling.parent !== returnFiber
		                  ? ((prevSibling = {
		                      parent: returnFiber,
		                      cache: returnFiber
		                    }),
		                    (workInProgress.memoizedState = prevSibling),
		                    0 === workInProgress.lanes &&
		                      (workInProgress.memoizedState =
		                        workInProgress.updateQueue.baseState =
		                          prevSibling),
		                    pushProvider(workInProgress, CacheContext, returnFiber))
		                  : ((returnFiber = nextProps.cache),
		                    pushProvider(workInProgress, CacheContext, returnFiber),
		                    returnFiber !== prevSibling.cache &&
		                      propagateContextChanges(
		                        workInProgress,
		                        [CacheContext],
		                        renderLanes,
		                        true
		                      ))),
		            reconcileChildren(
		              current,
		              workInProgress,
		              workInProgress.pendingProps.children,
		              renderLanes
		            ),
		            workInProgress.child
		          );
		        case 29:
		          throw workInProgress.pendingProps;
		      }
		      throw Error(
		        "Unknown unit of work tag (" +
		          workInProgress.tag +
		          "). This error is likely caused by a bug in React. Please file an issue."
		      );
		    }
		    function resetContextDependencies() {
		      lastContextDependency = currentlyRenderingFiber = null;
		      isDisallowedContextReadInDEV = false;
		    }
		    function pushProvider(providerFiber, context, nextValue) {
		      isPrimaryRenderer
		        ? (push(valueCursor, context._currentValue, providerFiber),
		          (context._currentValue = nextValue),
		          push(rendererCursorDEV, context._currentRenderer, providerFiber),
		          void 0 !== context._currentRenderer &&
		            null !== context._currentRenderer &&
		            context._currentRenderer !== rendererSigil &&
		            console.error(
		              "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
		            ),
		          (context._currentRenderer = rendererSigil))
		        : (push(valueCursor, context._currentValue2, providerFiber),
		          (context._currentValue2 = nextValue),
		          push(renderer2CursorDEV, context._currentRenderer2, providerFiber),
		          void 0 !== context._currentRenderer2 &&
		            null !== context._currentRenderer2 &&
		            context._currentRenderer2 !== rendererSigil &&
		            console.error(
		              "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
		            ),
		          (context._currentRenderer2 = rendererSigil));
		    }
		    function popProvider(context, providerFiber) {
		      var currentValue = valueCursor.current;
		      isPrimaryRenderer
		        ? ((context._currentValue = currentValue),
		          (currentValue = rendererCursorDEV.current),
		          pop(rendererCursorDEV, providerFiber),
		          (context._currentRenderer = currentValue))
		        : ((context._currentValue2 = currentValue),
		          (currentValue = renderer2CursorDEV.current),
		          pop(renderer2CursorDEV, providerFiber),
		          (context._currentRenderer2 = currentValue));
		      pop(valueCursor, providerFiber);
		    }
		    function scheduleContextWorkOnParentPath(
		      parent,
		      renderLanes,
		      propagationRoot
		    ) {
		      for (; null !== parent; ) {
		        var alternate = parent.alternate;
		        (parent.childLanes & renderLanes) !== renderLanes
		          ? ((parent.childLanes |= renderLanes),
		            null !== alternate && (alternate.childLanes |= renderLanes))
		          : null !== alternate &&
		            (alternate.childLanes & renderLanes) !== renderLanes &&
		            (alternate.childLanes |= renderLanes);
		        if (parent === propagationRoot) break;
		        parent = parent.return;
		      }
		      parent !== propagationRoot &&
		        console.error(
		          "Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue."
		        );
		    }
		    function propagateContextChanges(
		      workInProgress,
		      contexts,
		      renderLanes,
		      forcePropagateEntireTree
		    ) {
		      var fiber = workInProgress.child;
		      null !== fiber && (fiber.return = workInProgress);
		      for (; null !== fiber; ) {
		        var list = fiber.dependencies;
		        if (null !== list) {
		          var nextFiber = fiber.child;
		          list = list.firstContext;
		          a: for (; null !== list; ) {
		            var dependency = list;
		            list = fiber;
		            for (var i = 0; i < contexts.length; i++)
		              if (dependency.context === contexts[i]) {
		                list.lanes |= renderLanes;
		                dependency = list.alternate;
		                null !== dependency && (dependency.lanes |= renderLanes);
		                scheduleContextWorkOnParentPath(
		                  list.return,
		                  renderLanes,
		                  workInProgress
		                );
		                forcePropagateEntireTree || (nextFiber = null);
		                break a;
		              }
		            list = dependency.next;
		          }
		        } else if (18 === fiber.tag) {
		          nextFiber = fiber.return;
		          if (null === nextFiber)
		            throw Error(
		              "We just came from a parent so we must have had a parent. This is a bug in React."
		            );
		          nextFiber.lanes |= renderLanes;
		          list = nextFiber.alternate;
		          null !== list && (list.lanes |= renderLanes);
		          scheduleContextWorkOnParentPath(
		            nextFiber,
		            renderLanes,
		            workInProgress
		          );
		          nextFiber = null;
		        } else nextFiber = fiber.child;
		        if (null !== nextFiber) nextFiber.return = fiber;
		        else
		          for (nextFiber = fiber; null !== nextFiber; ) {
		            if (nextFiber === workInProgress) {
		              nextFiber = null;
		              break;
		            }
		            fiber = nextFiber.sibling;
		            if (null !== fiber) {
		              fiber.return = nextFiber.return;
		              nextFiber = fiber;
		              break;
		            }
		            nextFiber = nextFiber.return;
		          }
		        fiber = nextFiber;
		      }
		    }
		    function propagateParentContextChanges(
		      current,
		      workInProgress,
		      renderLanes,
		      forcePropagateEntireTree
		    ) {
		      current = null;
		      for (
		        var parent = workInProgress, isInsidePropagationBailout = false;
		        null !== parent;

		      ) {
		        if (!isInsidePropagationBailout)
		          if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
		          else if (0 !== (parent.flags & 262144)) break;
		        if (10 === parent.tag) {
		          var currentParent = parent.alternate;
		          if (null === currentParent)
		            throw Error("Should have a current fiber. This is a bug in React.");
		          currentParent = currentParent.memoizedProps;
		          if (null !== currentParent) {
		            var context = parent.type;
		            objectIs(parent.pendingProps.value, currentParent.value) ||
		              (null !== current
		                ? current.push(context)
		                : (current = [context]));
		          }
		        } else if (parent === hostTransitionProviderCursor.current) {
		          currentParent = parent.alternate;
		          if (null === currentParent)
		            throw Error("Should have a current fiber. This is a bug in React.");
		          currentParent.memoizedState.memoizedState !==
		            parent.memoizedState.memoizedState &&
		            (null !== current
		              ? current.push(HostTransitionContext)
		              : (current = [HostTransitionContext]));
		        }
		        parent = parent.return;
		      }
		      null !== current &&
		        propagateContextChanges(
		          workInProgress,
		          current,
		          renderLanes,
		          forcePropagateEntireTree
		        );
		      workInProgress.flags |= 262144;
		    }
		    function checkIfContextChanged(currentDependencies) {
		      for (
		        currentDependencies = currentDependencies.firstContext;
		        null !== currentDependencies;

		      ) {
		        var context = currentDependencies.context;
		        if (
		          !objectIs(
		            isPrimaryRenderer ? context._currentValue : context._currentValue2,
		            currentDependencies.memoizedValue
		          )
		        )
		          return true;
		        currentDependencies = currentDependencies.next;
		      }
		      return false;
		    }
		    function prepareToReadContext(workInProgress) {
		      currentlyRenderingFiber = workInProgress;
		      lastContextDependency = null;
		      workInProgress = workInProgress.dependencies;
		      null !== workInProgress && (workInProgress.firstContext = null);
		    }
		    function readContext(context) {
		      isDisallowedContextReadInDEV &&
		        console.error(
		          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
		        );
		      return readContextForConsumer(currentlyRenderingFiber, context);
		    }
		    function readContextDuringReconciliation(consumer, context) {
		      null === currentlyRenderingFiber && prepareToReadContext(consumer);
		      return readContextForConsumer(consumer, context);
		    }
		    function readContextForConsumer(consumer, context) {
		      var value = isPrimaryRenderer
		        ? context._currentValue
		        : context._currentValue2;
		      context = { context: context, memoizedValue: value, next: null };
		      if (null === lastContextDependency) {
		        if (null === consumer)
		          throw Error(
		            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
		          );
		        lastContextDependency = context;
		        consumer.dependencies = {
		          lanes: 0,
		          firstContext: context,
		          _debugThenableState: null
		        };
		        consumer.flags |= 524288;
		      } else lastContextDependency = lastContextDependency.next = context;
		      return value;
		    }
		    function createCache() {
		      return {
		        controller: new AbortControllerLocal(),
		        data: new Map(),
		        refCount: 0
		      };
		    }
		    function retainCache(cache) {
		      cache.controller.signal.aborted &&
		        console.warn(
		          "A cache instance was retained after it was already freed. This likely indicates a bug in React."
		        );
		      cache.refCount++;
		    }
		    function releaseCache(cache) {
		      cache.refCount--;
		      0 > cache.refCount &&
		        console.warn(
		          "A cache instance was released after it was already freed. This likely indicates a bug in React."
		        );
		      0 === cache.refCount &&
		        scheduleCallback$1(NormalPriority, function () {
		          cache.controller.abort();
		        });
		    }
		    function peekCacheFromPool() {
		      var cacheResumedFromPreviousRender = resumedCache.current;
		      return null !== cacheResumedFromPreviousRender
		        ? cacheResumedFromPreviousRender
		        : workInProgressRoot.pooledCache;
		    }
		    function pushTransition(offscreenWorkInProgress, prevCachePool) {
		      null === prevCachePool
		        ? push(resumedCache, resumedCache.current, offscreenWorkInProgress)
		        : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);
		    }
		    function getSuspendedCache() {
		      var cacheFromPool = peekCacheFromPool();
		      return null === cacheFromPool
		        ? null
		        : {
		            parent: isPrimaryRenderer
		              ? CacheContext._currentValue
		              : CacheContext._currentValue2,
		            pool: cacheFromPool
		          };
		    }
		    function markUpdate(workInProgress) {
		      workInProgress.flags |= 4;
		    }
		    function doesRequireClone(current, completedWork) {
		      if (null !== current && current.child === completedWork.child) return false;
		      if (0 !== (completedWork.flags & 16)) return true;
		      for (current = completedWork.child; null !== current; ) {
		        if (
		          0 !== (current.flags & 13878) ||
		          0 !== (current.subtreeFlags & 13878)
		        )
		          return true;
		        current = current.sibling;
		      }
		      return false;
		    }
		    function appendAllChildren(
		      parent,
		      workInProgress,
		      needsVisibilityToggle,
		      isHidden
		    ) {
		      if (supportsMutation)
		        for (
		          needsVisibilityToggle = workInProgress.child;
		          null !== needsVisibilityToggle;

		        ) {
		          if (
		            5 === needsVisibilityToggle.tag ||
		            6 === needsVisibilityToggle.tag
		          )
		            appendInitialChild(parent, needsVisibilityToggle.stateNode);
		          else if (
		            !(
		              4 === needsVisibilityToggle.tag ||
		              (supportsSingletons && 27 === needsVisibilityToggle.tag)
		            ) &&
		            null !== needsVisibilityToggle.child
		          ) {
		            needsVisibilityToggle.child.return = needsVisibilityToggle;
		            needsVisibilityToggle = needsVisibilityToggle.child;
		            continue;
		          }
		          if (needsVisibilityToggle === workInProgress) break;
		          for (; null === needsVisibilityToggle.sibling; ) {
		            if (
		              null === needsVisibilityToggle.return ||
		              needsVisibilityToggle.return === workInProgress
		            )
		              return;
		            needsVisibilityToggle = needsVisibilityToggle.return;
		          }
		          needsVisibilityToggle.sibling.return = needsVisibilityToggle.return;
		          needsVisibilityToggle = needsVisibilityToggle.sibling;
		        }
		      else if (supportsPersistence)
		        for (var _node = workInProgress.child; null !== _node; ) {
		          if (5 === _node.tag) {
		            var instance = _node.stateNode;
		            needsVisibilityToggle &&
		              isHidden &&
		              (instance = cloneHiddenInstance(
		                instance,
		                _node.type,
		                _node.memoizedProps
		              ));
		            appendInitialChild(parent, instance);
		          } else if (6 === _node.tag)
		            (instance = _node.stateNode),
		              needsVisibilityToggle &&
		                isHidden &&
		                (instance = cloneHiddenTextInstance(
		                  instance,
		                  _node.memoizedProps
		                )),
		              appendInitialChild(parent, instance);
		          else if (4 !== _node.tag)
		            if (22 === _node.tag && null !== _node.memoizedState)
		              (instance = _node.child),
		                null !== instance && (instance.return = _node),
		                appendAllChildren(parent, _node, true, true);
		            else if (null !== _node.child) {
		              _node.child.return = _node;
		              _node = _node.child;
		              continue;
		            }
		          if (_node === workInProgress) break;
		          for (; null === _node.sibling; ) {
		            if (null === _node.return || _node.return === workInProgress)
		              return;
		            _node = _node.return;
		          }
		          _node.sibling.return = _node.return;
		          _node = _node.sibling;
		        }
		    }
		    function appendAllChildrenToContainer(
		      containerChildSet,
		      workInProgress,
		      needsVisibilityToggle,
		      isHidden
		    ) {
		      if (supportsPersistence)
		        for (var node = workInProgress.child; null !== node; ) {
		          if (5 === node.tag) {
		            var instance = node.stateNode;
		            needsVisibilityToggle &&
		              isHidden &&
		              (instance = cloneHiddenInstance(
		                instance,
		                node.type,
		                node.memoizedProps
		              ));
		            appendChildToContainerChildSet(containerChildSet, instance);
		          } else if (6 === node.tag)
		            (instance = node.stateNode),
		              needsVisibilityToggle &&
		                isHidden &&
		                (instance = cloneHiddenTextInstance(
		                  instance,
		                  node.memoizedProps
		                )),
		              appendChildToContainerChildSet(containerChildSet, instance);
		          else if (4 !== node.tag)
		            if (22 === node.tag && null !== node.memoizedState)
		              (instance = node.child),
		                null !== instance && (instance.return = node),
		                appendAllChildrenToContainer(
		                  containerChildSet,
		                  node,
		                  !(
		                    null !== node.memoizedProps &&
		                    "manual" === node.memoizedProps.mode
		                  ),
		                  true
		                );
		            else if (null !== node.child) {
		              node.child.return = node;
		              node = node.child;
		              continue;
		            }
		          if (node === workInProgress) break;
		          for (; null === node.sibling; ) {
		            if (null === node.return || node.return === workInProgress) return;
		            node = node.return;
		          }
		          node.sibling.return = node.return;
		          node = node.sibling;
		        }
		    }
		    function updateHostContainer(current, workInProgress) {
		      if (supportsPersistence && doesRequireClone(current, workInProgress)) {
		        current = workInProgress.stateNode;
		        var container = current.containerInfo,
		          newChildSet = createContainerChildSet();
		        appendAllChildrenToContainer(newChildSet, workInProgress, false, false);
		        current.pendingChildren = newChildSet;
		        markUpdate(workInProgress);
		        finalizeContainerChildren(container, newChildSet);
		      }
		    }
		    function updateHostComponent(current, workInProgress, type, newProps) {
		      if (supportsMutation)
		        current.memoizedProps !== newProps && markUpdate(workInProgress);
		      else if (supportsPersistence) {
		        var currentInstance = current.stateNode,
		          _oldProps = current.memoizedProps;
		        if (
		          (current = doesRequireClone(current, workInProgress)) ||
		          _oldProps !== newProps
		        ) {
		          var currentHostContext = getHostContext();
		          _oldProps = cloneInstance(
		            currentInstance,
		            type,
		            _oldProps,
		            newProps,
		            !current,
		            null
		          );
		          _oldProps === currentInstance
		            ? (workInProgress.stateNode = currentInstance)
		            : (finalizeInitialChildren(
		                _oldProps,
		                type,
		                newProps,
		                currentHostContext
		              ) && markUpdate(workInProgress),
		              (workInProgress.stateNode = _oldProps),
		              current
		                ? appendAllChildren(_oldProps, workInProgress, false, false)
		                : markUpdate(workInProgress));
		        } else workInProgress.stateNode = currentInstance;
		      }
		    }
		    function preloadInstanceAndSuspendIfNeeded(workInProgress, type, props) {
		      if (maySuspendCommit(type, props)) {
		        if (((workInProgress.flags |= 16777216), !preloadInstance(type, props)))
		          if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;
		          else
		            throw (
		              ((suspendedThenable = noopSuspenseyCommitThenable),
		              SuspenseyCommitException)
		            );
		      } else workInProgress.flags &= -16777217;
		    }
		    function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {
		      if (mayResourceSuspendCommit(resource)) {
		        if (((workInProgress.flags |= 16777216), !preloadResource(resource)))
		          if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;
		          else
		            throw (
		              ((suspendedThenable = noopSuspenseyCommitThenable),
		              SuspenseyCommitException)
		            );
		      } else workInProgress.flags &= -16777217;
		    }
		    function scheduleRetryEffect(workInProgress, retryQueue) {
		      null !== retryQueue && (workInProgress.flags |= 4);
		      workInProgress.flags & 16384 &&
		        ((retryQueue =
		          22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),
		        (workInProgress.lanes |= retryQueue),
		        (workInProgressSuspendedRetryLanes |= retryQueue));
		    }
		    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
		      if (!isHydrating)
		        switch (renderState.tailMode) {
		          case "hidden":
		            hasRenderedATailFallback = renderState.tail;
		            for (var lastTailNode = null; null !== hasRenderedATailFallback; )
		              null !== hasRenderedATailFallback.alternate &&
		                (lastTailNode = hasRenderedATailFallback),
		                (hasRenderedATailFallback = hasRenderedATailFallback.sibling);
		            null === lastTailNode
		              ? (renderState.tail = null)
		              : (lastTailNode.sibling = null);
		            break;
		          case "collapsed":
		            lastTailNode = renderState.tail;
		            for (var _lastTailNode = null; null !== lastTailNode; )
		              null !== lastTailNode.alternate && (_lastTailNode = lastTailNode),
		                (lastTailNode = lastTailNode.sibling);
		            null === _lastTailNode
		              ? hasRenderedATailFallback || null === renderState.tail
		                ? (renderState.tail = null)
		                : (renderState.tail.sibling = null)
		              : (_lastTailNode.sibling = null);
		        }
		    }
		    function bubbleProperties(completedWork) {
		      var didBailout =
		          null !== completedWork.alternate &&
		          completedWork.alternate.child === completedWork.child,
		        newChildLanes = 0,
		        subtreeFlags = 0;
		      if (didBailout)
		        if ((completedWork.mode & 2) !== NoMode) {
		          for (
		            var _treeBaseDuration = completedWork.selfBaseDuration,
		              _child2 = completedWork.child;
		            null !== _child2;

		          )
		            (newChildLanes |= _child2.lanes | _child2.childLanes),
		              (subtreeFlags |= _child2.subtreeFlags & 31457280),
		              (subtreeFlags |= _child2.flags & 31457280),
		              (_treeBaseDuration += _child2.treeBaseDuration),
		              (_child2 = _child2.sibling);
		          completedWork.treeBaseDuration = _treeBaseDuration;
		        } else
		          for (
		            _treeBaseDuration = completedWork.child;
		            null !== _treeBaseDuration;

		          )
		            (newChildLanes |=
		              _treeBaseDuration.lanes | _treeBaseDuration.childLanes),
		              (subtreeFlags |= _treeBaseDuration.subtreeFlags & 31457280),
		              (subtreeFlags |= _treeBaseDuration.flags & 31457280),
		              (_treeBaseDuration.return = completedWork),
		              (_treeBaseDuration = _treeBaseDuration.sibling);
		      else if ((completedWork.mode & 2) !== NoMode) {
		        _treeBaseDuration = completedWork.actualDuration;
		        _child2 = completedWork.selfBaseDuration;
		        for (var child = completedWork.child; null !== child; )
		          (newChildLanes |= child.lanes | child.childLanes),
		            (subtreeFlags |= child.subtreeFlags),
		            (subtreeFlags |= child.flags),
		            (_treeBaseDuration += child.actualDuration),
		            (_child2 += child.treeBaseDuration),
		            (child = child.sibling);
		        completedWork.actualDuration = _treeBaseDuration;
		        completedWork.treeBaseDuration = _child2;
		      } else
		        for (
		          _treeBaseDuration = completedWork.child;
		          null !== _treeBaseDuration;

		        )
		          (newChildLanes |=
		            _treeBaseDuration.lanes | _treeBaseDuration.childLanes),
		            (subtreeFlags |= _treeBaseDuration.subtreeFlags),
		            (subtreeFlags |= _treeBaseDuration.flags),
		            (_treeBaseDuration.return = completedWork),
		            (_treeBaseDuration = _treeBaseDuration.sibling);
		      completedWork.subtreeFlags |= subtreeFlags;
		      completedWork.childLanes = newChildLanes;
		      return didBailout;
		    }
		    function completeWork(current, workInProgress, renderLanes) {
		      var newProps = workInProgress.pendingProps;
		      popTreeContext(workInProgress);
		      switch (workInProgress.tag) {
		        case 16:
		        case 15:
		        case 0:
		        case 11:
		        case 7:
		        case 8:
		        case 12:
		        case 9:
		        case 14:
		          return bubbleProperties(workInProgress), null;
		        case 1:
		          return bubbleProperties(workInProgress), null;
		        case 3:
		          renderLanes = workInProgress.stateNode;
		          newProps = null;
		          null !== current && (newProps = current.memoizedState.cache);
		          workInProgress.memoizedState.cache !== newProps &&
		            (workInProgress.flags |= 2048);
		          popProvider(CacheContext, workInProgress);
		          popHostContainer(workInProgress);
		          renderLanes.pendingContext &&
		            ((renderLanes.context = renderLanes.pendingContext),
		            (renderLanes.pendingContext = null));
		          if (null === current || null === current.child)
		            popHydrationState(workInProgress)
		              ? (emitPendingHydrationWarnings(), markUpdate(workInProgress))
		              : null === current ||
		                (current.memoizedState.isDehydrated &&
		                  0 === (workInProgress.flags & 256)) ||
		                ((workInProgress.flags |= 1024),
		                null !== hydrationErrors &&
		                  (queueRecoverableErrors(hydrationErrors),
		                  (hydrationErrors = null)));
		          updateHostContainer(current, workInProgress);
		          bubbleProperties(workInProgress);
		          return null;
		        case 26:
		          if (supportsResources) {
		            renderLanes = workInProgress.type;
		            var nextResource = workInProgress.memoizedState;
		            null === current
		              ? (markUpdate(workInProgress),
		                null !== nextResource
		                  ? (bubbleProperties(workInProgress),
		                    preloadResourceAndSuspendIfNeeded(
		                      workInProgress,
		                      nextResource
		                    ))
		                  : (bubbleProperties(workInProgress),
		                    preloadInstanceAndSuspendIfNeeded(
		                      workInProgress,
		                      renderLanes,
		                      newProps
		                    )))
		              : nextResource
		                ? nextResource !== current.memoizedState
		                  ? (markUpdate(workInProgress),
		                    bubbleProperties(workInProgress),
		                    preloadResourceAndSuspendIfNeeded(
		                      workInProgress,
		                      nextResource
		                    ))
		                  : (bubbleProperties(workInProgress),
		                    (workInProgress.flags &= -16777217))
		                : (supportsMutation
		                    ? current.memoizedProps !== newProps &&
		                      markUpdate(workInProgress)
		                    : updateHostComponent(
		                        current,
		                        workInProgress,
		                        renderLanes,
		                        newProps
		                      ),
		                  bubbleProperties(workInProgress),
		                  preloadInstanceAndSuspendIfNeeded(
		                    workInProgress,
		                    renderLanes,
		                    newProps
		                  ));
		            return null;
		          }
		        case 27:
		          if (supportsSingletons) {
		            popHostContext(workInProgress);
		            renderLanes = requiredContext(rootInstanceStackCursor.current);
		            nextResource = workInProgress.type;
		            if (null !== current && null != workInProgress.stateNode)
		              supportsMutation
		                ? current.memoizedProps !== newProps &&
		                  markUpdate(workInProgress)
		                : updateHostComponent(
		                    current,
		                    workInProgress,
		                    nextResource,
		                    newProps
		                  );
		            else {
		              if (!newProps) {
		                if (null === workInProgress.stateNode)
		                  throw Error(
		                    "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
		                  );
		                bubbleProperties(workInProgress);
		                return null;
		              }
		              current = getHostContext();
		              popHydrationState(workInProgress)
		                ? prepareToHydrateHostInstance(workInProgress, current)
		                : ((current = resolveSingletonInstance(
		                    nextResource,
		                    newProps,
		                    renderLanes,
		                    current,
		                    true
		                  )),
		                  (workInProgress.stateNode = current),
		                  markUpdate(workInProgress));
		            }
		            bubbleProperties(workInProgress);
		            return null;
		          }
		        case 5:
		          popHostContext(workInProgress);
		          renderLanes = workInProgress.type;
		          if (null !== current && null != workInProgress.stateNode)
		            updateHostComponent(current, workInProgress, renderLanes, newProps);
		          else {
		            if (!newProps) {
		              if (null === workInProgress.stateNode)
		                throw Error(
		                  "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
		                );
		              bubbleProperties(workInProgress);
		              return null;
		            }
		            current = getHostContext();
		            popHydrationState(workInProgress)
		              ? prepareToHydrateHostInstance(workInProgress, current)
		              : ((nextResource = requiredContext(
		                  rootInstanceStackCursor.current
		                )),
		                (nextResource = createInstance(
		                  renderLanes,
		                  newProps,
		                  nextResource,
		                  current,
		                  workInProgress
		                )),
		                appendAllChildren(nextResource, workInProgress, false, false),
		                (workInProgress.stateNode = nextResource),
		                finalizeInitialChildren(
		                  nextResource,
		                  renderLanes,
		                  newProps,
		                  current
		                ) && markUpdate(workInProgress));
		          }
		          bubbleProperties(workInProgress);
		          preloadInstanceAndSuspendIfNeeded(
		            workInProgress,
		            workInProgress.type,
		            workInProgress.pendingProps
		          );
		          return null;
		        case 6:
		          if (current && null != workInProgress.stateNode)
		            (renderLanes = current.memoizedProps),
		              supportsMutation
		                ? renderLanes !== newProps && markUpdate(workInProgress)
		                : supportsPersistence &&
		                  (renderLanes !== newProps
		                    ? ((current = requiredContext(
		                        rootInstanceStackCursor.current
		                      )),
		                      (renderLanes = getHostContext()),
		                      (workInProgress.stateNode = createTextInstance(
		                        newProps,
		                        current,
		                        renderLanes,
		                        workInProgress
		                      )),
		                      markUpdate(workInProgress))
		                    : (workInProgress.stateNode = current.stateNode));
		          else {
		            if (
		              "string" !== typeof newProps &&
		              null === workInProgress.stateNode
		            )
		              throw Error(
		                "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
		              );
		            current = requiredContext(rootInstanceStackCursor.current);
		            renderLanes = getHostContext();
		            if (popHydrationState(workInProgress)) {
		              if (!supportsHydration)
		                throw Error(
		                  "Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
		                );
		              current = workInProgress.stateNode;
		              renderLanes = workInProgress.memoizedProps;
		              nextResource = !didSuspendOrErrorDEV;
		              newProps = null;
		              var returnFiber = hydrationParentFiber;
		              if (null !== returnFiber)
		                switch (returnFiber.tag) {
		                  case 3:
		                    nextResource &&
		                      ((nextResource = diffHydratedTextForDevWarnings(
		                        current,
		                        renderLanes,
		                        newProps
		                      )),
		                      null !== nextResource &&
		                        (buildHydrationDiffNode(workInProgress, 0).serverProps =
		                          nextResource));
		                    break;
		                  case 27:
		                  case 5:
		                    (newProps = returnFiber.memoizedProps),
		                      nextResource &&
		                        ((nextResource = diffHydratedTextForDevWarnings(
		                          current,
		                          renderLanes,
		                          newProps
		                        )),
		                        null !== nextResource &&
		                          (buildHydrationDiffNode(
		                            workInProgress,
		                            0
		                          ).serverProps = nextResource));
		                }
		              hydrateTextInstance(
		                current,
		                renderLanes,
		                workInProgress,
		                newProps
		              ) || throwOnHydrationMismatch(workInProgress);
		            } else
		              workInProgress.stateNode = createTextInstance(
		                newProps,
		                current,
		                renderLanes,
		                workInProgress
		              );
		          }
		          bubbleProperties(workInProgress);
		          return null;
		        case 13:
		          newProps = workInProgress.memoizedState;
		          if (
		            null === current ||
		            (null !== current.memoizedState &&
		              null !== current.memoizedState.dehydrated)
		          ) {
		            nextResource = popHydrationState(workInProgress);
		            if (null !== newProps && null !== newProps.dehydrated) {
		              if (null === current) {
		                if (!nextResource)
		                  throw Error(
		                    "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
		                  );
		                if (!supportsHydration)
		                  throw Error(
		                    "Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
		                  );
		                nextResource = workInProgress.memoizedState;
		                nextResource =
		                  null !== nextResource ? nextResource.dehydrated : null;
		                if (!nextResource)
		                  throw Error(
		                    "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
		                  );
		                hydrateSuspenseInstance(nextResource, workInProgress);
		                bubbleProperties(workInProgress);
		                (workInProgress.mode & 2) !== NoMode &&
		                  null !== newProps &&
		                  ((nextResource = workInProgress.child),
		                  null !== nextResource &&
		                    (workInProgress.treeBaseDuration -=
		                      nextResource.treeBaseDuration));
		              } else
		                emitPendingHydrationWarnings(),
		                  resetHydrationState(),
		                  0 === (workInProgress.flags & 128) &&
		                    (workInProgress.memoizedState = null),
		                  (workInProgress.flags |= 4),
		                  bubbleProperties(workInProgress),
		                  (workInProgress.mode & 2) !== NoMode &&
		                    null !== newProps &&
		                    ((nextResource = workInProgress.child),
		                    null !== nextResource &&
		                      (workInProgress.treeBaseDuration -=
		                        nextResource.treeBaseDuration));
		              nextResource = false;
		            } else
		              null !== hydrationErrors &&
		                (queueRecoverableErrors(hydrationErrors),
		                (hydrationErrors = null)),
		                (nextResource = true);
		            if (!nextResource) {
		              if (workInProgress.flags & 256)
		                return popSuspenseHandler(workInProgress), workInProgress;
		              popSuspenseHandler(workInProgress);
		              return null;
		            }
		          }
		          popSuspenseHandler(workInProgress);
		          if (0 !== (workInProgress.flags & 128))
		            return (
		              (workInProgress.lanes = renderLanes),
		              (workInProgress.mode & 2) !== NoMode &&
		                transferActualDuration(workInProgress),
		              workInProgress
		            );
		          renderLanes = null !== newProps;
		          current = null !== current && null !== current.memoizedState;
		          renderLanes &&
		            ((newProps = workInProgress.child),
		            (nextResource = null),
		            null !== newProps.alternate &&
		              null !== newProps.alternate.memoizedState &&
		              null !== newProps.alternate.memoizedState.cachePool &&
		              (nextResource = newProps.alternate.memoizedState.cachePool.pool),
		            (returnFiber = null),
		            null !== newProps.memoizedState &&
		              null !== newProps.memoizedState.cachePool &&
		              (returnFiber = newProps.memoizedState.cachePool.pool),
		            returnFiber !== nextResource && (newProps.flags |= 2048));
		          renderLanes !== current &&
		            renderLanes &&
		            (workInProgress.child.flags |= 8192);
		          scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
		          bubbleProperties(workInProgress);
		          (workInProgress.mode & 2) !== NoMode &&
		            renderLanes &&
		            ((current = workInProgress.child),
		            null !== current &&
		              (workInProgress.treeBaseDuration -= current.treeBaseDuration));
		          return null;
		        case 4:
		          return (
		            popHostContainer(workInProgress),
		            updateHostContainer(current, workInProgress),
		            null === current &&
		              preparePortalMount(workInProgress.stateNode.containerInfo),
		            bubbleProperties(workInProgress),
		            null
		          );
		        case 10:
		          return (
		            popProvider(workInProgress.type, workInProgress),
		            bubbleProperties(workInProgress),
		            null
		          );
		        case 19:
		          pop(suspenseStackCursor, workInProgress);
		          nextResource = workInProgress.memoizedState;
		          if (null === nextResource)
		            return bubbleProperties(workInProgress), null;
		          newProps = 0 !== (workInProgress.flags & 128);
		          returnFiber = nextResource.rendering;
		          if (null === returnFiber)
		            if (newProps) cutOffTailIfNeeded(nextResource, false);
		            else {
		              if (
		                workInProgressRootExitStatus !== RootInProgress ||
		                (null !== current && 0 !== (current.flags & 128))
		              )
		                for (current = workInProgress.child; null !== current; ) {
		                  returnFiber = findFirstSuspended(current);
		                  if (null !== returnFiber) {
		                    workInProgress.flags |= 128;
		                    cutOffTailIfNeeded(nextResource, false);
		                    current = returnFiber.updateQueue;
		                    workInProgress.updateQueue = current;
		                    scheduleRetryEffect(workInProgress, current);
		                    workInProgress.subtreeFlags = 0;
		                    current = renderLanes;
		                    for (
		                      renderLanes = workInProgress.child;
		                      null !== renderLanes;

		                    )
		                      resetWorkInProgress(renderLanes, current),
		                        (renderLanes = renderLanes.sibling);
		                    push(
		                      suspenseStackCursor,
		                      (suspenseStackCursor.current &
		                        SubtreeSuspenseContextMask) |
		                        ForceSuspenseFallback,
		                      workInProgress
		                    );
		                    return workInProgress.child;
		                  }
		                  current = current.sibling;
		                }
		              null !== nextResource.tail &&
		                now$1() > workInProgressRootRenderTargetTime &&
		                ((workInProgress.flags |= 128),
		                (newProps = true),
		                cutOffTailIfNeeded(nextResource, false),
		                (workInProgress.lanes = 4194304));
		            }
		          else {
		            if (!newProps)
		              if (
		                ((current = findFirstSuspended(returnFiber)), null !== current)
		              ) {
		                if (
		                  ((workInProgress.flags |= 128),
		                  (newProps = true),
		                  (current = current.updateQueue),
		                  (workInProgress.updateQueue = current),
		                  scheduleRetryEffect(workInProgress, current),
		                  cutOffTailIfNeeded(nextResource, true),
		                  null === nextResource.tail &&
		                    "hidden" === nextResource.tailMode &&
		                    !returnFiber.alternate &&
		                    !isHydrating)
		                )
		                  return bubbleProperties(workInProgress), null;
		              } else
		                2 * now$1() - nextResource.renderingStartTime >
		                  workInProgressRootRenderTargetTime &&
		                  536870912 !== renderLanes &&
		                  ((workInProgress.flags |= 128),
		                  (newProps = true),
		                  cutOffTailIfNeeded(nextResource, false),
		                  (workInProgress.lanes = 4194304));
		            nextResource.isBackwards
		              ? ((returnFiber.sibling = workInProgress.child),
		                (workInProgress.child = returnFiber))
		              : ((current = nextResource.last),
		                null !== current
		                  ? (current.sibling = returnFiber)
		                  : (workInProgress.child = returnFiber),
		                (nextResource.last = returnFiber));
		          }
		          if (null !== nextResource.tail)
		            return (
		              (current = nextResource.tail),
		              (nextResource.rendering = current),
		              (nextResource.tail = current.sibling),
		              (nextResource.renderingStartTime = now$1()),
		              (current.sibling = null),
		              (renderLanes = suspenseStackCursor.current),
		              (renderLanes = newProps
		                ? (renderLanes & SubtreeSuspenseContextMask) |
		                  ForceSuspenseFallback
		                : renderLanes & SubtreeSuspenseContextMask),
		              push(suspenseStackCursor, renderLanes, workInProgress),
		              current
		            );
		          bubbleProperties(workInProgress);
		          return null;
		        case 22:
		        case 23:
		          return (
		            popSuspenseHandler(workInProgress),
		            popHiddenContext(workInProgress),
		            (newProps = null !== workInProgress.memoizedState),
		            null !== current
		              ? (null !== current.memoizedState) !== newProps &&
		                (workInProgress.flags |= 8192)
		              : newProps && (workInProgress.flags |= 8192),
		            newProps
		              ? 0 !== (renderLanes & 536870912) &&
		                0 === (workInProgress.flags & 128) &&
		                (bubbleProperties(workInProgress),
		                workInProgress.subtreeFlags & 6 &&
		                  (workInProgress.flags |= 8192))
		              : bubbleProperties(workInProgress),
		            (renderLanes = workInProgress.updateQueue),
		            null !== renderLanes &&
		              scheduleRetryEffect(workInProgress, renderLanes.retryQueue),
		            (renderLanes = null),
		            null !== current &&
		              null !== current.memoizedState &&
		              null !== current.memoizedState.cachePool &&
		              (renderLanes = current.memoizedState.cachePool.pool),
		            (newProps = null),
		            null !== workInProgress.memoizedState &&
		              null !== workInProgress.memoizedState.cachePool &&
		              (newProps = workInProgress.memoizedState.cachePool.pool),
		            newProps !== renderLanes && (workInProgress.flags |= 2048),
		            null !== current && pop(resumedCache, workInProgress),
		            null
		          );
		        case 24:
		          return (
		            (renderLanes = null),
		            null !== current && (renderLanes = current.memoizedState.cache),
		            workInProgress.memoizedState.cache !== renderLanes &&
		              (workInProgress.flags |= 2048),
		            popProvider(CacheContext, workInProgress),
		            bubbleProperties(workInProgress),
		            null
		          );
		        case 25:
		          return null;
		      }
		      throw Error(
		        "Unknown unit of work tag (" +
		          workInProgress.tag +
		          "). This error is likely caused by a bug in React. Please file an issue."
		      );
		    }
		    function unwindWork(current, workInProgress) {
		      popTreeContext(workInProgress);
		      switch (workInProgress.tag) {
		        case 1:
		          return (
		            (current = workInProgress.flags),
		            current & 65536
		              ? ((workInProgress.flags = (current & -65537) | 128),
		                (workInProgress.mode & 2) !== NoMode &&
		                  transferActualDuration(workInProgress),
		                workInProgress)
		              : null
		          );
		        case 3:
		          return (
		            popProvider(CacheContext, workInProgress),
		            popHostContainer(workInProgress),
		            (current = workInProgress.flags),
		            0 !== (current & 65536) && 0 === (current & 128)
		              ? ((workInProgress.flags = (current & -65537) | 128),
		                workInProgress)
		              : null
		          );
		        case 26:
		        case 27:
		        case 5:
		          return popHostContext(workInProgress), null;
		        case 13:
		          popSuspenseHandler(workInProgress);
		          current = workInProgress.memoizedState;
		          if (null !== current && null !== current.dehydrated) {
		            if (null === workInProgress.alternate)
		              throw Error(
		                "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
		              );
		            resetHydrationState();
		          }
		          current = workInProgress.flags;
		          return current & 65536
		            ? ((workInProgress.flags = (current & -65537) | 128),
		              (workInProgress.mode & 2) !== NoMode &&
		                transferActualDuration(workInProgress),
		              workInProgress)
		            : null;
		        case 19:
		          return pop(suspenseStackCursor, workInProgress), null;
		        case 4:
		          return popHostContainer(workInProgress), null;
		        case 10:
		          return popProvider(workInProgress.type, workInProgress), null;
		        case 22:
		        case 23:
		          return (
		            popSuspenseHandler(workInProgress),
		            popHiddenContext(workInProgress),
		            null !== current && pop(resumedCache, workInProgress),
		            (current = workInProgress.flags),
		            current & 65536
		              ? ((workInProgress.flags = (current & -65537) | 128),
		                (workInProgress.mode & 2) !== NoMode &&
		                  transferActualDuration(workInProgress),
		                workInProgress)
		              : null
		          );
		        case 24:
		          return popProvider(CacheContext, workInProgress), null;
		        case 25:
		          return null;
		        default:
		          return null;
		      }
		    }
		    function unwindInterruptedWork(current, interruptedWork) {
		      popTreeContext(interruptedWork);
		      switch (interruptedWork.tag) {
		        case 3:
		          popProvider(CacheContext, interruptedWork);
		          popHostContainer(interruptedWork);
		          break;
		        case 26:
		        case 27:
		        case 5:
		          popHostContext(interruptedWork);
		          break;
		        case 4:
		          popHostContainer(interruptedWork);
		          break;
		        case 13:
		          popSuspenseHandler(interruptedWork);
		          break;
		        case 19:
		          pop(suspenseStackCursor, interruptedWork);
		          break;
		        case 10:
		          popProvider(interruptedWork.type, interruptedWork);
		          break;
		        case 22:
		        case 23:
		          popSuspenseHandler(interruptedWork);
		          popHiddenContext(interruptedWork);
		          null !== current && pop(resumedCache, interruptedWork);
		          break;
		        case 24:
		          popProvider(CacheContext, interruptedWork);
		      }
		    }
		    function shouldProfile(current) {
		      return (current.mode & 2) !== NoMode;
		    }
		    function commitHookLayoutEffects(finishedWork, hookFlags) {
		      shouldProfile(finishedWork)
		        ? (startEffectTimer(),
		          commitHookEffectListMount(hookFlags, finishedWork),
		          recordEffectDuration())
		        : commitHookEffectListMount(hookFlags, finishedWork);
		    }
		    function commitHookLayoutUnmountEffects(
		      finishedWork,
		      nearestMountedAncestor,
		      hookFlags
		    ) {
		      shouldProfile(finishedWork)
		        ? (startEffectTimer(),
		          commitHookEffectListUnmount(
		            hookFlags,
		            finishedWork,
		            nearestMountedAncestor
		          ),
		          recordEffectDuration())
		        : commitHookEffectListUnmount(
		            hookFlags,
		            finishedWork,
		            nearestMountedAncestor
		          );
		    }
		    function commitHookEffectListMount(flags, finishedWork) {
		      try {
		        var updateQueue = finishedWork.updateQueue,
		          lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
		        if (null !== lastEffect) {
		          var firstEffect = lastEffect.next;
		          updateQueue = firstEffect;
		          do {
		            if (
		              (updateQueue.tag & flags) === flags &&
		              ((flags & Passive) !== NoFlags
		                ? null !== injectedProfilingHooks &&
		                  "function" ===
		                    typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted &&
		                  injectedProfilingHooks.markComponentPassiveEffectMountStarted(
		                    finishedWork
		                  )
		                : (flags & Layout) !== NoFlags &&
		                  null !== injectedProfilingHooks &&
		                  "function" ===
		                    typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted &&
		                  injectedProfilingHooks.markComponentLayoutEffectMountStarted(
		                    finishedWork
		                  ),
		              (lastEffect = void 0),
		              (flags & Insertion) !== NoFlags &&
		                (isRunningInsertionEffect = !0),
		              (lastEffect = runWithFiberInDEV(
		                finishedWork,
		                callCreateInDEV,
		                updateQueue
		              )),
		              (flags & Insertion) !== NoFlags &&
		                (isRunningInsertionEffect = !1),
		              (flags & Passive) !== NoFlags
		                ? null !== injectedProfilingHooks &&
		                  "function" ===
		                    typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped &&
		                  injectedProfilingHooks.markComponentPassiveEffectMountStopped()
		                : (flags & Layout) !== NoFlags &&
		                  null !== injectedProfilingHooks &&
		                  "function" ===
		                    typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped &&
		                  injectedProfilingHooks.markComponentLayoutEffectMountStopped(),
		              void 0 !== lastEffect && "function" !== typeof lastEffect)
		            ) {
		              var hookName = void 0;
		              hookName =
		                0 !== (updateQueue.tag & Layout)
		                  ? "useLayoutEffect"
		                  : 0 !== (updateQueue.tag & Insertion)
		                    ? "useInsertionEffect"
		                    : "useEffect";
		              var addendum = void 0;
		              addendum =
		                null === lastEffect
		                  ? " You returned null. If your effect does not require clean up, return undefined (or nothing)."
		                  : "function" === typeof lastEffect.then
		                    ? "\n\nIt looks like you wrote " +
		                      hookName +
		                      "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" +
		                      hookName +
		                      "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching"
		                    : " You returned: " + lastEffect;
		              runWithFiberInDEV(
		                finishedWork,
		                function (n, a) {
		                  console.error(
		                    "%s must not return anything besides a function, which is used for clean-up.%s",
		                    n,
		                    a
		                  );
		                },
		                hookName,
		                addendum
		              );
		            }
		            updateQueue = updateQueue.next;
		          } while (updateQueue !== firstEffect);
		        }
		      } catch (error) {
		        captureCommitPhaseError(finishedWork, finishedWork.return, error);
		      }
		    }
		    function commitHookEffectListUnmount(
		      flags,
		      finishedWork,
		      nearestMountedAncestor
		    ) {
		      try {
		        var updateQueue = finishedWork.updateQueue,
		          lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
		        if (null !== lastEffect) {
		          var firstEffect = lastEffect.next;
		          updateQueue = firstEffect;
		          do {
		            if ((updateQueue.tag & flags) === flags) {
		              var inst = updateQueue.inst,
		                destroy = inst.destroy;
		              void 0 !== destroy &&
		                ((inst.destroy = void 0),
		                (flags & Passive) !== NoFlags
		                  ? null !== injectedProfilingHooks &&
		                    "function" ===
		                      typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted &&
		                    injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(
		                      finishedWork
		                    )
		                  : (flags & Layout) !== NoFlags &&
		                    null !== injectedProfilingHooks &&
		                    "function" ===
		                      typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted &&
		                    injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(
		                      finishedWork
		                    ),
		                (flags & Insertion) !== NoFlags &&
		                  (isRunningInsertionEffect = !0),
		                runWithFiberInDEV(
		                  finishedWork,
		                  callDestroyInDEV,
		                  finishedWork,
		                  nearestMountedAncestor,
		                  destroy
		                ),
		                (flags & Insertion) !== NoFlags &&
		                  (isRunningInsertionEffect = !1),
		                (flags & Passive) !== NoFlags
		                  ? null !== injectedProfilingHooks &&
		                    "function" ===
		                      typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped &&
		                    injectedProfilingHooks.markComponentPassiveEffectUnmountStopped()
		                  : (flags & Layout) !== NoFlags &&
		                    null !== injectedProfilingHooks &&
		                    "function" ===
		                      typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped &&
		                    injectedProfilingHooks.markComponentLayoutEffectUnmountStopped());
		            }
		            updateQueue = updateQueue.next;
		          } while (updateQueue !== firstEffect);
		        }
		      } catch (error) {
		        captureCommitPhaseError(finishedWork, finishedWork.return, error);
		      }
		    }
		    function commitHookPassiveMountEffects(finishedWork, hookFlags) {
		      shouldProfile(finishedWork)
		        ? (startEffectTimer(),
		          commitHookEffectListMount(hookFlags, finishedWork),
		          recordEffectDuration())
		        : commitHookEffectListMount(hookFlags, finishedWork);
		    }
		    function commitHookPassiveUnmountEffects(
		      finishedWork,
		      nearestMountedAncestor,
		      hookFlags
		    ) {
		      shouldProfile(finishedWork)
		        ? (startEffectTimer(),
		          commitHookEffectListUnmount(
		            hookFlags,
		            finishedWork,
		            nearestMountedAncestor
		          ),
		          recordEffectDuration())
		        : commitHookEffectListUnmount(
		            hookFlags,
		            finishedWork,
		            nearestMountedAncestor
		          );
		    }
		    function commitClassCallbacks(finishedWork) {
		      var updateQueue = finishedWork.updateQueue;
		      if (null !== updateQueue) {
		        var instance = finishedWork.stateNode;
		        finishedWork.type.defaultProps ||
		          "ref" in finishedWork.memoizedProps ||
		          didWarnAboutReassigningProps ||
		          (instance.props !== finishedWork.memoizedProps &&
		            console.error(
		              "Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
		              getComponentNameFromFiber(finishedWork) || "instance"
		            ),
		          instance.state !== finishedWork.memoizedState &&
		            console.error(
		              "Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
		              getComponentNameFromFiber(finishedWork) || "instance"
		            ));
		        try {
		          runWithFiberInDEV(
		            finishedWork,
		            commitCallbacks,
		            updateQueue,
		            instance
		          );
		        } catch (error) {
		          captureCommitPhaseError(finishedWork, finishedWork.return, error);
		        }
		      }
		    }
		    function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {
		      return instance.getSnapshotBeforeUpdate(prevProps, prevState);
		    }
		    function commitClassSnapshot(finishedWork, current) {
		      var prevProps = current.memoizedProps,
		        prevState = current.memoizedState;
		      current = finishedWork.stateNode;
		      finishedWork.type.defaultProps ||
		        "ref" in finishedWork.memoizedProps ||
		        didWarnAboutReassigningProps ||
		        (current.props !== finishedWork.memoizedProps &&
		          console.error(
		            "Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
		            getComponentNameFromFiber(finishedWork) || "instance"
		          ),
		        current.state !== finishedWork.memoizedState &&
		          console.error(
		            "Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
		            getComponentNameFromFiber(finishedWork) || "instance"
		          ));
		      try {
		        var resolvedPrevProps = resolveClassComponentProps(
		          finishedWork.type,
		          prevProps,
		          finishedWork.elementType === finishedWork.type
		        );
		        var snapshot = runWithFiberInDEV(
		          finishedWork,
		          callGetSnapshotBeforeUpdates,
		          current,
		          resolvedPrevProps,
		          prevState
		        );
		        prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;
		        void 0 !== snapshot ||
		          prevProps.has(finishedWork.type) ||
		          (prevProps.add(finishedWork.type),
		          runWithFiberInDEV(finishedWork, function () {
		            console.error(
		              "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",
		              getComponentNameFromFiber(finishedWork)
		            );
		          }));
		        current.__reactInternalSnapshotBeforeUpdate = snapshot;
		      } catch (error) {
		        captureCommitPhaseError(finishedWork, finishedWork.return, error);
		      }
		    }
		    function safelyCallComponentWillUnmount(
		      current,
		      nearestMountedAncestor,
		      instance
		    ) {
		      instance.props = resolveClassComponentProps(
		        current.type,
		        current.memoizedProps
		      );
		      instance.state = current.memoizedState;
		      shouldProfile(current)
		        ? (startEffectTimer(),
		          runWithFiberInDEV(
		            current,
		            callComponentWillUnmountInDEV,
		            current,
		            nearestMountedAncestor,
		            instance
		          ),
		          recordEffectDuration())
		        : runWithFiberInDEV(
		            current,
		            callComponentWillUnmountInDEV,
		            current,
		            nearestMountedAncestor,
		            instance
		          );
		    }
		    function commitAttachRef(finishedWork) {
		      var ref = finishedWork.ref;
		      if (null !== ref) {
		        var instance = finishedWork.stateNode;
		        switch (finishedWork.tag) {
		          case 26:
		          case 27:
		          case 5:
		            instance = getPublicInstance(instance);
		        }
		        if ("function" === typeof ref)
		          if (shouldProfile(finishedWork))
		            try {
		              startEffectTimer(), (finishedWork.refCleanup = ref(instance));
		            } finally {
		              recordEffectDuration();
		            }
		          else finishedWork.refCleanup = ref(instance);
		        else
		          "string" === typeof ref
		            ? console.error("String refs are no longer supported.")
		            : ref.hasOwnProperty("current") ||
		              console.error(
		                "Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",
		                getComponentNameFromFiber(finishedWork)
		              ),
		            (ref.current = instance);
		      }
		    }
		    function safelyAttachRef(current, nearestMountedAncestor) {
		      try {
		        runWithFiberInDEV(current, commitAttachRef, current);
		      } catch (error) {
		        captureCommitPhaseError(current, nearestMountedAncestor, error);
		      }
		    }
		    function safelyDetachRef(current, nearestMountedAncestor) {
		      var ref = current.ref,
		        refCleanup = current.refCleanup;
		      if (null !== ref)
		        if ("function" === typeof refCleanup)
		          try {
		            if (shouldProfile(current))
		              try {
		                startEffectTimer(), runWithFiberInDEV(current, refCleanup);
		              } finally {
		                recordEffectDuration(current);
		              }
		            else runWithFiberInDEV(current, refCleanup);
		          } catch (error) {
		            captureCommitPhaseError(current, nearestMountedAncestor, error);
		          } finally {
		            (current.refCleanup = null),
		              (current = current.alternate),
		              null != current && (current.refCleanup = null);
		          }
		        else if ("function" === typeof ref)
		          try {
		            if (shouldProfile(current))
		              try {
		                startEffectTimer(), runWithFiberInDEV(current, ref, null);
		              } finally {
		                recordEffectDuration(current);
		              }
		            else runWithFiberInDEV(current, ref, null);
		          } catch (error$3) {
		            captureCommitPhaseError(current, nearestMountedAncestor, error$3);
		          }
		        else ref.current = null;
		    }
		    function commitProfiler(
		      finishedWork,
		      current,
		      commitStartTime,
		      effectDuration
		    ) {
		      var _finishedWork$memoize = finishedWork.memoizedProps,
		        id = _finishedWork$memoize.id,
		        onCommit = _finishedWork$memoize.onCommit;
		      _finishedWork$memoize = _finishedWork$memoize.onRender;
		      current = null === current ? "mount" : "update";
		      currentUpdateIsNested && (current = "nested-update");
		      "function" === typeof _finishedWork$memoize &&
		        _finishedWork$memoize(
		          id,
		          current,
		          finishedWork.actualDuration,
		          finishedWork.treeBaseDuration,
		          finishedWork.actualStartTime,
		          commitStartTime
		        );
		      "function" === typeof onCommit &&
		        onCommit(
		          finishedWork.memoizedProps.id,
		          current,
		          effectDuration,
		          commitStartTime
		        );
		    }
		    function commitProfilerPostCommitImpl(
		      finishedWork,
		      current,
		      commitStartTime,
		      passiveEffectDuration
		    ) {
		      var _finishedWork$memoize2 = finishedWork.memoizedProps;
		      finishedWork = _finishedWork$memoize2.id;
		      _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;
		      current = null === current ? "mount" : "update";
		      currentUpdateIsNested && (current = "nested-update");
		      "function" === typeof _finishedWork$memoize2 &&
		        _finishedWork$memoize2(
		          finishedWork,
		          current,
		          passiveEffectDuration,
		          commitStartTime
		        );
		    }
		    function commitHostMount(finishedWork) {
		      var type = finishedWork.type,
		        props = finishedWork.memoizedProps,
		        instance = finishedWork.stateNode;
		      try {
		        runWithFiberInDEV(
		          finishedWork,
		          commitMount,
		          instance,
		          type,
		          props,
		          finishedWork
		        );
		      } catch (error) {
		        captureCommitPhaseError(finishedWork, finishedWork.return, error);
		      }
		    }
		    function commitHostUpdate(finishedWork, newProps, oldProps) {
		      try {
		        runWithFiberInDEV(
		          finishedWork,
		          commitUpdate,
		          finishedWork.stateNode,
		          finishedWork.type,
		          oldProps,
		          newProps,
		          finishedWork
		        );
		      } catch (error) {
		        captureCommitPhaseError(finishedWork, finishedWork.return, error);
		      }
		    }
		    function isHostParent(fiber) {
		      return (
		        5 === fiber.tag ||
		        3 === fiber.tag ||
		        (supportsResources ? 26 === fiber.tag : false) ||
		        (supportsSingletons ? 27 === fiber.tag : false) ||
		        4 === fiber.tag
		      );
		    }
		    function getHostSibling(fiber) {
		      a: for (;;) {
		        for (; null === fiber.sibling; ) {
		          if (null === fiber.return || isHostParent(fiber.return)) return null;
		          fiber = fiber.return;
		        }
		        fiber.sibling.return = fiber.return;
		        for (
		          fiber = fiber.sibling;
		          5 !== fiber.tag &&
		          6 !== fiber.tag &&
		          (supportsSingletons ? 27 !== fiber.tag : 1) &&
		          18 !== fiber.tag;

		        ) {
		          if (fiber.flags & 2) continue a;
		          if (null === fiber.child || 4 === fiber.tag) continue a;
		          else (fiber.child.return = fiber), (fiber = fiber.child);
		        }
		        if (!(fiber.flags & 2)) return fiber.stateNode;
		      }
		    }
		    function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
		      var tag = node.tag;
		      if (5 === tag || 6 === tag)
		        (node = node.stateNode),
		          before
		            ? insertInContainerBefore(parent, node, before)
		            : appendChildToContainer(parent, node);
		      else if (
		        !(4 === tag || (supportsSingletons && 27 === tag)) &&
		        ((node = node.child), null !== node)
		      )
		        for (
		          insertOrAppendPlacementNodeIntoContainer(node, before, parent),
		            node = node.sibling;
		          null !== node;

		        )
		          insertOrAppendPlacementNodeIntoContainer(node, before, parent),
		            (node = node.sibling);
		    }
		    function insertOrAppendPlacementNode(node, before, parent) {
		      var tag = node.tag;
		      if (5 === tag || 6 === tag)
		        (node = node.stateNode),
		          before
		            ? insertBefore(parent, node, before)
		            : appendChild(parent, node);
		      else if (
		        !(4 === tag || (supportsSingletons && 27 === tag)) &&
		        ((node = node.child), null !== node)
		      )
		        for (
		          insertOrAppendPlacementNode(node, before, parent),
		            node = node.sibling;
		          null !== node;

		        )
		          insertOrAppendPlacementNode(node, before, parent),
		            (node = node.sibling);
		    }
		    function commitPlacement(finishedWork) {
		      if (
		        supportsMutation &&
		        (!supportsSingletons || 27 !== finishedWork.tag)
		      ) {
		        a: {
		          for (var parent = finishedWork.return; null !== parent; ) {
		            if (isHostParent(parent)) {
		              var parentFiber = parent;
		              break a;
		            }
		            parent = parent.return;
		          }
		          throw Error(
		            "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
		          );
		        }
		        switch (parentFiber.tag) {
		          case 27:
		            if (supportsSingletons) {
		              parent = parentFiber.stateNode;
		              parentFiber = getHostSibling(finishedWork);
		              insertOrAppendPlacementNode(finishedWork, parentFiber, parent);
		              break;
		            }
		          case 5:
		            parent = parentFiber.stateNode;
		            parentFiber.flags & 32 &&
		              (resetTextContent(parent), (parentFiber.flags &= -33));
		            parentFiber = getHostSibling(finishedWork);
		            insertOrAppendPlacementNode(finishedWork, parentFiber, parent);
		            break;
		          case 3:
		          case 4:
		            parent = parentFiber.stateNode.containerInfo;
		            parentFiber = getHostSibling(finishedWork);
		            insertOrAppendPlacementNodeIntoContainer(
		              finishedWork,
		              parentFiber,
		              parent
		            );
		            break;
		          default:
		            throw Error(
		              "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
		            );
		        }
		      }
		    }
		    function commitHostPortalContainerChildren(
		      portal,
		      finishedWork,
		      pendingChildren
		    ) {
		      portal = portal.containerInfo;
		      try {
		        runWithFiberInDEV(
		          finishedWork,
		          replaceContainerChildren,
		          portal,
		          pendingChildren
		        );
		      } catch (error) {
		        captureCommitPhaseError(finishedWork, finishedWork.return, error);
		      }
		    }
		    function commitBeforeMutationEffects(root, firstChild) {
		      prepareForCommit(root.containerInfo);
		      for (nextEffect = firstChild; null !== nextEffect; )
		        if (
		          ((root = nextEffect),
		          (firstChild = root.child),
		          0 !== (root.subtreeFlags & 1028) && null !== firstChild)
		        )
		          (firstChild.return = root), (nextEffect = firstChild);
		        else
		          for (; null !== nextEffect; ) {
		            firstChild = root = nextEffect;
		            var current = firstChild.alternate,
		              flags = firstChild.flags;
		            switch (firstChild.tag) {
		              case 0:
		                break;
		              case 11:
		              case 15:
		                break;
		              case 1:
		                0 !== (flags & 1024) &&
		                  null !== current &&
		                  commitClassSnapshot(firstChild, current);
		                break;
		              case 3:
		                0 !== (flags & 1024) &&
		                  supportsMutation &&
		                  clearContainer(firstChild.stateNode.containerInfo);
		                break;
		              case 5:
		              case 26:
		              case 27:
		              case 6:
		              case 4:
		              case 17:
		                break;
		              default:
		                if (0 !== (flags & 1024))
		                  throw Error(
		                    "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
		                  );
		            }
		            firstChild = root.sibling;
		            if (null !== firstChild) {
		              firstChild.return = root.return;
		              nextEffect = firstChild;
		              break;
		            }
		            nextEffect = root.return;
		          }
		      root = shouldFireAfterActiveInstanceBlur;
		      shouldFireAfterActiveInstanceBlur = false;
		      return root;
		    }
		    function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
		      var flags = finishedWork.flags;
		      switch (finishedWork.tag) {
		        case 0:
		        case 11:
		        case 15:
		          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		          flags & 4 &&
		            commitHookLayoutEffects(finishedWork, Layout | HasEffect);
		          break;
		        case 1:
		          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		          if (flags & 4)
		            if (((finishedRoot = finishedWork.stateNode), null === current))
		              finishedWork.type.defaultProps ||
		                "ref" in finishedWork.memoizedProps ||
		                didWarnAboutReassigningProps ||
		                (finishedRoot.props !== finishedWork.memoizedProps &&
		                  console.error(
		                    "Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
		                    getComponentNameFromFiber(finishedWork) || "instance"
		                  ),
		                finishedRoot.state !== finishedWork.memoizedState &&
		                  console.error(
		                    "Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
		                    getComponentNameFromFiber(finishedWork) || "instance"
		                  )),
		                shouldProfile(finishedWork)
		                  ? (startEffectTimer(),
		                    runWithFiberInDEV(
		                      finishedWork,
		                      callComponentDidMountInDEV,
		                      finishedWork,
		                      finishedRoot
		                    ),
		                    recordEffectDuration())
		                  : runWithFiberInDEV(
		                      finishedWork,
		                      callComponentDidMountInDEV,
		                      finishedWork,
		                      finishedRoot
		                    );
		            else {
		              var prevProps = resolveClassComponentProps(
		                finishedWork.type,
		                current.memoizedProps
		              );
		              current = current.memoizedState;
		              finishedWork.type.defaultProps ||
		                "ref" in finishedWork.memoizedProps ||
		                didWarnAboutReassigningProps ||
		                (finishedRoot.props !== finishedWork.memoizedProps &&
		                  console.error(
		                    "Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
		                    getComponentNameFromFiber(finishedWork) || "instance"
		                  ),
		                finishedRoot.state !== finishedWork.memoizedState &&
		                  console.error(
		                    "Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
		                    getComponentNameFromFiber(finishedWork) || "instance"
		                  ));
		              shouldProfile(finishedWork)
		                ? (startEffectTimer(),
		                  runWithFiberInDEV(
		                    finishedWork,
		                    callComponentDidUpdateInDEV,
		                    finishedWork,
		                    finishedRoot,
		                    prevProps,
		                    current,
		                    finishedRoot.__reactInternalSnapshotBeforeUpdate
		                  ),
		                  recordEffectDuration())
		                : runWithFiberInDEV(
		                    finishedWork,
		                    callComponentDidUpdateInDEV,
		                    finishedWork,
		                    finishedRoot,
		                    prevProps,
		                    current,
		                    finishedRoot.__reactInternalSnapshotBeforeUpdate
		                  );
		            }
		          flags & 64 && commitClassCallbacks(finishedWork);
		          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
		          break;
		        case 3:
		          current = pushNestedEffectDurations();
		          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		          if (
		            flags & 64 &&
		            ((flags = finishedWork.updateQueue), null !== flags)
		          ) {
		            prevProps = null;
		            if (null !== finishedWork.child)
		              switch (finishedWork.child.tag) {
		                case 27:
		                case 5:
		                  prevProps = getPublicInstance(finishedWork.child.stateNode);
		                  break;
		                case 1:
		                  prevProps = finishedWork.child.stateNode;
		              }
		            try {
		              runWithFiberInDEV(
		                finishedWork,
		                commitCallbacks,
		                flags,
		                prevProps
		              );
		            } catch (error) {
		              captureCommitPhaseError(finishedWork, finishedWork.return, error);
		            }
		          }
		          finishedRoot.effectDuration += popNestedEffectDurations(current);
		          break;
		        case 26:
		          if (supportsResources) {
		            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
		            break;
		          }
		        case 27:
		        case 5:
		          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		          null === current && flags & 4 && commitHostMount(finishedWork);
		          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
		          break;
		        case 12:
		          if (flags & 4) {
		            flags = pushNestedEffectDurations();
		            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		            finishedRoot = finishedWork.stateNode;
		            finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);
		            try {
		              runWithFiberInDEV(
		                finishedWork,
		                commitProfiler,
		                finishedWork,
		                current,
		                commitStartTime,
		                finishedRoot.effectDuration
		              );
		            } catch (error) {
		              captureCommitPhaseError(finishedWork, finishedWork.return, error);
		            }
		          } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		          break;
		        case 13:
		          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		          flags & 4 &&
		            commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
		          break;
		        case 22:
		          prevProps =
		            null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
		          if (!prevProps) {
		            current =
		              (null !== current && null !== current.memoizedState) ||
		              offscreenSubtreeWasHidden;
		            var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
		              prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
		            offscreenSubtreeIsHidden = prevProps;
		            (offscreenSubtreeWasHidden = current) &&
		            !prevOffscreenSubtreeWasHidden
		              ? recursivelyTraverseReappearLayoutEffects(
		                  finishedRoot,
		                  finishedWork,
		                  0 !== (finishedWork.subtreeFlags & 8772)
		                )
		              : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
		            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
		          }
		          flags & 512 &&
		            ("manual" === finishedWork.memoizedProps.mode
		              ? safelyAttachRef(finishedWork, finishedWork.return)
		              : safelyDetachRef(finishedWork, finishedWork.return));
		          break;
		        default:
		          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		      }
		    }
		    function detachFiberAfterEffects(fiber) {
		      var alternate = fiber.alternate;
		      null !== alternate &&
		        ((fiber.alternate = null), detachFiberAfterEffects(alternate));
		      fiber.child = null;
		      fiber.deletions = null;
		      fiber.sibling = null;
		      5 === fiber.tag &&
		        ((alternate = fiber.stateNode),
		        null !== alternate && detachDeletedInstance(alternate));
		      fiber.stateNode = null;
		      fiber._debugOwner = null;
		      fiber.return = null;
		      fiber.dependencies = null;
		      fiber.memoizedProps = null;
		      fiber.memoizedState = null;
		      fiber.pendingProps = null;
		      fiber.stateNode = null;
		      fiber.updateQueue = null;
		    }
		    function recursivelyTraverseDeletionEffects(
		      finishedRoot,
		      nearestMountedAncestor,
		      parent
		    ) {
		      for (parent = parent.child; null !== parent; )
		        commitDeletionEffectsOnFiber(
		          finishedRoot,
		          nearestMountedAncestor,
		          parent
		        ),
		          (parent = parent.sibling);
		    }
		    function commitDeletionEffectsOnFiber(
		      finishedRoot,
		      nearestMountedAncestor,
		      deletedFiber
		    ) {
		      if (
		        injectedHook &&
		        "function" === typeof injectedHook.onCommitFiberUnmount
		      )
		        try {
		          injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
		        } catch (err) {
		          hasLoggedError ||
		            ((hasLoggedError = true),
		            console.error(
		              "React instrumentation encountered an error: %s",
		              err
		            ));
		        }
		      switch (deletedFiber.tag) {
		        case 26:
		          if (supportsResources) {
		            offscreenSubtreeWasHidden ||
		              safelyDetachRef(deletedFiber, nearestMountedAncestor);
		            recursivelyTraverseDeletionEffects(
		              finishedRoot,
		              nearestMountedAncestor,
		              deletedFiber
		            );
		            deletedFiber.memoizedState
		              ? releaseResource(deletedFiber.memoizedState)
		              : deletedFiber.stateNode &&
		                unmountHoistable(deletedFiber.stateNode);
		            break;
		          }
		        case 27:
		          if (supportsSingletons) {
		            offscreenSubtreeWasHidden ||
		              safelyDetachRef(deletedFiber, nearestMountedAncestor);
		            var prevHostParent = hostParent,
		              prevHostParentIsContainer = hostParentIsContainer;
		            hostParent = deletedFiber.stateNode;
		            recursivelyTraverseDeletionEffects(
		              finishedRoot,
		              nearestMountedAncestor,
		              deletedFiber
		            );
		            releaseSingletonInstance(deletedFiber.stateNode);
		            hostParent = prevHostParent;
		            hostParentIsContainer = prevHostParentIsContainer;
		            break;
		          }
		        case 5:
		          offscreenSubtreeWasHidden ||
		            safelyDetachRef(deletedFiber, nearestMountedAncestor);
		        case 6:
		          if (supportsMutation) {
		            if (
		              ((prevHostParent = hostParent),
		              (prevHostParentIsContainer = hostParentIsContainer),
		              (hostParent = null),
		              recursivelyTraverseDeletionEffects(
		                finishedRoot,
		                nearestMountedAncestor,
		                deletedFiber
		              ),
		              (hostParent = prevHostParent),
		              (hostParentIsContainer = prevHostParentIsContainer),
		              null !== hostParent)
		            )
		              if (hostParentIsContainer)
		                try {
		                  runWithFiberInDEV(
		                    deletedFiber,
		                    removeChildFromContainer,
		                    hostParent,
		                    deletedFiber.stateNode
		                  );
		                } catch (error) {
		                  captureCommitPhaseError(
		                    deletedFiber,
		                    nearestMountedAncestor,
		                    error
		                  );
		                }
		              else
		                try {
		                  runWithFiberInDEV(
		                    deletedFiber,
		                    removeChild,
		                    hostParent,
		                    deletedFiber.stateNode
		                  );
		                } catch (error) {
		                  captureCommitPhaseError(
		                    deletedFiber,
		                    nearestMountedAncestor,
		                    error
		                  );
		                }
		          } else
		            recursivelyTraverseDeletionEffects(
		              finishedRoot,
		              nearestMountedAncestor,
		              deletedFiber
		            );
		          break;
		        case 18:
		          supportsMutation &&
		            null !== hostParent &&
		            (hostParentIsContainer
		              ? clearSuspenseBoundaryFromContainer(
		                  hostParent,
		                  deletedFiber.stateNode
		                )
		              : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
		          break;
		        case 4:
		          supportsMutation
		            ? ((prevHostParent = hostParent),
		              (prevHostParentIsContainer = hostParentIsContainer),
		              (hostParent = deletedFiber.stateNode.containerInfo),
		              (hostParentIsContainer = true),
		              recursivelyTraverseDeletionEffects(
		                finishedRoot,
		                nearestMountedAncestor,
		                deletedFiber
		              ),
		              (hostParent = prevHostParent),
		              (hostParentIsContainer = prevHostParentIsContainer))
		            : (supportsPersistence &&
		                commitHostPortalContainerChildren(
		                  deletedFiber.stateNode,
		                  deletedFiber,
		                  createContainerChildSet()
		                ),
		              recursivelyTraverseDeletionEffects(
		                finishedRoot,
		                nearestMountedAncestor,
		                deletedFiber
		              ));
		          break;
		        case 0:
		        case 11:
		        case 14:
		        case 15:
		          offscreenSubtreeWasHidden ||
		            commitHookEffectListUnmount(
		              Insertion,
		              deletedFiber,
		              nearestMountedAncestor
		            );
		          offscreenSubtreeWasHidden ||
		            commitHookLayoutUnmountEffects(
		              deletedFiber,
		              nearestMountedAncestor,
		              Layout
		            );
		          recursivelyTraverseDeletionEffects(
		            finishedRoot,
		            nearestMountedAncestor,
		            deletedFiber
		          );
		          break;
		        case 1:
		          offscreenSubtreeWasHidden ||
		            (safelyDetachRef(deletedFiber, nearestMountedAncestor),
		            (prevHostParent = deletedFiber.stateNode),
		            "function" === typeof prevHostParent.componentWillUnmount &&
		              safelyCallComponentWillUnmount(
		                deletedFiber,
		                nearestMountedAncestor,
		                prevHostParent
		              ));
		          recursivelyTraverseDeletionEffects(
		            finishedRoot,
		            nearestMountedAncestor,
		            deletedFiber
		          );
		          break;
		        case 21:
		          recursivelyTraverseDeletionEffects(
		            finishedRoot,
		            nearestMountedAncestor,
		            deletedFiber
		          );
		          break;
		        case 22:
		          offscreenSubtreeWasHidden ||
		            safelyDetachRef(deletedFiber, nearestMountedAncestor);
		          offscreenSubtreeWasHidden =
		            (prevHostParent = offscreenSubtreeWasHidden) ||
		            null !== deletedFiber.memoizedState;
		          recursivelyTraverseDeletionEffects(
		            finishedRoot,
		            nearestMountedAncestor,
		            deletedFiber
		          );
		          offscreenSubtreeWasHidden = prevHostParent;
		          break;
		        default:
		          recursivelyTraverseDeletionEffects(
		            finishedRoot,
		            nearestMountedAncestor,
		            deletedFiber
		          );
		      }
		    }
		    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
		      if (
		        supportsHydration &&
		        null === finishedWork.memoizedState &&
		        ((finishedRoot = finishedWork.alternate),
		        null !== finishedRoot &&
		          ((finishedRoot = finishedRoot.memoizedState),
		          null !== finishedRoot &&
		            ((finishedRoot = finishedRoot.dehydrated), null !== finishedRoot)))
		      )
		        try {
		          runWithFiberInDEV(
		            finishedWork,
		            commitHydratedSuspenseInstance,
		            finishedRoot
		          );
		        } catch (error) {
		          captureCommitPhaseError(finishedWork, finishedWork.return, error);
		        }
		    }
		    function getRetryCache(finishedWork) {
		      switch (finishedWork.tag) {
		        case 13:
		        case 19:
		          var retryCache = finishedWork.stateNode;
		          null === retryCache &&
		            (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
		          return retryCache;
		        case 22:
		          return (
		            (finishedWork = finishedWork.stateNode),
		            (retryCache = finishedWork._retryCache),
		            null === retryCache &&
		              (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),
		            retryCache
		          );
		        default:
		          throw Error(
		            "Unexpected Suspense handler tag (" +
		              finishedWork.tag +
		              "). This is a bug in React."
		          );
		      }
		    }
		    function attachSuspenseRetryListeners(finishedWork, wakeables) {
		      var retryCache = getRetryCache(finishedWork);
		      wakeables.forEach(function (wakeable) {
		        var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
		        if (!retryCache.has(wakeable)) {
		          retryCache.add(wakeable);
		          if (isDevToolsPresent)
		            if (null !== inProgressLanes && null !== inProgressRoot)
		              restorePendingUpdaters(inProgressRoot, inProgressLanes);
		            else
		              throw Error(
		                "Expected finished root and lanes to be set. This is a bug in React."
		              );
		          wakeable.then(retry, retry);
		        }
		      });
		    }
		    function commitMutationEffects(root, finishedWork, committedLanes) {
		      inProgressLanes = committedLanes;
		      inProgressRoot = root;
		      commitMutationEffectsOnFiber(finishedWork, root);
		      inProgressRoot = inProgressLanes = null;
		    }
		    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
		      var deletions = parentFiber.deletions;
		      if (null !== deletions)
		        for (var i = 0; i < deletions.length; i++) {
		          var root = root$jscomp$0,
		            returnFiber = parentFiber,
		            deletedFiber = deletions[i];
		          if (supportsMutation) {
		            var parent = returnFiber;
		            a: for (; null !== parent; ) {
		              switch (parent.tag) {
		                case 27:
		                case 5:
		                  hostParent = parent.stateNode;
		                  hostParentIsContainer = false;
		                  break a;
		                case 3:
		                  hostParent = parent.stateNode.containerInfo;
		                  hostParentIsContainer = true;
		                  break a;
		                case 4:
		                  hostParent = parent.stateNode.containerInfo;
		                  hostParentIsContainer = true;
		                  break a;
		              }
		              parent = parent.return;
		            }
		            if (null === hostParent)
		              throw Error(
		                "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
		              );
		            commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
		            hostParent = null;
		            hostParentIsContainer = false;
		          } else commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
		          root = deletedFiber;
		          returnFiber = root.alternate;
		          null !== returnFiber && (returnFiber.return = null);
		          root.return = null;
		        }
		      if (parentFiber.subtreeFlags & 13878)
		        for (parentFiber = parentFiber.child; null !== parentFiber; )
		          commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),
		            (parentFiber = parentFiber.sibling);
		    }
		    function commitMutationEffectsOnFiber(finishedWork, root) {
		      var current = finishedWork.alternate,
		        flags = finishedWork.flags;
		      switch (finishedWork.tag) {
		        case 0:
		        case 11:
		        case 14:
		        case 15:
		          recursivelyTraverseMutationEffects(root, finishedWork);
		          commitReconciliationEffects(finishedWork);
		          flags & 4 &&
		            (commitHookEffectListUnmount(
		              Insertion | HasEffect,
		              finishedWork,
		              finishedWork.return
		            ),
		            commitHookEffectListMount(Insertion | HasEffect, finishedWork),
		            commitHookLayoutUnmountEffects(
		              finishedWork,
		              finishedWork.return,
		              Layout | HasEffect
		            ));
		          break;
		        case 1:
		          recursivelyTraverseMutationEffects(root, finishedWork);
		          commitReconciliationEffects(finishedWork);
		          flags & 512 &&
		            (offscreenSubtreeWasHidden ||
		              null === current ||
		              safelyDetachRef(current, current.return));
		          flags & 64 &&
		            offscreenSubtreeIsHidden &&
		            ((finishedWork = finishedWork.updateQueue),
		            null !== finishedWork &&
		              ((flags = finishedWork.callbacks),
		              null !== flags &&
		                ((current = finishedWork.shared.hiddenCallbacks),
		                (finishedWork.shared.hiddenCallbacks =
		                  null === current ? flags : current.concat(flags)))));
		          break;
		        case 26:
		          if (supportsResources) {
		            var hoistableRoot = currentHoistableRoot;
		            recursivelyTraverseMutationEffects(root, finishedWork);
		            commitReconciliationEffects(finishedWork);
		            flags & 512 &&
		              (offscreenSubtreeWasHidden ||
		                null === current ||
		                safelyDetachRef(current, current.return));
		            flags & 4 &&
		              ((flags = null !== current ? current.memoizedState : null),
		              (root = finishedWork.memoizedState),
		              null === current
		                ? null === root
		                  ? null === finishedWork.stateNode
		                    ? (finishedWork.stateNode = hydrateHoistable(
		                        hoistableRoot,
		                        finishedWork.type,
		                        finishedWork.memoizedProps,
		                        finishedWork
		                      ))
		                    : mountHoistable(
		                        hoistableRoot,
		                        finishedWork.type,
		                        finishedWork.stateNode
		                      )
		                  : (finishedWork.stateNode = acquireResource(
		                      hoistableRoot,
		                      root,
		                      finishedWork.memoizedProps
		                    ))
		                : flags !== root
		                  ? (null === flags
		                      ? null !== current.stateNode &&
		                        unmountHoistable(current.stateNode)
		                      : releaseResource(flags),
		                    null === root
		                      ? mountHoistable(
		                          hoistableRoot,
		                          finishedWork.type,
		                          finishedWork.stateNode
		                        )
		                      : acquireResource(
		                          hoistableRoot,
		                          root,
		                          finishedWork.memoizedProps
		                        ))
		                  : null === root &&
		                    null !== finishedWork.stateNode &&
		                    commitHostUpdate(
		                      finishedWork,
		                      finishedWork.memoizedProps,
		                      current.memoizedProps
		                    ));
		            break;
		          }
		        case 27:
		          if (
		            supportsSingletons &&
		            flags & 4 &&
		            null === finishedWork.alternate
		          ) {
		            hoistableRoot = finishedWork.stateNode;
		            var props = finishedWork.memoizedProps;
		            try {
		              clearSingleton(hoistableRoot),
		                runWithFiberInDEV(
		                  finishedWork,
		                  acquireSingletonInstance,
		                  finishedWork.type,
		                  props,
		                  hoistableRoot,
		                  finishedWork
		                );
		            } catch (error) {
		              captureCommitPhaseError(finishedWork, finishedWork.return, error);
		            }
		          }
		        case 5:
		          recursivelyTraverseMutationEffects(root, finishedWork);
		          commitReconciliationEffects(finishedWork);
		          flags & 512 &&
		            (offscreenSubtreeWasHidden ||
		              null === current ||
		              safelyDetachRef(current, current.return));
		          if (supportsMutation) {
		            if (finishedWork.flags & 32) {
		              root = finishedWork.stateNode;
		              try {
		                runWithFiberInDEV(finishedWork, resetTextContent, root);
		              } catch (error) {
		                captureCommitPhaseError(
		                  finishedWork,
		                  finishedWork.return,
		                  error
		                );
		              }
		            }
		            flags & 4 &&
		              null != finishedWork.stateNode &&
		              ((root = finishedWork.memoizedProps),
		              commitHostUpdate(
		                finishedWork,
		                root,
		                null !== current ? current.memoizedProps : root
		              ));
		            flags & 1024 &&
		              ((needsFormReset = true),
		              "form" !== finishedWork.type &&
		                console.error(
		                  "Unexpected host component type. Expected a form. This is a bug in React."
		                ));
		          }
		          break;
		        case 6:
		          recursivelyTraverseMutationEffects(root, finishedWork);
		          commitReconciliationEffects(finishedWork);
		          if (flags & 4 && supportsMutation) {
		            if (null === finishedWork.stateNode)
		              throw Error(
		                "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
		              );
		            flags = finishedWork.memoizedProps;
		            current = null !== current ? current.memoizedProps : flags;
		            root = finishedWork.stateNode;
		            try {
		              runWithFiberInDEV(
		                finishedWork,
		                commitTextUpdate,
		                root,
		                current,
		                flags
		              );
		            } catch (error) {
		              captureCommitPhaseError(finishedWork, finishedWork.return, error);
		            }
		          }
		          break;
		        case 3:
		          hoistableRoot = pushNestedEffectDurations();
		          supportsResources
		            ? (prepareToCommitHoistables(),
		              (props = currentHoistableRoot),
		              (currentHoistableRoot = getHoistableRoot(root.containerInfo)),
		              recursivelyTraverseMutationEffects(root, finishedWork),
		              (currentHoistableRoot = props))
		            : recursivelyTraverseMutationEffects(root, finishedWork);
		          commitReconciliationEffects(finishedWork);
		          if (flags & 4) {
		            if (
		              supportsMutation &&
		              supportsHydration &&
		              null !== current &&
		              current.memoizedState.isDehydrated
		            )
		              try {
		                runWithFiberInDEV(
		                  finishedWork,
		                  commitHydratedContainer,
		                  root.containerInfo
		                );
		              } catch (error) {
		                captureCommitPhaseError(
		                  finishedWork,
		                  finishedWork.return,
		                  error
		                );
		              }
		            if (supportsPersistence) {
		              flags = root.containerInfo;
		              current = root.pendingChildren;
		              try {
		                runWithFiberInDEV(
		                  finishedWork,
		                  replaceContainerChildren,
		                  flags,
		                  current
		                );
		              } catch (error) {
		                captureCommitPhaseError(
		                  finishedWork,
		                  finishedWork.return,
		                  error
		                );
		              }
		            }
		          }
		          needsFormReset &&
		            ((needsFormReset = false), recursivelyResetForms(finishedWork));
		          root.effectDuration += popNestedEffectDurations(hoistableRoot);
		          break;
		        case 4:
		          supportsResources
		            ? ((current = currentHoistableRoot),
		              (currentHoistableRoot = getHoistableRoot(
		                finishedWork.stateNode.containerInfo
		              )),
		              recursivelyTraverseMutationEffects(root, finishedWork),
		              commitReconciliationEffects(finishedWork),
		              (currentHoistableRoot = current))
		            : (recursivelyTraverseMutationEffects(root, finishedWork),
		              commitReconciliationEffects(finishedWork));
		          flags & 4 &&
		            supportsPersistence &&
		            commitHostPortalContainerChildren(
		              finishedWork.stateNode,
		              finishedWork,
		              finishedWork.stateNode.pendingChildren
		            );
		          break;
		        case 12:
		          flags = pushNestedEffectDurations();
		          recursivelyTraverseMutationEffects(root, finishedWork);
		          commitReconciliationEffects(finishedWork);
		          finishedWork.stateNode.effectDuration +=
		            bubbleNestedEffectDurations(flags);
		          break;
		        case 13:
		          recursivelyTraverseMutationEffects(root, finishedWork);
		          commitReconciliationEffects(finishedWork);
		          finishedWork.child.flags & 8192 &&
		            (null !== finishedWork.memoizedState) !==
		              (null !== current && null !== current.memoizedState) &&
		            (globalMostRecentFallbackTime = now$1());
		          flags & 4 &&
		            ((flags = finishedWork.updateQueue),
		            null !== flags &&
		              ((finishedWork.updateQueue = null),
		              attachSuspenseRetryListeners(finishedWork, flags)));
		          break;
		        case 22:
		          flags & 512 &&
		            (offscreenSubtreeWasHidden ||
		              null === current ||
		              safelyDetachRef(current, current.return));
		          hoistableRoot = null !== finishedWork.memoizedState;
		          var wasHidden = null !== current && null !== current.memoizedState,
		            prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
		            prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
		          offscreenSubtreeIsHidden =
		            prevOffscreenSubtreeIsHidden || hoistableRoot;
		          offscreenSubtreeWasHidden =
		            prevOffscreenSubtreeWasHidden || wasHidden;
		          recursivelyTraverseMutationEffects(root, finishedWork);
		          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
		          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
		          commitReconciliationEffects(finishedWork);
		          root = finishedWork.stateNode;
		          root._current = finishedWork;
		          root._visibility &= -3;
		          root._visibility |= root._pendingVisibility & 2;
		          if (
		            flags & 8192 &&
		            ((root._visibility = hoistableRoot
		              ? root._visibility & -2
		              : root._visibility | 1),
		            hoistableRoot &&
		              ((root = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden),
		              null === current ||
		                wasHidden ||
		                root ||
		                recursivelyTraverseDisappearLayoutEffects(finishedWork)),
		            supportsMutation &&
		              (null === finishedWork.memoizedProps ||
		                "manual" !== finishedWork.memoizedProps.mode))
		          )
		            a: if (((current = null), supportsMutation))
		              for (root = finishedWork; ; ) {
		                if (
		                  5 === root.tag ||
		                  (supportsResources && 26 === root.tag) ||
		                  (supportsSingletons && 27 === root.tag)
		                ) {
		                  if (null === current) {
		                    wasHidden = current = root;
		                    try {
		                      (props = wasHidden.stateNode),
		                        hoistableRoot
		                          ? runWithFiberInDEV(wasHidden, hideInstance, props)
		                          : runWithFiberInDEV(
		                              wasHidden,
		                              unhideInstance,
		                              wasHidden.stateNode,
		                              wasHidden.memoizedProps
		                            );
		                    } catch (error) {
		                      captureCommitPhaseError(
		                        wasHidden,
		                        wasHidden.return,
		                        error
		                      );
		                    }
		                  }
		                } else if (6 === root.tag) {
		                  if (null === current) {
		                    wasHidden = root;
		                    try {
		                      var instance = wasHidden.stateNode;
		                      hoistableRoot
		                        ? runWithFiberInDEV(
		                            wasHidden,
		                            hideTextInstance,
		                            instance
		                          )
		                        : runWithFiberInDEV(
		                            wasHidden,
		                            unhideTextInstance,
		                            instance,
		                            wasHidden.memoizedProps
		                          );
		                    } catch (error) {
		                      captureCommitPhaseError(
		                        wasHidden,
		                        wasHidden.return,
		                        error
		                      );
		                    }
		                  }
		                } else if (
		                  ((22 !== root.tag && 23 !== root.tag) ||
		                    null === root.memoizedState ||
		                    root === finishedWork) &&
		                  null !== root.child
		                ) {
		                  root.child.return = root;
		                  root = root.child;
		                  continue;
		                }
		                if (root === finishedWork) break a;
		                for (; null === root.sibling; ) {
		                  if (null === root.return || root.return === finishedWork)
		                    break a;
		                  current === root && (current = null);
		                  root = root.return;
		                }
		                current === root && (current = null);
		                root.sibling.return = root.return;
		                root = root.sibling;
		              }
		          flags & 4 &&
		            ((flags = finishedWork.updateQueue),
		            null !== flags &&
		              ((current = flags.retryQueue),
		              null !== current &&
		                ((flags.retryQueue = null),
		                attachSuspenseRetryListeners(finishedWork, current))));
		          break;
		        case 19:
		          recursivelyTraverseMutationEffects(root, finishedWork);
		          commitReconciliationEffects(finishedWork);
		          flags & 4 &&
		            ((flags = finishedWork.updateQueue),
		            null !== flags &&
		              ((finishedWork.updateQueue = null),
		              attachSuspenseRetryListeners(finishedWork, flags)));
		          break;
		        case 21:
		          break;
		        default:
		          recursivelyTraverseMutationEffects(root, finishedWork),
		            commitReconciliationEffects(finishedWork);
		      }
		    }
		    function commitReconciliationEffects(finishedWork) {
		      var flags = finishedWork.flags;
		      if (flags & 2) {
		        try {
		          runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);
		        } catch (error) {
		          captureCommitPhaseError(finishedWork, finishedWork.return, error);
		        }
		        finishedWork.flags &= -3;
		      }
		      flags & 4096 && (finishedWork.flags &= -4097);
		    }
		    function recursivelyResetForms(parentFiber) {
		      if (parentFiber.subtreeFlags & 1024)
		        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
		          var fiber = parentFiber;
		          recursivelyResetForms(fiber);
		          5 === fiber.tag &&
		            fiber.flags & 1024 &&
		            resetFormInstance(fiber.stateNode);
		          parentFiber = parentFiber.sibling;
		        }
		    }
		    function commitLayoutEffects(finishedWork, root, committedLanes) {
		      inProgressLanes = committedLanes;
		      inProgressRoot = root;
		      commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);
		      inProgressRoot = inProgressLanes = null;
		    }
		    function recursivelyTraverseLayoutEffects(root, parentFiber) {
		      if (parentFiber.subtreeFlags & 8772)
		        for (parentFiber = parentFiber.child; null !== parentFiber; )
		          commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),
		            (parentFiber = parentFiber.sibling);
		    }
		    function disappearLayoutEffects(finishedWork) {
		      switch (finishedWork.tag) {
		        case 0:
		        case 11:
		        case 14:
		        case 15:
		          commitHookLayoutUnmountEffects(
		            finishedWork,
		            finishedWork.return,
		            Layout
		          );
		          recursivelyTraverseDisappearLayoutEffects(finishedWork);
		          break;
		        case 1:
		          safelyDetachRef(finishedWork, finishedWork.return);
		          var instance = finishedWork.stateNode;
		          "function" === typeof instance.componentWillUnmount &&
		            safelyCallComponentWillUnmount(
		              finishedWork,
		              finishedWork.return,
		              instance
		            );
		          recursivelyTraverseDisappearLayoutEffects(finishedWork);
		          break;
		        case 26:
		        case 27:
		        case 5:
		          safelyDetachRef(finishedWork, finishedWork.return);
		          recursivelyTraverseDisappearLayoutEffects(finishedWork);
		          break;
		        case 22:
		          safelyDetachRef(finishedWork, finishedWork.return);
		          null === finishedWork.memoizedState &&
		            recursivelyTraverseDisappearLayoutEffects(finishedWork);
		          break;
		        default:
		          recursivelyTraverseDisappearLayoutEffects(finishedWork);
		      }
		    }
		    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
		      for (parentFiber = parentFiber.child; null !== parentFiber; )
		        disappearLayoutEffects(parentFiber),
		          (parentFiber = parentFiber.sibling);
		    }
		    function reappearLayoutEffects(
		      finishedRoot,
		      current,
		      finishedWork,
		      includeWorkInProgressEffects
		    ) {
		      var flags = finishedWork.flags;
		      switch (finishedWork.tag) {
		        case 0:
		        case 11:
		        case 15:
		          recursivelyTraverseReappearLayoutEffects(
		            finishedRoot,
		            finishedWork,
		            includeWorkInProgressEffects
		          );
		          commitHookLayoutEffects(finishedWork, Layout);
		          break;
		        case 1:
		          recursivelyTraverseReappearLayoutEffects(
		            finishedRoot,
		            finishedWork,
		            includeWorkInProgressEffects
		          );
		          current = finishedWork.stateNode;
		          "function" === typeof current.componentDidMount &&
		            runWithFiberInDEV(
		              finishedWork,
		              callComponentDidMountInDEV,
		              finishedWork,
		              current
		            );
		          current = finishedWork.updateQueue;
		          if (null !== current) {
		            finishedRoot = finishedWork.stateNode;
		            try {
		              runWithFiberInDEV(
		                finishedWork,
		                commitHiddenCallbacks,
		                current,
		                finishedRoot
		              );
		            } catch (error) {
		              captureCommitPhaseError(finishedWork, finishedWork.return, error);
		            }
		          }
		          includeWorkInProgressEffects &&
		            flags & 64 &&
		            commitClassCallbacks(finishedWork);
		          safelyAttachRef(finishedWork, finishedWork.return);
		          break;
		        case 26:
		        case 27:
		        case 5:
		          recursivelyTraverseReappearLayoutEffects(
		            finishedRoot,
		            finishedWork,
		            includeWorkInProgressEffects
		          );
		          includeWorkInProgressEffects &&
		            null === current &&
		            flags & 4 &&
		            commitHostMount(finishedWork);
		          safelyAttachRef(finishedWork, finishedWork.return);
		          break;
		        case 12:
		          if (includeWorkInProgressEffects && flags & 4) {
		            flags = pushNestedEffectDurations();
		            recursivelyTraverseReappearLayoutEffects(
		              finishedRoot,
		              finishedWork,
		              includeWorkInProgressEffects
		            );
		            includeWorkInProgressEffects = finishedWork.stateNode;
		            includeWorkInProgressEffects.effectDuration +=
		              bubbleNestedEffectDurations(flags);
		            try {
		              runWithFiberInDEV(
		                finishedWork,
		                commitProfiler,
		                finishedWork,
		                current,
		                commitStartTime,
		                includeWorkInProgressEffects.effectDuration
		              );
		            } catch (error) {
		              captureCommitPhaseError(finishedWork, finishedWork.return, error);
		            }
		          } else
		            recursivelyTraverseReappearLayoutEffects(
		              finishedRoot,
		              finishedWork,
		              includeWorkInProgressEffects
		            );
		          break;
		        case 13:
		          recursivelyTraverseReappearLayoutEffects(
		            finishedRoot,
		            finishedWork,
		            includeWorkInProgressEffects
		          );
		          includeWorkInProgressEffects &&
		            flags & 4 &&
		            commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
		          break;
		        case 22:
		          null === finishedWork.memoizedState &&
		            recursivelyTraverseReappearLayoutEffects(
		              finishedRoot,
		              finishedWork,
		              includeWorkInProgressEffects
		            );
		          safelyAttachRef(finishedWork, finishedWork.return);
		          break;
		        default:
		          recursivelyTraverseReappearLayoutEffects(
		            finishedRoot,
		            finishedWork,
		            includeWorkInProgressEffects
		          );
		      }
		    }
		    function recursivelyTraverseReappearLayoutEffects(
		      finishedRoot,
		      parentFiber,
		      includeWorkInProgressEffects
		    ) {
		      includeWorkInProgressEffects =
		        includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
		      for (parentFiber = parentFiber.child; null !== parentFiber; )
		        reappearLayoutEffects(
		          finishedRoot,
		          parentFiber.alternate,
		          parentFiber,
		          includeWorkInProgressEffects
		        ),
		          (parentFiber = parentFiber.sibling);
		    }
		    function commitOffscreenPassiveMountEffects(current, finishedWork) {
		      var previousCache = null;
		      null !== current &&
		        null !== current.memoizedState &&
		        null !== current.memoizedState.cachePool &&
		        (previousCache = current.memoizedState.cachePool.pool);
		      current = null;
		      null !== finishedWork.memoizedState &&
		        null !== finishedWork.memoizedState.cachePool &&
		        (current = finishedWork.memoizedState.cachePool.pool);
		      current !== previousCache &&
		        (null != current && retainCache(current),
		        null != previousCache && releaseCache(previousCache));
		    }
		    function commitCachePassiveMountEffect(current, finishedWork) {
		      current = null;
		      null !== finishedWork.alternate &&
		        (current = finishedWork.alternate.memoizedState.cache);
		      finishedWork = finishedWork.memoizedState.cache;
		      finishedWork !== current &&
		        (retainCache(finishedWork), null != current && releaseCache(current));
		    }
		    function recursivelyTraversePassiveMountEffects(
		      root,
		      parentFiber,
		      committedLanes,
		      committedTransitions
		    ) {
		      if (parentFiber.subtreeFlags & 10256)
		        for (parentFiber = parentFiber.child; null !== parentFiber; )
		          commitPassiveMountOnFiber(
		            root,
		            parentFiber,
		            committedLanes,
		            committedTransitions
		          ),
		            (parentFiber = parentFiber.sibling);
		    }
		    function commitPassiveMountOnFiber(
		      finishedRoot,
		      finishedWork,
		      committedLanes,
		      committedTransitions
		    ) {
		      var flags = finishedWork.flags;
		      switch (finishedWork.tag) {
		        case 0:
		        case 11:
		        case 15:
		          recursivelyTraversePassiveMountEffects(
		            finishedRoot,
		            finishedWork,
		            committedLanes,
		            committedTransitions
		          );
		          flags & 2048 &&
		            commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);
		          break;
		        case 3:
		          var prevEffectDuration = pushNestedEffectDurations();
		          recursivelyTraversePassiveMountEffects(
		            finishedRoot,
		            finishedWork,
		            committedLanes,
		            committedTransitions
		          );
		          flags & 2048 &&
		            ((committedLanes = null),
		            null !== finishedWork.alternate &&
		              (committedLanes = finishedWork.alternate.memoizedState.cache),
		            (finishedWork = finishedWork.memoizedState.cache),
		            finishedWork !== committedLanes &&
		              (retainCache(finishedWork),
		              null != committedLanes && releaseCache(committedLanes)));
		          finishedRoot.passiveEffectDuration +=
		            popNestedEffectDurations(prevEffectDuration);
		          break;
		        case 12:
		          if (flags & 2048) {
		            prevEffectDuration = pushNestedEffectDurations();
		            recursivelyTraversePassiveMountEffects(
		              finishedRoot,
		              finishedWork,
		              committedLanes,
		              committedTransitions
		            );
		            finishedRoot = finishedWork.stateNode;
		            finishedRoot.passiveEffectDuration +=
		              bubbleNestedEffectDurations(prevEffectDuration);
		            try {
		              runWithFiberInDEV(
		                finishedWork,
		                commitProfilerPostCommitImpl,
		                finishedWork,
		                finishedWork.alternate,
		                commitStartTime,
		                finishedRoot.passiveEffectDuration
		              );
		            } catch (error) {
		              captureCommitPhaseError(finishedWork, finishedWork.return, error);
		            }
		          } else
		            recursivelyTraversePassiveMountEffects(
		              finishedRoot,
		              finishedWork,
		              committedLanes,
		              committedTransitions
		            );
		          break;
		        case 23:
		          break;
		        case 22:
		          prevEffectDuration = finishedWork.stateNode;
		          null !== finishedWork.memoizedState
		            ? prevEffectDuration._visibility & 4
		              ? recursivelyTraversePassiveMountEffects(
		                  finishedRoot,
		                  finishedWork,
		                  committedLanes,
		                  committedTransitions
		                )
		              : recursivelyTraverseAtomicPassiveEffects(
		                  finishedRoot,
		                  finishedWork
		                )
		            : prevEffectDuration._visibility & 4
		              ? recursivelyTraversePassiveMountEffects(
		                  finishedRoot,
		                  finishedWork,
		                  committedLanes,
		                  committedTransitions
		                )
		              : ((prevEffectDuration._visibility |= 4),
		                recursivelyTraverseReconnectPassiveEffects(
		                  finishedRoot,
		                  finishedWork,
		                  committedLanes,
		                  committedTransitions,
		                  0 !== (finishedWork.subtreeFlags & 10256)
		                ));
		          flags & 2048 &&
		            commitOffscreenPassiveMountEffects(
		              finishedWork.alternate,
		              finishedWork
		            );
		          break;
		        case 24:
		          recursivelyTraversePassiveMountEffects(
		            finishedRoot,
		            finishedWork,
		            committedLanes,
		            committedTransitions
		          );
		          flags & 2048 &&
		            commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
		          break;
		        default:
		          recursivelyTraversePassiveMountEffects(
		            finishedRoot,
		            finishedWork,
		            committedLanes,
		            committedTransitions
		          );
		      }
		    }
		    function recursivelyTraverseReconnectPassiveEffects(
		      finishedRoot,
		      parentFiber,
		      committedLanes,
		      committedTransitions,
		      includeWorkInProgressEffects
		    ) {
		      includeWorkInProgressEffects =
		        includeWorkInProgressEffects &&
		        0 !== (parentFiber.subtreeFlags & 10256);
		      for (parentFiber = parentFiber.child; null !== parentFiber; )
		        reconnectPassiveEffects(
		          finishedRoot,
		          parentFiber,
		          committedLanes,
		          committedTransitions,
		          includeWorkInProgressEffects
		        ),
		          (parentFiber = parentFiber.sibling);
		    }
		    function reconnectPassiveEffects(
		      finishedRoot,
		      finishedWork,
		      committedLanes,
		      committedTransitions,
		      includeWorkInProgressEffects
		    ) {
		      var flags = finishedWork.flags;
		      switch (finishedWork.tag) {
		        case 0:
		        case 11:
		        case 15:
		          recursivelyTraverseReconnectPassiveEffects(
		            finishedRoot,
		            finishedWork,
		            committedLanes,
		            committedTransitions,
		            includeWorkInProgressEffects
		          );
		          commitHookPassiveMountEffects(finishedWork, Passive);
		          break;
		        case 23:
		          break;
		        case 22:
		          var _instance2 = finishedWork.stateNode;
		          null !== finishedWork.memoizedState
		            ? _instance2._visibility & 4
		              ? recursivelyTraverseReconnectPassiveEffects(
		                  finishedRoot,
		                  finishedWork,
		                  committedLanes,
		                  committedTransitions,
		                  includeWorkInProgressEffects
		                )
		              : recursivelyTraverseAtomicPassiveEffects(
		                  finishedRoot,
		                  finishedWork
		                )
		            : ((_instance2._visibility |= 4),
		              recursivelyTraverseReconnectPassiveEffects(
		                finishedRoot,
		                finishedWork,
		                committedLanes,
		                committedTransitions,
		                includeWorkInProgressEffects
		              ));
		          includeWorkInProgressEffects &&
		            flags & 2048 &&
		            commitOffscreenPassiveMountEffects(
		              finishedWork.alternate,
		              finishedWork
		            );
		          break;
		        case 24:
		          recursivelyTraverseReconnectPassiveEffects(
		            finishedRoot,
		            finishedWork,
		            committedLanes,
		            committedTransitions,
		            includeWorkInProgressEffects
		          );
		          includeWorkInProgressEffects &&
		            flags & 2048 &&
		            commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
		          break;
		        default:
		          recursivelyTraverseReconnectPassiveEffects(
		            finishedRoot,
		            finishedWork,
		            committedLanes,
		            committedTransitions,
		            includeWorkInProgressEffects
		          );
		      }
		    }
		    function recursivelyTraverseAtomicPassiveEffects(
		      finishedRoot$jscomp$0,
		      parentFiber
		    ) {
		      if (parentFiber.subtreeFlags & 10256)
		        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
		          var finishedRoot = finishedRoot$jscomp$0,
		            finishedWork = parentFiber,
		            flags = finishedWork.flags;
		          switch (finishedWork.tag) {
		            case 22:
		              recursivelyTraverseAtomicPassiveEffects(
		                finishedRoot,
		                finishedWork
		              );
		              flags & 2048 &&
		                commitOffscreenPassiveMountEffects(
		                  finishedWork.alternate,
		                  finishedWork
		                );
		              break;
		            case 24:
		              recursivelyTraverseAtomicPassiveEffects(
		                finishedRoot,
		                finishedWork
		              );
		              flags & 2048 &&
		                commitCachePassiveMountEffect(
		                  finishedWork.alternate,
		                  finishedWork
		                );
		              break;
		            default:
		              recursivelyTraverseAtomicPassiveEffects(
		                finishedRoot,
		                finishedWork
		              );
		          }
		          parentFiber = parentFiber.sibling;
		        }
		    }
		    function recursivelyAccumulateSuspenseyCommit(parentFiber) {
		      if (parentFiber.subtreeFlags & suspenseyCommitFlag)
		        for (parentFiber = parentFiber.child; null !== parentFiber; )
		          accumulateSuspenseyCommitOnFiber(parentFiber),
		            (parentFiber = parentFiber.sibling);
		    }
		    function accumulateSuspenseyCommitOnFiber(fiber) {
		      switch (fiber.tag) {
		        case 26:
		          recursivelyAccumulateSuspenseyCommit(fiber);
		          fiber.flags & suspenseyCommitFlag &&
		            (null !== fiber.memoizedState
		              ? suspendResource(
		                  currentHoistableRoot,
		                  fiber.memoizedState,
		                  fiber.memoizedProps
		                )
		              : suspendInstance(fiber.type, fiber.memoizedProps));
		          break;
		        case 5:
		          recursivelyAccumulateSuspenseyCommit(fiber);
		          fiber.flags & suspenseyCommitFlag &&
		            suspendInstance(fiber.type, fiber.memoizedProps);
		          break;
		        case 3:
		        case 4:
		          if (supportsResources) {
		            var previousHoistableRoot = currentHoistableRoot;
		            currentHoistableRoot = getHoistableRoot(
		              fiber.stateNode.containerInfo
		            );
		            recursivelyAccumulateSuspenseyCommit(fiber);
		            currentHoistableRoot = previousHoistableRoot;
		          } else recursivelyAccumulateSuspenseyCommit(fiber);
		          break;
		        case 22:
		          null === fiber.memoizedState &&
		            ((previousHoistableRoot = fiber.alternate),
		            null !== previousHoistableRoot &&
		            null !== previousHoistableRoot.memoizedState
		              ? ((previousHoistableRoot = suspenseyCommitFlag),
		                (suspenseyCommitFlag = 16777216),
		                recursivelyAccumulateSuspenseyCommit(fiber),
		                (suspenseyCommitFlag = previousHoistableRoot))
		              : recursivelyAccumulateSuspenseyCommit(fiber));
		          break;
		        default:
		          recursivelyAccumulateSuspenseyCommit(fiber);
		      }
		    }
		    function detachAlternateSiblings(parentFiber) {
		      var previousFiber = parentFiber.alternate;
		      if (
		        null !== previousFiber &&
		        ((parentFiber = previousFiber.child), null !== parentFiber)
		      ) {
		        previousFiber.child = null;
		        do
		          (previousFiber = parentFiber.sibling),
		            (parentFiber.sibling = null),
		            (parentFiber = previousFiber);
		        while (null !== parentFiber);
		      }
		    }
		    function recursivelyTraversePassiveUnmountEffects(parentFiber) {
		      var deletions = parentFiber.deletions;
		      if (0 !== (parentFiber.flags & 16)) {
		        if (null !== deletions)
		          for (var i = 0; i < deletions.length; i++) {
		            var childToDelete = deletions[i];
		            nextEffect = childToDelete;
		            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
		              childToDelete,
		              parentFiber
		            );
		          }
		        detachAlternateSiblings(parentFiber);
		      }
		      if (parentFiber.subtreeFlags & 10256)
		        for (parentFiber = parentFiber.child; null !== parentFiber; )
		          commitPassiveUnmountOnFiber(parentFiber),
		            (parentFiber = parentFiber.sibling);
		    }
		    function commitPassiveUnmountOnFiber(finishedWork) {
		      switch (finishedWork.tag) {
		        case 0:
		        case 11:
		        case 15:
		          recursivelyTraversePassiveUnmountEffects(finishedWork);
		          finishedWork.flags & 2048 &&
		            commitHookPassiveUnmountEffects(
		              finishedWork,
		              finishedWork.return,
		              Passive | HasEffect
		            );
		          break;
		        case 3:
		          var prevEffectDuration = pushNestedEffectDurations();
		          recursivelyTraversePassiveUnmountEffects(finishedWork);
		          finishedWork.stateNode.passiveEffectDuration +=
		            popNestedEffectDurations(prevEffectDuration);
		          break;
		        case 12:
		          prevEffectDuration = pushNestedEffectDurations();
		          recursivelyTraversePassiveUnmountEffects(finishedWork);
		          finishedWork.stateNode.passiveEffectDuration +=
		            bubbleNestedEffectDurations(prevEffectDuration);
		          break;
		        case 22:
		          prevEffectDuration = finishedWork.stateNode;
		          null !== finishedWork.memoizedState &&
		          prevEffectDuration._visibility & 4 &&
		          (null === finishedWork.return || 13 !== finishedWork.return.tag)
		            ? ((prevEffectDuration._visibility &= -5),
		              recursivelyTraverseDisconnectPassiveEffects(finishedWork))
		            : recursivelyTraversePassiveUnmountEffects(finishedWork);
		          break;
		        default:
		          recursivelyTraversePassiveUnmountEffects(finishedWork);
		      }
		    }
		    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
		      var deletions = parentFiber.deletions;
		      if (0 !== (parentFiber.flags & 16)) {
		        if (null !== deletions)
		          for (var i = 0; i < deletions.length; i++) {
		            var childToDelete = deletions[i];
		            nextEffect = childToDelete;
		            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
		              childToDelete,
		              parentFiber
		            );
		          }
		        detachAlternateSiblings(parentFiber);
		      }
		      for (parentFiber = parentFiber.child; null !== parentFiber; )
		        disconnectPassiveEffect(parentFiber),
		          (parentFiber = parentFiber.sibling);
		    }
		    function disconnectPassiveEffect(finishedWork) {
		      switch (finishedWork.tag) {
		        case 0:
		        case 11:
		        case 15:
		          commitHookPassiveUnmountEffects(
		            finishedWork,
		            finishedWork.return,
		            Passive
		          );
		          recursivelyTraverseDisconnectPassiveEffects(finishedWork);
		          break;
		        case 22:
		          var instance = finishedWork.stateNode;
		          instance._visibility & 4 &&
		            ((instance._visibility &= -5),
		            recursivelyTraverseDisconnectPassiveEffects(finishedWork));
		          break;
		        default:
		          recursivelyTraverseDisconnectPassiveEffects(finishedWork);
		      }
		    }
		    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
		      deletedSubtreeRoot,
		      nearestMountedAncestor
		    ) {
		      for (; null !== nextEffect; ) {
		        var fiber = nextEffect,
		          current = fiber;
		        switch (current.tag) {
		          case 0:
		          case 11:
		          case 15:
		            commitHookPassiveUnmountEffects(
		              current,
		              nearestMountedAncestor,
		              Passive
		            );
		            break;
		          case 23:
		          case 22:
		            null !== current.memoizedState &&
		              null !== current.memoizedState.cachePool &&
		              ((current = current.memoizedState.cachePool.pool),
		              null != current && retainCache(current));
		            break;
		          case 24:
		            releaseCache(current.memoizedState.cache);
		        }
		        current = fiber.child;
		        if (null !== current) (current.return = fiber), (nextEffect = current);
		        else
		          a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
		            current = nextEffect;
		            var sibling = current.sibling,
		              returnFiber = current.return;
		            detachFiberAfterEffects(current);
		            if (current === fiber) {
		              nextEffect = null;
		              break a;
		            }
		            if (null !== sibling) {
		              sibling.return = returnFiber;
		              nextEffect = sibling;
		              break a;
		            }
		            nextEffect = returnFiber;
		          }
		      }
		    }
		    function findFiberRootForHostRoot(hostRoot) {
		      var maybeFiber = getInstanceFromNode(hostRoot);
		      if (null != maybeFiber) {
		        if ("string" !== typeof maybeFiber.memoizedProps["data-testname"])
		          throw Error(
		            "Invalid host root specified. Should be either a React container or a node with a testname attribute."
		          );
		        return maybeFiber;
		      }
		      hostRoot = findFiberRoot(hostRoot);
		      if (null === hostRoot)
		        throw Error(
		          "Could not find React container within specified host subtree."
		        );
		      return hostRoot.stateNode.current;
		    }
		    function matchSelector(fiber$jscomp$0, selector) {
		      var tag = fiber$jscomp$0.tag;
		      switch (selector.$$typeof) {
		        case COMPONENT_TYPE:
		          if (fiber$jscomp$0.type === selector.value) return true;
		          break;
		        case HAS_PSEUDO_CLASS_TYPE:
		          a: {
		            selector = selector.value;
		            fiber$jscomp$0 = [fiber$jscomp$0, 0];
		            for (tag = 0; tag < fiber$jscomp$0.length; ) {
		              var fiber = fiber$jscomp$0[tag++],
		                tag$jscomp$0 = fiber.tag,
		                selectorIndex = fiber$jscomp$0[tag++],
		                selector$jscomp$0 = selector[selectorIndex];
		              if (
		                (5 !== tag$jscomp$0 &&
		                  26 !== tag$jscomp$0 &&
		                  27 !== tag$jscomp$0) ||
		                !isHiddenSubtree(fiber)
		              ) {
		                for (
		                  ;
		                  null != selector$jscomp$0 &&
		                  matchSelector(fiber, selector$jscomp$0);

		                )
		                  selectorIndex++,
		                    (selector$jscomp$0 = selector[selectorIndex]);
		                if (selectorIndex === selector.length) {
		                  selector = true;
		                  break a;
		                } else
		                  for (fiber = fiber.child; null !== fiber; )
		                    fiber$jscomp$0.push(fiber, selectorIndex),
		                      (fiber = fiber.sibling);
		              }
		            }
		            selector = false;
		          }
		          return selector;
		        case ROLE_TYPE:
		          if (
		            (5 === tag || 26 === tag || 27 === tag) &&
		            matchAccessibilityRole(fiber$jscomp$0.stateNode, selector.value)
		          )
		            return true;
		          break;
		        case TEXT_TYPE:
		          if (5 === tag || 6 === tag || 26 === tag || 27 === tag)
		            if (
		              ((fiber$jscomp$0 = getTextContent(fiber$jscomp$0)),
		              null !== fiber$jscomp$0 &&
		                0 <= fiber$jscomp$0.indexOf(selector.value))
		            )
		              return true;
		          break;
		        case TEST_NAME_TYPE:
		          if (5 === tag || 26 === tag || 27 === tag)
		            if (
		              ((fiber$jscomp$0 = fiber$jscomp$0.memoizedProps["data-testname"]),
		              "string" === typeof fiber$jscomp$0 &&
		                fiber$jscomp$0.toLowerCase() === selector.value.toLowerCase())
		            )
		              return true;
		          break;
		        default:
		          throw Error("Invalid selector type specified.");
		      }
		      return false;
		    }
		    function selectorToString(selector) {
		      switch (selector.$$typeof) {
		        case COMPONENT_TYPE:
		          return (
		            "<" + (getComponentNameFromType(selector.value) || "Unknown") + ">"
		          );
		        case HAS_PSEUDO_CLASS_TYPE:
		          return ":has(" + (selectorToString(selector) || "") + ")";
		        case ROLE_TYPE:
		          return '[role="' + selector.value + '"]';
		        case TEXT_TYPE:
		          return '"' + selector.value + '"';
		        case TEST_NAME_TYPE:
		          return '[data-testname="' + selector.value + '"]';
		        default:
		          throw Error("Invalid selector type specified.");
		      }
		    }
		    function findPaths(root, selectors) {
		      var matchingFibers = [];
		      root = [root, 0];
		      for (var index = 0; index < root.length; ) {
		        var fiber = root[index++],
		          tag = fiber.tag,
		          selectorIndex = root[index++],
		          selector = selectors[selectorIndex];
		        if (
		          (5 !== tag && 26 !== tag && 27 !== tag) ||
		          !isHiddenSubtree(fiber)
		        ) {
		          for (; null != selector && matchSelector(fiber, selector); )
		            selectorIndex++, (selector = selectors[selectorIndex]);
		          if (selectorIndex === selectors.length) matchingFibers.push(fiber);
		          else
		            for (fiber = fiber.child; null !== fiber; )
		              root.push(fiber, selectorIndex), (fiber = fiber.sibling);
		        }
		      }
		      return matchingFibers;
		    }
		    function findAllNodes(hostRoot, selectors) {
		      if (!supportsTestSelectors)
		        throw Error("Test selector API is not supported by this renderer.");
		      hostRoot = findFiberRootForHostRoot(hostRoot);
		      hostRoot = findPaths(hostRoot, selectors);
		      selectors = [];
		      hostRoot = Array.from(hostRoot);
		      for (var index = 0; index < hostRoot.length; ) {
		        var node = hostRoot[index++],
		          tag = node.tag;
		        if (5 === tag || 26 === tag || 27 === tag)
		          isHiddenSubtree(node) || selectors.push(node.stateNode);
		        else
		          for (node = node.child; null !== node; )
		            hostRoot.push(node), (node = node.sibling);
		      }
		      return selectors;
		    }
		    function onCommitRoot() {
		      supportsTestSelectors &&
		        commitHooks.forEach(function (commitHook) {
		          return commitHook();
		        });
		    }
		    function isConcurrentActEnvironment() {
		      var isReactActEnvironmentGlobal =
		        "undefined" !== typeof IS_REACT_ACT_ENVIRONMENT
		          ? IS_REACT_ACT_ENVIRONMENT
		          : void 0;
		      isReactActEnvironmentGlobal ||
		        null === ReactSharedInternals.actQueue ||
		        console.error(
		          "The current testing environment is not configured to support act(...)"
		        );
		      return isReactActEnvironmentGlobal;
		    }
		    function requestUpdateLane(fiber) {
		      if (
		        (executionContext & RenderContext) !== NoContext &&
		        0 !== workInProgressRootRenderLanes
		      )
		        return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
		      var transition = ReactSharedInternals.T;
		      return null !== transition
		        ? (transition._updatedFibers || (transition._updatedFibers = new Set()),
		          transition._updatedFibers.add(fiber),
		          (fiber = currentEntangledLane),
		          0 !== fiber ? fiber : requestTransitionLane())
		        : resolveUpdatePriority();
		    }
		    function requestDeferredLane() {
		      0 === workInProgressDeferredLane &&
		        (workInProgressDeferredLane =
		          0 === (workInProgressRootRenderLanes & 536870912) || isHydrating
		            ? claimNextTransitionLane()
		            : 536870912);
		      var suspenseHandler = suspenseHandlerStackCursor.current;
		      null !== suspenseHandler && (suspenseHandler.flags |= 32);
		      return workInProgressDeferredLane;
		    }
		    function scheduleUpdateOnFiber(root, fiber, lane) {
		      isRunningInsertionEffect &&
		        console.error("useInsertionEffect must not schedule updates.");
		      isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = true);
		      if (
		        (root === workInProgressRoot &&
		          workInProgressSuspendedReason === SuspendedOnData) ||
		        null !== root.cancelPendingCommit
		      )
		        prepareFreshStack(root, 0),
		          markRootSuspended(
		            root,
		            workInProgressRootRenderLanes,
		            workInProgressDeferredLane,
		            false
		          );
		      markRootUpdated$1(root, lane);
		      if (
		        0 !== (executionContext & RenderContext) &&
		        root === workInProgressRoot
		      ) {
		        if (isRendering)
		          switch (fiber.tag) {
		            case 0:
		            case 11:
		            case 15:
		              root =
		                (workInProgress && getComponentNameFromFiber(workInProgress)) ||
		                "Unknown";
		              didWarnAboutUpdateInRenderForAnotherComponent.has(root) ||
		                (didWarnAboutUpdateInRenderForAnotherComponent.add(root),
		                (fiber = getComponentNameFromFiber(fiber) || "Unknown"),
		                console.error(
		                  "Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render",
		                  fiber,
		                  root,
		                  root
		                ));
		              break;
		            case 1:
		              didWarnAboutUpdateInRender ||
		                (console.error(
		                  "Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."
		                ),
		                (didWarnAboutUpdateInRender = true));
		          }
		      } else
		        isDevToolsPresent && addFiberToLanesMap(root, fiber, lane),
		          warnIfUpdatesNotWrappedWithActDEV(fiber),
		          root === workInProgressRoot &&
		            ((executionContext & RenderContext) === NoContext &&
		              (workInProgressRootInterleavedUpdatedLanes |= lane),
		            workInProgressRootExitStatus === RootSuspendedWithDelay &&
		              markRootSuspended(
		                root,
		                workInProgressRootRenderLanes,
		                workInProgressDeferredLane,
		                false
		              )),
		          ensureRootIsScheduled(root);
		    }
		    function performWorkOnRoot(root, lanes, forceSync) {
		      if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
		        throw Error("Should not already be working.");
		      var shouldTimeSlice =
		          (!forceSync &&
		            0 === (lanes & 60) &&
		            0 === (lanes & root.expiredLanes)) ||
		          checkIfRootIsPrerendering(root, lanes),
		        exitStatus = shouldTimeSlice
		          ? renderRootConcurrent(root, lanes)
		          : renderRootSync(root, lanes, true),
		        renderWasConcurrent = shouldTimeSlice;
		      do {
		        if (exitStatus === RootInProgress) {
		          workInProgressRootIsPrerendering &&
		            !shouldTimeSlice &&
		            markRootSuspended(root, lanes, 0, false);
		          break;
		        } else if (exitStatus === RootDidNotComplete)
		          markRootSuspended(
		            root,
		            lanes,
		            0,
		            !workInProgressRootDidSkipSuspendedSiblings
		          );
		        else {
		          forceSync = root.current.alternate;
		          if (
		            renderWasConcurrent &&
		            !isRenderConsistentWithExternalStores(forceSync)
		          ) {
		            exitStatus = renderRootSync(root, lanes, false);
		            renderWasConcurrent = false;
		            continue;
		          }
		          if (exitStatus === RootErrored) {
		            renderWasConcurrent = lanes;
		            if (root.errorRecoveryDisabledLanes & renderWasConcurrent)
		              var errorRetryLanes = 0;
		            else
		              (errorRetryLanes = root.pendingLanes & -536870913),
		                (errorRetryLanes =
		                  0 !== errorRetryLanes
		                    ? errorRetryLanes
		                    : errorRetryLanes & 536870912
		                      ? 536870912
		                      : 0);
		            if (0 !== errorRetryLanes) {
		              lanes = errorRetryLanes;
		              a: {
		                exitStatus = root;
		                var errorRetryLanes$jscomp$0 = errorRetryLanes;
		                errorRetryLanes = workInProgressRootConcurrentErrors;
		                var wasRootDehydrated =
		                  supportsHydration &&
		                  exitStatus.current.memoizedState.isDehydrated;
		                wasRootDehydrated &&
		                  (prepareFreshStack(
		                    exitStatus,
		                    errorRetryLanes$jscomp$0
		                  ).flags |= 256);
		                errorRetryLanes$jscomp$0 = renderRootSync(
		                  exitStatus,
		                  errorRetryLanes$jscomp$0,
		                  false
		                );
		                if (errorRetryLanes$jscomp$0 !== RootErrored) {
		                  if (
		                    workInProgressRootDidAttachPingListener &&
		                    !wasRootDehydrated
		                  ) {
		                    exitStatus.errorRecoveryDisabledLanes |=
		                      renderWasConcurrent;
		                    workInProgressRootInterleavedUpdatedLanes |=
		                      renderWasConcurrent;
		                    exitStatus = RootSuspendedWithDelay;
		                    break a;
		                  }
		                  exitStatus = workInProgressRootRecoverableErrors;
		                  workInProgressRootRecoverableErrors = errorRetryLanes;
		                  null !== exitStatus && queueRecoverableErrors(exitStatus);
		                }
		                exitStatus = errorRetryLanes$jscomp$0;
		              }
		              renderWasConcurrent = false;
		              if (exitStatus !== RootErrored) continue;
		            }
		          }
		          if (exitStatus === RootFatalErrored) {
		            prepareFreshStack(root, 0);
		            markRootSuspended(root, lanes, 0, true);
		            break;
		          }
		          a: {
		            shouldTimeSlice = root;
		            switch (exitStatus) {
		              case RootInProgress:
		              case RootFatalErrored:
		                throw Error("Root did not complete. This is a bug in React.");
		              case RootSuspendedWithDelay:
		                if ((lanes & 4194176) === lanes) {
		                  markRootSuspended(
		                    shouldTimeSlice,
		                    lanes,
		                    workInProgressDeferredLane,
		                    !workInProgressRootDidSkipSuspendedSiblings
		                  );
		                  break a;
		                }
		                break;
		              case RootErrored:
		                workInProgressRootRecoverableErrors = null;
		                break;
		              case RootSuspended:
		              case RootCompleted:
		                break;
		              default:
		                throw Error("Unknown root exit status.");
		            }
		            shouldTimeSlice.finishedWork = forceSync;
		            shouldTimeSlice.finishedLanes = lanes;
		            if (null !== ReactSharedInternals.actQueue)
		              commitRoot(
		                shouldTimeSlice,
		                workInProgressRootRecoverableErrors,
		                workInProgressTransitions,
		                workInProgressRootDidIncludeRecursiveRenderUpdate,
		                workInProgressDeferredLane,
		                workInProgressRootInterleavedUpdatedLanes,
		                workInProgressSuspendedRetryLanes,
		                IMMEDIATE_COMMIT,
		                -0,
		                0
		              );
		            else {
		              if (
		                (lanes & 62914560) === lanes &&
		                ((exitStatus =
		                  globalMostRecentFallbackTime +
		                  FALLBACK_THROTTLE_MS -
		                  now$1()),
		                10 < exitStatus)
		              ) {
		                markRootSuspended(
		                  shouldTimeSlice,
		                  lanes,
		                  workInProgressDeferredLane,
		                  !workInProgressRootDidSkipSuspendedSiblings
		                );
		                if (0 !== getNextLanes(shouldTimeSlice, 0)) break a;
		                shouldTimeSlice.timeoutHandle = scheduleTimeout(
		                  commitRootWhenReady.bind(
		                    null,
		                    shouldTimeSlice,
		                    forceSync,
		                    workInProgressRootRecoverableErrors,
		                    workInProgressTransitions,
		                    workInProgressRootDidIncludeRecursiveRenderUpdate,
		                    lanes,
		                    workInProgressDeferredLane,
		                    workInProgressRootInterleavedUpdatedLanes,
		                    workInProgressSuspendedRetryLanes,
		                    workInProgressRootDidSkipSuspendedSiblings,
		                    THROTTLED_COMMIT,
		                    -0,
		                    0
		                  ),
		                  exitStatus
		                );
		                break a;
		              }
		              commitRootWhenReady(
		                shouldTimeSlice,
		                forceSync,
		                workInProgressRootRecoverableErrors,
		                workInProgressTransitions,
		                workInProgressRootDidIncludeRecursiveRenderUpdate,
		                lanes,
		                workInProgressDeferredLane,
		                workInProgressRootInterleavedUpdatedLanes,
		                workInProgressSuspendedRetryLanes,
		                workInProgressRootDidSkipSuspendedSiblings,
		                IMMEDIATE_COMMIT,
		                -0,
		                0
		              );
		            }
		          }
		        }
		        break;
		      } while (1);
		      ensureRootIsScheduled(root);
		    }
		    function queueRecoverableErrors(errors) {
		      null === workInProgressRootRecoverableErrors
		        ? (workInProgressRootRecoverableErrors = errors)
		        : workInProgressRootRecoverableErrors.push.apply(
		            workInProgressRootRecoverableErrors,
		            errors
		          );
		    }
		    function commitRootWhenReady(
		      root,
		      finishedWork,
		      recoverableErrors,
		      transitions,
		      didIncludeRenderPhaseUpdate,
		      lanes,
		      spawnedLane,
		      updatedLanes,
		      suspendedRetryLanes,
		      didSkipSuspendedSiblings,
		      suspendedCommitReason,
		      completedRenderStartTime,
		      completedRenderEndTime
		    ) {
		      var subtreeFlags = finishedWork.subtreeFlags;
		      if (subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408))
		        if (
		          (startSuspendingCommit(),
		          accumulateSuspenseyCommitOnFiber(finishedWork),
		          (finishedWork = waitForCommitToBeReady()),
		          null !== finishedWork)
		        ) {
		          root.cancelPendingCommit = finishedWork(
		            commitRoot.bind(
		              null,
		              root,
		              recoverableErrors,
		              transitions,
		              didIncludeRenderPhaseUpdate,
		              spawnedLane,
		              updatedLanes,
		              suspendedRetryLanes,
		              SUSPENDED_COMMIT,
		              completedRenderStartTime,
		              completedRenderEndTime
		            )
		          );
		          markRootSuspended(
		            root,
		            lanes,
		            spawnedLane,
		            !didSkipSuspendedSiblings
		          );
		          return;
		        }
		      commitRoot(
		        root,
		        recoverableErrors,
		        transitions,
		        didIncludeRenderPhaseUpdate,
		        spawnedLane,
		        updatedLanes,
		        suspendedRetryLanes,
		        suspendedCommitReason,
		        completedRenderStartTime,
		        completedRenderEndTime
		      );
		    }
		    function isRenderConsistentWithExternalStores(finishedWork) {
		      for (var node = finishedWork; ; ) {
		        var tag = node.tag;
		        if (
		          (0 === tag || 11 === tag || 15 === tag) &&
		          node.flags & 16384 &&
		          ((tag = node.updateQueue),
		          null !== tag && ((tag = tag.stores), null !== tag))
		        )
		          for (var i = 0; i < tag.length; i++) {
		            var check = tag[i],
		              getSnapshot = check.getSnapshot;
		            check = check.value;
		            try {
		              if (!objectIs(getSnapshot(), check)) return !1;
		            } catch (error) {
		              return false;
		            }
		          }
		        tag = node.child;
		        if (node.subtreeFlags & 16384 && null !== tag)
		          (tag.return = node), (node = tag);
		        else {
		          if (node === finishedWork) break;
		          for (; null === node.sibling; ) {
		            if (null === node.return || node.return === finishedWork) return true;
		            node = node.return;
		          }
		          node.sibling.return = node.return;
		          node = node.sibling;
		        }
		      }
		      return true;
		    }
		    function markRootSuspended(
		      root,
		      suspendedLanes,
		      spawnedLane,
		      didAttemptEntireTree
		    ) {
		      suspendedLanes &= ~workInProgressRootPingedLanes;
		      suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
		      root.suspendedLanes |= suspendedLanes;
		      root.pingedLanes &= ~suspendedLanes;
		      didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
		      didAttemptEntireTree = root.expirationTimes;
		      for (var lanes = suspendedLanes; 0 < lanes; ) {
		        var index = 31 - clz32(lanes),
		          lane = 1 << index;
		        didAttemptEntireTree[index] = -1;
		        lanes &= ~lane;
		      }
		      0 !== spawnedLane &&
		        markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
		    }
		    function flushSyncWork() {
		      return (executionContext & (RenderContext | CommitContext)) === NoContext
		        ? (flushSyncWorkAcrossRoots_impl(0), false)
		        : true;
		    }
		    function resetWorkInProgressStack() {
		      if (null !== workInProgress) {
		        if (workInProgressSuspendedReason === NotSuspended)
		          var interruptedWork = workInProgress.return;
		        else
		          (interruptedWork = workInProgress),
		            resetContextDependencies(),
		            resetHooksOnUnwind(interruptedWork),
		            (thenableState$1 = null),
		            (thenableIndexCounter$1 = 0),
		            (interruptedWork = workInProgress);
		        for (; null !== interruptedWork; )
		          unwindInterruptedWork(interruptedWork.alternate, interruptedWork),
		            (interruptedWork = interruptedWork.return);
		        workInProgress = null;
		      }
		    }
		    function prepareFreshStack(root, lanes) {
		      root.finishedWork = null;
		      root.finishedLanes = 0;
		      var timeoutHandle = root.timeoutHandle;
		      timeoutHandle !== noTimeout &&
		        ((root.timeoutHandle = noTimeout), cancelTimeout(timeoutHandle));
		      timeoutHandle = root.cancelPendingCommit;
		      null !== timeoutHandle &&
		        ((root.cancelPendingCommit = null), timeoutHandle());
		      resetWorkInProgressStack();
		      workInProgressRoot = root;
		      workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
		      workInProgressRootRenderLanes = lanes;
		      workInProgressSuspendedReason = NotSuspended;
		      workInProgressThrownValue = null;
		      workInProgressRootDidSkipSuspendedSiblings = false;
		      workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
		      workInProgressRootDidAttachPingListener = false;
		      workInProgressRootExitStatus = RootInProgress;
		      workInProgressSuspendedRetryLanes =
		        workInProgressDeferredLane =
		        workInProgressRootPingedLanes =
		        workInProgressRootInterleavedUpdatedLanes =
		        workInProgressRootSkippedLanes =
		          0;
		      workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =
		        null;
		      workInProgressRootDidIncludeRecursiveRenderUpdate = false;
		      0 !== (lanes & 8) && (lanes |= lanes & 32);
		      var allEntangledLanes = root.entangledLanes;
		      if (0 !== allEntangledLanes)
		        for (
		          root = root.entanglements, allEntangledLanes &= lanes;
		          0 < allEntangledLanes;

		        ) {
		          var index = 31 - clz32(allEntangledLanes),
		            lane = 1 << index;
		          lanes |= root[index];
		          allEntangledLanes &= ~lane;
		        }
		      entangledRenderLanes = lanes;
		      finishQueueingConcurrentUpdates();
		      ReactStrictModeWarnings.discardPendingWarnings();
		      return timeoutHandle;
		    }
		    function handleThrow(root, thrownValue) {
		      currentlyRenderingFiber$1 = null;
		      ReactSharedInternals.H = ContextOnlyDispatcher;
		      ReactSharedInternals.getCurrentStack = null;
		      isRendering = false;
		      current = null;
		      thrownValue === SuspenseException
		        ? ((thrownValue = getSuspendedThenable()),
		          (workInProgressSuspendedReason = SuspendedOnImmediate))
		        : thrownValue === SuspenseyCommitException
		          ? ((thrownValue = getSuspendedThenable()),
		            (workInProgressSuspendedReason = SuspendedOnInstance))
		          : (workInProgressSuspendedReason =
		              thrownValue === SelectiveHydrationException
		                ? SuspendedOnHydration
		                : null !== thrownValue &&
		                    "object" === typeof thrownValue &&
		                    "function" === typeof thrownValue.then
		                  ? SuspendedOnDeprecatedThrowPromise
		                  : SuspendedOnError);
		      workInProgressThrownValue = thrownValue;
		      var erroredWork = workInProgress;
		      if (null === erroredWork)
		        (workInProgressRootExitStatus = RootFatalErrored),
		          logUncaughtError(
		            root,
		            createCapturedValueAtFiber(thrownValue, root.current)
		          );
		      else
		        switch (
		          (erroredWork.mode & 2 &&
		            stopProfilerTimerIfRunningAndRecordDuration(erroredWork),
		          markComponentRenderStopped(),
		          workInProgressSuspendedReason)
		        ) {
		          case SuspendedOnError:
		            null !== injectedProfilingHooks &&
		              "function" ===
		                typeof injectedProfilingHooks.markComponentErrored &&
		              injectedProfilingHooks.markComponentErrored(
		                erroredWork,
		                thrownValue,
		                workInProgressRootRenderLanes
		              );
		            break;
		          case SuspendedOnData:
		          case SuspendedOnImmediate:
		          case SuspendedOnDeprecatedThrowPromise:
		          case SuspendedAndReadyToContinue:
		            null !== injectedProfilingHooks &&
		              "function" ===
		                typeof injectedProfilingHooks.markComponentSuspended &&
		              injectedProfilingHooks.markComponentSuspended(
		                erroredWork,
		                thrownValue,
		                workInProgressRootRenderLanes
		              );
		        }
		    }
		    function shouldRemainOnPreviousScreen() {
		      var handler = suspenseHandlerStackCursor.current;
		      return null === handler
		        ? true
		        : (workInProgressRootRenderLanes & 4194176) ===
		            workInProgressRootRenderLanes
		          ? null === shellBoundary
		            ? true
		            : false
		          : (workInProgressRootRenderLanes & 62914560) ===
		                workInProgressRootRenderLanes ||
		              0 !== (workInProgressRootRenderLanes & 536870912)
		            ? handler === shellBoundary
		            : false;
		    }
		    function pushDispatcher() {
		      var prevDispatcher = ReactSharedInternals.H;
		      ReactSharedInternals.H = ContextOnlyDispatcher;
		      return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
		    }
		    function pushAsyncDispatcher() {
		      var prevAsyncDispatcher = ReactSharedInternals.A;
		      ReactSharedInternals.A = DefaultAsyncDispatcher;
		      return prevAsyncDispatcher;
		    }
		    function renderDidSuspendDelayIfPossible() {
		      workInProgressRootExitStatus = RootSuspendedWithDelay;
		      workInProgressRootDidSkipSuspendedSiblings ||
		        ((workInProgressRootRenderLanes & 4194176) !==
		          workInProgressRootRenderLanes &&
		          null !== suspenseHandlerStackCursor.current) ||
		        (workInProgressRootIsPrerendering = true);
		      (0 === (workInProgressRootSkippedLanes & 134217727) &&
		        0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||
		        null === workInProgressRoot ||
		        markRootSuspended(
		          workInProgressRoot,
		          workInProgressRootRenderLanes,
		          workInProgressDeferredLane,
		          false
		        );
		    }
		    function renderRootSync(root, lanes, shouldYieldForPrerendering) {
		      var prevExecutionContext = executionContext;
		      executionContext |= RenderContext;
		      var prevDispatcher = pushDispatcher(),
		        prevAsyncDispatcher = pushAsyncDispatcher();
		      if (
		        workInProgressRoot !== root ||
		        workInProgressRootRenderLanes !== lanes
		      ) {
		        if (isDevToolsPresent) {
		          var memoizedUpdaters = root.memoizedUpdaters;
		          0 < memoizedUpdaters.size &&
		            (restorePendingUpdaters(root, workInProgressRootRenderLanes),
		            memoizedUpdaters.clear());
		          movePendingFibersToMemoized(root, lanes);
		        }
		        workInProgressTransitions = null;
		        prepareFreshStack(root, lanes);
		      }
		      markRenderStarted(lanes);
		      lanes = false;
		      memoizedUpdaters = workInProgressRootExitStatus;
		      a: do
		        try {
		          if (
		            workInProgressSuspendedReason !== NotSuspended &&
		            null !== workInProgress
		          ) {
		            var unitOfWork = workInProgress,
		              thrownValue = workInProgressThrownValue;
		            switch (workInProgressSuspendedReason) {
		              case SuspendedOnHydration:
		                resetWorkInProgressStack();
		                memoizedUpdaters = RootDidNotComplete;
		                break a;
		              case SuspendedOnImmediate:
		              case SuspendedOnData:
		              case SuspendedOnDeprecatedThrowPromise:
		                null === suspenseHandlerStackCursor.current && (lanes = !0);
		                var reason = workInProgressSuspendedReason;
		                workInProgressSuspendedReason = NotSuspended;
		                workInProgressThrownValue = null;
		                throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
		                if (
		                  shouldYieldForPrerendering &&
		                  workInProgressRootIsPrerendering
		                ) {
		                  memoizedUpdaters = RootInProgress;
		                  break a;
		                }
		                break;
		              default:
		                (reason = workInProgressSuspendedReason),
		                  (workInProgressSuspendedReason = NotSuspended),
		                  (workInProgressThrownValue = null),
		                  throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
		            }
		          }
		          workLoopSync();
		          memoizedUpdaters = workInProgressRootExitStatus;
		          break;
		        } catch (thrownValue$4) {
		          handleThrow(root, thrownValue$4);
		        }
		      while (1);
		      lanes && root.shellSuspendCounter++;
		      resetContextDependencies();
		      executionContext = prevExecutionContext;
		      ReactSharedInternals.H = prevDispatcher;
		      ReactSharedInternals.A = prevAsyncDispatcher;
		      markRenderStopped();
		      null === workInProgress &&
		        ((workInProgressRoot = null),
		        (workInProgressRootRenderLanes = 0),
		        finishQueueingConcurrentUpdates());
		      return memoizedUpdaters;
		    }
		    function workLoopSync() {
		      for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
		    }
		    function renderRootConcurrent(root, lanes) {
		      var prevExecutionContext = executionContext;
		      executionContext |= RenderContext;
		      var prevDispatcher = pushDispatcher(),
		        prevAsyncDispatcher = pushAsyncDispatcher();
		      if (
		        workInProgressRoot !== root ||
		        workInProgressRootRenderLanes !== lanes
		      ) {
		        if (isDevToolsPresent) {
		          var memoizedUpdaters = root.memoizedUpdaters;
		          0 < memoizedUpdaters.size &&
		            (restorePendingUpdaters(root, workInProgressRootRenderLanes),
		            memoizedUpdaters.clear());
		          movePendingFibersToMemoized(root, lanes);
		        }
		        workInProgressTransitions = null;
		        workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;
		        prepareFreshStack(root, lanes);
		      } else
		        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
		          root,
		          lanes
		        );
		      markRenderStarted(lanes);
		      a: do
		        try {
		          if (
		            workInProgressSuspendedReason !== NotSuspended &&
		            null !== workInProgress
		          )
		            b: switch (
		              ((lanes = workInProgress),
		              (memoizedUpdaters = workInProgressThrownValue),
		              workInProgressSuspendedReason)
		            ) {
		              case SuspendedOnError:
		                workInProgressSuspendedReason = NotSuspended;
		                workInProgressThrownValue = null;
		                throwAndUnwindWorkLoop(
		                  root,
		                  lanes,
		                  memoizedUpdaters,
		                  SuspendedOnError
		                );
		                break;
		              case SuspendedOnData:
		                if (isThenableResolved(memoizedUpdaters)) {
		                  workInProgressSuspendedReason = NotSuspended;
		                  workInProgressThrownValue = null;
		                  replaySuspendedUnitOfWork(lanes);
		                  break;
		                }
		                lanes = function () {
		                  workInProgressSuspendedReason === SuspendedOnData &&
		                    workInProgressRoot === root &&
		                    (workInProgressSuspendedReason =
		                      SuspendedAndReadyToContinue);
		                  ensureRootIsScheduled(root);
		                };
		                memoizedUpdaters.then(lanes, lanes);
		                break a;
		              case SuspendedOnImmediate:
		                workInProgressSuspendedReason = SuspendedAndReadyToContinue;
		                break a;
		              case SuspendedOnInstance:
		                workInProgressSuspendedReason =
		                  SuspendedOnInstanceAndReadyToContinue;
		                break a;
		              case SuspendedAndReadyToContinue:
		                isThenableResolved(memoizedUpdaters)
		                  ? ((workInProgressSuspendedReason = NotSuspended),
		                    (workInProgressThrownValue = null),
		                    replaySuspendedUnitOfWork(lanes))
		                  : ((workInProgressSuspendedReason = NotSuspended),
		                    (workInProgressThrownValue = null),
		                    throwAndUnwindWorkLoop(
		                      root,
		                      lanes,
		                      memoizedUpdaters,
		                      SuspendedAndReadyToContinue
		                    ));
		                break;
		              case SuspendedOnInstanceAndReadyToContinue:
		                var resource = null;
		                switch (workInProgress.tag) {
		                  case 26:
		                    resource = workInProgress.memoizedState;
		                  case 5:
		                  case 27:
		                    var hostFiber = workInProgress,
		                      type = hostFiber.type,
		                      props = hostFiber.pendingProps;
		                    if (
		                      resource
		                        ? preloadResource(resource)
		                        : preloadInstance(type, props)
		                    ) {
		                      workInProgressSuspendedReason = NotSuspended;
		                      workInProgressThrownValue = null;
		                      var sibling = hostFiber.sibling;
		                      if (null !== sibling) workInProgress = sibling;
		                      else {
		                        var returnFiber = hostFiber.return;
		                        null !== returnFiber
		                          ? ((workInProgress = returnFiber),
		                            completeUnitOfWork(returnFiber))
		                          : (workInProgress = null);
		                      }
		                      break b;
		                    }
		                    break;
		                  default:
		                    console.error(
		                      "Unexpected type of fiber triggered a suspensey commit. This is a bug in React."
		                    );
		                }
		                workInProgressSuspendedReason = NotSuspended;
		                workInProgressThrownValue = null;
		                throwAndUnwindWorkLoop(
		                  root,
		                  lanes,
		                  memoizedUpdaters,
		                  SuspendedOnInstanceAndReadyToContinue
		                );
		                break;
		              case SuspendedOnDeprecatedThrowPromise:
		                workInProgressSuspendedReason = NotSuspended;
		                workInProgressThrownValue = null;
		                throwAndUnwindWorkLoop(
		                  root,
		                  lanes,
		                  memoizedUpdaters,
		                  SuspendedOnDeprecatedThrowPromise
		                );
		                break;
		              case SuspendedOnHydration:
		                resetWorkInProgressStack();
		                workInProgressRootExitStatus = RootDidNotComplete;
		                break a;
		              default:
		                throw Error(
		                  "Unexpected SuspendedReason. This is a bug in React."
		                );
		            }
		          null !== ReactSharedInternals.actQueue
		            ? workLoopSync()
		            : workLoopConcurrent();
		          break;
		        } catch (thrownValue$5) {
		          handleThrow(root, thrownValue$5);
		        }
		      while (1);
		      resetContextDependencies();
		      ReactSharedInternals.H = prevDispatcher;
		      ReactSharedInternals.A = prevAsyncDispatcher;
		      executionContext = prevExecutionContext;
		      if (null !== workInProgress)
		        return (
		          null !== injectedProfilingHooks &&
		            "function" === typeof injectedProfilingHooks.markRenderYielded &&
		            injectedProfilingHooks.markRenderYielded(),
		          RootInProgress
		        );
		      markRenderStopped();
		      workInProgressRoot = null;
		      workInProgressRootRenderLanes = 0;
		      finishQueueingConcurrentUpdates();
		      return workInProgressRootExitStatus;
		    }
		    function workLoopConcurrent() {
		      for (; null !== workInProgress && !shouldYield(); )
		        performUnitOfWork(workInProgress);
		    }
		    function performUnitOfWork(unitOfWork) {
		      var current = unitOfWork.alternate;
		      (unitOfWork.mode & 2) !== NoMode
		        ? (startProfilerTimer(unitOfWork),
		          (current = runWithFiberInDEV(
		            unitOfWork,
		            beginWork,
		            current,
		            unitOfWork,
		            entangledRenderLanes
		          )),
		          stopProfilerTimerIfRunningAndRecordDuration(unitOfWork))
		        : (current = runWithFiberInDEV(
		            unitOfWork,
		            beginWork,
		            current,
		            unitOfWork,
		            entangledRenderLanes
		          ));
		      unitOfWork.memoizedProps = unitOfWork.pendingProps;
		      null === current
		        ? completeUnitOfWork(unitOfWork)
		        : (workInProgress = current);
		    }
		    function replaySuspendedUnitOfWork(unitOfWork) {
		      var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);
		      unitOfWork.memoizedProps = unitOfWork.pendingProps;
		      null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
		    }
		    function replayBeginWork(unitOfWork) {
		      var current = unitOfWork.alternate,
		        isProfilingMode = (unitOfWork.mode & 2) !== NoMode;
		      isProfilingMode && startProfilerTimer(unitOfWork);
		      switch (unitOfWork.tag) {
		        case 15:
		        case 0:
		          current = replayFunctionComponent(
		            current,
		            unitOfWork,
		            unitOfWork.pendingProps,
		            unitOfWork.type,
		            void 0,
		            workInProgressRootRenderLanes
		          );
		          break;
		        case 11:
		          current = replayFunctionComponent(
		            current,
		            unitOfWork,
		            unitOfWork.pendingProps,
		            unitOfWork.type.render,
		            unitOfWork.ref,
		            workInProgressRootRenderLanes
		          );
		          break;
		        case 5:
		          resetHooksOnUnwind(unitOfWork);
		        default:
		          unwindInterruptedWork(current, unitOfWork),
		            (unitOfWork = workInProgress =
		              resetWorkInProgress(unitOfWork, entangledRenderLanes)),
		            (current = beginWork(current, unitOfWork, entangledRenderLanes));
		      }
		      isProfilingMode &&
		        stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);
		      return current;
		    }
		    function throwAndUnwindWorkLoop(
		      root,
		      unitOfWork,
		      thrownValue,
		      suspendedReason
		    ) {
		      resetContextDependencies();
		      resetHooksOnUnwind(unitOfWork);
		      thenableState$1 = null;
		      thenableIndexCounter$1 = 0;
		      var returnFiber = unitOfWork.return;
		      try {
		        if (
		          throwException(
		            root,
		            returnFiber,
		            unitOfWork,
		            thrownValue,
		            workInProgressRootRenderLanes
		          )
		        ) {
		          workInProgressRootExitStatus = RootFatalErrored;
		          logUncaughtError(
		            root,
		            createCapturedValueAtFiber(thrownValue, root.current)
		          );
		          workInProgress = null;
		          return;
		        }
		      } catch (error) {
		        if (null !== returnFiber) throw ((workInProgress = returnFiber), error);
		        workInProgressRootExitStatus = RootFatalErrored;
		        logUncaughtError(
		          root,
		          createCapturedValueAtFiber(thrownValue, root.current)
		        );
		        workInProgress = null;
		        return;
		      }
		      if (unitOfWork.flags & 32768) {
		        if (isHydrating || suspendedReason === SuspendedOnError) root = true;
		        else if (
		          workInProgressRootIsPrerendering ||
		          0 !== (workInProgressRootRenderLanes & 536870912)
		        )
		          root = false;
		        else if (
		          ((workInProgressRootDidSkipSuspendedSiblings = root = true),
		          suspendedReason === SuspendedOnData ||
		            suspendedReason === SuspendedOnImmediate ||
		            suspendedReason === SuspendedOnDeprecatedThrowPromise)
		        )
		          (suspendedReason = suspenseHandlerStackCursor.current),
		            null !== suspendedReason &&
		              13 === suspendedReason.tag &&
		              (suspendedReason.flags |= 16384);
		        unwindUnitOfWork(unitOfWork, root);
		      } else completeUnitOfWork(unitOfWork);
		    }
		    function completeUnitOfWork(unitOfWork) {
		      var completedWork = unitOfWork;
		      do {
		        if (0 !== (completedWork.flags & 32768)) {
		          unwindUnitOfWork(
		            completedWork,
		            workInProgressRootDidSkipSuspendedSiblings
		          );
		          return;
		        }
		        var current = completedWork.alternate;
		        unitOfWork = completedWork.return;
		        startProfilerTimer(completedWork);
		        current = runWithFiberInDEV(
		          completedWork,
		          completeWork,
		          current,
		          completedWork,
		          entangledRenderLanes
		        );
		        (completedWork.mode & 2) !== NoMode &&
		          stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);
		        if (null !== current) {
		          workInProgress = current;
		          return;
		        }
		        completedWork = completedWork.sibling;
		        if (null !== completedWork) {
		          workInProgress = completedWork;
		          return;
		        }
		        workInProgress = completedWork = unitOfWork;
		      } while (null !== completedWork);
		      workInProgressRootExitStatus === RootInProgress &&
		        (workInProgressRootExitStatus = RootCompleted);
		    }
		    function unwindUnitOfWork(unitOfWork, skipSiblings) {
		      do {
		        var next = unwindWork(unitOfWork.alternate, unitOfWork);
		        if (null !== next) {
		          next.flags &= 32767;
		          workInProgress = next;
		          return;
		        }
		        if ((unitOfWork.mode & 2) !== NoMode) {
		          stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);
		          next = unitOfWork.actualDuration;
		          for (var child = unitOfWork.child; null !== child; )
		            (next += child.actualDuration), (child = child.sibling);
		          unitOfWork.actualDuration = next;
		        }
		        next = unitOfWork.return;
		        null !== next &&
		          ((next.flags |= 32768),
		          (next.subtreeFlags = 0),
		          (next.deletions = null));
		        if (
		          !skipSiblings &&
		          ((unitOfWork = unitOfWork.sibling), null !== unitOfWork)
		        ) {
		          workInProgress = unitOfWork;
		          return;
		        }
		        workInProgress = unitOfWork = next;
		      } while (null !== unitOfWork);
		      workInProgressRootExitStatus = RootDidNotComplete;
		      workInProgress = null;
		    }
		    function commitRoot(
		      root,
		      recoverableErrors,
		      transitions,
		      didIncludeRenderPhaseUpdate,
		      spawnedLane,
		      updatedLanes,
		      suspendedRetryLanes,
		      suspendedCommitReason,
		      completedRenderStartTime,
		      completedRenderEndTime
		    ) {
		      var prevTransition = ReactSharedInternals.T,
		        previousUpdateLanePriority = getCurrentUpdatePriority();
		      try {
		        setCurrentUpdatePriority(2),
		          (ReactSharedInternals.T = null),
		          commitRootImpl(
		            root,
		            recoverableErrors,
		            transitions,
		            didIncludeRenderPhaseUpdate,
		            previousUpdateLanePriority,
		            spawnedLane,
		            updatedLanes,
		            suspendedRetryLanes,
		            suspendedCommitReason,
		            completedRenderStartTime,
		            completedRenderEndTime
		          );
		      } finally {
		        (ReactSharedInternals.T = prevTransition),
		          setCurrentUpdatePriority(previousUpdateLanePriority);
		      }
		    }
		    function commitRootImpl(
		      root,
		      recoverableErrors,
		      transitions,
		      didIncludeRenderPhaseUpdate,
		      renderPriorityLevel,
		      spawnedLane,
		      updatedLanes,
		      suspendedRetryLanes
		    ) {
		      do flushPassiveEffects();
		      while (null !== rootWithPendingPassiveEffects);
		      ReactStrictModeWarnings.flushLegacyContextWarning();
		      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
		      if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
		        throw Error("Should not already be working.");
		      var finishedWork = root.finishedWork;
		      didIncludeRenderPhaseUpdate = root.finishedLanes;
		      null !== injectedProfilingHooks &&
		        "function" === typeof injectedProfilingHooks.markCommitStarted &&
		        injectedProfilingHooks.markCommitStarted(didIncludeRenderPhaseUpdate);
		      if (null === finishedWork) return markCommitStopped(), null;
		      0 === didIncludeRenderPhaseUpdate &&
		        console.error(
		          "root.finishedLanes should not be empty during a commit. This is a bug in React."
		        );
		      root.finishedWork = null;
		      root.finishedLanes = 0;
		      if (finishedWork === root.current)
		        throw Error(
		          "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
		        );
		      root.callbackNode = null;
		      root.callbackPriority = 0;
		      root.cancelPendingCommit = null;
		      var remainingLanes = finishedWork.lanes | finishedWork.childLanes;
		      remainingLanes |= concurrentlyUpdatedLanes;
		      markRootFinished(
		        root,
		        didIncludeRenderPhaseUpdate,
		        remainingLanes,
		        spawnedLane,
		        updatedLanes,
		        suspendedRetryLanes
		      );
		      root === workInProgressRoot &&
		        ((workInProgress = workInProgressRoot = null),
		        (workInProgressRootRenderLanes = 0));
		      (0 === (finishedWork.subtreeFlags & 10256) &&
		        0 === (finishedWork.flags & 10256)) ||
		        rootDoesHavePassiveEffects ||
		        ((rootDoesHavePassiveEffects = true),
		        (pendingPassiveEffectsRemainingLanes = remainingLanes),
		        (pendingPassiveTransitions = transitions),
		        scheduleCallback(NormalPriority$1, function () {
		          flushPassiveEffects();
		          return null;
		        }));
		      commitStartTime = now();
		      transitions = 0 !== (finishedWork.flags & 15990);
		      0 !== (finishedWork.subtreeFlags & 15990) || transitions
		        ? ((transitions = ReactSharedInternals.T),
		          (ReactSharedInternals.T = null),
		          (spawnedLane = getCurrentUpdatePriority()),
		          setCurrentUpdatePriority(2),
		          (updatedLanes = executionContext),
		          (executionContext |= CommitContext),
		          commitBeforeMutationEffects(root, finishedWork),
		          commitMutationEffects(
		            root,
		            finishedWork,
		            didIncludeRenderPhaseUpdate
		          ),
		          resetAfterCommit(root.containerInfo),
		          (root.current = finishedWork),
		          null !== injectedProfilingHooks &&
		            "function" ===
		              typeof injectedProfilingHooks.markLayoutEffectsStarted &&
		            injectedProfilingHooks.markLayoutEffectsStarted(
		              didIncludeRenderPhaseUpdate
		            ),
		          commitLayoutEffects(finishedWork, root, didIncludeRenderPhaseUpdate),
		          null !== injectedProfilingHooks &&
		            "function" ===
		              typeof injectedProfilingHooks.markLayoutEffectsStopped &&
		            injectedProfilingHooks.markLayoutEffectsStopped(),
		          requestPaint(),
		          (executionContext = updatedLanes),
		          setCurrentUpdatePriority(spawnedLane),
		          (ReactSharedInternals.T = transitions))
		        : (root.current = finishedWork);
		      (transitions = rootDoesHavePassiveEffects)
		        ? ((rootDoesHavePassiveEffects = false),
		          (rootWithPendingPassiveEffects = root),
		          (pendingPassiveEffectsLanes = didIncludeRenderPhaseUpdate))
		        : (releaseRootPooledCache(root, remainingLanes),
		          (nestedPassiveUpdateCount = 0),
		          (rootWithPassiveNestedUpdates = null));
		      remainingLanes = root.pendingLanes;
		      0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
		      transitions || commitDoubleInvokeEffectsInDEV(root);
		      onCommitRoot$1(finishedWork.stateNode, renderPriorityLevel);
		      isDevToolsPresent && root.memoizedUpdaters.clear();
		      onCommitRoot();
		      ensureRootIsScheduled(root);
		      if (null !== recoverableErrors)
		        for (
		          renderPriorityLevel = root.onRecoverableError, finishedWork = 0;
		          finishedWork < recoverableErrors.length;
		          finishedWork++
		        )
		          (remainingLanes = recoverableErrors[finishedWork]),
		            (transitions = makeErrorInfo(remainingLanes.stack)),
		            runWithFiberInDEV(
		              remainingLanes.source,
		              renderPriorityLevel,
		              remainingLanes.value,
		              transitions
		            );
		      0 !== (pendingPassiveEffectsLanes & 3) && flushPassiveEffects();
		      remainingLanes = root.pendingLanes;
		      0 !== (didIncludeRenderPhaseUpdate & 4194218) &&
		      0 !== (remainingLanes & 42)
		        ? ((nestedUpdateScheduled = true),
		          root === rootWithNestedUpdates
		            ? nestedUpdateCount++
		            : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root)))
		        : (nestedUpdateCount = 0);
		      flushSyncWorkAcrossRoots_impl(0);
		      markCommitStopped();
		      return null;
		    }
		    function makeErrorInfo(componentStack) {
		      componentStack = { componentStack: componentStack };
		      Object.defineProperty(componentStack, "digest", {
		        get: function () {
		          console.error(
		            'You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.'
		          );
		        }
		      });
		      return componentStack;
		    }
		    function releaseRootPooledCache(root, remainingLanes) {
		      0 === (root.pooledCacheLanes &= remainingLanes) &&
		        ((remainingLanes = root.pooledCache),
		        null != remainingLanes &&
		          ((root.pooledCache = null), releaseCache(remainingLanes)));
		    }
		    function flushPassiveEffects() {
		      if (null !== rootWithPendingPassiveEffects) {
		        var root = rootWithPendingPassiveEffects,
		          remainingLanes = pendingPassiveEffectsRemainingLanes;
		        pendingPassiveEffectsRemainingLanes = 0;
		        var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes),
		          priority = 32 > renderPriority ? 32 : renderPriority;
		        renderPriority = ReactSharedInternals.T;
		        var previousPriority = getCurrentUpdatePriority();
		        try {
		          setCurrentUpdatePriority(priority);
		          ReactSharedInternals.T = null;
		          if (null === rootWithPendingPassiveEffects)
		            var JSCompiler_inline_result = !1;
		          else {
		            priority = pendingPassiveTransitions;
		            pendingPassiveTransitions = null;
		            var root$jscomp$0 = rootWithPendingPassiveEffects,
		              lanes = pendingPassiveEffectsLanes;
		            rootWithPendingPassiveEffects = null;
		            pendingPassiveEffectsLanes = 0;
		            if (
		              (executionContext & (RenderContext | CommitContext)) !==
		              NoContext
		            )
		              throw Error(
		                "Cannot flush passive effects while already rendering."
		              );
		            isFlushingPassiveEffects = !0;
		            didScheduleUpdateDuringPassiveEffects = !1;
		            null !== injectedProfilingHooks &&
		              "function" ===
		                typeof injectedProfilingHooks.markPassiveEffectsStarted &&
		              injectedProfilingHooks.markPassiveEffectsStarted(lanes);
		            var prevExecutionContext = executionContext;
		            executionContext |= CommitContext;
		            commitPassiveUnmountOnFiber(root$jscomp$0.current);
		            commitPassiveMountOnFiber(
		              root$jscomp$0,
		              root$jscomp$0.current,
		              lanes,
		              priority
		            );
		            null !== injectedProfilingHooks &&
		              "function" ===
		                typeof injectedProfilingHooks.markPassiveEffectsStopped &&
		              injectedProfilingHooks.markPassiveEffectsStopped();
		            commitDoubleInvokeEffectsInDEV(root$jscomp$0);
		            executionContext = prevExecutionContext;
		            flushSyncWorkAcrossRoots_impl(0, !1);
		            didScheduleUpdateDuringPassiveEffects
		              ? root$jscomp$0 === rootWithPassiveNestedUpdates
		                ? nestedPassiveUpdateCount++
		                : ((nestedPassiveUpdateCount = 0),
		                  (rootWithPassiveNestedUpdates = root$jscomp$0))
		              : (nestedPassiveUpdateCount = 0);
		            didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects =
		              !1;
		            if (
		              injectedHook &&
		              "function" === typeof injectedHook.onPostCommitFiberRoot
		            )
		              try {
		                injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
		              } catch (err) {
		                hasLoggedError ||
		                  ((hasLoggedError = !0),
		                  console.error(
		                    "React instrumentation encountered an error: %s",
		                    err
		                  ));
		              }
		            var stateNode = root$jscomp$0.current.stateNode;
		            stateNode.effectDuration = 0;
		            stateNode.passiveEffectDuration = 0;
		            JSCompiler_inline_result = !0;
		          }
		          return JSCompiler_inline_result;
		        } finally {
		          setCurrentUpdatePriority(previousPriority),
		            (ReactSharedInternals.T = renderPriority),
		            releaseRootPooledCache(root, remainingLanes);
		        }
		      }
		      return false;
		    }
		    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
		      sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
		      sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
		      rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
		      null !== rootFiber &&
		        (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
		    }
		    function captureCommitPhaseError(
		      sourceFiber,
		      nearestMountedAncestor,
		      error
		    ) {
		      isRunningInsertionEffect = false;
		      if (3 === sourceFiber.tag)
		        captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
		      else {
		        for (; null !== nearestMountedAncestor; ) {
		          if (3 === nearestMountedAncestor.tag) {
		            captureCommitPhaseErrorOnRoot(
		              nearestMountedAncestor,
		              sourceFiber,
		              error
		            );
		            return;
		          }
		          if (1 === nearestMountedAncestor.tag) {
		            var instance = nearestMountedAncestor.stateNode;
		            if (
		              "function" ===
		                typeof nearestMountedAncestor.type.getDerivedStateFromError ||
		              ("function" === typeof instance.componentDidCatch &&
		                (null === legacyErrorBoundariesThatAlreadyFailed ||
		                  !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
		            ) {
		              sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
		              error = createClassErrorUpdate(2);
		              instance = enqueueUpdate(nearestMountedAncestor, error, 2);
		              null !== instance &&
		                (initializeClassErrorUpdate(
		                  error,
		                  instance,
		                  nearestMountedAncestor,
		                  sourceFiber
		                ),
		                markRootUpdated$1(instance, 2),
		                ensureRootIsScheduled(instance));
		              return;
		            }
		          }
		          nearestMountedAncestor = nearestMountedAncestor.return;
		        }
		        console.error(
		          "Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s",
		          error
		        );
		      }
		    }
		    function attachPingListener(root, wakeable, lanes) {
		      var pingCache = root.pingCache;
		      if (null === pingCache) {
		        pingCache = root.pingCache = new PossiblyWeakMap();
		        var threadIDs = new Set();
		        pingCache.set(wakeable, threadIDs);
		      } else
		        (threadIDs = pingCache.get(wakeable)),
		          void 0 === threadIDs &&
		            ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs));
		      threadIDs.has(lanes) ||
		        ((workInProgressRootDidAttachPingListener = true),
		        threadIDs.add(lanes),
		        (pingCache = pingSuspendedRoot.bind(null, root, wakeable, lanes)),
		        isDevToolsPresent && restorePendingUpdaters(root, lanes),
		        wakeable.then(pingCache, pingCache));
		    }
		    function pingSuspendedRoot(root, wakeable, pingedLanes) {
		      var pingCache = root.pingCache;
		      null !== pingCache && pingCache.delete(wakeable);
		      root.pingedLanes |= root.suspendedLanes & pingedLanes;
		      root.warmLanes &= ~pingedLanes;
		      isConcurrentActEnvironment() &&
		        null === ReactSharedInternals.actQueue &&
		        console.error(
		          "A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act"
		        );
		      workInProgressRoot === root &&
		        (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
		        (workInProgressRootExitStatus === RootSuspendedWithDelay ||
		        (workInProgressRootExitStatus === RootSuspended &&
		          (workInProgressRootRenderLanes & 62914560) ===
		            workInProgressRootRenderLanes &&
		          now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)
		          ? (executionContext & RenderContext) === NoContext &&
		            prepareFreshStack(root, 0)
		          : (workInProgressRootPingedLanes |= pingedLanes),
		        workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes &&
		          (workInProgressSuspendedRetryLanes = 0));
		      ensureRootIsScheduled(root);
		    }
		    function retryTimedOutBoundary(boundaryFiber, retryLane) {
		      0 === retryLane && (retryLane = claimNextRetryLane());
		      boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
		      null !== boundaryFiber &&
		        (markRootUpdated$1(boundaryFiber, retryLane),
		        ensureRootIsScheduled(boundaryFiber));
		    }
		    function retryDehydratedSuspenseBoundary(boundaryFiber) {
		      var suspenseState = boundaryFiber.memoizedState,
		        retryLane = 0;
		      null !== suspenseState && (retryLane = suspenseState.retryLane);
		      retryTimedOutBoundary(boundaryFiber, retryLane);
		    }
		    function resolveRetryWakeable(boundaryFiber, wakeable) {
		      var retryLane = 0;
		      switch (boundaryFiber.tag) {
		        case 13:
		          var retryCache = boundaryFiber.stateNode;
		          var suspenseState = boundaryFiber.memoizedState;
		          null !== suspenseState && (retryLane = suspenseState.retryLane);
		          break;
		        case 19:
		          retryCache = boundaryFiber.stateNode;
		          break;
		        case 22:
		          retryCache = boundaryFiber.stateNode._retryCache;
		          break;
		        default:
		          throw Error(
		            "Pinged unknown suspense boundary type. This is probably a bug in React."
		          );
		      }
		      null !== retryCache && retryCache.delete(wakeable);
		      retryTimedOutBoundary(boundaryFiber, retryLane);
		    }
		    function recursivelyTraverseAndDoubleInvokeEffectsInDEV(
		      root$jscomp$0,
		      parentFiber,
		      isInStrictMode
		    ) {
		      if (0 !== (parentFiber.subtreeFlags & 33562624))
		        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
		          var root = root$jscomp$0,
		            fiber = parentFiber,
		            isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;
		          isStrictModeFiber = isInStrictMode || isStrictModeFiber;
		          22 !== fiber.tag
		            ? fiber.flags & 33554432
		              ? isStrictModeFiber &&
		                runWithFiberInDEV(
		                  fiber,
		                  doubleInvokeEffectsOnFiber,
		                  root,
		                  fiber,
		                  (fiber.mode & 64) === NoMode
		                )
		              : recursivelyTraverseAndDoubleInvokeEffectsInDEV(
		                  root,
		                  fiber,
		                  isStrictModeFiber
		                )
		            : null === fiber.memoizedState &&
		              (isStrictModeFiber && fiber.flags & 8192
		                ? runWithFiberInDEV(
		                    fiber,
		                    doubleInvokeEffectsOnFiber,
		                    root,
		                    fiber
		                  )
		                : fiber.subtreeFlags & 33554432 &&
		                  runWithFiberInDEV(
		                    fiber,
		                    recursivelyTraverseAndDoubleInvokeEffectsInDEV,
		                    root,
		                    fiber,
		                    isStrictModeFiber
		                  ));
		          parentFiber = parentFiber.sibling;
		        }
		    }
		    function doubleInvokeEffectsOnFiber(root, fiber) {
		      var shouldDoubleInvokePassiveEffects =
		        2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : true;
		      setIsStrictModeForDevtools(true);
		      try {
		        disappearLayoutEffects(fiber),
		          shouldDoubleInvokePassiveEffects && disconnectPassiveEffect(fiber),
		          reappearLayoutEffects(root, fiber.alternate, fiber, !1),
		          shouldDoubleInvokePassiveEffects &&
		            reconnectPassiveEffects(root, fiber, 0, null, !1);
		      } finally {
		        setIsStrictModeForDevtools(false);
		      }
		    }
		    function commitDoubleInvokeEffectsInDEV(root) {
		      var doubleInvokeEffects = true;
		      root.current.mode & 24 || (doubleInvokeEffects = false);
		      recursivelyTraverseAndDoubleInvokeEffectsInDEV(
		        root,
		        root.current,
		        doubleInvokeEffects
		      );
		    }
		    function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
		      if ((executionContext & RenderContext) === NoContext) {
		        var tag = fiber.tag;
		        if (
		          3 === tag ||
		          1 === tag ||
		          0 === tag ||
		          11 === tag ||
		          14 === tag ||
		          15 === tag
		        ) {
		          tag = getComponentNameFromFiber(fiber) || "ReactComponent";
		          if (null !== didWarnStateUpdateForNotYetMountedComponent) {
		            if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;
		            didWarnStateUpdateForNotYetMountedComponent.add(tag);
		          } else didWarnStateUpdateForNotYetMountedComponent = new Set([tag]);
		          runWithFiberInDEV(fiber, function () {
		            console.error(
		              "Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead."
		            );
		          });
		        }
		      }
		    }
		    function restorePendingUpdaters(root, lanes) {
		      isDevToolsPresent &&
		        root.memoizedUpdaters.forEach(function (schedulingFiber) {
		          addFiberToLanesMap(root, schedulingFiber, lanes);
		        });
		    }
		    function scheduleCallback(priorityLevel, callback) {
		      var actQueue = ReactSharedInternals.actQueue;
		      return null !== actQueue
		        ? (actQueue.push(callback), fakeActCallbackNode)
		        : scheduleCallback$3(priorityLevel, callback);
		    }
		    function warnIfUpdatesNotWrappedWithActDEV(fiber) {
		      isConcurrentActEnvironment() &&
		        null === ReactSharedInternals.actQueue &&
		        runWithFiberInDEV(fiber, function () {
		          console.error(
		            "An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act",
		            getComponentNameFromFiber(fiber)
		          );
		        });
		    }
		    function resolveFunctionForHotReloading(type) {
		      if (null === resolveFamily) return type;
		      var family = resolveFamily(type);
		      return void 0 === family ? type : family.current;
		    }
		    function resolveForwardRefForHotReloading(type) {
		      if (null === resolveFamily) return type;
		      var family = resolveFamily(type);
		      return void 0 === family
		        ? null !== type &&
		          void 0 !== type &&
		          "function" === typeof type.render &&
		          ((family = resolveFunctionForHotReloading(type.render)),
		          type.render !== family)
		          ? ((family = { $$typeof: REACT_FORWARD_REF_TYPE, render: family }),
		            void 0 !== type.displayName &&
		              (family.displayName = type.displayName),
		            family)
		          : type
		        : family.current;
		    }
		    function isCompatibleFamilyForHotReloading(fiber, element) {
		      if (null === resolveFamily) return false;
		      var prevType = fiber.elementType;
		      element = element.type;
		      var needsCompareFamilies = false,
		        $$typeofNextType =
		          "object" === typeof element && null !== element
		            ? element.$$typeof
		            : null;
		      switch (fiber.tag) {
		        case 1:
		          "function" === typeof element && (needsCompareFamilies = true);
		          break;
		        case 0:
		          "function" === typeof element
		            ? (needsCompareFamilies = true)
		            : $$typeofNextType === REACT_LAZY_TYPE &&
		              (needsCompareFamilies = true);
		          break;
		        case 11:
		          $$typeofNextType === REACT_FORWARD_REF_TYPE
		            ? (needsCompareFamilies = true)
		            : $$typeofNextType === REACT_LAZY_TYPE &&
		              (needsCompareFamilies = true);
		          break;
		        case 14:
		        case 15:
		          $$typeofNextType === REACT_MEMO_TYPE
		            ? (needsCompareFamilies = true)
		            : $$typeofNextType === REACT_LAZY_TYPE &&
		              (needsCompareFamilies = true);
		          break;
		        default:
		          return false;
		      }
		      return needsCompareFamilies &&
		        ((fiber = resolveFamily(prevType)),
		        void 0 !== fiber && fiber === resolveFamily(element))
		        ? true
		        : false;
		    }
		    function markFailedErrorBoundaryForHotReloading(fiber) {
		      null !== resolveFamily &&
		        "function" === typeof WeakSet &&
		        (null === failedBoundaries && (failedBoundaries = new WeakSet()),
		        failedBoundaries.add(fiber));
		    }
		    function scheduleFibersWithFamiliesRecursively(
		      fiber,
		      updatedFamilies,
		      staleFamilies
		    ) {
		      var alternate = fiber.alternate,
		        child = fiber.child,
		        sibling = fiber.sibling,
		        tag = fiber.tag,
		        type = fiber.type,
		        candidateType = null;
		      switch (tag) {
		        case 0:
		        case 15:
		        case 1:
		          candidateType = type;
		          break;
		        case 11:
		          candidateType = type.render;
		      }
		      if (null === resolveFamily)
		        throw Error("Expected resolveFamily to be set during hot reload.");
		      var needsRender = false;
		      type = false;
		      null !== candidateType &&
		        ((candidateType = resolveFamily(candidateType)),
		        void 0 !== candidateType &&
		          (staleFamilies.has(candidateType)
		            ? (type = true)
		            : updatedFamilies.has(candidateType) &&
		              (1 === tag ? (type = true) : (needsRender = true))));
		      null !== failedBoundaries &&
		        (failedBoundaries.has(fiber) ||
		          (null !== alternate && failedBoundaries.has(alternate))) &&
		        (type = true);
		      type && (fiber._debugNeedsRemount = true);
		      if (type || needsRender)
		        (alternate = enqueueConcurrentRenderForLane(fiber, 2)),
		          null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);
		      null === child ||
		        type ||
		        scheduleFibersWithFamiliesRecursively(
		          child,
		          updatedFamilies,
		          staleFamilies
		        );
		      null !== sibling &&
		        scheduleFibersWithFamiliesRecursively(
		          sibling,
		          updatedFamilies,
		          staleFamilies
		        );
		    }
		    function FiberNode(tag, pendingProps, key, mode) {
		      this.tag = tag;
		      this.key = key;
		      this.sibling =
		        this.child =
		        this.return =
		        this.stateNode =
		        this.type =
		        this.elementType =
		          null;
		      this.index = 0;
		      this.refCleanup = this.ref = null;
		      this.pendingProps = pendingProps;
		      this.dependencies =
		        this.memoizedState =
		        this.updateQueue =
		        this.memoizedProps =
		          null;
		      this.mode = mode;
		      this.subtreeFlags = this.flags = 0;
		      this.deletions = null;
		      this.childLanes = this.lanes = 0;
		      this.alternate = null;
		      this.actualDuration = -0;
		      this.actualStartTime = -1.1;
		      this.treeBaseDuration = this.selfBaseDuration = -0;
		      this._debugOwner = this._debugInfo = null;
		      this._debugNeedsRemount = false;
		      this._debugHookTypes = null;
		      hasBadMapPolyfill ||
		        "function" !== typeof Object.preventExtensions ||
		        Object.preventExtensions(this);
		    }
		    function shouldConstruct(Component) {
		      Component = Component.prototype;
		      return !(!Component || !Component.isReactComponent);
		    }
		    function createWorkInProgress(current, pendingProps) {
		      var workInProgress = current.alternate;
		      null === workInProgress
		        ? ((workInProgress = createFiber(
		            current.tag,
		            pendingProps,
		            current.key,
		            current.mode
		          )),
		          (workInProgress.elementType = current.elementType),
		          (workInProgress.type = current.type),
		          (workInProgress.stateNode = current.stateNode),
		          (workInProgress._debugOwner = current._debugOwner),
		          (workInProgress._debugHookTypes = current._debugHookTypes),
		          (workInProgress.alternate = current),
		          (current.alternate = workInProgress))
		        : ((workInProgress.pendingProps = pendingProps),
		          (workInProgress.type = current.type),
		          (workInProgress.flags = 0),
		          (workInProgress.subtreeFlags = 0),
		          (workInProgress.deletions = null),
		          (workInProgress.actualDuration = -0),
		          (workInProgress.actualStartTime = -1.1));
		      workInProgress.flags = current.flags & 31457280;
		      workInProgress.childLanes = current.childLanes;
		      workInProgress.lanes = current.lanes;
		      workInProgress.child = current.child;
		      workInProgress.memoizedProps = current.memoizedProps;
		      workInProgress.memoizedState = current.memoizedState;
		      workInProgress.updateQueue = current.updateQueue;
		      pendingProps = current.dependencies;
		      workInProgress.dependencies =
		        null === pendingProps
		          ? null
		          : {
		              lanes: pendingProps.lanes,
		              firstContext: pendingProps.firstContext,
		              _debugThenableState: pendingProps._debugThenableState
		            };
		      workInProgress.sibling = current.sibling;
		      workInProgress.index = current.index;
		      workInProgress.ref = current.ref;
		      workInProgress.refCleanup = current.refCleanup;
		      workInProgress.selfBaseDuration = current.selfBaseDuration;
		      workInProgress.treeBaseDuration = current.treeBaseDuration;
		      workInProgress._debugInfo = current._debugInfo;
		      workInProgress._debugNeedsRemount = current._debugNeedsRemount;
		      switch (workInProgress.tag) {
		        case 0:
		        case 15:
		          workInProgress.type = resolveFunctionForHotReloading(current.type);
		          break;
		        case 1:
		          workInProgress.type = resolveFunctionForHotReloading(current.type);
		          break;
		        case 11:
		          workInProgress.type = resolveForwardRefForHotReloading(current.type);
		      }
		      return workInProgress;
		    }
		    function resetWorkInProgress(workInProgress, renderLanes) {
		      workInProgress.flags &= 31457282;
		      var current = workInProgress.alternate;
		      null === current
		        ? ((workInProgress.childLanes = 0),
		          (workInProgress.lanes = renderLanes),
		          (workInProgress.child = null),
		          (workInProgress.subtreeFlags = 0),
		          (workInProgress.memoizedProps = null),
		          (workInProgress.memoizedState = null),
		          (workInProgress.updateQueue = null),
		          (workInProgress.dependencies = null),
		          (workInProgress.stateNode = null),
		          (workInProgress.selfBaseDuration = 0),
		          (workInProgress.treeBaseDuration = 0))
		        : ((workInProgress.childLanes = current.childLanes),
		          (workInProgress.lanes = current.lanes),
		          (workInProgress.child = current.child),
		          (workInProgress.subtreeFlags = 0),
		          (workInProgress.deletions = null),
		          (workInProgress.memoizedProps = current.memoizedProps),
		          (workInProgress.memoizedState = current.memoizedState),
		          (workInProgress.updateQueue = current.updateQueue),
		          (workInProgress.type = current.type),
		          (renderLanes = current.dependencies),
		          (workInProgress.dependencies =
		            null === renderLanes
		              ? null
		              : {
		                  lanes: renderLanes.lanes,
		                  firstContext: renderLanes.firstContext,
		                  _debugThenableState: renderLanes._debugThenableState
		                }),
		          (workInProgress.selfBaseDuration = current.selfBaseDuration),
		          (workInProgress.treeBaseDuration = current.treeBaseDuration));
		      return workInProgress;
		    }
		    function createFiberFromTypeAndProps(
		      type,
		      key,
		      pendingProps,
		      owner,
		      mode,
		      lanes
		    ) {
		      var fiberTag = 0,
		        resolvedType = type;
		      if ("function" === typeof type)
		        shouldConstruct(type) && (fiberTag = 1),
		          (resolvedType = resolveFunctionForHotReloading(resolvedType));
		      else if ("string" === typeof type)
		        supportsResources && supportsSingletons
		          ? ((fiberTag = getHostContext()),
		            (fiberTag = isHostHoistableType(type, pendingProps, fiberTag)
		              ? 26
		              : isHostSingletonType(type)
		                ? 27
		                : 5))
		          : supportsResources
		            ? ((fiberTag = getHostContext()),
		              (fiberTag = isHostHoistableType(type, pendingProps, fiberTag)
		                ? 26
		                : 5))
		            : (fiberTag = supportsSingletons
		                ? isHostSingletonType(type)
		                  ? 27
		                  : 5
		                : 5);
		      else
		        a: switch (type) {
		          case REACT_FRAGMENT_TYPE:
		            return createFiberFromFragment(
		              pendingProps.children,
		              mode,
		              lanes,
		              key
		            );
		          case REACT_STRICT_MODE_TYPE:
		            fiberTag = 8;
		            mode |= 24;
		            break;
		          case REACT_PROFILER_TYPE:
		            return (
		              (type = pendingProps),
		              (owner = mode),
		              "string" !== typeof type.id &&
		                console.error(
		                  'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
		                  typeof type.id
		                ),
		              (key = createFiber(12, type, key, owner | 2)),
		              (key.elementType = REACT_PROFILER_TYPE),
		              (key.lanes = lanes),
		              (key.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }),
		              key
		            );
		          case REACT_SUSPENSE_TYPE:
		            return (
		              (key = createFiber(13, pendingProps, key, mode)),
		              (key.elementType = REACT_SUSPENSE_TYPE),
		              (key.lanes = lanes),
		              key
		            );
		          case REACT_SUSPENSE_LIST_TYPE:
		            return (
		              (key = createFiber(19, pendingProps, key, mode)),
		              (key.elementType = REACT_SUSPENSE_LIST_TYPE),
		              (key.lanes = lanes),
		              key
		            );
		          case REACT_OFFSCREEN_TYPE:
		            return createFiberFromOffscreen(pendingProps, mode, lanes, key);
		          default:
		            if ("object" === typeof type && null !== type)
		              switch (type.$$typeof) {
		                case REACT_PROVIDER_TYPE:
		                case REACT_CONTEXT_TYPE:
		                  fiberTag = 10;
		                  break a;
		                case REACT_CONSUMER_TYPE:
		                  fiberTag = 9;
		                  break a;
		                case REACT_FORWARD_REF_TYPE:
		                  fiberTag = 11;
		                  resolvedType = resolveForwardRefForHotReloading(resolvedType);
		                  break a;
		                case REACT_MEMO_TYPE:
		                  fiberTag = 14;
		                  break a;
		                case REACT_LAZY_TYPE:
		                  fiberTag = 16;
		                  resolvedType = null;
		                  break a;
		              }
		            resolvedType = "";
		            if (
		              void 0 === type ||
		              ("object" === typeof type &&
		                null !== type &&
		                0 === Object.keys(type).length)
		            )
		              resolvedType +=
		                " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
		            null === type
		              ? (pendingProps = "null")
		              : isArrayImpl(type)
		                ? (pendingProps = "array")
		                : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE
		                  ? ((pendingProps =
		                      "<" +
		                      (getComponentNameFromType(type.type) || "Unknown") +
		                      " />"),
		                    (resolvedType =
		                      " Did you accidentally export a JSX literal instead of a component?"))
		                  : (pendingProps = typeof type);
		            fiberTag = owner
		              ? "number" === typeof owner.tag
		                ? getComponentNameFromFiber(owner)
		                : "string" === typeof owner.name
		                  ? owner.name
		                  : null
		              : null;
		            fiberTag &&
		              (resolvedType +=
		                "\n\nCheck the render method of `" + fiberTag + "`.");
		            fiberTag = 29;
		            pendingProps = Error(
		              "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " +
		                (pendingProps + "." + resolvedType)
		            );
		            resolvedType = null;
		        }
		      key = createFiber(fiberTag, pendingProps, key, mode);
		      key.elementType = type;
		      key.type = resolvedType;
		      key.lanes = lanes;
		      key._debugOwner = owner;
		      return key;
		    }
		    function createFiberFromElement(element, mode, lanes) {
		      mode = createFiberFromTypeAndProps(
		        element.type,
		        element.key,
		        element.props,
		        element._owner,
		        mode,
		        lanes
		      );
		      mode._debugOwner = element._owner;
		      return mode;
		    }
		    function createFiberFromFragment(elements, mode, lanes, key) {
		      elements = createFiber(7, elements, key, mode);
		      elements.lanes = lanes;
		      return elements;
		    }
		    function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
		      pendingProps = createFiber(22, pendingProps, key, mode);
		      pendingProps.elementType = REACT_OFFSCREEN_TYPE;
		      pendingProps.lanes = lanes;
		      var primaryChildInstance = {
		        _visibility: 1,
		        _pendingVisibility: 1,
		        _pendingMarkers: null,
		        _retryCache: null,
		        _transitions: null,
		        _current: null,
		        detach: function () {
		          var instance = primaryChildInstance,
		            fiber = instance._current;
		          if (null === fiber)
		            throw Error(
		              "Calling Offscreen.detach before instance handle has been set."
		            );
		          if (0 === (instance._pendingVisibility & 2)) {
		            var root = enqueueConcurrentRenderForLane(fiber, 2);
		            null !== root &&
		              ((instance._pendingVisibility |= 2),
		              scheduleUpdateOnFiber(root, fiber, 2));
		          }
		        },
		        attach: function () {
		          var instance = primaryChildInstance,
		            fiber = instance._current;
		          if (null === fiber)
		            throw Error(
		              "Calling Offscreen.detach before instance handle has been set."
		            );
		          if (0 !== (instance._pendingVisibility & 2)) {
		            var root = enqueueConcurrentRenderForLane(fiber, 2);
		            null !== root &&
		              ((instance._pendingVisibility &= -3),
		              scheduleUpdateOnFiber(root, fiber, 2));
		          }
		        }
		      };
		      pendingProps.stateNode = primaryChildInstance;
		      return pendingProps;
		    }
		    function createFiberFromText(content, mode, lanes) {
		      content = createFiber(6, content, null, mode);
		      content.lanes = lanes;
		      return content;
		    }
		    function createFiberFromPortal(portal, mode, lanes) {
		      mode = createFiber(
		        4,
		        null !== portal.children ? portal.children : [],
		        portal.key,
		        mode
		      );
		      mode.lanes = lanes;
		      mode.stateNode = {
		        containerInfo: portal.containerInfo,
		        pendingChildren: null,
		        implementation: portal.implementation
		      };
		      return mode;
		    }
		    function FiberRootNode(
		      containerInfo,
		      tag,
		      hydrate,
		      identifierPrefix,
		      onUncaughtError,
		      onCaughtError,
		      onRecoverableError,
		      formState
		    ) {
		      this.tag = 1;
		      this.containerInfo = containerInfo;
		      this.finishedWork =
		        this.pingCache =
		        this.current =
		        this.pendingChildren =
		          null;
		      this.timeoutHandle = noTimeout;
		      this.callbackNode =
		        this.next =
		        this.pendingContext =
		        this.context =
		        this.cancelPendingCommit =
		          null;
		      this.callbackPriority = 0;
		      this.expirationTimes = createLaneMap(-1);
		      this.entangledLanes =
		        this.shellSuspendCounter =
		        this.errorRecoveryDisabledLanes =
		        this.finishedLanes =
		        this.expiredLanes =
		        this.warmLanes =
		        this.pingedLanes =
		        this.suspendedLanes =
		        this.pendingLanes =
		          0;
		      this.entanglements = createLaneMap(0);
		      this.hiddenUpdates = createLaneMap(null);
		      this.identifierPrefix = identifierPrefix;
		      this.onUncaughtError = onUncaughtError;
		      this.onCaughtError = onCaughtError;
		      this.onRecoverableError = onRecoverableError;
		      this.pooledCache = null;
		      this.pooledCacheLanes = 0;
		      this.formState = formState;
		      this.incompleteTransitions = new Map();
		      this.passiveEffectDuration = this.effectDuration = -0;
		      this.memoizedUpdaters = new Set();
		      containerInfo = this.pendingUpdatersLaneMap = [];
		      for (tag = 0; 31 > tag; tag++) containerInfo.push(new Set());
		      this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
		    }
		    function createFiberRoot(
		      containerInfo,
		      tag,
		      hydrate,
		      initialChildren,
		      hydrationCallbacks,
		      isStrictMode,
		      identifierPrefix,
		      onUncaughtError,
		      onCaughtError,
		      onRecoverableError,
		      transitionCallbacks,
		      formState
		    ) {
		      containerInfo = new FiberRootNode(
		        containerInfo,
		        tag,
		        hydrate,
		        identifierPrefix,
		        onUncaughtError,
		        onCaughtError,
		        onRecoverableError,
		        formState
		      );
		      tag = 1;
		      true === isStrictMode && (tag |= 24);
		      isDevToolsPresent && (tag |= 2);
		      isStrictMode = createFiber(3, null, null, tag);
		      containerInfo.current = isStrictMode;
		      isStrictMode.stateNode = containerInfo;
		      tag = createCache();
		      retainCache(tag);
		      containerInfo.pooledCache = tag;
		      retainCache(tag);
		      isStrictMode.memoizedState = {
		        element: initialChildren,
		        isDehydrated: hydrate,
		        cache: tag
		      };
		      initializeUpdateQueue(isStrictMode);
		      return containerInfo;
		    }
		    function testStringCoercion(value) {
		      return "" + value;
		    }
		    function getContextForSubtree(parentComponent) {
		      if (!parentComponent) return emptyContextObject;
		      parentComponent = emptyContextObject;
		      return parentComponent;
		    }
		    function updateContainerSync(
		      element,
		      container,
		      parentComponent,
		      callback
		    ) {
		      0 === container.tag && flushPassiveEffects();
		      updateContainerImpl(
		        container.current,
		        2,
		        element,
		        container,
		        parentComponent,
		        callback
		      );
		      return 2;
		    }
		    function updateContainerImpl(
		      rootFiber,
		      lane,
		      element,
		      container,
		      parentComponent,
		      callback
		    ) {
		      if (
		        injectedHook &&
		        "function" === typeof injectedHook.onScheduleFiberRoot
		      )
		        try {
		          injectedHook.onScheduleFiberRoot(rendererID, container, element);
		        } catch (err) {
		          hasLoggedError ||
		            ((hasLoggedError = true),
		            console.error(
		              "React instrumentation encountered an error: %s",
		              err
		            ));
		        }
		      null !== injectedProfilingHooks &&
		        "function" === typeof injectedProfilingHooks.markRenderScheduled &&
		        injectedProfilingHooks.markRenderScheduled(lane);
		      parentComponent = getContextForSubtree(parentComponent);
		      null === container.context
		        ? (container.context = parentComponent)
		        : (container.pendingContext = parentComponent);
		      isRendering &&
		        null !== current &&
		        !didWarnAboutNestedUpdates &&
		        ((didWarnAboutNestedUpdates = true),
		        console.error(
		          "Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.",
		          getComponentNameFromFiber(current) || "Unknown"
		        ));
		      container = createUpdate(lane);
		      container.payload = { element: element };
		      callback = void 0 === callback ? null : callback;
		      null !== callback &&
		        ("function" !== typeof callback &&
		          console.error(
		            "Expected the last optional `callback` argument to be a function. Instead received: %s.",
		            callback
		          ),
		        (container.callback = callback));
		      element = enqueueUpdate(rootFiber, container, lane);
		      null !== element &&
		        (scheduleUpdateOnFiber(element, rootFiber, lane),
		        entangleTransitions(element, rootFiber, lane));
		    }
		    function markRetryLaneImpl(fiber, retryLane) {
		      fiber = fiber.memoizedState;
		      if (null !== fiber && null !== fiber.dehydrated) {
		        var a = fiber.retryLane;
		        fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
		      }
		    }
		    function markRetryLaneIfNotHydrated(fiber, retryLane) {
		      markRetryLaneImpl(fiber, retryLane);
		      (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
		    }
		    function getCurrentFiberForDevTools() {
		      return current;
		    }
		    function getLaneLabelMap() {
		      for (var map = new Map(), lane = 1, index = 0; 31 > index; index++) {
		        var label = getLabelForLane(lane);
		        map.set(lane, label);
		        lane *= 2;
		      }
		      return map;
		    }
		    var exports = {};
		    var React = React__default,
		      Scheduler = requireScheduler$1(),
		      assign = Object.assign,
		      REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
		      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
		      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
		      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
		      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
		      REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
		      REACT_PROVIDER_TYPE = Symbol.for("react.provider"),
		      REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
		      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
		      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
		      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
		      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
		      REACT_MEMO_TYPE = Symbol.for("react.memo"),
		      REACT_LAZY_TYPE = Symbol.for("react.lazy");
		    var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
		    var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
		      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
		      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
		      ReactSharedInternals =
		        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
		      disabledDepth = 0,
		      prevLog,
		      prevInfo,
		      prevWarn,
		      prevError,
		      prevGroup,
		      prevGroupCollapsed,
		      prevGroupEnd;
		    disabledLog.__reactDisabledLog = true;
		    var prefix,
		      suffix,
		      reentry = false;
		    var componentFrameCache = new (
		      "function" === typeof WeakMap ? WeakMap : Map
		    )();
		    var current = null,
		      isRendering = false,
		      isArrayImpl = Array.isArray,
		      rendererVersion = $$$config.rendererVersion,
		      rendererPackageName = $$$config.rendererPackageName,
		      extraDevToolsConfig = $$$config.extraDevToolsConfig,
		      getPublicInstance = $$$config.getPublicInstance,
		      getRootHostContext = $$$config.getRootHostContext,
		      getChildHostContext = $$$config.getChildHostContext,
		      prepareForCommit = $$$config.prepareForCommit,
		      resetAfterCommit = $$$config.resetAfterCommit,
		      createInstance = $$$config.createInstance,
		      appendInitialChild = $$$config.appendInitialChild,
		      finalizeInitialChildren = $$$config.finalizeInitialChildren,
		      shouldSetTextContent = $$$config.shouldSetTextContent,
		      createTextInstance = $$$config.createTextInstance,
		      scheduleTimeout = $$$config.scheduleTimeout,
		      cancelTimeout = $$$config.cancelTimeout,
		      noTimeout = $$$config.noTimeout,
		      isPrimaryRenderer = $$$config.isPrimaryRenderer;
		    $$$config.warnsIfNotActing;
		    var supportsMutation = $$$config.supportsMutation,
		      supportsPersistence = $$$config.supportsPersistence,
		      supportsHydration = $$$config.supportsHydration,
		      getInstanceFromNode = $$$config.getInstanceFromNode;
		    $$$config.beforeActiveInstanceBlur;
		    $$$config.afterActiveInstanceBlur;
		    var preparePortalMount = $$$config.preparePortalMount;
		    $$$config.prepareScopeUpdate;
		    $$$config.getInstanceFromScope;
		    var setCurrentUpdatePriority = $$$config.setCurrentUpdatePriority,
		      getCurrentUpdatePriority = $$$config.getCurrentUpdatePriority,
		      resolveUpdatePriority = $$$config.resolveUpdatePriority;
		    $$$config.resolveEventType;
		    $$$config.resolveEventTimeStamp;
		    var shouldAttemptEagerTransition = $$$config.shouldAttemptEagerTransition,
		      detachDeletedInstance = $$$config.detachDeletedInstance;
		    $$$config.requestPostPaintCallback;
		    var maySuspendCommit = $$$config.maySuspendCommit,
		      preloadInstance = $$$config.preloadInstance,
		      startSuspendingCommit = $$$config.startSuspendingCommit,
		      suspendInstance = $$$config.suspendInstance,
		      waitForCommitToBeReady = $$$config.waitForCommitToBeReady,
		      NotPendingTransition = $$$config.NotPendingTransition,
		      HostTransitionContext = $$$config.HostTransitionContext,
		      resetFormInstance = $$$config.resetFormInstance,
		      bindToConsole = $$$config.bindToConsole,
		      supportsMicrotasks = $$$config.supportsMicrotasks,
		      scheduleMicrotask = $$$config.scheduleMicrotask,
		      supportsTestSelectors = $$$config.supportsTestSelectors,
		      findFiberRoot = $$$config.findFiberRoot,
		      getBoundingRect = $$$config.getBoundingRect,
		      getTextContent = $$$config.getTextContent,
		      isHiddenSubtree = $$$config.isHiddenSubtree,
		      matchAccessibilityRole = $$$config.matchAccessibilityRole,
		      setFocusIfFocusable = $$$config.setFocusIfFocusable,
		      setupIntersectionObserver = $$$config.setupIntersectionObserver,
		      appendChild = $$$config.appendChild,
		      appendChildToContainer = $$$config.appendChildToContainer,
		      commitTextUpdate = $$$config.commitTextUpdate,
		      commitMount = $$$config.commitMount,
		      commitUpdate = $$$config.commitUpdate,
		      insertBefore = $$$config.insertBefore,
		      insertInContainerBefore = $$$config.insertInContainerBefore,
		      removeChild = $$$config.removeChild,
		      removeChildFromContainer = $$$config.removeChildFromContainer,
		      resetTextContent = $$$config.resetTextContent,
		      hideInstance = $$$config.hideInstance,
		      hideTextInstance = $$$config.hideTextInstance,
		      unhideInstance = $$$config.unhideInstance,
		      unhideTextInstance = $$$config.unhideTextInstance,
		      clearContainer = $$$config.clearContainer,
		      cloneInstance = $$$config.cloneInstance,
		      createContainerChildSet = $$$config.createContainerChildSet,
		      appendChildToContainerChildSet = $$$config.appendChildToContainerChildSet,
		      finalizeContainerChildren = $$$config.finalizeContainerChildren,
		      replaceContainerChildren = $$$config.replaceContainerChildren,
		      cloneHiddenInstance = $$$config.cloneHiddenInstance,
		      cloneHiddenTextInstance = $$$config.cloneHiddenTextInstance,
		      isSuspenseInstancePending = $$$config.isSuspenseInstancePending,
		      isSuspenseInstanceFallback = $$$config.isSuspenseInstanceFallback,
		      getSuspenseInstanceFallbackErrorDetails =
		        $$$config.getSuspenseInstanceFallbackErrorDetails,
		      registerSuspenseInstanceRetry = $$$config.registerSuspenseInstanceRetry,
		      canHydrateFormStateMarker = $$$config.canHydrateFormStateMarker,
		      isFormStateMarkerMatching = $$$config.isFormStateMarkerMatching,
		      getNextHydratableSibling = $$$config.getNextHydratableSibling,
		      getFirstHydratableChild = $$$config.getFirstHydratableChild,
		      getFirstHydratableChildWithinContainer =
		        $$$config.getFirstHydratableChildWithinContainer,
		      getFirstHydratableChildWithinSuspenseInstance =
		        $$$config.getFirstHydratableChildWithinSuspenseInstance,
		      canHydrateInstance = $$$config.canHydrateInstance,
		      canHydrateTextInstance = $$$config.canHydrateTextInstance,
		      canHydrateSuspenseInstance = $$$config.canHydrateSuspenseInstance,
		      hydrateInstance = $$$config.hydrateInstance,
		      hydrateTextInstance = $$$config.hydrateTextInstance,
		      hydrateSuspenseInstance = $$$config.hydrateSuspenseInstance,
		      getNextHydratableInstanceAfterSuspenseInstance =
		        $$$config.getNextHydratableInstanceAfterSuspenseInstance,
		      commitHydratedContainer = $$$config.commitHydratedContainer,
		      commitHydratedSuspenseInstance = $$$config.commitHydratedSuspenseInstance,
		      clearSuspenseBoundary = $$$config.clearSuspenseBoundary,
		      clearSuspenseBoundaryFromContainer =
		        $$$config.clearSuspenseBoundaryFromContainer,
		      shouldDeleteUnhydratedTailInstances =
		        $$$config.shouldDeleteUnhydratedTailInstances,
		      diffHydratedPropsForDevWarnings =
		        $$$config.diffHydratedPropsForDevWarnings,
		      diffHydratedTextForDevWarnings = $$$config.diffHydratedTextForDevWarnings,
		      describeHydratableInstanceForDevWarnings =
		        $$$config.describeHydratableInstanceForDevWarnings,
		      validateHydratableInstance = $$$config.validateHydratableInstance,
		      validateHydratableTextInstance = $$$config.validateHydratableTextInstance,
		      supportsResources = $$$config.supportsResources,
		      isHostHoistableType = $$$config.isHostHoistableType,
		      getHoistableRoot = $$$config.getHoistableRoot,
		      getResource = $$$config.getResource,
		      acquireResource = $$$config.acquireResource,
		      releaseResource = $$$config.releaseResource,
		      hydrateHoistable = $$$config.hydrateHoistable,
		      mountHoistable = $$$config.mountHoistable,
		      unmountHoistable = $$$config.unmountHoistable,
		      createHoistableInstance = $$$config.createHoistableInstance,
		      prepareToCommitHoistables = $$$config.prepareToCommitHoistables,
		      mayResourceSuspendCommit = $$$config.mayResourceSuspendCommit,
		      preloadResource = $$$config.preloadResource,
		      suspendResource = $$$config.suspendResource,
		      supportsSingletons = $$$config.supportsSingletons,
		      resolveSingletonInstance = $$$config.resolveSingletonInstance,
		      clearSingleton = $$$config.clearSingleton,
		      acquireSingletonInstance = $$$config.acquireSingletonInstance,
		      releaseSingletonInstance = $$$config.releaseSingletonInstance,
		      isHostSingletonType = $$$config.isHostSingletonType,
		      valueStack = [];
		    var fiberStack = [];
		    var index$jscomp$0 = -1,
		      emptyContextObject = {};
		    Object.freeze(emptyContextObject);
		    var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
		      log$1 = Math.log,
		      LN2 = Math.LN2,
		      nextTransitionLane = 128,
		      nextRetryLane = 4194304,
		      scheduleCallback$3 = Scheduler.unstable_scheduleCallback,
		      cancelCallback$1 = Scheduler.unstable_cancelCallback,
		      shouldYield = Scheduler.unstable_shouldYield,
		      requestPaint = Scheduler.unstable_requestPaint,
		      now$1 = Scheduler.unstable_now,
		      ImmediatePriority = Scheduler.unstable_ImmediatePriority,
		      UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
		      NormalPriority$1 = Scheduler.unstable_NormalPriority,
		      IdlePriority = Scheduler.unstable_IdlePriority,
		      log = Scheduler.log,
		      unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,
		      rendererID = null,
		      injectedHook = null,
		      injectedProfilingHooks = null,
		      hasLoggedError = false,
		      isDevToolsPresent = "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__,
		      objectIs = "function" === typeof Object.is ? Object.is : is,
		      CapturedStacks = new WeakMap(),
		      forkStack = [],
		      forkStackIndex = 0,
		      treeForkProvider = null,
		      treeForkCount = 0,
		      idStack = [],
		      idStackIndex = 0,
		      treeContextProvider = null,
		      treeContextId = 1,
		      treeContextOverflow = "",
		      contextStackCursor = createCursor(null),
		      contextFiberStackCursor = createCursor(null),
		      rootInstanceStackCursor = createCursor(null),
		      hostTransitionProviderCursor = createCursor(null),
		      needsEscaping = /["'&<>\n\t]|^\s|\s$/,
		      hydrationParentFiber = null,
		      nextHydratableInstance = null,
		      isHydrating = false,
		      didSuspendOrErrorDEV = false,
		      hydrationDiffRootDEV = null,
		      hydrationErrors = null,
		      rootOrSingletonContext = false,
		      HydrationMismatchException = Error(
		        "Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
		      ),
		      NoMode = 0,
		      concurrentQueues = [],
		      concurrentQueuesIndex = 0,
		      concurrentlyUpdatedLanes = 0,
		      now = Scheduler.unstable_now,
		      commitStartTime = -0,
		      profilerStartTime = -1.1,
		      profilerEffectDuration = -0,
		      currentUpdateIsNested = false,
		      nestedUpdateScheduled = false,
		      firstScheduledRoot = null,
		      lastScheduledRoot = null,
		      didScheduleMicrotask = false,
		      didScheduleMicrotask_act = false,
		      mightHavePendingSyncWork = false,
		      isFlushingWork = false,
		      currentEventTransitionLane = 0,
		      fakeActCallbackNode$1 = {},
		      currentEntangledListeners = null,
		      currentEntangledPendingCount = 0,
		      currentEntangledLane = 0,
		      currentEntangledActionThenable = null,
		      UpdateState = 0,
		      ReplaceState = 1,
		      ForceUpdate = 2,
		      CaptureUpdate = 3,
		      hasForceUpdate = false;
		    var didWarnUpdateInsideUpdate = false;
		    var currentlyProcessingQueue = null;
		    var didReadFromEntangledAsyncAction = false,
		      hasOwnProperty = Object.prototype.hasOwnProperty,
		      ReactStrictModeWarnings = {
		        recordUnsafeLifecycleWarnings: function () {},
		        flushPendingUnsafeLifecycleWarnings: function () {},
		        recordLegacyContextWarning: function () {},
		        flushLegacyContextWarning: function () {},
		        discardPendingWarnings: function () {}
		      },
		      pendingComponentWillMountWarnings = [],
		      pendingUNSAFE_ComponentWillMountWarnings = [],
		      pendingComponentWillReceivePropsWarnings = [],
		      pendingUNSAFE_ComponentWillReceivePropsWarnings = [],
		      pendingComponentWillUpdateWarnings = [],
		      pendingUNSAFE_ComponentWillUpdateWarnings = [],
		      didWarnAboutUnsafeLifecycles = new Set();
		    ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (
		      fiber,
		      instance
		    ) {
		      didWarnAboutUnsafeLifecycles.has(fiber.type) ||
		        ("function" === typeof instance.componentWillMount &&
		          true !== instance.componentWillMount.__suppressDeprecationWarning &&
		          pendingComponentWillMountWarnings.push(fiber),
		        fiber.mode & 8 &&
		          "function" === typeof instance.UNSAFE_componentWillMount &&
		          pendingUNSAFE_ComponentWillMountWarnings.push(fiber),
		        "function" === typeof instance.componentWillReceiveProps &&
		          true !==
		            instance.componentWillReceiveProps.__suppressDeprecationWarning &&
		          pendingComponentWillReceivePropsWarnings.push(fiber),
		        fiber.mode & 8 &&
		          "function" === typeof instance.UNSAFE_componentWillReceiveProps &&
		          pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber),
		        "function" === typeof instance.componentWillUpdate &&
		          true !== instance.componentWillUpdate.__suppressDeprecationWarning &&
		          pendingComponentWillUpdateWarnings.push(fiber),
		        fiber.mode & 8 &&
		          "function" === typeof instance.UNSAFE_componentWillUpdate &&
		          pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
		    };
		    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {
		      var componentWillMountUniqueNames = new Set();
		      0 < pendingComponentWillMountWarnings.length &&
		        (pendingComponentWillMountWarnings.forEach(function (fiber) {
		          componentWillMountUniqueNames.add(
		            getComponentNameFromFiber(fiber) || "Component"
		          );
		          didWarnAboutUnsafeLifecycles.add(fiber.type);
		        }),
		        (pendingComponentWillMountWarnings = []));
		      var UNSAFE_componentWillMountUniqueNames = new Set();
		      0 < pendingUNSAFE_ComponentWillMountWarnings.length &&
		        (pendingUNSAFE_ComponentWillMountWarnings.forEach(function (fiber) {
		          UNSAFE_componentWillMountUniqueNames.add(
		            getComponentNameFromFiber(fiber) || "Component"
		          );
		          didWarnAboutUnsafeLifecycles.add(fiber.type);
		        }),
		        (pendingUNSAFE_ComponentWillMountWarnings = []));
		      var componentWillReceivePropsUniqueNames = new Set();
		      0 < pendingComponentWillReceivePropsWarnings.length &&
		        (pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {
		          componentWillReceivePropsUniqueNames.add(
		            getComponentNameFromFiber(fiber) || "Component"
		          );
		          didWarnAboutUnsafeLifecycles.add(fiber.type);
		        }),
		        (pendingComponentWillReceivePropsWarnings = []));
		      var UNSAFE_componentWillReceivePropsUniqueNames = new Set();
		      0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length &&
		        (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(
		          function (fiber) {
		            UNSAFE_componentWillReceivePropsUniqueNames.add(
		              getComponentNameFromFiber(fiber) || "Component"
		            );
		            didWarnAboutUnsafeLifecycles.add(fiber.type);
		          }
		        ),
		        (pendingUNSAFE_ComponentWillReceivePropsWarnings = []));
		      var componentWillUpdateUniqueNames = new Set();
		      0 < pendingComponentWillUpdateWarnings.length &&
		        (pendingComponentWillUpdateWarnings.forEach(function (fiber) {
		          componentWillUpdateUniqueNames.add(
		            getComponentNameFromFiber(fiber) || "Component"
		          );
		          didWarnAboutUnsafeLifecycles.add(fiber.type);
		        }),
		        (pendingComponentWillUpdateWarnings = []));
		      var UNSAFE_componentWillUpdateUniqueNames = new Set();
		      0 < pendingUNSAFE_ComponentWillUpdateWarnings.length &&
		        (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function (fiber) {
		          UNSAFE_componentWillUpdateUniqueNames.add(
		            getComponentNameFromFiber(fiber) || "Component"
		          );
		          didWarnAboutUnsafeLifecycles.add(fiber.type);
		        }),
		        (pendingUNSAFE_ComponentWillUpdateWarnings = []));
		      if (0 < UNSAFE_componentWillMountUniqueNames.size) {
		        var sortedNames = setToSortedString(
		          UNSAFE_componentWillMountUniqueNames
		        );
		        console.error(
		          "Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s",
		          sortedNames
		        );
		      }
		      0 < UNSAFE_componentWillReceivePropsUniqueNames.size &&
		        ((sortedNames = setToSortedString(
		          UNSAFE_componentWillReceivePropsUniqueNames
		        )),
		        console.error(
		          "Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n\nPlease update the following components: %s",
		          sortedNames
		        ));
		      0 < UNSAFE_componentWillUpdateUniqueNames.size &&
		        ((sortedNames = setToSortedString(
		          UNSAFE_componentWillUpdateUniqueNames
		        )),
		        console.error(
		          "Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s",
		          sortedNames
		        ));
		      0 < componentWillMountUniqueNames.size &&
		        ((sortedNames = setToSortedString(componentWillMountUniqueNames)),
		        console.warn(
		          "componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
		          sortedNames
		        ));
		      0 < componentWillReceivePropsUniqueNames.size &&
		        ((sortedNames = setToSortedString(
		          componentWillReceivePropsUniqueNames
		        )),
		        console.warn(
		          "componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
		          sortedNames
		        ));
		      0 < componentWillUpdateUniqueNames.size &&
		        ((sortedNames = setToSortedString(componentWillUpdateUniqueNames)),
		        console.warn(
		          "componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
		          sortedNames
		        ));
		    };
		    var pendingLegacyContextWarning = new Map(),
		      didWarnAboutLegacyContext = new Set();
		    ReactStrictModeWarnings.recordLegacyContextWarning = function (
		      fiber,
		      instance
		    ) {
		      var strictRoot = null;
		      for (var node = fiber; null !== node; )
		        node.mode & 8 && (strictRoot = node), (node = node.return);
		      null === strictRoot
		        ? console.error(
		            "Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue."
		          )
		        : !didWarnAboutLegacyContext.has(fiber.type) &&
		          ((node = pendingLegacyContextWarning.get(strictRoot)),
		          null != fiber.type.contextTypes ||
		            null != fiber.type.childContextTypes ||
		            (null !== instance &&
		              "function" === typeof instance.getChildContext)) &&
		          (void 0 === node &&
		            ((node = []), pendingLegacyContextWarning.set(strictRoot, node)),
		          node.push(fiber));
		    };
		    ReactStrictModeWarnings.flushLegacyContextWarning = function () {
		      pendingLegacyContextWarning.forEach(function (fiberArray) {
		        if (0 !== fiberArray.length) {
		          var firstFiber = fiberArray[0],
		            uniqueNames = new Set();
		          fiberArray.forEach(function (fiber) {
		            uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
		            didWarnAboutLegacyContext.add(fiber.type);
		          });
		          var sortedNames = setToSortedString(uniqueNames);
		          runWithFiberInDEV(firstFiber, function () {
		            console.error(
		              "Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://react.dev/link/legacy-context",
		              sortedNames
		            );
		          });
		        }
		      });
		    };
		    ReactStrictModeWarnings.discardPendingWarnings = function () {
		      pendingComponentWillMountWarnings = [];
		      pendingUNSAFE_ComponentWillMountWarnings = [];
		      pendingComponentWillReceivePropsWarnings = [];
		      pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
		      pendingComponentWillUpdateWarnings = [];
		      pendingUNSAFE_ComponentWillUpdateWarnings = [];
		      pendingLegacyContextWarning = new Map();
		    };
		    var SuspenseException = Error(
		        "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`"
		      ),
		      SuspenseyCommitException = Error(
		        "Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
		      ),
		      noopSuspenseyCommitThenable = {
		        then: function () {
		          console.error(
		            'Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.'
		          );
		        }
		      },
		      suspendedThenable = null,
		      needsToResetSuspendedThenableDEV = false,
		      callComponent = {
		        "react-stack-bottom-frame": function (Component, props, secondArg) {
		          var wasRendering = isRendering;
		          isRendering = true;
		          try {
		            return Component(props, secondArg);
		          } finally {
		            isRendering = wasRendering;
		          }
		        }
		      },
		      callComponentInDEV =
		        callComponent["react-stack-bottom-frame"].bind(callComponent),
		      callRender = {
		        "react-stack-bottom-frame": function (instance) {
		          var wasRendering = isRendering;
		          isRendering = true;
		          try {
		            return instance.render();
		          } finally {
		            isRendering = wasRendering;
		          }
		        }
		      },
		      callRenderInDEV = callRender["react-stack-bottom-frame"].bind(callRender),
		      callComponentDidMount = {
		        "react-stack-bottom-frame": function (finishedWork, instance) {
		          try {
		            instance.componentDidMount();
		          } catch (error) {
		            captureCommitPhaseError(finishedWork, finishedWork.return, error);
		          }
		        }
		      },
		      callComponentDidMountInDEV = callComponentDidMount[
		        "react-stack-bottom-frame"
		      ].bind(callComponentDidMount),
		      callComponentDidUpdate = {
		        "react-stack-bottom-frame": function (
		          finishedWork,
		          instance,
		          prevProps,
		          prevState,
		          snapshot
		        ) {
		          try {
		            instance.componentDidUpdate(prevProps, prevState, snapshot);
		          } catch (error) {
		            captureCommitPhaseError(finishedWork, finishedWork.return, error);
		          }
		        }
		      },
		      callComponentDidUpdateInDEV = callComponentDidUpdate[
		        "react-stack-bottom-frame"
		      ].bind(callComponentDidUpdate),
		      callComponentDidCatch = {
		        "react-stack-bottom-frame": function (instance, errorInfo) {
		          var stack = errorInfo.stack;
		          instance.componentDidCatch(errorInfo.value, {
		            componentStack: null !== stack ? stack : ""
		          });
		        }
		      },
		      callComponentDidCatchInDEV = callComponentDidCatch[
		        "react-stack-bottom-frame"
		      ].bind(callComponentDidCatch),
		      callComponentWillUnmount = {
		        "react-stack-bottom-frame": function (
		          current,
		          nearestMountedAncestor,
		          instance
		        ) {
		          try {
		            instance.componentWillUnmount();
		          } catch (error) {
		            captureCommitPhaseError(current, nearestMountedAncestor, error);
		          }
		        }
		      },
		      callComponentWillUnmountInDEV = callComponentWillUnmount[
		        "react-stack-bottom-frame"
		      ].bind(callComponentWillUnmount),
		      callCreate = {
		        "react-stack-bottom-frame": function (effect) {
		          var create = effect.create;
		          effect = effect.inst;
		          create = create();
		          return (effect.destroy = create);
		        }
		      },
		      callCreateInDEV = callCreate["react-stack-bottom-frame"].bind(callCreate),
		      callDestroy = {
		        "react-stack-bottom-frame": function (
		          current,
		          nearestMountedAncestor,
		          destroy
		        ) {
		          try {
		            destroy();
		          } catch (error) {
		            captureCommitPhaseError(current, nearestMountedAncestor, error);
		          }
		        }
		      },
		      callDestroyInDEV =
		        callDestroy["react-stack-bottom-frame"].bind(callDestroy),
		      callLazyInit = {
		        "react-stack-bottom-frame": function (lazy) {
		          var init = lazy._init;
		          return init(lazy._payload);
		        }
		      },
		      callLazyInitInDEV =
		        callLazyInit["react-stack-bottom-frame"].bind(callLazyInit),
		      thenableState$1 = null,
		      thenableIndexCounter$1 = 0,
		      currentDebugInfo = null,
		      didWarnAboutMaps;
		    var didWarnAboutGenerators = (didWarnAboutMaps = false);
		    var ownerHasKeyUseWarning = {};
		    var ownerHasFunctionTypeWarning = {};
		    var ownerHasSymbolTypeWarning = {};
		    warnForMissingKey = function (returnFiber, workInProgress, child) {
		      if (
		        null !== child &&
		        "object" === typeof child &&
		        child._store &&
		        ((!child._store.validated && null == child.key) ||
		          2 === child._store.validated)
		      ) {
		        if ("object" !== typeof child._store)
		          throw Error(
		            "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
		          );
		        child._store.validated = 1;
		        var componentName = getComponentNameFromFiber(returnFiber),
		          componentKey = componentName || "null";
		        if (!ownerHasKeyUseWarning[componentKey]) {
		          ownerHasKeyUseWarning[componentKey] = true;
		          child = child._owner;
		          returnFiber = returnFiber._debugOwner;
		          var currentComponentErrorInfo = "";
		          returnFiber &&
		            "number" === typeof returnFiber.tag &&
		            (componentKey = getComponentNameFromFiber(returnFiber)) &&
		            (currentComponentErrorInfo =
		              "\n\nCheck the render method of `" + componentKey + "`.");
		          currentComponentErrorInfo ||
		            (componentName &&
		              (currentComponentErrorInfo =
		                "\n\nCheck the top-level render call using <" +
		                componentName +
		                ">."));
		          var childOwnerAppendix = "";
		          null != child &&
		            returnFiber !== child &&
		            ((componentName = null),
		            "number" === typeof child.tag
		              ? (componentName = getComponentNameFromFiber(child))
		              : "string" === typeof child.name && (componentName = child.name),
		            componentName &&
		              (childOwnerAppendix =
		                " It was passed a child from " + componentName + "."));
		          runWithFiberInDEV(workInProgress, function () {
		            console.error(
		              'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
		              currentComponentErrorInfo,
		              childOwnerAppendix
		            );
		          });
		        }
		      }
		    };
		    var reconcileChildFibers = createChildReconciler(true),
		      mountChildFibers = createChildReconciler(false),
		      currentTreeHiddenStackCursor = createCursor(null),
		      prevEntangledRenderLanesCursor = createCursor(0),
		      suspenseHandlerStackCursor = createCursor(null),
		      shellBoundary = null,
		      SubtreeSuspenseContextMask = 1,
		      ForceSuspenseFallback = 2,
		      suspenseStackCursor = createCursor(0),
		      NoFlags = 0,
		      HasEffect = 1,
		      Insertion = 2,
		      Layout = 4,
		      Passive = 8,
		      didWarnUncachedGetSnapshot;
		    var didWarnAboutMismatchedHooksForComponent = new Set();
		    var didWarnAboutUseWrappedInTryCatch = new Set();
		    var didWarnAboutAsyncClientComponent = new Set();
		    var didWarnAboutUseFormState = new Set();
		    var renderLanes = 0,
		      currentlyRenderingFiber$1 = null,
		      currentHook = null,
		      workInProgressHook = null,
		      didScheduleRenderPhaseUpdate = false,
		      didScheduleRenderPhaseUpdateDuringThisPass = false,
		      shouldDoubleInvokeUserFnsInHooksDEV = false,
		      localIdCounter = 0,
		      thenableIndexCounter = 0,
		      thenableState = null,
		      globalClientIdCounter = 0,
		      RE_RENDER_LIMIT = 25,
		      currentHookNameInDev = null,
		      hookTypesDev = null,
		      hookTypesUpdateIndexDev = -1,
		      ignorePreviousDependencies = false;
		    var createFunctionComponentUpdateQueue = function () {
		      return { lastEffect: null, events: null, stores: null, memoCache: null };
		    };
		    var ContextOnlyDispatcher = {
		      readContext: readContext,
		      use: use,
		      useCallback: throwInvalidHookError,
		      useContext: throwInvalidHookError,
		      useEffect: throwInvalidHookError,
		      useImperativeHandle: throwInvalidHookError,
		      useLayoutEffect: throwInvalidHookError,
		      useInsertionEffect: throwInvalidHookError,
		      useMemo: throwInvalidHookError,
		      useReducer: throwInvalidHookError,
		      useRef: throwInvalidHookError,
		      useState: throwInvalidHookError,
		      useDebugValue: throwInvalidHookError,
		      useDeferredValue: throwInvalidHookError,
		      useTransition: throwInvalidHookError,
		      useSyncExternalStore: throwInvalidHookError,
		      useId: throwInvalidHookError
		    };
		    ContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError;
		    ContextOnlyDispatcher.useMemoCache = throwInvalidHookError;
		    ContextOnlyDispatcher.useHostTransitionStatus = throwInvalidHookError;
		    ContextOnlyDispatcher.useFormState = throwInvalidHookError;
		    ContextOnlyDispatcher.useActionState = throwInvalidHookError;
		    ContextOnlyDispatcher.useOptimistic = throwInvalidHookError;
		    var HooksDispatcherOnMountInDEV = null,
		      HooksDispatcherOnMountWithHookTypesInDEV = null,
		      HooksDispatcherOnUpdateInDEV = null,
		      HooksDispatcherOnRerenderInDEV = null,
		      InvalidNestedHooksDispatcherOnMountInDEV = null,
		      InvalidNestedHooksDispatcherOnUpdateInDEV = null,
		      InvalidNestedHooksDispatcherOnRerenderInDEV = null;
		    HooksDispatcherOnMountInDEV = {
		      readContext: function (context) {
		        return readContext(context);
		      },
		      use: use,
		      useCallback: function (callback, deps) {
		        currentHookNameInDev = "useCallback";
		        mountHookTypesDev();
		        checkDepsAreArrayDev(deps);
		        return mountCallback(callback, deps);
		      },
		      useContext: function (context) {
		        currentHookNameInDev = "useContext";
		        mountHookTypesDev();
		        return readContext(context);
		      },
		      useEffect: function (create, deps) {
		        currentHookNameInDev = "useEffect";
		        mountHookTypesDev();
		        checkDepsAreArrayDev(deps);
		        return mountEffect(create, deps);
		      },
		      useImperativeHandle: function (ref, create, deps) {
		        currentHookNameInDev = "useImperativeHandle";
		        mountHookTypesDev();
		        checkDepsAreArrayDev(deps);
		        return mountImperativeHandle(ref, create, deps);
		      },
		      useInsertionEffect: function (create, deps) {
		        currentHookNameInDev = "useInsertionEffect";
		        mountHookTypesDev();
		        checkDepsAreArrayDev(deps);
		        mountEffectImpl(4, Insertion, create, deps);
		      },
		      useLayoutEffect: function (create, deps) {
		        currentHookNameInDev = "useLayoutEffect";
		        mountHookTypesDev();
		        checkDepsAreArrayDev(deps);
		        return mountLayoutEffect(create, deps);
		      },
		      useMemo: function (create, deps) {
		        currentHookNameInDev = "useMemo";
		        mountHookTypesDev();
		        checkDepsAreArrayDev(deps);
		        var prevDispatcher = ReactSharedInternals.H;
		        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
		        try {
		          return mountMemo(create, deps);
		        } finally {
		          ReactSharedInternals.H = prevDispatcher;
		        }
		      },
		      useReducer: function (reducer, initialArg, init) {
		        currentHookNameInDev = "useReducer";
		        mountHookTypesDev();
		        var prevDispatcher = ReactSharedInternals.H;
		        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
		        try {
		          return mountReducer(reducer, initialArg, init);
		        } finally {
		          ReactSharedInternals.H = prevDispatcher;
		        }
		      },
		      useRef: function (initialValue) {
		        currentHookNameInDev = "useRef";
		        mountHookTypesDev();
		        return mountRef(initialValue);
		      },
		      useState: function (initialState) {
		        currentHookNameInDev = "useState";
		        mountHookTypesDev();
		        var prevDispatcher = ReactSharedInternals.H;
		        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
		        try {
		          return mountState(initialState);
		        } finally {
		          ReactSharedInternals.H = prevDispatcher;
		        }
		      },
		      useDebugValue: function () {
		        currentHookNameInDev = "useDebugValue";
		        mountHookTypesDev();
		      },
		      useDeferredValue: function (value, initialValue) {
		        currentHookNameInDev = "useDeferredValue";
		        mountHookTypesDev();
		        return mountDeferredValue(value, initialValue);
		      },
		      useTransition: function () {
		        currentHookNameInDev = "useTransition";
		        mountHookTypesDev();
		        return mountTransition();
		      },
		      useSyncExternalStore: function (
		        subscribe,
		        getSnapshot,
		        getServerSnapshot
		      ) {
		        currentHookNameInDev = "useSyncExternalStore";
		        mountHookTypesDev();
		        return mountSyncExternalStore(
		          subscribe,
		          getSnapshot,
		          getServerSnapshot
		        );
		      },
		      useId: function () {
		        currentHookNameInDev = "useId";
		        mountHookTypesDev();
		        return mountId();
		      },
		      useCacheRefresh: function () {
		        currentHookNameInDev = "useCacheRefresh";
		        mountHookTypesDev();
		        return mountRefresh();
		      }
		    };
		    HooksDispatcherOnMountInDEV.useMemoCache = useMemoCache;
		    HooksDispatcherOnMountInDEV.useHostTransitionStatus =
		      useHostTransitionStatus;
		    HooksDispatcherOnMountInDEV.useFormState = function (action, initialState) {
		      currentHookNameInDev = "useFormState";
		      mountHookTypesDev();
		      warnOnUseFormStateInDev();
		      return mountActionState(action, initialState);
		    };
		    HooksDispatcherOnMountInDEV.useActionState = function (
		      action,
		      initialState
		    ) {
		      currentHookNameInDev = "useActionState";
		      mountHookTypesDev();
		      return mountActionState(action, initialState);
		    };
		    HooksDispatcherOnMountInDEV.useOptimistic = function (passthrough) {
		      currentHookNameInDev = "useOptimistic";
		      mountHookTypesDev();
		      return mountOptimistic(passthrough);
		    };
		    HooksDispatcherOnMountWithHookTypesInDEV = {
		      readContext: function (context) {
		        return readContext(context);
		      },
		      use: use,
		      useCallback: function (callback, deps) {
		        currentHookNameInDev = "useCallback";
		        updateHookTypesDev();
		        return mountCallback(callback, deps);
		      },
		      useContext: function (context) {
		        currentHookNameInDev = "useContext";
		        updateHookTypesDev();
		        return readContext(context);
		      },
		      useEffect: function (create, deps) {
		        currentHookNameInDev = "useEffect";
		        updateHookTypesDev();
		        return mountEffect(create, deps);
		      },
		      useImperativeHandle: function (ref, create, deps) {
		        currentHookNameInDev = "useImperativeHandle";
		        updateHookTypesDev();
		        return mountImperativeHandle(ref, create, deps);
		      },
		      useInsertionEffect: function (create, deps) {
		        currentHookNameInDev = "useInsertionEffect";
		        updateHookTypesDev();
		        mountEffectImpl(4, Insertion, create, deps);
		      },
		      useLayoutEffect: function (create, deps) {
		        currentHookNameInDev = "useLayoutEffect";
		        updateHookTypesDev();
		        return mountLayoutEffect(create, deps);
		      },
		      useMemo: function (create, deps) {
		        currentHookNameInDev = "useMemo";
		        updateHookTypesDev();
		        var prevDispatcher = ReactSharedInternals.H;
		        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
		        try {
		          return mountMemo(create, deps);
		        } finally {
		          ReactSharedInternals.H = prevDispatcher;
		        }
		      },
		      useReducer: function (reducer, initialArg, init) {
		        currentHookNameInDev = "useReducer";
		        updateHookTypesDev();
		        var prevDispatcher = ReactSharedInternals.H;
		        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
		        try {
		          return mountReducer(reducer, initialArg, init);
		        } finally {
		          ReactSharedInternals.H = prevDispatcher;
		        }
		      },
		      useRef: function (initialValue) {
		        currentHookNameInDev = "useRef";
		        updateHookTypesDev();
		        return mountRef(initialValue);
		      },
		      useState: function (initialState) {
		        currentHookNameInDev = "useState";
		        updateHookTypesDev();
		        var prevDispatcher = ReactSharedInternals.H;
		        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
		        try {
		          return mountState(initialState);
		        } finally {
		          ReactSharedInternals.H = prevDispatcher;
		        }
		      },
		      useDebugValue: function () {
		        currentHookNameInDev = "useDebugValue";
		        updateHookTypesDev();
		      },
		      useDeferredValue: function (value, initialValue) {
		        currentHookNameInDev = "useDeferredValue";
		        updateHookTypesDev();
		        return mountDeferredValue(value, initialValue);
		      },
		      useTransition: function () {
		        currentHookNameInDev = "useTransition";
		        updateHookTypesDev();
		        return mountTransition();
		      },
		      useSyncExternalStore: function (
		        subscribe,
		        getSnapshot,
		        getServerSnapshot
		      ) {
		        currentHookNameInDev = "useSyncExternalStore";
		        updateHookTypesDev();
		        return mountSyncExternalStore(
		          subscribe,
		          getSnapshot,
		          getServerSnapshot
		        );
		      },
		      useId: function () {
		        currentHookNameInDev = "useId";
		        updateHookTypesDev();
		        return mountId();
		      },
		      useCacheRefresh: function () {
		        currentHookNameInDev = "useCacheRefresh";
		        updateHookTypesDev();
		        return mountRefresh();
		      }
		    };
		    HooksDispatcherOnMountWithHookTypesInDEV.useMemoCache = useMemoCache;
		    HooksDispatcherOnMountWithHookTypesInDEV.useHostTransitionStatus =
		      useHostTransitionStatus;
		    HooksDispatcherOnMountWithHookTypesInDEV.useFormState = function (
		      action,
		      initialState
		    ) {
		      currentHookNameInDev = "useFormState";
		      updateHookTypesDev();
		      warnOnUseFormStateInDev();
		      return mountActionState(action, initialState);
		    };
		    HooksDispatcherOnMountWithHookTypesInDEV.useActionState = function (
		      action,
		      initialState
		    ) {
		      currentHookNameInDev = "useActionState";
		      updateHookTypesDev();
		      return mountActionState(action, initialState);
		    };
		    HooksDispatcherOnMountWithHookTypesInDEV.useOptimistic = function (
		      passthrough
		    ) {
		      currentHookNameInDev = "useOptimistic";
		      updateHookTypesDev();
		      return mountOptimistic(passthrough);
		    };
		    HooksDispatcherOnUpdateInDEV = {
		      readContext: function (context) {
		        return readContext(context);
		      },
		      use: use,
		      useCallback: function (callback, deps) {
		        currentHookNameInDev = "useCallback";
		        updateHookTypesDev();
		        return updateCallback(callback, deps);
		      },
		      useContext: function (context) {
		        currentHookNameInDev = "useContext";
		        updateHookTypesDev();
		        return readContext(context);
		      },
		      useEffect: function (create, deps) {
		        currentHookNameInDev = "useEffect";
		        updateHookTypesDev();
		        updateEffectImpl(2048, Passive, create, deps);
		      },
		      useImperativeHandle: function (ref, create, deps) {
		        currentHookNameInDev = "useImperativeHandle";
		        updateHookTypesDev();
		        return updateImperativeHandle(ref, create, deps);
		      },
		      useInsertionEffect: function (create, deps) {
		        currentHookNameInDev = "useInsertionEffect";
		        updateHookTypesDev();
		        return updateEffectImpl(4, Insertion, create, deps);
		      },
		      useLayoutEffect: function (create, deps) {
		        currentHookNameInDev = "useLayoutEffect";
		        updateHookTypesDev();
		        return updateEffectImpl(4, Layout, create, deps);
		      },
		      useMemo: function (create, deps) {
		        currentHookNameInDev = "useMemo";
		        updateHookTypesDev();
		        var prevDispatcher = ReactSharedInternals.H;
		        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
		        try {
		          return updateMemo(create, deps);
		        } finally {
		          ReactSharedInternals.H = prevDispatcher;
		        }
		      },
		      useReducer: function (reducer, initialArg, init) {
		        currentHookNameInDev = "useReducer";
		        updateHookTypesDev();
		        var prevDispatcher = ReactSharedInternals.H;
		        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
		        try {
		          return updateReducer(reducer, initialArg, init);
		        } finally {
		          ReactSharedInternals.H = prevDispatcher;
		        }
		      },
		      useRef: function () {
		        currentHookNameInDev = "useRef";
		        updateHookTypesDev();
		        return updateWorkInProgressHook().memoizedState;
		      },
		      useState: function () {
		        currentHookNameInDev = "useState";
		        updateHookTypesDev();
		        var prevDispatcher = ReactSharedInternals.H;
		        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
		        try {
		          return updateReducer(basicStateReducer);
		        } finally {
		          ReactSharedInternals.H = prevDispatcher;
		        }
		      },
		      useDebugValue: function () {
		        currentHookNameInDev = "useDebugValue";
		        updateHookTypesDev();
		      },
		      useDeferredValue: function (value, initialValue) {
		        currentHookNameInDev = "useDeferredValue";
		        updateHookTypesDev();
		        return updateDeferredValue(value, initialValue);
		      },
		      useTransition: function () {
		        currentHookNameInDev = "useTransition";
		        updateHookTypesDev();
		        return updateTransition();
		      },
		      useSyncExternalStore: function (
		        subscribe,
		        getSnapshot,
		        getServerSnapshot
		      ) {
		        currentHookNameInDev = "useSyncExternalStore";
		        updateHookTypesDev();
		        return updateSyncExternalStore(
		          subscribe,
		          getSnapshot,
		          getServerSnapshot
		        );
		      },
		      useId: function () {
		        currentHookNameInDev = "useId";
		        updateHookTypesDev();
		        return updateWorkInProgressHook().memoizedState;
		      },
		      useCacheRefresh: function () {
		        currentHookNameInDev = "useCacheRefresh";
		        updateHookTypesDev();
		        return updateWorkInProgressHook().memoizedState;
		      }
		    };
		    HooksDispatcherOnUpdateInDEV.useMemoCache = useMemoCache;
		    HooksDispatcherOnUpdateInDEV.useHostTransitionStatus =
		      useHostTransitionStatus;
		    HooksDispatcherOnUpdateInDEV.useFormState = function (action) {
		      currentHookNameInDev = "useFormState";
		      updateHookTypesDev();
		      warnOnUseFormStateInDev();
		      return updateActionState(action);
		    };
		    HooksDispatcherOnUpdateInDEV.useActionState = function (action) {
		      currentHookNameInDev = "useActionState";
		      updateHookTypesDev();
		      return updateActionState(action);
		    };
		    HooksDispatcherOnUpdateInDEV.useOptimistic = function (
		      passthrough,
		      reducer
		    ) {
		      currentHookNameInDev = "useOptimistic";
		      updateHookTypesDev();
		      return updateOptimistic(passthrough, reducer);
		    };
		    HooksDispatcherOnRerenderInDEV = {
		      readContext: function (context) {
		        return readContext(context);
		      },
		      use: use,
		      useCallback: function (callback, deps) {
		        currentHookNameInDev = "useCallback";
		        updateHookTypesDev();
		        return updateCallback(callback, deps);
		      },
		      useContext: function (context) {
		        currentHookNameInDev = "useContext";
		        updateHookTypesDev();
		        return readContext(context);
		      },
		      useEffect: function (create, deps) {
		        currentHookNameInDev = "useEffect";
		        updateHookTypesDev();
		        updateEffectImpl(2048, Passive, create, deps);
		      },
		      useImperativeHandle: function (ref, create, deps) {
		        currentHookNameInDev = "useImperativeHandle";
		        updateHookTypesDev();
		        return updateImperativeHandle(ref, create, deps);
		      },
		      useInsertionEffect: function (create, deps) {
		        currentHookNameInDev = "useInsertionEffect";
		        updateHookTypesDev();
		        return updateEffectImpl(4, Insertion, create, deps);
		      },
		      useLayoutEffect: function (create, deps) {
		        currentHookNameInDev = "useLayoutEffect";
		        updateHookTypesDev();
		        return updateEffectImpl(4, Layout, create, deps);
		      },
		      useMemo: function (create, deps) {
		        currentHookNameInDev = "useMemo";
		        updateHookTypesDev();
		        var prevDispatcher = ReactSharedInternals.H;
		        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
		        try {
		          return updateMemo(create, deps);
		        } finally {
		          ReactSharedInternals.H = prevDispatcher;
		        }
		      },
		      useReducer: function (reducer, initialArg, init) {
		        currentHookNameInDev = "useReducer";
		        updateHookTypesDev();
		        var prevDispatcher = ReactSharedInternals.H;
		        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
		        try {
		          return rerenderReducer(reducer, initialArg, init);
		        } finally {
		          ReactSharedInternals.H = prevDispatcher;
		        }
		      },
		      useRef: function () {
		        currentHookNameInDev = "useRef";
		        updateHookTypesDev();
		        return updateWorkInProgressHook().memoizedState;
		      },
		      useState: function () {
		        currentHookNameInDev = "useState";
		        updateHookTypesDev();
		        var prevDispatcher = ReactSharedInternals.H;
		        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
		        try {
		          return rerenderReducer(basicStateReducer);
		        } finally {
		          ReactSharedInternals.H = prevDispatcher;
		        }
		      },
		      useDebugValue: function () {
		        currentHookNameInDev = "useDebugValue";
		        updateHookTypesDev();
		      },
		      useDeferredValue: function (value, initialValue) {
		        currentHookNameInDev = "useDeferredValue";
		        updateHookTypesDev();
		        return rerenderDeferredValue(value, initialValue);
		      },
		      useTransition: function () {
		        currentHookNameInDev = "useTransition";
		        updateHookTypesDev();
		        return rerenderTransition();
		      },
		      useSyncExternalStore: function (
		        subscribe,
		        getSnapshot,
		        getServerSnapshot
		      ) {
		        currentHookNameInDev = "useSyncExternalStore";
		        updateHookTypesDev();
		        return updateSyncExternalStore(
		          subscribe,
		          getSnapshot,
		          getServerSnapshot
		        );
		      },
		      useId: function () {
		        currentHookNameInDev = "useId";
		        updateHookTypesDev();
		        return updateWorkInProgressHook().memoizedState;
		      },
		      useCacheRefresh: function () {
		        currentHookNameInDev = "useCacheRefresh";
		        updateHookTypesDev();
		        return updateWorkInProgressHook().memoizedState;
		      }
		    };
		    HooksDispatcherOnRerenderInDEV.useMemoCache = useMemoCache;
		    HooksDispatcherOnRerenderInDEV.useHostTransitionStatus =
		      useHostTransitionStatus;
		    HooksDispatcherOnRerenderInDEV.useFormState = function (action) {
		      currentHookNameInDev = "useFormState";
		      updateHookTypesDev();
		      warnOnUseFormStateInDev();
		      return rerenderActionState(action);
		    };
		    HooksDispatcherOnRerenderInDEV.useActionState = function (action) {
		      currentHookNameInDev = "useActionState";
		      updateHookTypesDev();
		      return rerenderActionState(action);
		    };
		    HooksDispatcherOnRerenderInDEV.useOptimistic = function (
		      passthrough,
		      reducer
		    ) {
		      currentHookNameInDev = "useOptimistic";
		      updateHookTypesDev();
		      return rerenderOptimistic(passthrough, reducer);
		    };
		    InvalidNestedHooksDispatcherOnMountInDEV = {
		      readContext: function (context) {
		        warnInvalidContextAccess();
		        return readContext(context);
		      },
		      use: function (usable) {
		        warnInvalidHookAccess();
		        return use(usable);
		      },
		      useCallback: function (callback, deps) {
		        currentHookNameInDev = "useCallback";
		        warnInvalidHookAccess();
		        mountHookTypesDev();
		        return mountCallback(callback, deps);
		      },
		      useContext: function (context) {
		        currentHookNameInDev = "useContext";
		        warnInvalidHookAccess();
		        mountHookTypesDev();
		        return readContext(context);
		      },
		      useEffect: function (create, deps) {
		        currentHookNameInDev = "useEffect";
		        warnInvalidHookAccess();
		        mountHookTypesDev();
		        return mountEffect(create, deps);
		      },
		      useImperativeHandle: function (ref, create, deps) {
		        currentHookNameInDev = "useImperativeHandle";
		        warnInvalidHookAccess();
		        mountHookTypesDev();
		        return mountImperativeHandle(ref, create, deps);
		      },
		      useInsertionEffect: function (create, deps) {
		        currentHookNameInDev = "useInsertionEffect";
		        warnInvalidHookAccess();
		        mountHookTypesDev();
		        mountEffectImpl(4, Insertion, create, deps);
		      },
		      useLayoutEffect: function (create, deps) {
		        currentHookNameInDev = "useLayoutEffect";
		        warnInvalidHookAccess();
		        mountHookTypesDev();
		        return mountLayoutEffect(create, deps);
		      },
		      useMemo: function (create, deps) {
		        currentHookNameInDev = "useMemo";
		        warnInvalidHookAccess();
		        mountHookTypesDev();
		        var prevDispatcher = ReactSharedInternals.H;
		        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
		        try {
		          return mountMemo(create, deps);
		        } finally {
		          ReactSharedInternals.H = prevDispatcher;
		        }
		      },
		      useReducer: function (reducer, initialArg, init) {
		        currentHookNameInDev = "useReducer";
		        warnInvalidHookAccess();
		        mountHookTypesDev();
		        var prevDispatcher = ReactSharedInternals.H;
		        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
		        try {
		          return mountReducer(reducer, initialArg, init);
		        } finally {
		          ReactSharedInternals.H = prevDispatcher;
		        }
		      },
		      useRef: function (initialValue) {
		        currentHookNameInDev = "useRef";
		        warnInvalidHookAccess();
		        mountHookTypesDev();
		        return mountRef(initialValue);
		      },
		      useState: function (initialState) {
		        currentHookNameInDev = "useState";
		        warnInvalidHookAccess();
		        mountHookTypesDev();
		        var prevDispatcher = ReactSharedInternals.H;
		        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
		        try {
		          return mountState(initialState);
		        } finally {
		          ReactSharedInternals.H = prevDispatcher;
		        }
		      },
		      useDebugValue: function () {
		        currentHookNameInDev = "useDebugValue";
		        warnInvalidHookAccess();
		        mountHookTypesDev();
		      },
		      useDeferredValue: function (value, initialValue) {
		        currentHookNameInDev = "useDeferredValue";
		        warnInvalidHookAccess();
		        mountHookTypesDev();
		        return mountDeferredValue(value, initialValue);
		      },
		      useTransition: function () {
		        currentHookNameInDev = "useTransition";
		        warnInvalidHookAccess();
		        mountHookTypesDev();
		        return mountTransition();
		      },
		      useSyncExternalStore: function (
		        subscribe,
		        getSnapshot,
		        getServerSnapshot
		      ) {
		        currentHookNameInDev = "useSyncExternalStore";
		        warnInvalidHookAccess();
		        mountHookTypesDev();
		        return mountSyncExternalStore(
		          subscribe,
		          getSnapshot,
		          getServerSnapshot
		        );
		      },
		      useId: function () {
		        currentHookNameInDev = "useId";
		        warnInvalidHookAccess();
		        mountHookTypesDev();
		        return mountId();
		      },
		      useCacheRefresh: function () {
		        currentHookNameInDev = "useCacheRefresh";
		        mountHookTypesDev();
		        return mountRefresh();
		      },
		      useMemoCache: function (size) {
		        warnInvalidHookAccess();
		        return useMemoCache(size);
		      }
		    };
		    InvalidNestedHooksDispatcherOnMountInDEV.useHostTransitionStatus =
		      useHostTransitionStatus;
		    InvalidNestedHooksDispatcherOnMountInDEV.useFormState = function (
		      action,
		      initialState
		    ) {
		      currentHookNameInDev = "useFormState";
		      warnInvalidHookAccess();
		      mountHookTypesDev();
		      return mountActionState(action, initialState);
		    };
		    InvalidNestedHooksDispatcherOnMountInDEV.useActionState = function (
		      action,
		      initialState
		    ) {
		      currentHookNameInDev = "useActionState";
		      warnInvalidHookAccess();
		      mountHookTypesDev();
		      return mountActionState(action, initialState);
		    };
		    InvalidNestedHooksDispatcherOnMountInDEV.useOptimistic = function (
		      passthrough
		    ) {
		      currentHookNameInDev = "useOptimistic";
		      warnInvalidHookAccess();
		      mountHookTypesDev();
		      return mountOptimistic(passthrough);
		    };
		    InvalidNestedHooksDispatcherOnUpdateInDEV = {
		      readContext: function (context) {
		        warnInvalidContextAccess();
		        return readContext(context);
		      },
		      use: function (usable) {
		        warnInvalidHookAccess();
		        return use(usable);
		      },
		      useCallback: function (callback, deps) {
		        currentHookNameInDev = "useCallback";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		        return updateCallback(callback, deps);
		      },
		      useContext: function (context) {
		        currentHookNameInDev = "useContext";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		        return readContext(context);
		      },
		      useEffect: function (create, deps) {
		        currentHookNameInDev = "useEffect";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		        updateEffectImpl(2048, Passive, create, deps);
		      },
		      useImperativeHandle: function (ref, create, deps) {
		        currentHookNameInDev = "useImperativeHandle";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		        return updateImperativeHandle(ref, create, deps);
		      },
		      useInsertionEffect: function (create, deps) {
		        currentHookNameInDev = "useInsertionEffect";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		        return updateEffectImpl(4, Insertion, create, deps);
		      },
		      useLayoutEffect: function (create, deps) {
		        currentHookNameInDev = "useLayoutEffect";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		        return updateEffectImpl(4, Layout, create, deps);
		      },
		      useMemo: function (create, deps) {
		        currentHookNameInDev = "useMemo";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		        var prevDispatcher = ReactSharedInternals.H;
		        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
		        try {
		          return updateMemo(create, deps);
		        } finally {
		          ReactSharedInternals.H = prevDispatcher;
		        }
		      },
		      useReducer: function (reducer, initialArg, init) {
		        currentHookNameInDev = "useReducer";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		        var prevDispatcher = ReactSharedInternals.H;
		        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
		        try {
		          return updateReducer(reducer, initialArg, init);
		        } finally {
		          ReactSharedInternals.H = prevDispatcher;
		        }
		      },
		      useRef: function () {
		        currentHookNameInDev = "useRef";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		        return updateWorkInProgressHook().memoizedState;
		      },
		      useState: function () {
		        currentHookNameInDev = "useState";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		        var prevDispatcher = ReactSharedInternals.H;
		        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
		        try {
		          return updateReducer(basicStateReducer);
		        } finally {
		          ReactSharedInternals.H = prevDispatcher;
		        }
		      },
		      useDebugValue: function () {
		        currentHookNameInDev = "useDebugValue";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		      },
		      useDeferredValue: function (value, initialValue) {
		        currentHookNameInDev = "useDeferredValue";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		        return updateDeferredValue(value, initialValue);
		      },
		      useTransition: function () {
		        currentHookNameInDev = "useTransition";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		        return updateTransition();
		      },
		      useSyncExternalStore: function (
		        subscribe,
		        getSnapshot,
		        getServerSnapshot
		      ) {
		        currentHookNameInDev = "useSyncExternalStore";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		        return updateSyncExternalStore(
		          subscribe,
		          getSnapshot,
		          getServerSnapshot
		        );
		      },
		      useId: function () {
		        currentHookNameInDev = "useId";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		        return updateWorkInProgressHook().memoizedState;
		      },
		      useCacheRefresh: function () {
		        currentHookNameInDev = "useCacheRefresh";
		        updateHookTypesDev();
		        return updateWorkInProgressHook().memoizedState;
		      },
		      useMemoCache: function (size) {
		        warnInvalidHookAccess();
		        return useMemoCache(size);
		      }
		    };
		    InvalidNestedHooksDispatcherOnUpdateInDEV.useHostTransitionStatus =
		      useHostTransitionStatus;
		    InvalidNestedHooksDispatcherOnUpdateInDEV.useFormState = function (action) {
		      currentHookNameInDev = "useFormState";
		      warnInvalidHookAccess();
		      updateHookTypesDev();
		      return updateActionState(action);
		    };
		    InvalidNestedHooksDispatcherOnUpdateInDEV.useActionState = function (
		      action
		    ) {
		      currentHookNameInDev = "useActionState";
		      warnInvalidHookAccess();
		      updateHookTypesDev();
		      return updateActionState(action);
		    };
		    InvalidNestedHooksDispatcherOnUpdateInDEV.useOptimistic = function (
		      passthrough,
		      reducer
		    ) {
		      currentHookNameInDev = "useOptimistic";
		      warnInvalidHookAccess();
		      updateHookTypesDev();
		      return updateOptimistic(passthrough, reducer);
		    };
		    InvalidNestedHooksDispatcherOnRerenderInDEV = {
		      readContext: function (context) {
		        warnInvalidContextAccess();
		        return readContext(context);
		      },
		      use: function (usable) {
		        warnInvalidHookAccess();
		        return use(usable);
		      },
		      useCallback: function (callback, deps) {
		        currentHookNameInDev = "useCallback";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		        return updateCallback(callback, deps);
		      },
		      useContext: function (context) {
		        currentHookNameInDev = "useContext";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		        return readContext(context);
		      },
		      useEffect: function (create, deps) {
		        currentHookNameInDev = "useEffect";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		        updateEffectImpl(2048, Passive, create, deps);
		      },
		      useImperativeHandle: function (ref, create, deps) {
		        currentHookNameInDev = "useImperativeHandle";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		        return updateImperativeHandle(ref, create, deps);
		      },
		      useInsertionEffect: function (create, deps) {
		        currentHookNameInDev = "useInsertionEffect";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		        return updateEffectImpl(4, Insertion, create, deps);
		      },
		      useLayoutEffect: function (create, deps) {
		        currentHookNameInDev = "useLayoutEffect";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		        return updateEffectImpl(4, Layout, create, deps);
		      },
		      useMemo: function (create, deps) {
		        currentHookNameInDev = "useMemo";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		        var prevDispatcher = ReactSharedInternals.H;
		        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
		        try {
		          return updateMemo(create, deps);
		        } finally {
		          ReactSharedInternals.H = prevDispatcher;
		        }
		      },
		      useReducer: function (reducer, initialArg, init) {
		        currentHookNameInDev = "useReducer";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		        var prevDispatcher = ReactSharedInternals.H;
		        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
		        try {
		          return rerenderReducer(reducer, initialArg, init);
		        } finally {
		          ReactSharedInternals.H = prevDispatcher;
		        }
		      },
		      useRef: function () {
		        currentHookNameInDev = "useRef";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		        return updateWorkInProgressHook().memoizedState;
		      },
		      useState: function () {
		        currentHookNameInDev = "useState";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		        var prevDispatcher = ReactSharedInternals.H;
		        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
		        try {
		          return rerenderReducer(basicStateReducer);
		        } finally {
		          ReactSharedInternals.H = prevDispatcher;
		        }
		      },
		      useDebugValue: function () {
		        currentHookNameInDev = "useDebugValue";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		      },
		      useDeferredValue: function (value, initialValue) {
		        currentHookNameInDev = "useDeferredValue";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		        return rerenderDeferredValue(value, initialValue);
		      },
		      useTransition: function () {
		        currentHookNameInDev = "useTransition";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		        return rerenderTransition();
		      },
		      useSyncExternalStore: function (
		        subscribe,
		        getSnapshot,
		        getServerSnapshot
		      ) {
		        currentHookNameInDev = "useSyncExternalStore";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		        return updateSyncExternalStore(
		          subscribe,
		          getSnapshot,
		          getServerSnapshot
		        );
		      },
		      useId: function () {
		        currentHookNameInDev = "useId";
		        warnInvalidHookAccess();
		        updateHookTypesDev();
		        return updateWorkInProgressHook().memoizedState;
		      },
		      useCacheRefresh: function () {
		        currentHookNameInDev = "useCacheRefresh";
		        updateHookTypesDev();
		        return updateWorkInProgressHook().memoizedState;
		      },
		      useMemoCache: function (size) {
		        warnInvalidHookAccess();
		        return useMemoCache(size);
		      }
		    };
		    InvalidNestedHooksDispatcherOnRerenderInDEV.useHostTransitionStatus =
		      useHostTransitionStatus;
		    InvalidNestedHooksDispatcherOnRerenderInDEV.useFormState = function (
		      action
		    ) {
		      currentHookNameInDev = "useFormState";
		      warnInvalidHookAccess();
		      updateHookTypesDev();
		      return rerenderActionState(action);
		    };
		    InvalidNestedHooksDispatcherOnRerenderInDEV.useActionState = function (
		      action
		    ) {
		      currentHookNameInDev = "useActionState";
		      warnInvalidHookAccess();
		      updateHookTypesDev();
		      return rerenderActionState(action);
		    };
		    InvalidNestedHooksDispatcherOnRerenderInDEV.useOptimistic = function (
		      passthrough,
		      reducer
		    ) {
		      currentHookNameInDev = "useOptimistic";
		      warnInvalidHookAccess();
		      updateHookTypesDev();
		      return rerenderOptimistic(passthrough, reducer);
		    };
		    var fakeInternalInstance = {};
		    var didWarnAboutStateAssignmentForComponent = new Set();
		    var didWarnAboutUninitializedState = new Set();
		    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
		    var didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
		    var didWarnAboutDirectlyAssigningPropsToState = new Set();
		    var didWarnAboutUndefinedDerivedState = new Set();
		    var didWarnAboutContextTypes$1 = new Set();
		    var didWarnAboutChildContextTypes = new Set();
		    var didWarnAboutInvalidateContextType = new Set();
		    var didWarnOnInvalidCallback = new Set();
		    Object.freeze(fakeInternalInstance);
		    var classComponentUpdater = {
		        isMounted: function (component) {
		          var owner = current;
		          if (null !== owner && isRendering && 1 === owner.tag) {
		            var instance = owner.stateNode;
		            instance._warnedAboutRefsInRender ||
		              console.error(
		                "%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.",
		                getComponentNameFromFiber(owner) || "A component"
		              );
		            instance._warnedAboutRefsInRender = true;
		          }
		          return (component = component._reactInternals)
		            ? getNearestMountedFiber(component) === component
		            : false;
		        },
		        enqueueSetState: function (inst, payload, callback) {
		          inst = inst._reactInternals;
		          var lane = requestUpdateLane(inst),
		            update = createUpdate(lane);
		          update.payload = payload;
		          void 0 !== callback &&
		            null !== callback &&
		            (warnOnInvalidCallback(callback), (update.callback = callback));
		          payload = enqueueUpdate(inst, update, lane);
		          null !== payload &&
		            (scheduleUpdateOnFiber(payload, inst, lane),
		            entangleTransitions(payload, inst, lane));
		          markStateUpdateScheduled(inst, lane);
		        },
		        enqueueReplaceState: function (inst, payload, callback) {
		          inst = inst._reactInternals;
		          var lane = requestUpdateLane(inst),
		            update = createUpdate(lane);
		          update.tag = ReplaceState;
		          update.payload = payload;
		          void 0 !== callback &&
		            null !== callback &&
		            (warnOnInvalidCallback(callback), (update.callback = callback));
		          payload = enqueueUpdate(inst, update, lane);
		          null !== payload &&
		            (scheduleUpdateOnFiber(payload, inst, lane),
		            entangleTransitions(payload, inst, lane));
		          markStateUpdateScheduled(inst, lane);
		        },
		        enqueueForceUpdate: function (inst, callback) {
		          inst = inst._reactInternals;
		          var lane = requestUpdateLane(inst),
		            update = createUpdate(lane);
		          update.tag = ForceUpdate;
		          void 0 !== callback &&
		            null !== callback &&
		            (warnOnInvalidCallback(callback), (update.callback = callback));
		          callback = enqueueUpdate(inst, update, lane);
		          null !== callback &&
		            (scheduleUpdateOnFiber(callback, inst, lane),
		            entangleTransitions(callback, inst, lane));
		          null !== injectedProfilingHooks &&
		            "function" ===
		              typeof injectedProfilingHooks.markForceUpdateScheduled &&
		            injectedProfilingHooks.markForceUpdateScheduled(inst, lane);
		        }
		      },
		      reportGlobalError =
		        "function" === typeof reportError
		          ? reportError
		          : function (error) {
		              if (
		                "object" === typeof window &&
		                "function" === typeof window.ErrorEvent
		              ) {
		                var event = new window.ErrorEvent("error", {
		                  bubbles: true,
		                  cancelable: true,
		                  message:
		                    "object" === typeof error &&
		                    null !== error &&
		                    "string" === typeof error.message
		                      ? String(error.message)
		                      : String(error),
		                  error: error
		                });
		                if (!window.dispatchEvent(event)) return;
		              } else if (
		                "object" === typeof process &&
		                "function" === typeof process.emit
		              ) {
		                process.emit("uncaughtException", error);
		                return;
		              }
		              console.error(error);
		            },
		      componentName = null,
		      errorBoundaryName = null,
		      SelectiveHydrationException = Error(
		        "This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."
		      ),
		      didReceiveUpdate = false;
		    var didWarnAboutBadClass = {};
		    var didWarnAboutContextTypeOnFunctionComponent = {};
		    var didWarnAboutContextTypes = {};
		    var didWarnAboutGetDerivedStateOnFunctionComponent = {};
		    var didWarnAboutReassigningProps = false;
		    var didWarnAboutRevealOrder = {};
		    var didWarnAboutTailOptions = {};
		    var SUSPENDED_MARKER = {
		        dehydrated: null,
		        treeContext: null,
		        retryLane: 0
		      },
		      hasWarnedAboutUsingNoValuePropOnContextProvider = false,
		      valueCursor = createCursor(null);
		    var rendererCursorDEV = createCursor(null);
		    var renderer2CursorDEV = createCursor(null);
		    var rendererSigil = {};
		    var currentlyRenderingFiber = null,
		      lastContextDependency = null,
		      isDisallowedContextReadInDEV = false,
		      AbortControllerLocal =
		        "undefined" !== typeof AbortController
		          ? AbortController
		          : function () {
		              var listeners = [],
		                signal = (this.signal = {
		                  aborted: false,
		                  addEventListener: function (type, listener) {
		                    listeners.push(listener);
		                  }
		                });
		              this.abort = function () {
		                signal.aborted = true;
		                listeners.forEach(function (listener) {
		                  return listener();
		                });
		              };
		            },
		      scheduleCallback$1 = Scheduler.unstable_scheduleCallback,
		      NormalPriority = Scheduler.unstable_NormalPriority,
		      CacheContext = {
		        $$typeof: REACT_CONTEXT_TYPE,
		        Consumer: null,
		        Provider: null,
		        _currentValue: null,
		        _currentValue2: null,
		        _threadCount: 0,
		        _currentRenderer: null,
		        _currentRenderer2: null
		      },
		      prevOnStartTransitionFinish = ReactSharedInternals.S;
		    ReactSharedInternals.S = function (transition, returnValue) {
		      "object" === typeof returnValue &&
		        null !== returnValue &&
		        "function" === typeof returnValue.then &&
		        entangleAsyncAction(transition, returnValue);
		      null !== prevOnStartTransitionFinish &&
		        prevOnStartTransitionFinish(transition, returnValue);
		    };
		    var resumedCache = createCursor(null),
		      didWarnAboutUndefinedSnapshotBeforeUpdate = null;
		    didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
		    var offscreenSubtreeIsHidden = false,
		      offscreenSubtreeWasHidden = false,
		      needsFormReset = false,
		      PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
		      nextEffect = null,
		      inProgressLanes = null,
		      inProgressRoot = null,
		      shouldFireAfterActiveInstanceBlur = false,
		      hostParent = null,
		      hostParentIsContainer = false,
		      currentHoistableRoot = null,
		      suspenseyCommitFlag = 8192,
		      DefaultAsyncDispatcher = {
		        getCacheForType: function (resourceType) {
		          var cache = readContext(CacheContext),
		            cacheForType = cache.data.get(resourceType);
		          void 0 === cacheForType &&
		            ((cacheForType = resourceType()),
		            cache.data.set(resourceType, cacheForType));
		          return cacheForType;
		        },
		        getOwner: function () {
		          return current;
		        }
		      },
		      COMPONENT_TYPE = 0,
		      HAS_PSEUDO_CLASS_TYPE = 1,
		      ROLE_TYPE = 2,
		      TEST_NAME_TYPE = 3,
		      TEXT_TYPE = 4;
		    if ("function" === typeof Symbol && Symbol.for) {
		      var symbolFor = Symbol.for;
		      COMPONENT_TYPE = symbolFor("selector.component");
		      HAS_PSEUDO_CLASS_TYPE = symbolFor("selector.has_pseudo_class");
		      ROLE_TYPE = symbolFor("selector.role");
		      TEST_NAME_TYPE = symbolFor("selector.test_id");
		      TEXT_TYPE = symbolFor("selector.text");
		    }
		    var commitHooks = [],
		      PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
		      NoContext = 0,
		      RenderContext = 2,
		      CommitContext = 4,
		      RootInProgress = 0,
		      RootFatalErrored = 1,
		      RootErrored = 2,
		      RootSuspended = 3,
		      RootSuspendedWithDelay = 4,
		      RootCompleted = 5,
		      RootDidNotComplete = 6,
		      executionContext = NoContext,
		      workInProgressRoot = null,
		      workInProgress = null,
		      workInProgressRootRenderLanes = 0,
		      NotSuspended = 0,
		      SuspendedOnError = 1,
		      SuspendedOnData = 2,
		      SuspendedOnImmediate = 3,
		      SuspendedOnInstance = 4,
		      SuspendedOnInstanceAndReadyToContinue = 5,
		      SuspendedOnDeprecatedThrowPromise = 6,
		      SuspendedAndReadyToContinue = 7,
		      SuspendedOnHydration = 8,
		      workInProgressSuspendedReason = NotSuspended,
		      workInProgressThrownValue = null,
		      workInProgressRootDidSkipSuspendedSiblings = false,
		      workInProgressRootIsPrerendering = false,
		      workInProgressRootDidAttachPingListener = false,
		      entangledRenderLanes = 0,
		      workInProgressRootExitStatus = RootInProgress,
		      workInProgressRootSkippedLanes = 0,
		      workInProgressRootInterleavedUpdatedLanes = 0,
		      workInProgressRootPingedLanes = 0,
		      workInProgressDeferredLane = 0,
		      workInProgressSuspendedRetryLanes = 0,
		      workInProgressRootConcurrentErrors = null,
		      workInProgressRootRecoverableErrors = null,
		      workInProgressRootDidIncludeRecursiveRenderUpdate = false,
		      globalMostRecentFallbackTime = 0,
		      FALLBACK_THROTTLE_MS = 300,
		      workInProgressRootRenderTargetTime = Infinity,
		      RENDER_TIMEOUT_MS = 500,
		      workInProgressTransitions = null,
		      legacyErrorBoundariesThatAlreadyFailed = null,
		      rootDoesHavePassiveEffects = false,
		      rootWithPendingPassiveEffects = null,
		      pendingPassiveEffectsLanes = 0,
		      pendingPassiveEffectsRemainingLanes = 0,
		      pendingPassiveTransitions = null,
		      NESTED_UPDATE_LIMIT = 50,
		      nestedUpdateCount = 0,
		      rootWithNestedUpdates = null,
		      isFlushingPassiveEffects = false,
		      didScheduleUpdateDuringPassiveEffects = false,
		      NESTED_PASSIVE_UPDATE_LIMIT = 50,
		      nestedPassiveUpdateCount = 0,
		      rootWithPassiveNestedUpdates = null,
		      isRunningInsertionEffect = false,
		      IMMEDIATE_COMMIT = 0,
		      SUSPENDED_COMMIT = 1,
		      THROTTLED_COMMIT = 2,
		      didWarnStateUpdateForNotYetMountedComponent = null,
		      didWarnAboutUpdateInRender = false;
		    var didWarnAboutUpdateInRenderForAnotherComponent = new Set();
		    var fakeActCallbackNode = {},
		      resolveFamily = null,
		      failedBoundaries = null;
		    var hasBadMapPolyfill = false;
		    try {
		      var nonExtensibleObject = Object.preventExtensions({});
		      new Map([[nonExtensibleObject, null]]);
		      new Set([nonExtensibleObject]);
		    } catch (e) {
		      hasBadMapPolyfill = true;
		    }
		    var didWarnAboutNestedUpdates = false;
		    var didWarnAboutFindNodeInStrictMode = {};
		    var overrideHookState = null,
		      overrideHookStateDeletePath = null,
		      overrideHookStateRenamePath = null,
		      overrideProps = null,
		      overridePropsDeletePath = null,
		      overridePropsRenamePath = null,
		      scheduleUpdate = null,
		      setErrorHandler = null,
		      setSuspenseHandler = null;
		    overrideHookState = function (fiber, id, path, value) {
		      id = findHook(fiber, id);
		      null !== id &&
		        ((path = copyWithSetImpl(id.memoizedState, path, 0, value)),
		        (id.memoizedState = path),
		        (id.baseState = path),
		        (fiber.memoizedProps = assign({}, fiber.memoizedProps)),
		        (path = enqueueConcurrentRenderForLane(fiber, 2)),
		        null !== path && scheduleUpdateOnFiber(path, fiber, 2));
		    };
		    overrideHookStateDeletePath = function (fiber, id, path) {
		      id = findHook(fiber, id);
		      null !== id &&
		        ((path = copyWithDeleteImpl(id.memoizedState, path, 0)),
		        (id.memoizedState = path),
		        (id.baseState = path),
		        (fiber.memoizedProps = assign({}, fiber.memoizedProps)),
		        (path = enqueueConcurrentRenderForLane(fiber, 2)),
		        null !== path && scheduleUpdateOnFiber(path, fiber, 2));
		    };
		    overrideHookStateRenamePath = function (fiber, id, oldPath, newPath) {
		      id = findHook(fiber, id);
		      null !== id &&
		        ((oldPath = copyWithRename(id.memoizedState, oldPath, newPath)),
		        (id.memoizedState = oldPath),
		        (id.baseState = oldPath),
		        (fiber.memoizedProps = assign({}, fiber.memoizedProps)),
		        (oldPath = enqueueConcurrentRenderForLane(fiber, 2)),
		        null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));
		    };
		    overrideProps = function (fiber, path, value) {
		      fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);
		      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
		      path = enqueueConcurrentRenderForLane(fiber, 2);
		      null !== path && scheduleUpdateOnFiber(path, fiber, 2);
		    };
		    overridePropsDeletePath = function (fiber, path) {
		      fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);
		      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
		      path = enqueueConcurrentRenderForLane(fiber, 2);
		      null !== path && scheduleUpdateOnFiber(path, fiber, 2);
		    };
		    overridePropsRenamePath = function (fiber, oldPath, newPath) {
		      fiber.pendingProps = copyWithRename(
		        fiber.memoizedProps,
		        oldPath,
		        newPath
		      );
		      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
		      oldPath = enqueueConcurrentRenderForLane(fiber, 2);
		      null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);
		    };
		    scheduleUpdate = function (fiber) {
		      var root = enqueueConcurrentRenderForLane(fiber, 2);
		      null !== root && scheduleUpdateOnFiber(root, fiber, 2);
		    };
		    setErrorHandler = function (newShouldErrorImpl) {
		      shouldErrorImpl = newShouldErrorImpl;
		    };
		    setSuspenseHandler = function (newShouldSuspendImpl) {
		      shouldSuspendImpl = newShouldSuspendImpl;
		    };
		    exports.attemptContinuousHydration = function (fiber) {
		      if (13 === fiber.tag) {
		        var root = enqueueConcurrentRenderForLane(fiber, 67108864);
		        null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);
		        markRetryLaneIfNotHydrated(fiber, 67108864);
		      }
		    };
		    exports.attemptHydrationAtCurrentPriority = function (fiber) {
		      if (13 === fiber.tag) {
		        var lane = requestUpdateLane(fiber),
		          root = enqueueConcurrentRenderForLane(fiber, lane);
		        null !== root && scheduleUpdateOnFiber(root, fiber, lane);
		        markRetryLaneIfNotHydrated(fiber, lane);
		      }
		    };
		    exports.attemptSynchronousHydration = function (fiber) {
		      switch (fiber.tag) {
		        case 3:
		          fiber = fiber.stateNode;
		          if (fiber.current.memoizedState.isDehydrated) {
		            var lanes = getHighestPriorityLanes(fiber.pendingLanes);
		            if (0 !== lanes) {
		              fiber.pendingLanes |= 2;
		              for (fiber.entangledLanes |= 2; lanes; ) {
		                var lane = 1 << (31 - clz32(lanes));
		                fiber.entanglements[1] |= lane;
		                lanes &= ~lane;
		              }
		              ensureRootIsScheduled(fiber);
		              (executionContext & (RenderContext | CommitContext)) ===
		                NoContext &&
		                ((workInProgressRootRenderTargetTime =
		                  now$1() + RENDER_TIMEOUT_MS),
		                flushSyncWorkAcrossRoots_impl(0));
		            }
		          }
		          break;
		        case 13:
		          (lanes = enqueueConcurrentRenderForLane(fiber, 2)),
		            null !== lanes && scheduleUpdateOnFiber(lanes, fiber, 2),
		            flushSyncWork(),
		            markRetryLaneIfNotHydrated(fiber, 2);
		      }
		    };
		    exports.batchedUpdates = function (fn, a) {
		      return fn(a);
		    };
		    exports.createComponentSelector = function (component) {
		      return { $$typeof: COMPONENT_TYPE, value: component };
		    };
		    exports.createContainer = function (
		      containerInfo,
		      tag,
		      hydrationCallbacks,
		      isStrictMode,
		      concurrentUpdatesByDefaultOverride,
		      identifierPrefix,
		      onUncaughtError,
		      onCaughtError,
		      onRecoverableError,
		      transitionCallbacks
		    ) {
		      return createFiberRoot(
		        containerInfo,
		        tag,
		        false,
		        null,
		        hydrationCallbacks,
		        isStrictMode,
		        identifierPrefix,
		        onUncaughtError,
		        onCaughtError,
		        onRecoverableError,
		        transitionCallbacks,
		        null
		      );
		    };
		    exports.createHasPseudoClassSelector = function (selectors) {
		      return { $$typeof: HAS_PSEUDO_CLASS_TYPE, value: selectors };
		    };
		    exports.createHydrationContainer = function (
		      initialChildren,
		      callback,
		      containerInfo,
		      tag,
		      hydrationCallbacks,
		      isStrictMode,
		      concurrentUpdatesByDefaultOverride,
		      identifierPrefix,
		      onUncaughtError,
		      onCaughtError,
		      onRecoverableError,
		      transitionCallbacks,
		      formState
		    ) {
		      initialChildren = createFiberRoot(
		        containerInfo,
		        tag,
		        true,
		        initialChildren,
		        hydrationCallbacks,
		        isStrictMode,
		        identifierPrefix,
		        onUncaughtError,
		        onCaughtError,
		        onRecoverableError,
		        transitionCallbacks,
		        formState
		      );
		      initialChildren.context = getContextForSubtree(null);
		      containerInfo = initialChildren.current;
		      tag = requestUpdateLane(containerInfo);
		      hydrationCallbacks = createUpdate(tag);
		      hydrationCallbacks.callback =
		        void 0 !== callback && null !== callback ? callback : null;
		      enqueueUpdate(containerInfo, hydrationCallbacks, tag);
		      initialChildren.current.lanes = tag;
		      markRootUpdated$1(initialChildren, tag);
		      ensureRootIsScheduled(initialChildren);
		      return initialChildren;
		    };
		    exports.createPortal = function (children, containerInfo, implementation) {
		      var key =
		        3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
		      try {
		        testStringCoercion(key);
		        var JSCompiler_inline_result = !1;
		      } catch (e$6) {
		        JSCompiler_inline_result = true;
		      }
		      JSCompiler_inline_result &&
		        (console.error(
		          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
		          ("function" === typeof Symbol &&
		            Symbol.toStringTag &&
		            key[Symbol.toStringTag]) ||
		            key.constructor.name ||
		            "Object"
		        ),
		        testStringCoercion(key));
		      return {
		        $$typeof: REACT_PORTAL_TYPE,
		        key: null == key ? null : "" + key,
		        children: children,
		        containerInfo: containerInfo,
		        implementation: implementation
		      };
		    };
		    exports.createRoleSelector = function (role) {
		      return { $$typeof: ROLE_TYPE, value: role };
		    };
		    exports.createTestNameSelector = function (id) {
		      return { $$typeof: TEST_NAME_TYPE, value: id };
		    };
		    exports.createTextSelector = function (text) {
		      return { $$typeof: TEXT_TYPE, value: text };
		    };
		    exports.defaultOnCaughtError = function (error, errorInfo) {
		      var componentNameMessage = componentName
		          ? "The above error occurred in the <" + componentName + "> component."
		          : "The above error occurred in one of your React components.",
		        recreateMessage =
		          "React will try to recreate this component tree from scratch using the error boundary you provided, " +
		          ((errorBoundaryName || "Anonymous") + "."),
		        prevGetCurrentStack = ReactSharedInternals.getCurrentStack,
		        componentStack =
		          null != errorInfo.componentStack ? errorInfo.componentStack : "";
		      ReactSharedInternals.getCurrentStack = function () {
		        return componentStack;
		      };
		      try {
		        "object" === typeof error &&
		        null !== error &&
		        "string" === typeof error.environmentName
		          ? bindToConsole(
		              "error",
		              [
		                "%o\n\n%s\n\n%s\n",
		                error,
		                componentNameMessage,
		                recreateMessage
		              ],
		              error.environmentName
		            )()
		          : console.error(
		              "%o\n\n%s\n\n%s\n",
		              error,
		              componentNameMessage,
		              recreateMessage
		            );
		      } finally {
		        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
		      }
		    };
		    exports.defaultOnRecoverableError = function (error) {
		      reportGlobalError(error);
		    };
		    exports.defaultOnUncaughtError = function (error, errorInfo) {
		      reportGlobalError(error);
		      error = componentName
		        ? "An error occurred in the <" + componentName + "> component."
		        : "An error occurred in one of your React components.";
		      var prevGetCurrentStack = ReactSharedInternals.getCurrentStack,
		        componentStack =
		          null != errorInfo.componentStack ? errorInfo.componentStack : "";
		      ReactSharedInternals.getCurrentStack = function () {
		        return componentStack;
		      };
		      try {
		        console.warn(
		          "%s\n\n%s\n",
		          error,
		          "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries."
		        );
		      } finally {
		        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
		      }
		    };
		    exports.deferredUpdates = function (fn) {
		      var prevTransition = ReactSharedInternals.T,
		        previousPriority = getCurrentUpdatePriority();
		      try {
		        return (
		          setCurrentUpdatePriority(32), (ReactSharedInternals.T = null), fn()
		        );
		      } finally {
		        setCurrentUpdatePriority(previousPriority),
		          (ReactSharedInternals.T = prevTransition);
		      }
		    };
		    exports.discreteUpdates = function (fn, a, b, c, d) {
		      var prevTransition = ReactSharedInternals.T,
		        previousPriority = getCurrentUpdatePriority();
		      try {
		        return (
		          setCurrentUpdatePriority(2),
		          (ReactSharedInternals.T = null),
		          fn(a, b, c, d)
		        );
		      } finally {
		        setCurrentUpdatePriority(previousPriority),
		          (ReactSharedInternals.T = prevTransition),
		          executionContext === NoContext &&
		            (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS);
		      }
		    };
		    exports.findAllNodes = findAllNodes;
		    exports.findBoundingRects = function (hostRoot, selectors) {
		      if (!supportsTestSelectors)
		        throw Error("Test selector API is not supported by this renderer.");
		      selectors = findAllNodes(hostRoot, selectors);
		      hostRoot = [];
		      for (var i = 0; i < selectors.length; i++)
		        hostRoot.push(getBoundingRect(selectors[i]));
		      for (selectors = hostRoot.length - 1; 0 < selectors; selectors--) {
		        i = hostRoot[selectors];
		        for (
		          var targetLeft = i.x,
		            targetRight = targetLeft + i.width,
		            targetTop = i.y,
		            targetBottom = targetTop + i.height,
		            j = selectors - 1;
		          0 <= j;
		          j--
		        )
		          if (selectors !== j) {
		            var otherRect = hostRoot[j],
		              otherLeft = otherRect.x,
		              otherRight = otherLeft + otherRect.width,
		              otherTop = otherRect.y,
		              otherBottom = otherTop + otherRect.height;
		            if (
		              targetLeft >= otherLeft &&
		              targetTop >= otherTop &&
		              targetRight <= otherRight &&
		              targetBottom <= otherBottom
		            ) {
		              hostRoot.splice(selectors, 1);
		              break;
		            } else if (
		              !(
		                targetLeft !== otherLeft ||
		                i.width !== otherRect.width ||
		                otherBottom < targetTop ||
		                otherTop > targetBottom
		              )
		            ) {
		              otherTop > targetTop &&
		                ((otherRect.height += otherTop - targetTop),
		                (otherRect.y = targetTop));
		              otherBottom < targetBottom &&
		                (otherRect.height = targetBottom - otherTop);
		              hostRoot.splice(selectors, 1);
		              break;
		            } else if (
		              !(
		                targetTop !== otherTop ||
		                i.height !== otherRect.height ||
		                otherRight < targetLeft ||
		                otherLeft > targetRight
		              )
		            ) {
		              otherLeft > targetLeft &&
		                ((otherRect.width += otherLeft - targetLeft),
		                (otherRect.x = targetLeft));
		              otherRight < targetRight &&
		                (otherRect.width = targetRight - otherLeft);
		              hostRoot.splice(selectors, 1);
		              break;
		            }
		          }
		      }
		      return hostRoot;
		    };
		    exports.findHostInstance = function (component) {
		      var fiber = component._reactInternals;
		      if (void 0 === fiber) {
		        if ("function" === typeof component.render)
		          throw Error("Unable to find node on an unmounted component.");
		        component = Object.keys(component).join(",");
		        throw Error(
		          "Argument appears to not be a ReactComponent. Keys: " + component
		        );
		      }
		      component = findCurrentHostFiber(fiber);
		      return null === component ? null : getPublicInstance(component.stateNode);
		    };
		    exports.findHostInstanceWithNoPortals = function (fiber) {
		      fiber = findCurrentFiberUsingSlowPath(fiber);
		      fiber =
		        null !== fiber ? findCurrentHostFiberWithNoPortalsImpl(fiber) : null;
		      return null === fiber ? null : getPublicInstance(fiber.stateNode);
		    };
		    exports.findHostInstanceWithWarning = function (component, methodName) {
		      var fiber = component._reactInternals;
		      if (void 0 === fiber) {
		        if ("function" === typeof component.render)
		          throw Error("Unable to find node on an unmounted component.");
		        component = Object.keys(component).join(",");
		        throw Error(
		          "Argument appears to not be a ReactComponent. Keys: " + component
		        );
		      }
		      component = findCurrentHostFiber(fiber);
		      if (null === component) return null;
		      if (component.mode & 8) {
		        var componentName = getComponentNameFromFiber(fiber) || "Component";
		        didWarnAboutFindNodeInStrictMode[componentName] ||
		          ((didWarnAboutFindNodeInStrictMode[componentName] = true),
		          runWithFiberInDEV(component, function () {
		            fiber.mode & 8
		              ? console.error(
		                  "%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://react.dev/link/strict-mode-find-node",
		                  methodName,
		                  methodName,
		                  componentName
		                )
		              : console.error(
		                  "%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://react.dev/link/strict-mode-find-node",
		                  methodName,
		                  methodName,
		                  componentName
		                );
		          }));
		      }
		      return getPublicInstance(component.stateNode);
		    };
		    exports.flushPassiveEffects = flushPassiveEffects;
		    exports.flushSyncFromReconciler = function (fn) {
		      var prevExecutionContext = executionContext;
		      executionContext |= 1;
		      var prevTransition = ReactSharedInternals.T,
		        previousPriority = getCurrentUpdatePriority();
		      try {
		        if ((setCurrentUpdatePriority(2), (ReactSharedInternals.T = null), fn))
		          return fn();
		      } finally {
		        setCurrentUpdatePriority(previousPriority),
		          (ReactSharedInternals.T = prevTransition),
		          (executionContext = prevExecutionContext),
		          (executionContext & (RenderContext | CommitContext)) === NoContext &&
		            flushSyncWorkAcrossRoots_impl(0);
		      }
		    };
		    exports.flushSyncWork = flushSyncWork;
		    exports.focusWithin = function (hostRoot, selectors) {
		      if (!supportsTestSelectors)
		        throw Error("Test selector API is not supported by this renderer.");
		      hostRoot = findFiberRootForHostRoot(hostRoot);
		      selectors = findPaths(hostRoot, selectors);
		      selectors = Array.from(selectors);
		      for (hostRoot = 0; hostRoot < selectors.length; ) {
		        var fiber = selectors[hostRoot++],
		          tag = fiber.tag;
		        if (!isHiddenSubtree(fiber)) {
		          if (
		            (5 === tag || 26 === tag || 27 === tag) &&
		            setFocusIfFocusable(fiber.stateNode)
		          )
		            return true;
		          for (fiber = fiber.child; null !== fiber; )
		            selectors.push(fiber), (fiber = fiber.sibling);
		        }
		      }
		      return false;
		    };
		    exports.getFindAllNodesFailureDescription = function (hostRoot, selectors) {
		      if (!supportsTestSelectors)
		        throw Error("Test selector API is not supported by this renderer.");
		      var maxSelectorIndex = 0,
		        matchedNames = [];
		      hostRoot = [findFiberRootForHostRoot(hostRoot), 0];
		      for (var index = 0; index < hostRoot.length; ) {
		        var fiber = hostRoot[index++],
		          tag = fiber.tag,
		          selectorIndex = hostRoot[index++],
		          selector = selectors[selectorIndex];
		        if ((5 !== tag && 26 !== tag && 27 !== tag) || !isHiddenSubtree(fiber))
		          if (
		            (matchSelector(fiber, selector) &&
		              (matchedNames.push(selectorToString(selector)),
		              selectorIndex++,
		              selectorIndex > maxSelectorIndex &&
		                (maxSelectorIndex = selectorIndex)),
		            selectorIndex < selectors.length)
		          )
		            for (fiber = fiber.child; null !== fiber; )
		              hostRoot.push(fiber, selectorIndex), (fiber = fiber.sibling);
		      }
		      if (maxSelectorIndex < selectors.length) {
		        for (
		          hostRoot = [];
		          maxSelectorIndex < selectors.length;
		          maxSelectorIndex++
		        )
		          hostRoot.push(selectorToString(selectors[maxSelectorIndex]));
		        return (
		          "findAllNodes was able to match part of the selector:\n  " +
		          (matchedNames.join(" > ") +
		            "\n\nNo matching component was found for:\n  ") +
		          hostRoot.join(" > ")
		        );
		      }
		      return null;
		    };
		    exports.getPublicRootInstance = function (container) {
		      container = container.current;
		      if (!container.child) return null;
		      switch (container.child.tag) {
		        case 27:
		        case 5:
		          return getPublicInstance(container.child.stateNode);
		        default:
		          return container.child.stateNode;
		      }
		    };
		    exports.injectIntoDevTools = function () {
		      var internals = {
		        bundleType: 1,
		        version: rendererVersion,
		        rendererPackageName: rendererPackageName,
		        currentDispatcherRef: ReactSharedInternals,
		        findFiberByHostInstance: getInstanceFromNode,
		        reconcilerVersion: "19.0.0"
		      };
		      null !== extraDevToolsConfig &&
		        (internals.rendererConfig = extraDevToolsConfig);
		      internals.overrideHookState = overrideHookState;
		      internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
		      internals.overrideHookStateRenamePath = overrideHookStateRenamePath;
		      internals.overrideProps = overrideProps;
		      internals.overridePropsDeletePath = overridePropsDeletePath;
		      internals.overridePropsRenamePath = overridePropsRenamePath;
		      internals.scheduleUpdate = scheduleUpdate;
		      internals.setErrorHandler = setErrorHandler;
		      internals.setSuspenseHandler = setSuspenseHandler;
		      internals.scheduleRefresh = scheduleRefresh;
		      internals.scheduleRoot = scheduleRoot;
		      internals.setRefreshHandler = setRefreshHandler;
		      internals.getCurrentFiber = getCurrentFiberForDevTools;
		      internals.getLaneLabelMap = getLaneLabelMap;
		      internals.injectProfilingHooks = injectProfilingHooks;
		      return injectInternals(internals);
		    };
		    exports.isAlreadyRendering = function () {
		      return (executionContext & (RenderContext | CommitContext)) !== NoContext;
		    };
		    exports.observeVisibleRects = function (
		      hostRoot,
		      selectors,
		      callback,
		      options
		    ) {
		      function commitHook() {
		        var nextInstanceRoots = findAllNodes(hostRoot, selectors);
		        instanceRoots.forEach(function (target) {
		          0 > nextInstanceRoots.indexOf(target) && unobserve(target);
		        });
		        nextInstanceRoots.forEach(function (target) {
		          0 > instanceRoots.indexOf(target) && observe(target);
		        });
		      }
		      if (!supportsTestSelectors)
		        throw Error("Test selector API is not supported by this renderer.");
		      var instanceRoots = findAllNodes(hostRoot, selectors);
		      callback = setupIntersectionObserver(instanceRoots, callback, options);
		      var disconnect = callback.disconnect,
		        observe = callback.observe,
		        unobserve = callback.unobserve;
		      commitHooks.push(commitHook);
		      return {
		        disconnect: function () {
		          var index = commitHooks.indexOf(commitHook);
		          0 <= index && commitHooks.splice(index, 1);
		          disconnect();
		        }
		      };
		    };
		    exports.shouldError = function (fiber) {
		      return shouldErrorImpl(fiber);
		    };
		    exports.shouldSuspend = function (fiber) {
		      return shouldSuspendImpl(fiber);
		    };
		    exports.startHostTransition = function (
		      formFiber,
		      pendingState,
		      action,
		      formData
		    ) {
		      if (5 !== formFiber.tag)
		        throw Error(
		          "Expected the form instance to be a HostComponent. This is a bug in React."
		        );
		      var queue = ensureFormComponentIsStateful(formFiber).queue;
		      startTransition(
		        formFiber,
		        queue,
		        pendingState,
		        NotPendingTransition,
		        null === action
		          ? noop
		          : function () {
		              null === ReactSharedInternals.T &&
		                console.error(
		                  "requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition."
		                );
		              var resetStateQueue =
		                ensureFormComponentIsStateful(formFiber).next.queue;
		              dispatchSetStateInternal(
		                formFiber,
		                resetStateQueue,
		                {},
		                requestUpdateLane(formFiber)
		              );
		              return action(formData);
		            }
		      );
		    };
		    exports.updateContainer = function (
		      element,
		      container,
		      parentComponent,
		      callback
		    ) {
		      var current = container.current,
		        lane = requestUpdateLane(current);
		      updateContainerImpl(
		        current,
		        lane,
		        element,
		        container,
		        parentComponent,
		        callback
		      );
		      return lane;
		    };
		    exports.updateContainerSync = updateContainerSync;
		    return exports;
		  }),
		  (module.exports.default = module.exports),
		  Object.defineProperty(module.exports, "__esModule", { value: true })); 
	} (reactReconciler_development));
	return reactReconciler_development.exports;
}

var hasRequiredReactReconciler;

function requireReactReconciler () {
	if (hasRequiredReactReconciler) return reactReconciler.exports;
	hasRequiredReactReconciler = 1;

	if (process.env.NODE_ENV === 'production') {
	  reactReconciler.exports = requireReactReconciler_production();
	} else {
	  reactReconciler.exports = requireReactReconciler_development();
	}
	return reactReconciler.exports;
}

var reactReconcilerExports = requireReactReconciler();
var ReactFiberReconciler = /*@__PURE__*/getDefaultExportFromCjs(reactReconcilerExports);

var constants = {exports: {}};

var reactReconcilerConstants_production = {};

/**
 * @license React
 * react-reconciler-constants.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactReconcilerConstants_production;

function requireReactReconcilerConstants_production () {
	if (hasRequiredReactReconcilerConstants_production) return reactReconcilerConstants_production;
	hasRequiredReactReconcilerConstants_production = 1;
	reactReconcilerConstants_production.ConcurrentRoot = 1;
	reactReconcilerConstants_production.ContinuousEventPriority = 8;
	reactReconcilerConstants_production.DefaultEventPriority = 32;
	reactReconcilerConstants_production.DiscreteEventPriority = 2;
	reactReconcilerConstants_production.IdleEventPriority = 268435456;
	reactReconcilerConstants_production.LegacyRoot = 0;
	reactReconcilerConstants_production.NoEventPriority = 0;
	return reactReconcilerConstants_production;
}

var reactReconcilerConstants_development = {};

/**
 * @license React
 * react-reconciler-constants.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactReconcilerConstants_development;

function requireReactReconcilerConstants_development () {
	if (hasRequiredReactReconcilerConstants_development) return reactReconcilerConstants_development;
	hasRequiredReactReconcilerConstants_development = 1;
	"production" !== process.env.NODE_ENV &&
	  ((reactReconcilerConstants_development.ConcurrentRoot = 1),
	  (reactReconcilerConstants_development.ContinuousEventPriority = 8),
	  (reactReconcilerConstants_development.DefaultEventPriority = 32),
	  (reactReconcilerConstants_development.DiscreteEventPriority = 2),
	  (reactReconcilerConstants_development.IdleEventPriority = 268435456),
	  (reactReconcilerConstants_development.LegacyRoot = 0),
	  (reactReconcilerConstants_development.NoEventPriority = 0));
	return reactReconcilerConstants_development;
}

var hasRequiredConstants;

function requireConstants () {
	if (hasRequiredConstants) return constants.exports;
	hasRequiredConstants = 1;

	if (process.env.NODE_ENV === 'production') {
	  constants.exports = requireReactReconcilerConstants_production();
	} else {
	  constants.exports = requireReactReconcilerConstants_development();
	}
	return constants.exports;
}

var constantsExports = requireConstants();

var GlobalExports = requireGlobal();

const propsToSkip = {
    children: true,
    ref: true,
    key: true,
    style: true,
    forwardedRef: true,
    unstable_applyCache: true,
    unstable_applyDrawHitFromCache: true,
};
let zIndexWarningShowed = false;
let dragWarningShowed = false;
const EVENTS_NAMESPACE = '.react-konva-event';
const DRAGGABLE_WARNING = `ReactKonva: You have a Konva node with draggable = true and position defined but no onDragMove or onDragEnd events are handled.
Position of a node will be changed during drag&drop, so you should update state of the react app as well.
Consider to add onDragMove or onDragEnd events.
For more info see: https://github.com/konvajs/react-konva/issues/256
`;
const Z_INDEX_WARNING = `ReactKonva: You are using "zIndex" attribute for a Konva node.
react-konva may get confused with ordering. Just define correct order of elements in your render function of a component.
For more info see: https://github.com/konvajs/react-konva/issues/194
`;
const EMPTY_PROPS = {};
function applyNodeProps(instance, props, oldProps = EMPTY_PROPS) {
    // don't use zIndex in react-konva
    if (!zIndexWarningShowed && 'zIndex' in props) {
        console.warn(Z_INDEX_WARNING);
        zIndexWarningShowed = true;
    }
    // check correct draggable usage
    if (!dragWarningShowed && props.draggable) {
        var hasPosition = props.x !== undefined || props.y !== undefined;
        var hasEvents = props.onDragEnd || props.onDragMove;
        if (hasPosition && !hasEvents) {
            console.warn(DRAGGABLE_WARNING);
            dragWarningShowed = true;
        }
    }
    // check old props
    // we need to unset properties that are not in new props
    // and remove all events
    for (var key in oldProps) {
        if (propsToSkip[key]) {
            continue;
        }
        var isEvent = key.slice(0, 2) === 'on';
        var propChanged = oldProps[key] !== props[key];
        // if that is a changed event, we need to remove it
        if (isEvent && propChanged) {
            var eventName = key.substr(2).toLowerCase();
            if (eventName.substr(0, 7) === 'content') {
                eventName =
                    'content' +
                        eventName.substr(7, 1).toUpperCase() +
                        eventName.substr(8);
            }
            instance.off(eventName, oldProps[key]);
        }
        var toRemove = !props.hasOwnProperty(key);
        if (toRemove) {
            instance.setAttr(key, undefined);
        }
    }
    var strictUpdate = props._useStrictMode;
    var updatedProps = {};
    var hasUpdates = false;
    const newEvents = {};
    for (var key in props) {
        if (propsToSkip[key]) {
            continue;
        }
        var isEvent = key.slice(0, 2) === 'on';
        var toAdd = oldProps[key] !== props[key];
        if (isEvent && toAdd) {
            var eventName = key.substr(2).toLowerCase();
            if (eventName.substr(0, 7) === 'content') {
                eventName =
                    'content' +
                        eventName.substr(7, 1).toUpperCase() +
                        eventName.substr(8);
            }
            // check that event is not undefined
            if (props[key]) {
                newEvents[eventName] = props[key];
            }
        }
        if (!isEvent &&
            (props[key] !== oldProps[key] ||
                (strictUpdate && props[key] !== instance.getAttr(key)))) {
            hasUpdates = true;
            updatedProps[key] = props[key];
        }
    }
    if (hasUpdates) {
        instance.setAttrs(updatedProps);
        updatePicture(instance);
    }
    // subscribe to events AFTER we set attrs
    // we need it to fix https://github.com/konvajs/react-konva/issues/471
    // settings attrs may add events. Like "draggable: true" will add "mousedown" listener
    for (var eventName in newEvents) {
        instance.on(eventName + EVENTS_NAMESPACE, newEvents[eventName]);
    }
}
function updatePicture(node) {
    if (!GlobalExports.Konva.autoDrawEnabled) {
        var drawingNode = node.getLayer() || node.getStage();
        drawingNode && drawingNode.batchDraw();
    }
}

var scheduler = {exports: {}};

var scheduler_production = {};

/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredScheduler_production;

function requireScheduler_production () {
	if (hasRequiredScheduler_production) return scheduler_production;
	hasRequiredScheduler_production = 1;
	(function (exports) {
		function push(heap, node) {
		  var index = heap.length;
		  heap.push(node);
		  a: for (; 0 < index; ) {
		    var parentIndex = (index - 1) >>> 1,
		      parent = heap[parentIndex];
		    if (0 < compare(parent, node))
		      (heap[parentIndex] = node), (heap[index] = parent), (index = parentIndex);
		    else break a;
		  }
		}
		function peek(heap) {
		  return 0 === heap.length ? null : heap[0];
		}
		function pop(heap) {
		  if (0 === heap.length) return null;
		  var first = heap[0],
		    last = heap.pop();
		  if (last !== first) {
		    heap[0] = last;
		    a: for (
		      var index = 0, length = heap.length, halfLength = length >>> 1;
		      index < halfLength;

		    ) {
		      var leftIndex = 2 * (index + 1) - 1,
		        left = heap[leftIndex],
		        rightIndex = leftIndex + 1,
		        right = heap[rightIndex];
		      if (0 > compare(left, last))
		        rightIndex < length && 0 > compare(right, left)
		          ? ((heap[index] = right),
		            (heap[rightIndex] = last),
		            (index = rightIndex))
		          : ((heap[index] = left),
		            (heap[leftIndex] = last),
		            (index = leftIndex));
		      else if (rightIndex < length && 0 > compare(right, last))
		        (heap[index] = right), (heap[rightIndex] = last), (index = rightIndex);
		      else break a;
		    }
		  }
		  return first;
		}
		function compare(a, b) {
		  var diff = a.sortIndex - b.sortIndex;
		  return 0 !== diff ? diff : a.id - b.id;
		}
		exports.unstable_now = void 0;
		if ("object" === typeof performance && "function" === typeof performance.now) {
		  var localPerformance = performance;
		  exports.unstable_now = function () {
		    return localPerformance.now();
		  };
		} else {
		  var localDate = Date,
		    initialTime = localDate.now();
		  exports.unstable_now = function () {
		    return localDate.now() - initialTime;
		  };
		}
		var taskQueue = [],
		  timerQueue = [],
		  taskIdCounter = 1,
		  currentTask = null,
		  currentPriorityLevel = 3,
		  isPerformingWork = false,
		  isHostCallbackScheduled = false,
		  isHostTimeoutScheduled = false,
		  localSetTimeout = "function" === typeof setTimeout ? setTimeout : null,
		  localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null,
		  localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
		function advanceTimers(currentTime) {
		  for (var timer = peek(timerQueue); null !== timer; ) {
		    if (null === timer.callback) pop(timerQueue);
		    else if (timer.startTime <= currentTime)
		      pop(timerQueue),
		        (timer.sortIndex = timer.expirationTime),
		        push(taskQueue, timer);
		    else break;
		    timer = peek(timerQueue);
		  }
		}
		function handleTimeout(currentTime) {
		  isHostTimeoutScheduled = false;
		  advanceTimers(currentTime);
		  if (!isHostCallbackScheduled)
		    if (null !== peek(taskQueue))
		      (isHostCallbackScheduled = true), requestHostCallback();
		    else {
		      var firstTimer = peek(timerQueue);
		      null !== firstTimer &&
		        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
		    }
		}
		var isMessageLoopRunning = false,
		  taskTimeoutID = -1,
		  frameInterval = 5,
		  startTime = -1;
		function shouldYieldToHost() {
		  return exports.unstable_now() - startTime < frameInterval ? false : true;
		}
		function performWorkUntilDeadline() {
		  if (isMessageLoopRunning) {
		    var currentTime = exports.unstable_now();
		    startTime = currentTime;
		    var hasMoreWork = true;
		    try {
		      a: {
		        isHostCallbackScheduled = !1;
		        isHostTimeoutScheduled &&
		          ((isHostTimeoutScheduled = !1),
		          localClearTimeout(taskTimeoutID),
		          (taskTimeoutID = -1));
		        isPerformingWork = !0;
		        var previousPriorityLevel = currentPriorityLevel;
		        try {
		          b: {
		            advanceTimers(currentTime);
		            for (
		              currentTask = peek(taskQueue);
		              null !== currentTask &&
		              !(
		                currentTask.expirationTime > currentTime && shouldYieldToHost()
		              );

		            ) {
		              var callback = currentTask.callback;
		              if ("function" === typeof callback) {
		                currentTask.callback = null;
		                currentPriorityLevel = currentTask.priorityLevel;
		                var continuationCallback = callback(
		                  currentTask.expirationTime <= currentTime
		                );
		                currentTime = exports.unstable_now();
		                if ("function" === typeof continuationCallback) {
		                  currentTask.callback = continuationCallback;
		                  advanceTimers(currentTime);
		                  hasMoreWork = !0;
		                  break b;
		                }
		                currentTask === peek(taskQueue) && pop(taskQueue);
		                advanceTimers(currentTime);
		              } else pop(taskQueue);
		              currentTask = peek(taskQueue);
		            }
		            if (null !== currentTask) hasMoreWork = !0;
		            else {
		              var firstTimer = peek(timerQueue);
		              null !== firstTimer &&
		                requestHostTimeout(
		                  handleTimeout,
		                  firstTimer.startTime - currentTime
		                );
		              hasMoreWork = !1;
		            }
		          }
		          break a;
		        } finally {
		          (currentTask = null),
		            (currentPriorityLevel = previousPriorityLevel),
		            (isPerformingWork = !1);
		        }
		        hasMoreWork = void 0;
		      }
		    } finally {
		      hasMoreWork
		        ? schedulePerformWorkUntilDeadline()
		        : (isMessageLoopRunning = false);
		    }
		  }
		}
		var schedulePerformWorkUntilDeadline;
		if ("function" === typeof localSetImmediate)
		  schedulePerformWorkUntilDeadline = function () {
		    localSetImmediate(performWorkUntilDeadline);
		  };
		else if ("undefined" !== typeof MessageChannel) {
		  var channel = new MessageChannel(),
		    port = channel.port2;
		  channel.port1.onmessage = performWorkUntilDeadline;
		  schedulePerformWorkUntilDeadline = function () {
		    port.postMessage(null);
		  };
		} else
		  schedulePerformWorkUntilDeadline = function () {
		    localSetTimeout(performWorkUntilDeadline, 0);
		  };
		function requestHostCallback() {
		  isMessageLoopRunning ||
		    ((isMessageLoopRunning = true), schedulePerformWorkUntilDeadline());
		}
		function requestHostTimeout(callback, ms) {
		  taskTimeoutID = localSetTimeout(function () {
		    callback(exports.unstable_now());
		  }, ms);
		}
		exports.unstable_IdlePriority = 5;
		exports.unstable_ImmediatePriority = 1;
		exports.unstable_LowPriority = 4;
		exports.unstable_NormalPriority = 3;
		exports.unstable_Profiling = null;
		exports.unstable_UserBlockingPriority = 2;
		exports.unstable_cancelCallback = function (task) {
		  task.callback = null;
		};
		exports.unstable_continueExecution = function () {
		  isHostCallbackScheduled ||
		    isPerformingWork ||
		    ((isHostCallbackScheduled = true), requestHostCallback());
		};
		exports.unstable_forceFrameRate = function (fps) {
		  0 > fps || 125 < fps
		    ? console.error(
		        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
		      )
		    : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);
		};
		exports.unstable_getCurrentPriorityLevel = function () {
		  return currentPriorityLevel;
		};
		exports.unstable_getFirstCallbackNode = function () {
		  return peek(taskQueue);
		};
		exports.unstable_next = function (eventHandler) {
		  switch (currentPriorityLevel) {
		    case 1:
		    case 2:
		    case 3:
		      var priorityLevel = 3;
		      break;
		    default:
		      priorityLevel = currentPriorityLevel;
		  }
		  var previousPriorityLevel = currentPriorityLevel;
		  currentPriorityLevel = priorityLevel;
		  try {
		    return eventHandler();
		  } finally {
		    currentPriorityLevel = previousPriorityLevel;
		  }
		};
		exports.unstable_pauseExecution = function () {};
		exports.unstable_requestPaint = function () {};
		exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {
		  switch (priorityLevel) {
		    case 1:
		    case 2:
		    case 3:
		    case 4:
		    case 5:
		      break;
		    default:
		      priorityLevel = 3;
		  }
		  var previousPriorityLevel = currentPriorityLevel;
		  currentPriorityLevel = priorityLevel;
		  try {
		    return eventHandler();
		  } finally {
		    currentPriorityLevel = previousPriorityLevel;
		  }
		};
		exports.unstable_scheduleCallback = function (
		  priorityLevel,
		  callback,
		  options
		) {
		  var currentTime = exports.unstable_now();
		  "object" === typeof options && null !== options
		    ? ((options = options.delay),
		      (options =
		        "number" === typeof options && 0 < options
		          ? currentTime + options
		          : currentTime))
		    : (options = currentTime);
		  switch (priorityLevel) {
		    case 1:
		      var timeout = -1;
		      break;
		    case 2:
		      timeout = 250;
		      break;
		    case 5:
		      timeout = 1073741823;
		      break;
		    case 4:
		      timeout = 1e4;
		      break;
		    default:
		      timeout = 5e3;
		  }
		  timeout = options + timeout;
		  priorityLevel = {
		    id: taskIdCounter++,
		    callback: callback,
		    priorityLevel: priorityLevel,
		    startTime: options,
		    expirationTime: timeout,
		    sortIndex: -1
		  };
		  options > currentTime
		    ? ((priorityLevel.sortIndex = options),
		      push(timerQueue, priorityLevel),
		      null === peek(taskQueue) &&
		        priorityLevel === peek(timerQueue) &&
		        (isHostTimeoutScheduled
		          ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))
		          : (isHostTimeoutScheduled = true),
		        requestHostTimeout(handleTimeout, options - currentTime)))
		    : ((priorityLevel.sortIndex = timeout),
		      push(taskQueue, priorityLevel),
		      isHostCallbackScheduled ||
		        isPerformingWork ||
		        ((isHostCallbackScheduled = true), requestHostCallback()));
		  return priorityLevel;
		};
		exports.unstable_shouldYield = shouldYieldToHost;
		exports.unstable_wrapCallback = function (callback) {
		  var parentPriorityLevel = currentPriorityLevel;
		  return function () {
		    var previousPriorityLevel = currentPriorityLevel;
		    currentPriorityLevel = parentPriorityLevel;
		    try {
		      return callback.apply(this, arguments);
		    } finally {
		      currentPriorityLevel = previousPriorityLevel;
		    }
		  };
		}; 
	} (scheduler_production));
	return scheduler_production;
}

var scheduler_development = {};

/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredScheduler_development;

function requireScheduler_development () {
	if (hasRequiredScheduler_development) return scheduler_development;
	hasRequiredScheduler_development = 1;
	(function (exports) {
		"production" !== process.env.NODE_ENV &&
		  (function () {
		    function performWorkUntilDeadline() {
		      if (isMessageLoopRunning) {
		        var currentTime = exports.unstable_now();
		        startTime = currentTime;
		        var hasMoreWork = true;
		        try {
		          a: {
		            isHostCallbackScheduled = !1;
		            isHostTimeoutScheduled &&
		              ((isHostTimeoutScheduled = !1),
		              localClearTimeout(taskTimeoutID),
		              (taskTimeoutID = -1));
		            isPerformingWork = !0;
		            var previousPriorityLevel = currentPriorityLevel;
		            try {
		              b: {
		                advanceTimers(currentTime);
		                for (
		                  currentTask = peek(taskQueue);
		                  null !== currentTask &&
		                  !(
		                    currentTask.expirationTime > currentTime &&
		                    shouldYieldToHost()
		                  );

		                ) {
		                  var callback = currentTask.callback;
		                  if ("function" === typeof callback) {
		                    currentTask.callback = null;
		                    currentPriorityLevel = currentTask.priorityLevel;
		                    var continuationCallback = callback(
		                      currentTask.expirationTime <= currentTime
		                    );
		                    currentTime = exports.unstable_now();
		                    if ("function" === typeof continuationCallback) {
		                      currentTask.callback = continuationCallback;
		                      advanceTimers(currentTime);
		                      hasMoreWork = !0;
		                      break b;
		                    }
		                    currentTask === peek(taskQueue) && pop(taskQueue);
		                    advanceTimers(currentTime);
		                  } else pop(taskQueue);
		                  currentTask = peek(taskQueue);
		                }
		                if (null !== currentTask) hasMoreWork = !0;
		                else {
		                  var firstTimer = peek(timerQueue);
		                  null !== firstTimer &&
		                    requestHostTimeout(
		                      handleTimeout,
		                      firstTimer.startTime - currentTime
		                    );
		                  hasMoreWork = !1;
		                }
		              }
		              break a;
		            } finally {
		              (currentTask = null),
		                (currentPriorityLevel = previousPriorityLevel),
		                (isPerformingWork = !1);
		            }
		            hasMoreWork = void 0;
		          }
		        } finally {
		          hasMoreWork
		            ? schedulePerformWorkUntilDeadline()
		            : (isMessageLoopRunning = false);
		        }
		      }
		    }
		    function push(heap, node) {
		      var index = heap.length;
		      heap.push(node);
		      a: for (; 0 < index; ) {
		        var parentIndex = (index - 1) >>> 1,
		          parent = heap[parentIndex];
		        if (0 < compare(parent, node))
		          (heap[parentIndex] = node),
		            (heap[index] = parent),
		            (index = parentIndex);
		        else break a;
		      }
		    }
		    function peek(heap) {
		      return 0 === heap.length ? null : heap[0];
		    }
		    function pop(heap) {
		      if (0 === heap.length) return null;
		      var first = heap[0],
		        last = heap.pop();
		      if (last !== first) {
		        heap[0] = last;
		        a: for (
		          var index = 0, length = heap.length, halfLength = length >>> 1;
		          index < halfLength;

		        ) {
		          var leftIndex = 2 * (index + 1) - 1,
		            left = heap[leftIndex],
		            rightIndex = leftIndex + 1,
		            right = heap[rightIndex];
		          if (0 > compare(left, last))
		            rightIndex < length && 0 > compare(right, left)
		              ? ((heap[index] = right),
		                (heap[rightIndex] = last),
		                (index = rightIndex))
		              : ((heap[index] = left),
		                (heap[leftIndex] = last),
		                (index = leftIndex));
		          else if (rightIndex < length && 0 > compare(right, last))
		            (heap[index] = right),
		              (heap[rightIndex] = last),
		              (index = rightIndex);
		          else break a;
		        }
		      }
		      return first;
		    }
		    function compare(a, b) {
		      var diff = a.sortIndex - b.sortIndex;
		      return 0 !== diff ? diff : a.id - b.id;
		    }
		    function advanceTimers(currentTime) {
		      for (var timer = peek(timerQueue); null !== timer; ) {
		        if (null === timer.callback) pop(timerQueue);
		        else if (timer.startTime <= currentTime)
		          pop(timerQueue),
		            (timer.sortIndex = timer.expirationTime),
		            push(taskQueue, timer);
		        else break;
		        timer = peek(timerQueue);
		      }
		    }
		    function handleTimeout(currentTime) {
		      isHostTimeoutScheduled = false;
		      advanceTimers(currentTime);
		      if (!isHostCallbackScheduled)
		        if (null !== peek(taskQueue))
		          (isHostCallbackScheduled = true), requestHostCallback();
		        else {
		          var firstTimer = peek(timerQueue);
		          null !== firstTimer &&
		            requestHostTimeout(
		              handleTimeout,
		              firstTimer.startTime - currentTime
		            );
		        }
		    }
		    function shouldYieldToHost() {
		      return exports.unstable_now() - startTime < frameInterval ? false : true;
		    }
		    function requestHostCallback() {
		      isMessageLoopRunning ||
		        ((isMessageLoopRunning = true), schedulePerformWorkUntilDeadline());
		    }
		    function requestHostTimeout(callback, ms) {
		      taskTimeoutID = localSetTimeout(function () {
		        callback(exports.unstable_now());
		      }, ms);
		    }
		    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
		      "function" ===
		        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&
		      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
		    exports.unstable_now = void 0;
		    if (
		      "object" === typeof performance &&
		      "function" === typeof performance.now
		    ) {
		      var localPerformance = performance;
		      exports.unstable_now = function () {
		        return localPerformance.now();
		      };
		    } else {
		      var localDate = Date,
		        initialTime = localDate.now();
		      exports.unstable_now = function () {
		        return localDate.now() - initialTime;
		      };
		    }
		    var taskQueue = [],
		      timerQueue = [],
		      taskIdCounter = 1,
		      currentTask = null,
		      currentPriorityLevel = 3,
		      isPerformingWork = false,
		      isHostCallbackScheduled = false,
		      isHostTimeoutScheduled = false,
		      localSetTimeout = "function" === typeof setTimeout ? setTimeout : null,
		      localClearTimeout =
		        "function" === typeof clearTimeout ? clearTimeout : null,
		      localSetImmediate =
		        "undefined" !== typeof setImmediate ? setImmediate : null,
		      isMessageLoopRunning = false,
		      taskTimeoutID = -1,
		      frameInterval = 5,
		      startTime = -1;
		    if ("function" === typeof localSetImmediate)
		      var schedulePerformWorkUntilDeadline = function () {
		        localSetImmediate(performWorkUntilDeadline);
		      };
		    else if ("undefined" !== typeof MessageChannel) {
		      var channel = new MessageChannel(),
		        port = channel.port2;
		      channel.port1.onmessage = performWorkUntilDeadline;
		      schedulePerformWorkUntilDeadline = function () {
		        port.postMessage(null);
		      };
		    } else
		      schedulePerformWorkUntilDeadline = function () {
		        localSetTimeout(performWorkUntilDeadline, 0);
		      };
		    exports.unstable_IdlePriority = 5;
		    exports.unstable_ImmediatePriority = 1;
		    exports.unstable_LowPriority = 4;
		    exports.unstable_NormalPriority = 3;
		    exports.unstable_Profiling = null;
		    exports.unstable_UserBlockingPriority = 2;
		    exports.unstable_cancelCallback = function (task) {
		      task.callback = null;
		    };
		    exports.unstable_continueExecution = function () {
		      isHostCallbackScheduled ||
		        isPerformingWork ||
		        ((isHostCallbackScheduled = true), requestHostCallback());
		    };
		    exports.unstable_forceFrameRate = function (fps) {
		      0 > fps || 125 < fps
		        ? console.error(
		            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
		          )
		        : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);
		    };
		    exports.unstable_getCurrentPriorityLevel = function () {
		      return currentPriorityLevel;
		    };
		    exports.unstable_getFirstCallbackNode = function () {
		      return peek(taskQueue);
		    };
		    exports.unstable_next = function (eventHandler) {
		      switch (currentPriorityLevel) {
		        case 1:
		        case 2:
		        case 3:
		          var priorityLevel = 3;
		          break;
		        default:
		          priorityLevel = currentPriorityLevel;
		      }
		      var previousPriorityLevel = currentPriorityLevel;
		      currentPriorityLevel = priorityLevel;
		      try {
		        return eventHandler();
		      } finally {
		        currentPriorityLevel = previousPriorityLevel;
		      }
		    };
		    exports.unstable_pauseExecution = function () {};
		    exports.unstable_requestPaint = function () {};
		    exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {
		      switch (priorityLevel) {
		        case 1:
		        case 2:
		        case 3:
		        case 4:
		        case 5:
		          break;
		        default:
		          priorityLevel = 3;
		      }
		      var previousPriorityLevel = currentPriorityLevel;
		      currentPriorityLevel = priorityLevel;
		      try {
		        return eventHandler();
		      } finally {
		        currentPriorityLevel = previousPriorityLevel;
		      }
		    };
		    exports.unstable_scheduleCallback = function (
		      priorityLevel,
		      callback,
		      options
		    ) {
		      var currentTime = exports.unstable_now();
		      "object" === typeof options && null !== options
		        ? ((options = options.delay),
		          (options =
		            "number" === typeof options && 0 < options
		              ? currentTime + options
		              : currentTime))
		        : (options = currentTime);
		      switch (priorityLevel) {
		        case 1:
		          var timeout = -1;
		          break;
		        case 2:
		          timeout = 250;
		          break;
		        case 5:
		          timeout = 1073741823;
		          break;
		        case 4:
		          timeout = 1e4;
		          break;
		        default:
		          timeout = 5e3;
		      }
		      timeout = options + timeout;
		      priorityLevel = {
		        id: taskIdCounter++,
		        callback: callback,
		        priorityLevel: priorityLevel,
		        startTime: options,
		        expirationTime: timeout,
		        sortIndex: -1
		      };
		      options > currentTime
		        ? ((priorityLevel.sortIndex = options),
		          push(timerQueue, priorityLevel),
		          null === peek(taskQueue) &&
		            priorityLevel === peek(timerQueue) &&
		            (isHostTimeoutScheduled
		              ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))
		              : (isHostTimeoutScheduled = true),
		            requestHostTimeout(handleTimeout, options - currentTime)))
		        : ((priorityLevel.sortIndex = timeout),
		          push(taskQueue, priorityLevel),
		          isHostCallbackScheduled ||
		            isPerformingWork ||
		            ((isHostCallbackScheduled = true), requestHostCallback()));
		      return priorityLevel;
		    };
		    exports.unstable_shouldYield = shouldYieldToHost;
		    exports.unstable_wrapCallback = function (callback) {
		      var parentPriorityLevel = currentPriorityLevel;
		      return function () {
		        var previousPriorityLevel = currentPriorityLevel;
		        currentPriorityLevel = parentPriorityLevel;
		        try {
		          return callback.apply(this, arguments);
		        } finally {
		          currentPriorityLevel = previousPriorityLevel;
		        }
		      };
		    };
		    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
		      "function" ===
		        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&
		      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
		  })(); 
	} (scheduler_development));
	return scheduler_development;
}

var hasRequiredScheduler;

function requireScheduler () {
	if (hasRequiredScheduler) return scheduler.exports;
	hasRequiredScheduler = 1;

	if (process.env.NODE_ENV === 'production') {
	  scheduler.exports = requireScheduler_production();
	} else {
	  scheduler.exports = requireScheduler_development();
	}
	return scheduler.exports;
}

var schedulerExports = requireScheduler();

const NO_CONTEXT = {};
const UPDATE_SIGNAL = {};
// for react-spring capability
Konva.Node.prototype._applyProps = applyNodeProps;
// let currentUpdatePriority: number = NoEventPriority;
let currentUpdatePriority = constantsExports.DefaultEventPriority;
function appendInitialChild(parentInstance, child) {
    if (typeof child === 'string') {
        // Noop for string children of Text (eg <Text>foo</Text>)
        console.error(`Do not use plain text as child of Konva.Node. You are using text: ${child}`);
        return;
    }
    parentInstance.add(child);
    updatePicture(parentInstance);
}
function createInstance(type, props, internalInstanceHandle) {
    let NodeClass = Konva[type];
    if (!NodeClass) {
        console.error(`Konva has no node with the type ${type}. Group will be used instead. If you use minimal version of react-konva, just import required nodes into Konva: "import "konva/lib/shapes/${type}"  If you want to render DOM elements as part of canvas tree take a look into this demo: https://konvajs.github.io/docs/react/DOM_Portal.html`);
        NodeClass = Konva.Group;
    }
    // we need to split props into events and non events
    // we we can pass non events into constructor directly
    // that way the performance should be better
    // we we apply change "applyNodeProps"
    // then it will trigger change events on first run
    // but we don't need them!
    const propsWithoutEvents = {};
    const propsWithOnlyEvents = {};
    for (var key in props) {
        var isEvent = key.slice(0, 2) === 'on';
        if (isEvent) {
            propsWithOnlyEvents[key] = props[key];
        }
        else {
            propsWithoutEvents[key] = props[key];
        }
    }
    const instance = new NodeClass(propsWithoutEvents);
    applyNodeProps(instance, propsWithOnlyEvents);
    return instance;
}
function createTextInstance(text, rootContainerInstance, internalInstanceHandle) {
    console.error(`Text components are not supported for now in ReactKonva. Your text is: "${text}"`);
}
function finalizeInitialChildren(domElement, type, props) {
    return false;
}
function getPublicInstance(instance) {
    return instance;
}
function prepareForCommit() {
    return null;
}
function preparePortalMount() {
    return null;
}
function prepareUpdate(domElement, type, oldProps, newProps) {
    return UPDATE_SIGNAL;
}
function resetAfterCommit() {
    // Noop
}
function resetTextContent(domElement) {
    // Noop
}
function shouldDeprioritizeSubtree(type, props) {
    return false;
}
function getRootHostContext() {
    return NO_CONTEXT;
}
function getChildHostContext() {
    return NO_CONTEXT;
}
const scheduleTimeout = setTimeout;
const cancelTimeout = clearTimeout;
const supportsMicrotasks = true;
// use this to schedule microtasks
// I don't know if we should do this in react-konva
// better to run schedule in sync mode
// so setState will call render imidiatly
// it may be not optimal
// but working in sync mode is simpler.
const scheduleMicrotask = (fn) => {
    fn();
};
const noTimeout = -1;
// export const schedulePassiveEffects = scheduleDeferredCallback;
// export const cancelPassiveEffects = cancelDeferredCallback;
function shouldSetTextContent(type, props) {
    return false;
}
// The Konva renderer is secondary to the React DOM renderer.
const isPrimaryRenderer = false;
const warnsIfNotActing = false;
const supportsMutation = true;
const supportsPersistence = false;
const supportsHydration = false;
function appendChild(parentInstance, child) {
    if (child.parent === parentInstance) {
        child.moveToTop();
    }
    else {
        parentInstance.add(child);
    }
    updatePicture(parentInstance);
}
function appendChildToContainer(parentInstance, child) {
    if (child.parent === parentInstance) {
        child.moveToTop();
    }
    else {
        parentInstance.add(child);
    }
    updatePicture(parentInstance);
}
function insertBefore(parentInstance, child, beforeChild) {
    // child._remove() will not stop dragging
    // but child.remove() will stop it, but we don't need it
    // removing will reset zIndexes
    child._remove();
    parentInstance.add(child);
    child.setZIndex(beforeChild.getZIndex());
    updatePicture(parentInstance);
}
function insertInContainerBefore(parentInstance, child, beforeChild) {
    insertBefore(parentInstance, child, beforeChild);
}
function removeChild(parentInstance, child) {
    child.destroy();
    child.off(EVENTS_NAMESPACE);
    updatePicture(parentInstance);
}
function removeChildFromContainer(parentInstance, child) {
    child.destroy();
    child.off(EVENTS_NAMESPACE);
    updatePicture(parentInstance);
}
function commitTextUpdate(textInstance, oldText, newText) {
    console.error(`Text components are not yet supported in ReactKonva. You text is: "${newText}"`);
}
function commitMount(instance, type, newProps) {
    // Noop
}
function commitUpdate(instance, type, oldProps, newProps) {
    applyNodeProps(instance, newProps, oldProps);
}
function hideInstance(instance) {
    instance.hide();
    updatePicture(instance);
}
function hideTextInstance(textInstance) {
    // Noop
}
function unhideInstance(instance, props) {
    if (props.visible == null || props.visible) {
        instance.show();
    }
}
function unhideTextInstance(textInstance, text) {
    // Noop
}
function clearContainer(container) {
    // Noop
}
function detachDeletedInstance() { }
function getCurrentEventPriority() {
    return constantsExports.DefaultEventPriority;
}
function prepareScopeUpdate() { }
function getInstanceFromScope() {
    return null;
}
function setCurrentUpdatePriority(newPriority) {
    currentUpdatePriority = newPriority;
}
function getCurrentUpdatePriority() {
    return currentUpdatePriority;
}
function resolveUpdatePriority() {
    return constantsExports.DiscreteEventPriority;
}
function shouldAttemptEagerTransition() {
    return false;
}
function requestPostPaintCallback() { }
function maySuspendCommit() {
    return false;
}
function preloadInstance() {
    return true;
}
function startSuspendingCommit() { }
function suspendInstance() { }
function waitForCommitToBeReady() {
    return null;
}
const NotPendingTransition = null;
function resetFormInstance() { }

var HostConfig = /*#__PURE__*/Object.freeze({
    __proto__: null,
    NotPendingTransition: NotPendingTransition,
    appendChild: appendChild,
    appendChildToContainer: appendChildToContainer,
    appendInitialChild: appendInitialChild,
    cancelTimeout: cancelTimeout,
    clearContainer: clearContainer,
    commitMount: commitMount,
    commitTextUpdate: commitTextUpdate,
    commitUpdate: commitUpdate,
    createInstance: createInstance,
    createTextInstance: createTextInstance,
    detachDeletedInstance: detachDeletedInstance,
    finalizeInitialChildren: finalizeInitialChildren,
    getChildHostContext: getChildHostContext,
    getCurrentEventPriority: getCurrentEventPriority,
    getCurrentUpdatePriority: getCurrentUpdatePriority,
    getInstanceFromScope: getInstanceFromScope,
    getPublicInstance: getPublicInstance,
    getRootHostContext: getRootHostContext,
    hideInstance: hideInstance,
    hideTextInstance: hideTextInstance,
    idlePriority: schedulerExports.unstable_IdlePriority,
    insertBefore: insertBefore,
    insertInContainerBefore: insertInContainerBefore,
    isPrimaryRenderer: isPrimaryRenderer,
    maySuspendCommit: maySuspendCommit,
    noTimeout: noTimeout,
    now: schedulerExports.unstable_now,
    preloadInstance: preloadInstance,
    prepareForCommit: prepareForCommit,
    preparePortalMount: preparePortalMount,
    prepareScopeUpdate: prepareScopeUpdate,
    prepareUpdate: prepareUpdate,
    removeChild: removeChild,
    removeChildFromContainer: removeChildFromContainer,
    requestPostPaintCallback: requestPostPaintCallback,
    resetAfterCommit: resetAfterCommit,
    resetFormInstance: resetFormInstance,
    resetTextContent: resetTextContent,
    resolveUpdatePriority: resolveUpdatePriority,
    run: schedulerExports.unstable_runWithPriority,
    scheduleMicrotask: scheduleMicrotask,
    scheduleTimeout: scheduleTimeout,
    setCurrentUpdatePriority: setCurrentUpdatePriority,
    shouldAttemptEagerTransition: shouldAttemptEagerTransition,
    shouldDeprioritizeSubtree: shouldDeprioritizeSubtree,
    shouldSetTextContent: shouldSetTextContent,
    startSuspendingCommit: startSuspendingCommit,
    supportsHydration: supportsHydration,
    supportsMicrotasks: supportsMicrotasks,
    supportsMutation: supportsMutation,
    supportsPersistence: supportsPersistence,
    suspendInstance: suspendInstance,
    unhideInstance: unhideInstance,
    unhideTextInstance: unhideTextInstance,
    waitForCommitToBeReady: waitForCommitToBeReady,
    warnsIfNotActing: warnsIfNotActing
});

function i(e, t, r) {
  if (!e) return;
  if (r(e) === true) return e;
  let n = e.child;
  for (; n; ) {
    const u = i(n, t, r);
    if (u) return u;
    n = n.sibling;
  }
}
function l(e) {
  try {
    return Object.defineProperties(e, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {
        }
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {
        }
      }
    });
  } catch (t) {
    return e;
  }
}
const a = /* @__PURE__ */ l(/* @__PURE__ */ React.createContext(null));
class m extends React.Component {
  render() {
    return /* @__PURE__ */ React.createElement(a.Provider, { value: this._reactInternals }, this.props.children);
  }
}
function c() {
  const e = React.useContext(a);
  if (e === null) throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
  const t = React.useId();
  return React.useMemo(() => {
    for (const n of [e, e == null ? void 0 : e.alternate]) {
      if (!n) continue;
      const u = i(n, false, (d) => {
        let s = d.memoizedState;
        for (; s; ) {
          if (s.memoizedState === t) return true;
          s = s.next;
        }
      });
      if (u) return u;
    }
  }, [e, t]);
}
const p = Symbol.for("react.context"), b = (e) => e !== null && typeof e == "object" && "$$typeof" in e && e.$$typeof === p;
function h() {
  const e = c(), [t] = React.useState(() => /* @__PURE__ */ new Map());
  t.clear();
  let r = e;
  for (; r; ) {
    const n = r.type;
    b(n) && n !== a && !t.has(n) && t.set(n, React.use(l(n))), r = r.return;
  }
  return t;
}
function x() {
  const e = h();
  return React.useMemo(
    () => Array.from(e.keys()).reduce(
      (t, r) => (n) => /* @__PURE__ */ React.createElement(t, null, /* @__PURE__ */ React.createElement(r.Provider, { ...n, value: e.get(r) })),
      (t) => /* @__PURE__ */ React.createElement(m, { ...t })
    ),
    [e]
  );
}

/**
 * Based on ReactArt.js
 * Copyright (c) 2017-present Lavrenov Anton.
 * All rights reserved.
 *
 * MIT
 */
if (React__default.version.indexOf('19') === -1) {
    throw new Error('react-konva version 19 is only compatible with React 19. Make sure to have the last version of react-konva and react or downgrade react-konva to version 18.');
}
function usePrevious(value) {
    const ref = React__default.useRef({});
    React__default.useLayoutEffect(() => {
        ref.current = value;
    });
    React__default.useLayoutEffect(() => {
        return () => {
            // when using suspense it is possible that stage is unmounted
            // but React still keep component ref
            // in that case we need to manually flush props
            // we have a special test for that
            ref.current = {};
        };
    }, []);
    return ref.current;
}
const StageWrap = (props) => {
    const container = React__default.useRef(null);
    const stage = React__default.useRef(null);
    const fiberRef = React__default.useRef(null);
    const oldProps = usePrevious(props);
    const Bridge = x();
    const _setRef = (stage) => {
        const { forwardedRef } = props;
        if (!forwardedRef) {
            return;
        }
        if (typeof forwardedRef === 'function') {
            forwardedRef(stage);
        }
        else {
            forwardedRef.current = stage;
        }
    };
    React__default.useLayoutEffect(() => {
        stage.current = new Konva.Stage({
            width: props.width,
            height: props.height,
            container: container.current,
        });
        _setRef(stage.current);
        // @ts-ignore
        fiberRef.current = KonvaRenderer.createContainer(stage.current, constantsExports.ConcurrentRoot, null, false, null, '', console.error, console.error, console.error, null);
        KonvaRenderer.updateContainer(React__default.createElement(Bridge, {}, props.children), fiberRef.current, null, () => { });
        return () => {
            _setRef(null);
            KonvaRenderer.updateContainer(null, fiberRef.current, null);
            stage.current.destroy();
        };
    }, []);
    React__default.useLayoutEffect(() => {
        _setRef(stage.current);
        applyNodeProps(stage.current, props, oldProps);
        KonvaRenderer.updateContainer(React__default.createElement(Bridge, {}, props.children), fiberRef.current, null);
    });
    return React__default.createElement('div', {
        ref: container,
        id: props.id,
        accessKey: props.accessKey,
        className: props.className,
        role: props.role,
        style: props.style,
        tabIndex: props.tabIndex,
        title: props.title,
    });
};
const Layer = 'Layer';
const Group = 'Group';
const Rect = 'Rect';
const Circle = 'Circle';
const Line = 'Line';
const Image = 'Image';
// @ts-ignore
const KonvaRenderer = ReactFiberReconciler(HostConfig);
KonvaRenderer.injectIntoDevTools({
    // @ts-ignore
    findHostInstanceByFiber: () => null,
    bundleType: process.env.NODE_ENV !== 'production' ? 1 : 0,
    version: React__default.version,
    rendererPackageName: 'react-konva',
});
// Update Stage component declaration
const Stage = React__default.forwardRef((props, ref) => {
    return React__default.createElement(m, {}, React__default.createElement(StageWrap, { ...props, forwardedRef: ref }));
});

var ImageMaskCanvas = forwardRef(function (props, ref) {
    var _a, _b, _c, _d, _e;
    var _f = useState(null), image = _f[0], setImage = _f[1];
    var _g = useState(false), isDrawing = _g[0], setIsDrawing = _g[1];
    var _h = useState(null), startPoint = _h[0], setStartPoint = _h[1];
    var _j = useState([]), currentPath = _j[0], setCurrentPath = _j[1];
    var _k = useState(null), currentBox = _k[0], setCurrentBox = _k[1];
    var _l = useState(null), maskCanvas = _l[0], setMaskCanvas = _l[1];
    var _m = useState(null), tempCanvas = _m[0], setTempCanvas = _m[1];
    var _o = useState(null), maskImage = _o[0], setMaskImage = _o[1];
    var _p = useState([]), history = _p[0], setHistory = _p[1];
    var _q = useState(-1), historyIndex = _q[0], setHistoryIndex = _q[1];
    var _r = useState(props.opacity || 0.5), currentOpacity = _r[0], setCurrentOpacity = _r[1];
    useRef(props.opacity || 0.5);
    var _s = useState(1), scale = _s[0], setScale = _s[1];
    var _t = useState({ x: 0, y: 0 }), position = _t[0], setPosition = _t[1];
    var _u = useState('rgba(0, 0, 0, 1)'), maskColor = _u[0], setMaskColor = _u[1];
    var _v = useState(10), brushSize = _v[0], setBrushSize = _v[1];
    var _w = useState(null), cursorPosition = _w[0], setCursorPosition = _w[1];
    var _x = useState([]), polygonPoints = _x[0], setPolygonPoints = _x[1];
    var _y = useState(false), isDrawingPolygon = _y[0], setIsDrawingPolygon = _y[1];
    var _z = useState(null), tempPolygonPoint = _z[0], setTempPolygonPoint = _z[1];
    var src = props.src, width = props.width, height = props.height, onZoomChange = props.onZoomChange, toolMode = props.toolMode, onHistoryChange = props.onHistoryChange;
    var stageRef = useRef(null);
    var layerRef = useRef(null);
    var drawingPathRef = useRef([]);
    var lastUpdateTimeRef = useRef(0);
    var animationFrameRef = useRef(undefined);
    var tempCanvasRef = useRef(null);
    var getScaledPoint = useCallback(function (point) {
        return {
            x: (point.x - position.x) / scale,
            y: (point.y - position.y) / scale
        };
    }, [position, scale]);
    useEffect(function () {
        var img = new window.Image();
        img.src = src;
        img.onload = function () {
            console.log('Image loaded with dimensions:', img.width, 'x', img.height);
            setImage(img);
            // Send initial zoom value when image is loaded
            onZoomChange === null || onZoomChange === void 0 ? void 0 : onZoomChange(Math.round(scale * 100));
        };
        // Initialize mask canvas
        var canvas = document.createElement('canvas');
        canvas.width = width || 1024;
        canvas.height = height || 1024;
        var ctx = canvas.getContext('2d');
        if (ctx) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        setMaskCanvas(canvas);
        // Initialize temp canvas
        var temp = document.createElement('canvas');
        temp.width = canvas.width;
        temp.height = canvas.height;
        var tempCtx = temp.getContext('2d');
        if (tempCtx) {
            tempCtx.fillStyle = 'rgba(0, 0, 0, 0)';
            tempCtx.fillRect(0, 0, canvas.width, canvas.height);
        }
        setTempCanvas(temp);
        // Add initial empty state to history
        var initialState = {
            canvasData: canvas.toDataURL(),
            toolMode: 'mask-freehand'
        };
        setHistory([initialState]);
        setHistoryIndex(0);
    }, [src, width, height, scale, onZoomChange]);
    // Initialize temporary canvas for drawing operations
    useEffect(function () {
        var canvas = document.createElement('canvas');
        canvas.width = width || 1024;
        canvas.height = height || 1024;
        tempCanvasRef.current = canvas;
        return function () {
            tempCanvasRef.current = null;
        };
    }, [width, height]);
    var updateMaskImage = useCallback(function () {
        if (!maskCanvas)
            return;
        var img = new window.Image();
        img.src = maskCanvas.toDataURL();
        img.onload = function () {
            setMaskImage(img);
        };
    }, [maskCanvas]);
    var saveToHistory = useCallback(function () {
        if (!maskCanvas)
            return;
        var newState = {
            canvasData: maskCanvas.toDataURL(),
            toolMode: toolMode
        };
        // If we're not at the end of history, remove future states
        var newHistory = history.slice(0, historyIndex + 1);
        newHistory.push(newState);
        setHistory(newHistory);
        setHistoryIndex(newHistory.length - 1);
        // Emit history change event - enable undo if we have more than one state
        onHistoryChange === null || onHistoryChange === void 0 ? void 0 : onHistoryChange(newHistory.length > 1, false);
    }, [maskCanvas, history, historyIndex, toolMode, onHistoryChange]);
    var loadStateFromHistory = function (index) {
        if (!maskCanvas || index < 0 || index >= history.length)
            return;
        var state = history[index];
        var img = new window.Image();
        img.src = state.canvasData;
        img.onload = function () {
            var ctx = maskCanvas.getContext('2d');
            if (ctx) {
                // Clear the canvas
                ctx.clearRect(0, 0, width || 1024, height || 1024);
                // Draw the previous state
                ctx.drawImage(img, 0, 0);
                // Apply current opacity to the loaded state
                var imageData = ctx.getImageData(0, 0, width || 1024, height || 1024);
                var data = imageData.data;
                // Extract RGB values from the mask color
                var rgbMatch = maskColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
                if (rgbMatch) {
                    rgbMatch[0]; var r = rgbMatch[1], g = rgbMatch[2], b = rgbMatch[3];
                    // Update the alpha channel for all non-transparent pixels
                    for (var i = 3; i < data.length; i += 4) {
                        if (data[i] > 0) { // If pixel is not transparent
                            // Set the RGB values to match the mask color
                            data[i - 3] = parseInt(r);
                            data[i - 2] = parseInt(g);
                            data[i - 1] = parseInt(b);
                            // Set the alpha to the current opacity, but never to 0
                            data[i] = Math.max(1, Math.round(currentOpacity * 255));
                        }
                    }
                    // Put the modified data back
                    ctx.putImageData(imageData, 0, 0);
                }
                // Update the mask image
                updateMaskImage();
            }
        };
    };
    var undo = function () {
        if (historyIndex > 0) {
            var newIndex = historyIndex - 1;
            loadStateFromHistory(newIndex);
            setHistoryIndex(newIndex);
            onHistoryChange === null || onHistoryChange === void 0 ? void 0 : onHistoryChange(newIndex > 0, true);
        }
    };
    var redo = function () {
        if (historyIndex < history.length - 1) {
            var newIndex = historyIndex + 1;
            loadStateFromHistory(newIndex);
            setHistoryIndex(newIndex);
            onHistoryChange === null || onHistoryChange === void 0 ? void 0 : onHistoryChange(true, newIndex < history.length - 1);
        }
    };
    var getMaskColorWithOpacity = useCallback(function () {
        // Extract RGB values from the mask color
        var rgbMatch = maskColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
        if (!rgbMatch)
            return maskColor;
        rgbMatch[0]; var r = rgbMatch[1], g = rgbMatch[2], b = rgbMatch[3];
        // Ensure opacity is never 0
        var opacity = Math.max(0.01, currentOpacity);
        return "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(opacity, ")");
    }, [maskColor, currentOpacity]);
    // Throttle the preview update
    var updatePreview = useCallback(function () {
        if (drawingPathRef.current.length > 0) {
            setCurrentPath(__spreadArray([], drawingPathRef.current, true));
        }
    }, []);
    var drawOnMask = useCallback(function (points, isEraser) {
        if (isEraser === void 0) { isEraser = false; }
        if (!maskCanvas || !tempCanvasRef.current)
            return;
        var ctx = maskCanvas.getContext('2d');
        var tempCtx = tempCanvasRef.current.getContext('2d');
        if (!ctx || !tempCtx)
            return;
        if (points.length < 2)
            return;
        // Clear the temporary canvas
        tempCtx.clearRect(0, 0, width || 1024, height || 1024);
        // Copy the current mask state to the temporary canvas
        tempCtx.drawImage(maskCanvas, 0, 0);
        if (isEraser) {
            // For eraser, use destination-out to remove existing mask
            tempCtx.globalCompositeOperation = 'destination-out';
            tempCtx.beginPath();
            tempCtx.moveTo(points[0].x, points[0].y);
            for (var i = 1; i < points.length; i++) {
                tempCtx.lineTo(points[i].x, points[i].y);
            }
            tempCtx.lineWidth = brushSize;
            tempCtx.lineCap = 'round';
            tempCtx.lineJoin = 'round';
            tempCtx.strokeStyle = 'rgba(0, 0, 0, 1)';
            tempCtx.stroke();
        }
        else {
            // For drawing mask, use source-over to replace existing content
            tempCtx.globalCompositeOperation = 'source-over';
            tempCtx.beginPath();
            tempCtx.moveTo(points[0].x, points[0].y);
            for (var i = 1; i < points.length; i++) {
                tempCtx.lineTo(points[i].x, points[i].y);
            }
            tempCtx.lineWidth = brushSize;
            tempCtx.lineCap = 'round';
            tempCtx.lineJoin = 'round';
            tempCtx.strokeStyle = getMaskColorWithOpacity();
            tempCtx.stroke();
        }
        // Reset composite operation
        tempCtx.globalCompositeOperation = 'source-over';
        // Copy the result back to the main canvas
        ctx.clearRect(0, 0, width || 1024, height || 1024);
        ctx.drawImage(tempCanvasRef.current, 0, 0);
        // Update the mask image
        updateMaskImage();
    }, [maskCanvas, brushSize, getMaskColorWithOpacity, updateMaskImage, width, height]);
    var drawBoxOnMask = useCallback(function (box, isEraser) {
        if (isEraser === void 0) { isEraser = false; }
        if (!maskCanvas || !tempCanvasRef.current)
            return;
        var ctx = maskCanvas.getContext('2d');
        var tempCtx = tempCanvasRef.current.getContext('2d');
        if (!ctx || !tempCtx)
            return;
        if (isEraser) {
            // For eraser, draw directly on the main canvas
            ctx.globalCompositeOperation = 'destination-out';
            ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            ctx.fillRect(box.x, box.y, box.width, box.height);
            // Reset composite operation
            ctx.globalCompositeOperation = 'source-over';
        }
        else {
            // For drawing mask, draw directly on the main canvas
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = getMaskColorWithOpacity();
            ctx.fillRect(box.x, box.y, box.width, box.height);
        }
        // Update the mask image
        updateMaskImage();
    }, [maskCanvas, getMaskColorWithOpacity, updateMaskImage]);
    var drawPolygonOnMask = useCallback(function (points) {
        if (!maskCanvas || !tempCanvasRef.current)
            return;
        var ctx = maskCanvas.getContext('2d');
        var tempCtx = tempCanvasRef.current.getContext('2d');
        if (!ctx || !tempCtx)
            return;
        if (points.length < 3)
            return;
        // Clear the temporary canvas
        tempCtx.clearRect(0, 0, width || 1024, height || 1024);
        // Copy the current mask state to the temporary canvas
        tempCtx.drawImage(maskCanvas, 0, 0);
        // Draw the polygon
        tempCtx.globalCompositeOperation = 'source-over';
        tempCtx.beginPath();
        tempCtx.moveTo(points[0].x, points[0].y);
        for (var i = 1; i < points.length; i++) {
            tempCtx.lineTo(points[i].x, points[i].y);
        }
        tempCtx.closePath();
        tempCtx.fillStyle = getMaskColorWithOpacity();
        tempCtx.fill();
        // Copy the result back to the main canvas
        ctx.clearRect(0, 0, width || 1024, height || 1024);
        ctx.drawImage(tempCanvasRef.current, 0, 0);
        // Update the mask image
        updateMaskImage();
    }, [maskCanvas, getMaskColorWithOpacity, updateMaskImage, width, height]);
    var handleMouseMove = useCallback(function (e) {
        var stage = e.target.getStage();
        if (!stage)
            return;
        var point = stage.getPointerPosition();
        if (!point)
            return;
        var scaledPoint = getScaledPoint(point);
        setCursorPosition(scaledPoint);
        if (props.toolMode === 'mask-polygon') {
            if (isDrawingPolygon && polygonPoints.length > 0) {
                setTempPolygonPoint(scaledPoint);
            }
            return;
        }
        if (!isDrawing || !startPoint)
            return;
        if (props.toolMode === 'mask-box' || props.toolMode === 'eraser-box') {
            var x = Math.min(startPoint.x, scaledPoint.x);
            var y = Math.min(startPoint.y, scaledPoint.y);
            var width_1 = Math.abs(scaledPoint.x - startPoint.x);
            var height_1 = Math.abs(scaledPoint.y - startPoint.y);
            setCurrentBox({ x: x, y: y, width: width_1, height: height_1 });
        }
        else {
            // Add point to the ref instead of state
            drawingPathRef.current.push(scaledPoint);
            // Throttle the preview update
            var now = performance.now();
            if (now - lastUpdateTimeRef.current > 16) { // ~60fps
                lastUpdateTimeRef.current = now;
                if (animationFrameRef.current) {
                    cancelAnimationFrame(animationFrameRef.current);
                }
                animationFrameRef.current = requestAnimationFrame(updatePreview);
            }
        }
    }, [isDrawing, startPoint, props.toolMode, updatePreview, getScaledPoint, isDrawingPolygon, polygonPoints]);
    var handleMouseDown = function (e) {
        if (props.toolMode === 'move')
            return;
        var stage = e.target.getStage();
        if (!stage)
            return;
        var point = stage.getPointerPosition();
        if (!point)
            return;
        var scaledPoint = getScaledPoint(point);
        if (props.toolMode === 'mask-polygon') {
            if (!isDrawingPolygon) {
                setIsDrawingPolygon(true);
                setPolygonPoints([scaledPoint]);
            }
            else {
                // Check if we're closing the polygon (clicking near the first point)
                if (polygonPoints.length > 2) {
                    var firstPoint = polygonPoints[0];
                    var distance = Math.sqrt(Math.pow(scaledPoint.x - firstPoint.x, 2) +
                        Math.pow(scaledPoint.y - firstPoint.y, 2));
                    if (distance < 10) { // Close the polygon if within 10 pixels of first point
                        drawPolygonOnMask(polygonPoints);
                        setIsDrawingPolygon(false);
                        setPolygonPoints([]);
                        setTempPolygonPoint(null);
                        return;
                    }
                }
                setPolygonPoints(__spreadArray(__spreadArray([], polygonPoints, true), [scaledPoint], false));
            }
            return;
        }
        setIsDrawing(true);
        setStartPoint(scaledPoint);
        if (props.toolMode === 'mask-box' || props.toolMode === 'eraser-box') {
            setCurrentBox({ x: scaledPoint.x, y: scaledPoint.y, width: 0, height: 0 });
        }
        else {
            setCurrentPath([scaledPoint]);
        }
    };
    var handleMouseUp = useCallback(function () {
        if (props.toolMode === 'mask-polygon')
            return;
        if (!isDrawing || !props.toolMode || props.toolMode === 'move')
            return;
        var isEraser = props.toolMode.startsWith('eraser');
        if (props.toolMode === 'mask-box' || props.toolMode === 'eraser-box') {
            if (currentBox) {
                // Clamp box coordinates to image boundaries
                var clampedBox = {
                    x: Math.max(0, Math.min(currentBox.x, width || 1024)),
                    y: Math.max(0, Math.min(currentBox.y, height || 1024)),
                    width: Math.min(width || 1024 - currentBox.x, Math.max(0, currentBox.width)),
                    height: Math.min(height || 1024 - currentBox.y, Math.max(0, currentBox.height))
                };
                drawBoxOnMask(clampedBox, isEraser);
                saveToHistory();
            }
        }
        else if (drawingPathRef.current.length > 1) {
            // Clamp the last point to image boundaries
            var lastPoint = drawingPathRef.current[drawingPathRef.current.length - 1];
            var clampedPoint = {
                x: Math.max(0, Math.min(lastPoint.x, width || 1024)),
                y: Math.max(0, Math.min(lastPoint.y, height || 1024))
            };
            var clampedPath = __spreadArray(__spreadArray([], drawingPathRef.current.slice(0, -1), true), [clampedPoint], false);
            drawOnMask(clampedPath, isEraser);
            saveToHistory();
        }
        // Clean up
        setIsDrawing(false);
        drawingPathRef.current = [];
        setCurrentPath([]);
        setCurrentBox(null);
        setStartPoint(null);
    }, [isDrawing, props.toolMode, currentBox, width, height, drawOnMask, drawBoxOnMask, saveToHistory]);
    var clearMask = function () {
        if (!maskCanvas || !tempCanvas)
            return;
        var ctx = maskCanvas.getContext('2d');
        var tempCtx = tempCanvas.getContext('2d');
        if (!ctx || !tempCtx)
            return;
        // Clear both canvases
        ctx.clearRect(0, 0, width || 1024, height || 1024);
        tempCtx.clearRect(0, 0, width || 1024, height || 1024);
        // Reset the canvases to transparent
        ctx.fillStyle = 'rgba(0, 0, 0, 0)';
        ctx.fillRect(0, 0, width || 1024, height || 1024);
        tempCtx.fillStyle = 'rgba(0, 0, 0, 0)';
        tempCtx.fillRect(0, 0, width || 1024, height || 1024);
        // Update the mask image
        updateMaskImage();
        // Reset states
        setCurrentPath([]);
        setCurrentBox(null);
        setStartPoint(null);
        // Save to history
        saveToHistory();
    };
    var handleWheel = function (e) {
        var _a;
        e.evt.preventDefault();
        var stage = stageRef.current;
        if (!stage)
            return;
        var oldScale = scale;
        var pointer = stage.getPointerPosition();
        if (!pointer)
            return;
        // Calculate new scale
        var newScale = e.evt.deltaY > 0 ? oldScale * 0.98 : oldScale * 1.02;
        // Limit scale between 1 and 10
        var boundedScale = Math.min(Math.max(1, newScale), 10);
        // Calculate new position to zoom towards mouse pointer
        var mousePointTo = {
            x: (pointer.x - position.x) / oldScale,
            y: (pointer.y - position.y) / oldScale,
        };
        var newPosition = {
            x: pointer.x - mousePointTo.x * boundedScale,
            y: pointer.y - mousePointTo.y * boundedScale,
        };
        setScale(boundedScale);
        setPosition(newPosition);
        // Call the callback if provided, converting scale to percentage
        (_a = props.onZoomChange) === null || _a === void 0 ? void 0 : _a.call(props, Math.round(boundedScale * 100));
    };
    var updateMaskColor = function (newColor) {
        if (!maskCanvas)
            return;
        var ctx = maskCanvas.getContext('2d');
        if (!ctx)
            return;
        // Get the current mask data
        var imageData = ctx.getImageData(0, 0, width || 1024, height || 1024);
        var data = imageData.data;
        // Extract RGB values from the new color
        var rgbMatch = newColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
        if (!rgbMatch)
            return;
        rgbMatch[0]; var r = rgbMatch[1], g = rgbMatch[2], b = rgbMatch[3];
        // Update all non-transparent pixels to the new color
        for (var i = 0; i < data.length; i += 4) {
            if (data[i + 3] > 0) { // If pixel is not transparent
                data[i] = parseInt(r); // R
                data[i + 1] = parseInt(g); // G
                data[i + 2] = parseInt(b); // B
                // Keep original alpha
            }
        }
        // Put the modified data back
        ctx.putImageData(imageData, 0, 0);
        updateMaskImage();
        saveToHistory();
    };
    var handleMouseLeave = function () {
        setCursorPosition(null);
    };
    useEffect(function () {
        if (!maskCanvas)
            return;
        var ctx = maskCanvas.getContext('2d');
        if (!ctx)
            return;
        // Get the current mask data
        var imageData = ctx.getImageData(0, 0, width || 1024, height || 1024);
        var data = imageData.data;
        // Extract RGB values from the mask color
        var rgbMatch = maskColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
        if (!rgbMatch)
            return;
        rgbMatch[0]; var r = rgbMatch[1], g = rgbMatch[2], b = rgbMatch[3];
        // Update the alpha channel for all non-transparent pixels
        for (var i = 3; i < data.length; i += 4) {
            if (data[i] > 0) { // If pixel is not transparent
                // Set the RGB values to match the mask color
                data[i - 3] = parseInt(r);
                data[i - 2] = parseInt(g);
                data[i - 1] = parseInt(b);
                // Set the alpha to the current opacity, but never to 0
                data[i] = Math.max(1, Math.round(currentOpacity * 255));
            }
        }
        // Put the modified data back
        ctx.putImageData(imageData, 0, 0);
        updateMaskImage();
    }, [currentOpacity, maskCanvas, maskColor, width, height, updateMaskImage]);
    // Reset polygon state when tool mode changes
    useEffect(function () {
        if (props.toolMode !== 'mask-polygon') {
            setIsDrawingPolygon(false);
            setPolygonPoints([]);
            setTempPolygonPoint(null);
        }
    }, [props.toolMode]);
    // Clean up animation frame on unmount
    useEffect(function () {
        return function () {
            if (animationFrameRef.current) {
                cancelAnimationFrame(animationFrameRef.current);
            }
        };
    }, []);
    var setZoom = function (zoomPercentage) {
        var _a;
        var stage = stageRef.current;
        if (!stage)
            return;
        var oldScale = scale;
        var newScale = zoomPercentage / 100;
        var boundedScale = Math.min(Math.max(1, newScale), 10);
        // Get the center of the visible area
        var center = {
            x: stage.width() / 2,
            y: stage.height() / 2
        };
        // Calculate new position to keep the center point fixed
        var mousePointTo = {
            x: (center.x - position.x) / oldScale,
            y: (center.y - position.y) / oldScale,
        };
        var newPosition = {
            x: center.x - mousePointTo.x * boundedScale,
            y: center.y - mousePointTo.y * boundedScale,
        };
        setScale(boundedScale);
        setPosition(newPosition);
        (_a = props.onZoomChange) === null || _a === void 0 ? void 0 : _a.call(props, Math.round(boundedScale * 100));
    };
    var setOpacity = useCallback(function (opacity) {
        setCurrentOpacity(opacity);
        if (!maskCanvas)
            return;
        var ctx = maskCanvas.getContext('2d');
        if (!ctx)
            return;
        // Get the current mask data
        var imageData = ctx.getImageData(0, 0, width || 1024, height || 1024);
        var data = imageData.data;
        // Extract RGB values from the mask color
        var rgbMatch = maskColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
        if (!rgbMatch)
            return;
        rgbMatch[0]; var r = rgbMatch[1], g = rgbMatch[2], b = rgbMatch[3];
        // Update the alpha channel for all non-transparent pixels
        for (var i = 3; i < data.length; i += 4) {
            if (data[i] > 0) { // If pixel is not transparent
                // Set the RGB values to match the mask color
                data[i - 3] = parseInt(r);
                data[i - 2] = parseInt(g);
                data[i - 1] = parseInt(b);
                // Set the alpha to the current opacity, but never to 0
                data[i] = Math.max(1, Math.round(opacity * 255));
            }
        }
        // Put the modified data back
        ctx.putImageData(imageData, 0, 0);
        updateMaskImage();
    }, [maskCanvas, maskColor, width, height, updateMaskImage]);
    useImperativeHandle(ref, function () { return ({
        getMaskData: function () { return (maskCanvas === null || maskCanvas === void 0 ? void 0 : maskCanvas.toDataURL()) || null; },
        clearMask: clearMask,
        undo: undo,
        redo: redo,
        setToolMode: function (mode) {
            // No need to set state since it's controlled by parent
        },
        setMaskColor: function (color) {
            setMaskColor(color);
            updateMaskColor(color);
        },
        setOpacity: setOpacity,
        setBrushSize: function (size) {
            setBrushSize(size);
        },
        canUndo: history.length > 1,
        canRedo: historyIndex < history.length - 1,
        setZoom: setZoom
    }); });
    return (jsxs("div", __assign({ className: "image-mask-container" }, { children: [jsx("div", { className: "controls" }), jsx(Stage, __assign({ ref: stageRef, width: width || 1024, height: height || 1024, onMouseDown: handleMouseDown, onMouseMove: handleMouseMove, onMouseUp: handleMouseUp, onWheel: handleWheel, onMouseLeave: handleMouseLeave, scaleX: scale, scaleY: scale, x: position.x, y: position.y, draggable: props.toolMode === 'move', onDragEnd: function (e) {
                    setPosition({
                        x: e.target.x(),
                        y: e.target.y(),
                    });
                }, "data-testid": "drawing-stage", style: {
                    cursor: props.toolMode === 'move' ? 'grab' :
                        props.toolMode === 'mask-box' || props.toolMode === 'eraser-box' || props.toolMode === 'mask-polygon' ? 'crosshair' :
                            props.toolMode === 'clear' ? 'pointer' : 'none'
                } }, { children: jsxs(Layer, __assign({ ref: layerRef }, { children: [image && (jsx(Image, { image: image, width: width || 1024, height: height || 1024 })), maskImage && (jsx(Image, { image: maskImage, width: width || 1024, height: height || 1024 })), props.toolMode === 'mask-polygon' && polygonPoints.length > 0 && (jsxs(Group, { children: [jsx(Line, { points: __spreadArray(__spreadArray([], polygonPoints, true), [tempPolygonPoint], false).filter(function (point) { return point !== null; }).flatMap(function (point) { return [point.x, point.y]; }), stroke: getMaskColorWithOpacity(), strokeWidth: 2, lineCap: "round", lineJoin: "round", closed: false }), polygonPoints.map(function (point, index) {
                                    var isFirstPoint = index === 0;
                                    var isNearFirstPoint = isFirstPoint && tempPolygonPoint &&
                                        Math.sqrt(Math.pow(tempPolygonPoint.x - point.x, 2) +
                                            Math.pow(tempPolygonPoint.y - point.y, 2)) < 10;
                                    return (jsx(Circle, { x: point.x, y: point.y, radius: isNearFirstPoint ? 8 : 4, fill: getMaskColorWithOpacity(), stroke: "white", strokeWidth: 1 }, index));
                                })] })), currentPath.length > 0 && (jsx(Group, { children: jsx(Line, { points: currentPath.flatMap(function (point) { return [point.x, point.y]; }), stroke: ((_a = props.toolMode) === null || _a === void 0 ? void 0 : _a.startsWith('eraser')) ? "rgba(255, 0, 0, ".concat(currentOpacity, ")") : getMaskColorWithOpacity(), strokeWidth: brushSize, lineCap: "round", lineJoin: "round" }) })), currentBox && (jsx(Rect, { x: currentBox.x, y: currentBox.y, width: currentBox.width, height: currentBox.height, stroke: ((_b = props.toolMode) === null || _b === void 0 ? void 0 : _b.startsWith('eraser')) ? "rgba(255, 0, 0, ".concat(currentOpacity, ")") : getMaskColorWithOpacity(), strokeWidth: 2, fill: ((_c = props.toolMode) === null || _c === void 0 ? void 0 : _c.startsWith('eraser')) ? "rgba(255, 0, 0, ".concat(currentOpacity, ")") : getMaskColorWithOpacity() })), cursorPosition && (props.toolMode === 'mask-freehand' || props.toolMode === 'eraser-freehand') && (jsx(Circle, { x: cursorPosition.x, y: cursorPosition.y, radius: brushSize / 2, stroke: ((_d = props.toolMode) === null || _d === void 0 ? void 0 : _d.startsWith('eraser')) ? 'rgba(255, 0, 0, 0.5)' : maskColor, strokeWidth: 0.5, fill: ((_e = props.toolMode) === null || _e === void 0 ? void 0 : _e.startsWith('eraser')) ? 'rgba(255, 0, 0, 0.3)' : maskColor.replace('1)', '0.3)') }))] })) }))] })));
});
ImageMaskCanvas.displayName = 'ImageMaskCanvas';

var ImageMask = function () {
    var canvasRef = useRef(null);
    var _a = useState('mask-freehand'), toolMode = _a[0], setToolMode = _a[1];
    var _b = useState(1), currentZoom = _b[0], setCurrentZoom = _b[1];
    var _c = useState(false), canUndo = _c[0], setCanUndo = _c[1];
    var _d = useState(false), canRedo = _d[0], setCanRedo = _d[1];
    var _e = useState('rgba(0, 0, 0, 1)'), currentMaskColor = _e[0], setCurrentMaskColor = _e[1];
    var _f = useState(0.5), currentOpacity = _f[0], setCurrentOpacity = _f[1];
    var _g = useState(10), currentBrushSize = _g[0], setCurrentBrushSize = _g[1];
    var clearMask = useCallback(function () {
        var _a;
        (_a = canvasRef.current) === null || _a === void 0 ? void 0 : _a.clearMask();
    }, []);
    var handleHistoryChange = useCallback(function (canUndo, canRedo) {
        setCanUndo(canUndo);
        setCanRedo(canRedo);
    }, []);
    var handleDownloadMask = useCallback(function () {
        var _a;
        var maskData = (_a = canvasRef.current) === null || _a === void 0 ? void 0 : _a.getMaskData();
        if (maskData) {
            var link = document.createElement('a');
            link.href = maskData;
            link.download = 'mask.png';
            link.click();
        }
    }, []);
    var setMaskColor = useCallback(function (color) {
        var _a;
        setCurrentMaskColor(color);
        (_a = canvasRef.current) === null || _a === void 0 ? void 0 : _a.setMaskColor(color);
    }, []);
    var setOpacity = useCallback(function (opacity) {
        var _a;
        setCurrentOpacity(opacity);
        (_a = canvasRef.current) === null || _a === void 0 ? void 0 : _a.setOpacity(opacity);
    }, []);
    var setBrushSize = useCallback(function (size) {
        var _a;
        setCurrentBrushSize(size);
        (_a = canvasRef.current) === null || _a === void 0 ? void 0 : _a.setBrushSize(size);
    }, []);
    var setZoom = useCallback(function (zoom) {
        var _a;
        setCurrentZoom(zoom);
        (_a = canvasRef.current) === null || _a === void 0 ? void 0 : _a.setZoom(zoom);
    }, []);
    return (jsxs("div", __assign({ className: "tool-mode", "data-testid": "image-mask-container" }, { children: [jsx(ImageMaskControls, { setToolMode: setToolMode, toolMode: toolMode, clearCanvas: clearMask, currentZoom: currentZoom, undo: function () { var _a; return (_a = canvasRef.current) === null || _a === void 0 ? void 0 : _a.undo(); }, redo: function () { var _a; return (_a = canvasRef.current) === null || _a === void 0 ? void 0 : _a.redo(); }, canUndo: canUndo, canRedo: canRedo, onDownloadMask: handleDownloadMask, setMaskColor: setMaskColor, currentMaskColor: currentMaskColor, setOpacity: setOpacity, currentOpacity: currentOpacity, setBrushSize: setBrushSize, currentBrushSize: currentBrushSize, setZoom: setZoom }), jsx(ImageMaskCanvas, { ref: canvasRef, src: "https://picsum.photos/1024/1024", toolMode: toolMode, onZoomChange: setCurrentZoom, onHistoryChange: handleHistoryChange })] })));
};

var downloadMask = function (maskCanvas, width, height) {
    if (!maskCanvas)
        return;
    // Create a temporary canvas to ensure we get the full mask
    var tempCanvas = document.createElement('canvas');
    tempCanvas.width = width;
    tempCanvas.height = height;
    var ctx = tempCanvas.getContext('2d');
    if (!ctx)
        return;
    // Draw the mask
    ctx.drawImage(maskCanvas, 0, 0);
    // Get the image data
    var imageData = ctx.getImageData(0, 0, width, height);
    var data = imageData.data;
    // Convert all non-transparent pixels to pure black with full opacity
    for (var i = 0; i < data.length; i += 4) {
        if (data[i + 3] > 0) { // If pixel is not transparent
            data[i] = 0; // R
            data[i + 1] = 0; // G
            data[i + 2] = 0; // B
            data[i + 3] = 255; // A (full opacity)
        }
    }
    // Put the modified data back
    ctx.putImageData(imageData, 0, 0);
    // Convert to PNG and download
    var link = document.createElement('a');
    link.download = 'mask.png';
    link.href = tempCanvas.toDataURL('image/png');
    link.click();
};

export { ImageMask, ImageMaskCanvas, ImageMaskControls, downloadMask };
//# sourceMappingURL=index.esm.js.map
